<html><head><TITLE></TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>    </H2><BLOCKQUOTE>

UCalendar C API is used  for converting between a <code>UDate</code> object
and a set of integer fields such as <code>UCAL_YEAR</code>, <code>UCAL_MONTH</code>, 
<code>UCAL_DAY</code>, <code>UCAL_HOUR</code>, and so on
</BLOCKQUOTE>
<A NAME="DOC.DOCU">
<BLOCKQUOTE>

UCalendar C API is used  for converting between a <code>UDate</code> object
and a set of integer fields such as <code>UCAL_YEAR</code>, <code>UCAL_MONTH</code>, 
<code>UCAL_DAY</code>, <code>UCAL_HOUR</code>, and so on.
(A <code>UDate</code> object represents a specific instant in
time with millisecond precision. See
{@link UDate}
for information about the <code>UDate</code> .)

<p>
Types of <code>UCalendar</code> interpret a <code>UDate</code>
according to the rules of a specific calendar system. The CAPI
provides the enum UCalendarType with UCAL_TRADITIONAL and 
UCAL_GREGORIAN.
<p>
Like other locale-sensitive C API, calendar API  provides a
function, <code>ucal_open()</code>, which returns a pointer to
<code>UCalendar</code> whose time fields have been initialized 
with the current date and time. We need to specify the type of
calendar to be opened and the  timezoneId. 
<blockquote>
<pre>
UCalendar *caldef;
UChar *tzId;
UErrorCode status;
tzId=(UChar*)malloc(sizeof(UChar) * (strlen("PST") +1) );
u_uastrcpy(tzId, "PST");
caldef=ucal_open(tzID, u_strlen(tzID), NULL, UCAL_TRADITIONAL, &status);
</pre>
</blockquote>

<p>
A <code>UCalendar</code> object can produce all the time field values
needed to implement the date-time formatting for a particular language
and calendar style (for example, Japanese-Gregorian, Japanese-Traditional).

<p>
When computing a <code>UDate</code> from time fields, two special circumstances
may arise: there may be insufficient information to compute the
<code>UDate</code> (such as only year and month but no day in the month),
or there may be inconsistent information (such as "Tuesday, July 15, 1996"
-- July 15, 1996 is actually a Monday).

<p>
<strong>Insufficient information.</strong> The calendar will use default
information to specify the missing fields. This may vary by calendar; for
the Gregorian calendar, the default for a field is the same as that of the
start of the epoch: i.e., UCAL_YEAR = 1970, UCAL_MONTH = JANUARY, UCAL_DATE = 1, etc.

<p>
<strong>Inconsistent information.</strong> If fields conflict, the calendar
will give preference to fields set more recently. For example, when
determining the day, the calendar will look for one of the following
combinations of fields.  The most recent combination, as determined by the
most recently set single field, will be used.

<blockquote>
<pre>
UCAL_MONTH + UCAL_DAY_OF_MONTH
UCAL_MONTH + UCAL_WEEK_OF_MONTH + UCAL_DAY_OF_WEEK
UCAL_MONTH + UCAL_DAY_OF_WEEK_IN_MONTH + UCAL_DAY_OF_WEEK
UCAL_DAY_OF_YEAR
UCAL_DAY_OF_WEEK + UCAL_WEEK_OF_YEAR
</pre>
</blockquote>

For the time of day:

<blockquote>
<pre>
UCAL_HOUR_OF_DAY
UCAL_AM_PM + UCAL_HOUR
</pre>
</blockquote>

<p>
<strong>Note:</strong> for some non-Gregorian calendars, different
fields may be necessary for complete disambiguation. For example, a full
specification of the historial Arabic astronomical calendar requires year,
month, day-of-month <em>and</em> day-of-week in some cases.

<p>
<strong>Note:</strong> There are certain possible ambiguities in
interpretation of certain singular times, which are resolved in the
following ways:
<ol>
<li> 24:00:00 "belongs" to the following day. That is,
23:59 on Dec 31, 1969 &lt; 24:00 on Jan 1, 1970 &lt; 24:01:00 on Jan 1, 1970

<li> Although historically not precise, midnight also belongs to "am",
and noon belongs to "pm", so on the same day,
12:00 am (midnight) &lt; 12:01 am, and 12:00 pm (noon) &lt; 12:01 pm
</ol>

<p>
The date or time format strings are not part of the definition of a
calendar, as those must be modifiable or overridable by the user at
runtime. Use {@link UDateFormat}
to format dates.

<p>
<code>Calendar</code> provides an API for field "rolling", where fields
can be incremented or decremented, but wrap around. For example, rolling the
month up in the date <code>December 12, <b>1996</b></code> results in
<code>January 12, <b>1996</b></code>.

<p>
<code>Calendar</code> also provides a date arithmetic function for
adding the specified (signed) amount of time to a particular time field.
For example, subtracting 5 days from the date <code>September 12, 1996</code>
results in <code>September 7, 1996</code>.

</BLOCKQUOTE>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
