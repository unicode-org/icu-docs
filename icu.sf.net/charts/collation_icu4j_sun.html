<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Collation: ICU4J vs. Sun</title>
<link rel="stylesheet" href="../icu.css" type="text/css" />
</head>
<body>
<!--#include virtual="../ssi/header.html" -->
<h2>Collation: Sun JDK 1.4.1 vs ICU4J 2.6</h2>
<p>The performance test takes a locale and creates a RuleBasedCollator with
default options. A large list of names is used as data in each test, where the
names vary according to language. Each Collation operation over the whole list
is repeated 1000 times. The percentage values in the final column are the most
useful. They measure differences, where positive is better for ICU4C, and
negative is better for the compared implementation.</p>
<h3 align="left">Key</h3>
<table border="1" cellspacing="0" cellpadding="4">
<tr>
<th align="left">Operation</th>
<th align="left">Units</th>
<th align="left">Description</th>
</tr>
<tr>
<td>strcoll</td>
<td>nanosecs</td>
<td>Timing for string collation, an incremental compare of strings.</td>
</tr>
<tr>
<td>keygen</td>
<td>nanosecs</td>
<td>Timing for generation of sort keys, used to 'precompile' information so
that subsequent operations can use binary comparison.</td>
</tr>
<tr>
<td>keylen</td>
<td>bytes/char</td>
<td>The average length of the generated sort keys, in bytes per character
(Unicode/ISO 10646 code point). Generally this is the important field for sort
key performance, since it directly impacts the time necessary for binary
comparison, and the overhead of memory usage and retrieval time for sort
keys.</td>
</tr>
</table>
<h3 align="left">Data</h3>
<pre>
                                      ---- ICU4J ----   ---- JDK ----   (JDK - ICU4J)/ICU4J
Locale     Data file                 strcoll   keylen  strcoll  keylen     coll   keylen
-------------------------------------------------------------------------------------------
en_US      TestNames_Latin.txt      |   560    1.59  |   3880    5.92  |   +593%   +272%
da_DK      TestNames_Latin.txt      |   636    1.61  |  10829    5.92  |  +1603%   +268%
de_DE      TestNames_Latin.txt      |   558    1.59  |   3867    5.92  |   +593%   +272%
de__PHONEB TestNames_Latin.txt      |   556    1.59  |   3872    5.92  |   +596%   +272%
fr_FR      TestNames_Latin.txt      |   555    1.59  |   3922    5.92  |   +607%   +272%
ja_JP      TestNames_Latin.txt      |   554    1.59  |   3879    5.92  |   +600%   +272%
ja_JP      TestNames_Japanese_h.txt |  1969    3.32  |   2131   11.74  |     +8%   +254%
ja_JP      TestNames_Japanese_k.txt |  1970    3.32  |   2135   11.74  |     +8%   +254%
ja_JP      TestNames_Asian.txt      |  2209    3.49  |   2073      12  |     -6%   +244%
zh_TW      TestNames_Latin.txt      |   556    1.59  |   3912    5.92  |   +604%   +272%
zh_TW      TestNames_Chinese.txt    |  1934    4.26  |   2101   13.34  |     +9%   +213%
zh_CN      TestNames_Latin.txt      |   554    1.59  |   3880    5.92  |   +600%   +272%
zh_CN      TestNames_Simplified_Chin|  1912    4.27  |   2086   13.34  |     +9%   +212%
zh__PINYIN TestNames_Latin.txt      |   554    1.59  |   3887    5.92  |   +602%   +272%
zh__PINYIN TestNames_Simplified_Chin|  1884    4.27  |   2079   13.34  |    +10%   +212%
ko_KR      TestNames_Latin.txt      |   559    1.59  |   3876    5.92  |   +593%   +272%
ko_KR      TestNames_Korean.txt     |  3773    4.66  |   2439    7.33  |    -35%    +57%
ru_RU      TestNames_Latin.txt      |   555    1.59  |   3870    5.92  |   +597%   +272%
ru_RU      TestNames_Russian.txt    |  3097    1.59  |   7522    5.85  |   +143%   +268%
th         TestNames_Latin.txt      |   555    1.58  |   4000     5.9  |   +621%   +273%
th         TestNames_Thai.txt       |  2521    1.59  |   4240    5.76  |    +68%   +262%
</pre>
<h3><i>Notes</i></h3>
<ol>
<li>The tests are performed on a Pentium 3 machine, 700mhz with 384mb RAM,
running Windows 2000.</li>
<li>We were responsible for the original implementation of collation in Java,
so we've learned quite a bit since then.</li>
<li>We're not sure why Japanese keylens in glibc are so small; it seems
suspicious, so we are suspecting that they do not use a multilevel sort.</li>
<li>As with all performance measurements, the results will vary according to
the hardware and compiler. The strcoll operation is particularly sensitive; we
have found that even slight changes in code alignment can produce 10%
differences.</li>
<li>For more information on incremental vs. sort key comparison, the importance
of multi-level sorting, and other features of collation, see <a href=
"http://www.unicode.org/reports/tr10/">Unicode Collation (UCA)</a>.</li>
<li>For general information on ICU collation see <a href=
"/userguide/Collate_Intro.html">User Guide</a>.</li>
<li>For information on APIs, see <a href="/apiref/icu4c/ucol_8h.html">C</a>,
<a href="/apiref/icu4c/classCollator.html">C++</a>, or <a href=
"/apiref/icu4j/doc/com/ibm/icu/text/Collator.html">Java</a>. There is also a
JNI implementation for better speed in Java.</li>
</ol>
<!--#include virtual="../ssi/footer.html" -->
</body>
</html>
