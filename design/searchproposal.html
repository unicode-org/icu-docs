<html>

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1252">
<meta name=Generator content="Microsoft Word 10 (filtered)">
<title>ICU API Proposal</title>

<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:Helvetica;
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:Courier;
	panose-1:2 7 4 9 2 2 5 2 4 4;}
@font-face
	{font-family:Wingdings;
	panose-1:5 0 0 0 0 0 0 0 0 0;}
@font-face
	{font-family:"MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
@font-face
	{font-family:"Arial Unicode MS";
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:"\@Arial Unicode MS";
	panose-1:2 11 6 4 2 2 2 2 2 4;}
@font-face
	{font-family:"\@MS Mincho";
	panose-1:2 2 6 9 4 2 5 8 3 4;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:12.0pt;
	font-family:"Times New Roman";}
h1
	{margin:0in;
	margin-bottom:.0001pt;
	page-break-after:avoid;
	font-size:10.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
h2
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	page-break-after:avoid;
	font-size:14.0pt;
	font-family:Arial;
	font-weight:bold;
	font-style:italic;}
h3
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:3.0pt;
	margin-left:0in;
	page-break-after:avoid;
	font-size:13.0pt;
	font-family:Arial;
	font-weight:bold;}
p.MsoListBullet2, li.MsoListBullet2, div.MsoListBullet2
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	text-indent:-.25in;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.MsoListBullet3, li.MsoListBullet3, div.MsoListBullet3
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.75in;
	margin-bottom:.0001pt;
	text-indent:-.25in;
	font-size:12.0pt;
	font-family:"Times New Roman";}
p.MsoBodyTextIndent, li.MsoBodyTextIndent, div.MsoBodyTextIndent
	{margin-top:0in;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:Arial;}
p.MsoBodyTextIndent2, li.MsoBodyTextIndent2, div.MsoBodyTextIndent2
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.25in;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Arial;
	color:black;}
p.MsoBodyTextIndent3, li.MsoBodyTextIndent3, div.MsoBodyTextIndent3
	{margin-top:12.0pt;
	margin-right:0in;
	margin-bottom:0in;
	margin-left:.5in;
	margin-bottom:.0001pt;
	line-height:12.0pt;
	text-autospace:none;
	font-size:10.0pt;
	font-family:Arial;
	color:black;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;}
a:visited, span.MsoHyperlinkFollowed
	{color:purple;
	text-decoration:underline;}
p
	{margin-right:0in;
	margin-left:0in;
	font-size:12.0pt;
	font-family:"Arial Unicode MS";}
pre
	{margin:0in;
	margin-bottom:.0001pt;
	font-size:10.0pt;
	font-family:"Arial Unicode MS";}
tt
	{font-family:"Arial Unicode MS";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.0in 1.0in 1.0in;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>

</head>

<body lang=EN-US link=blue vlink=purple>

<div class=Section1>

<h1><span style='font-family:Arial'>ICU API Proposal</span></h1>

<h2 style='margin-top:0in'>Search Mechanism for Unicode Strings</h2>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>&nbsp;</span></p>

<h3><span style='font-size:14.0pt'>Introduction</span></h3>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>As of ICU4C
release 1.8.1, the collation module is UCA (Unicode Collation Algorithm)
conformant. The collation module is able to perform language-sensitive
comparison between two Unicode strings and even generate sort keys that can be
easily binary compared. For instance:</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>&nbsp;</span></p>

<p class=MsoBodyTextIndent>Characters ß and SS will be compared equals on
primary strength using a German collator. </p>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Arial'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>What if a
user would like to look for the non-case-sensitive match of the pattern “ß”
within the Unicode string “abcSSdef”? The C API <i>UChar * u_strstr(const UChar
*s, const UChar *substring)</i> and the C++ API <i>UTextOffset
UnicodeString::indexOf(const UnicodeString&amp; text)</i> would not find it,
since both does a bitwise comparison. ICU4C does not have the appropriate APIs
to perform a language-sensitive search.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>The Java
class com.ibm.text.StringSearch belonging to the ICU4J libraries is a search
iterator that provides such a search function missing from ICU4C.
com.ibm.text.StringSearch follows the rules defined in a
java.text.RuleBasedCollator object (Java’s version of a collator) for matching.
To optimize, it uses a version of the Boyer-Moore search algorithm adapted to
work with Unicode strings. For more information, see “<a
href="http://icu.sourceforge.net/docs/papers/efficient_text_searching_in_java.html">Efficient
Text Searching in Java</a>” published in the Java Report February 1999, and the
com.ibm.text.StringSearch APIs located at <a
href="http://icu.sourceforge.net/apiref/icu4j/com/ibm/icu/text/StringSearch.html">http://icu.sourceforge.net/apiref/icu4j/com/ibm/icu/text/StringSearch.html</a>.
</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>Using ICU4J
as a guide, our goal in this proposal is to provide a set of C and C++ APIs
that takes a Unicode string as a pattern and looks for its match within another
Unicode string, using the rules defined in a given collator. The proposed C and
C++ API will have exactly the same functionalities.</span></p>

<pre><span style='font-family:Arial'>&nbsp;</span></pre>

<h3><span style='font-size:14.0pt'>Proposal</span></h3>

<h1><span style='font-family:Arial'>&nbsp;</span></h1>

<p style='margin:0in;margin-bottom:.0001pt'><span style='font-size:10.0pt;
font-family:Arial'>Since ICU’s C and C++ search mechanism plans to provide
exactly the same functionality, for the benefit of clarity, we will treat them
as one single entity and name the entity <i>StringSearch</i>. </span></p>

<p style='margin:0in;margin-bottom:.0001pt'><span style='font-size:10.0pt;
font-family:Arial'>&nbsp;</span></p>

<p style='margin:0in;margin-bottom:.0001pt'><span style='font-size:10.0pt;
font-family:Arial'>Henceforth, any mention of <i>pattern</i>, refers to the
Unicode text string to be matched. And any mention of <i>text</i>, refers to
the Unicode text string in which is to be searched for pattern.</span></p>

<p style='margin:0in;margin-bottom:.0001pt'><span style='font-family:"Times New Roman"'>&nbsp;</span></p>

<h1><span style='font-family:Arial'>The StringSearch Model</span></h1>

<p class=MsoNormal style='margin-top:12.0pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial;color:black'>Two strings match when
given a collator, if <i>ucol_strcoll</i> == <i>UCOL_EQUAL</i>. String searching
is a little different. A pattern matches at the offsets &lt;<i>start</i>, <i>end</i>&gt;
in a text given a collator, if some sub-string between <i>start</i> and <i>end</i>,
compares equivalent to the pattern.</span></p>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.5in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial;color:black'>So in Danish (where
&quot;aa&quot; matches &quot;å&quot;) &quot;baad&quot; will match
&quot;a--båd--man&quot; at position &lt;3,5&gt;.</span></p>

<p class=MsoNormal style='margin-top:12.0pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial;color:black'>Below is a list of the
exceptional cases and the steps that will be taken to handle them.</span></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal style='color:black;margin-top:12.0pt;line-height:12.0pt'><b><span
     style='font-size:10.0pt;font-family:Arial'>Fuzzy Endings</span></b> </li>
</ol>

<p class=MsoBodyTextIndent2>Suppose a collator with ignored punctuation is
being used. Then &quot;baad&quot; will match &quot;a--båd--man&quot; not only
at start = 3, but also at 2 and 1. And end could be 5, 6, or 7. So a condition
will be added: that if the pattern matches at &lt;start, end&gt; and also at
&lt;start+1, end&gt;, we will disregard &lt;start, end&gt;. Similarly, if it
matches at &lt;start, end&gt; and &lt;start, end-1&gt;, we will disregard
&lt;start, end&gt;.</p>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.5in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial;color:black'>So in Danish (with
ignored punctuation) &quot;baad&quot; will match &quot;a--båd--man&quot; ONLY
at position &lt;3,5&gt;.</span></p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal style='margin-top:12.0pt;line-height:12.0pt'><b><span
     style='font-size:10.0pt;font-family:Arial'>Thai and Lao Character
     Boundaries</span></b> </li>
</ol>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial'>In collation, certain Thai and Lao
vowels are swapped with the following character. For example, the text string </span><tt><span
style='font-size:10.0pt;font-family:Arial;color:black'>“A\u0E02\u0E40” is modified
internally in collation to “A\u0E40\u0E02”. </span></tt></p>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial'>Looking for “A\u0E40” in “</span><tt><span
style='font-size:10.0pt;font-family:Arial;color:black'>A\u0E02\u0E40”</span></tt><span
style='font-size:10.0pt;font-family:Arial'> would find a ready match at the
starting offset 0. The problem is in deciding which ending offset to return.
Since users do not have access to the internal collation structure which
handles the swapped string, the return offset for the example will be &lt;0,
2&gt;, even though the range would encompass the extra character ‘\u0E02’. </span></p>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial'>In short, if a pattern “P</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>0</span></sub><span
style='font-size:10.0pt;font-family:Arial'> P</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>1</span></sub><span
style='font-size:10.0pt;font-family:Arial'> .. P</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>n</span></sub><span
style='font-size:10.0pt;font-family:Arial'>” is searched for in the text “T</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>0</span></sub><span
style='font-size:10.0pt;font-family:Arial'> T</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>1</span></sub><span
style='font-size:10.0pt;font-family:Arial'> .. T</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>m</span></sub><span
style='font-size:10.0pt;font-family:Arial'> P</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>0</span></sub><span
style='font-size:10.0pt;font-family:Arial'> P</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>1</span></sub><span
style='font-size:10.0pt;font-family:Arial'> .. P</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>n-1 </span></sub><span
style='font-size:10.0pt;font-family:Arial'>T</span><sub><span style='font-size:
10.0pt;font-family:Helvetica'>m+n </span></sub><span style='font-size:10.0pt;
font-family:Arial'>P</span><sub><span style='font-size:10.0pt;font-family:Helvetica'>n
</span></sub><span style='font-size:10.0pt;font-family:Arial'>T</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>m+n+2  </span></sub><span
style='font-size:10.0pt;font-family:Arial'>T</span><sub><span style='font-size:
10.0pt;font-family:Helvetica'>m+n+3</span></sub><span style='font-size:10.0pt;
font-family:Arial'>…”, where ‘T</span><sub><span style='font-size:10.0pt;
font-family:Helvetica'>m+n </span></sub><span style='font-size:10.0pt;
font-family:Arial'>’ and ‘P</span><sub><span style='font-size:10.0pt;
font-family:Helvetica'>n</span></sub><span style='font-size:10.0pt;font-family:
Arial'>‘ are to be swapped, a match will be found at &lt;m+1, m+n+1&gt;.
Similarly, if a pattern “P</span><sub><span style='font-size:10.0pt;font-family:
Helvetica'>0</span></sub><span style='font-size:10.0pt;font-family:Arial'> P</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>1</span></sub><span
style='font-size:10.0pt;font-family:Arial'> .. P</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>n</span></sub><span
style='font-size:10.0pt;font-family:Arial'>” is searched for in the text “T</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>0</span></sub><span
style='font-size:10.0pt;font-family:Arial'> T</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>1</span></sub><span
style='font-size:10.0pt;font-family:Arial'> .. T</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>m-1</span></sub><span
style='font-size:10.0pt;font-family:Arial'> P</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>0</span></sub><span
style='font-size:10.0pt;font-family:Arial'> T</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>m </span></sub><span
style='font-size:10.0pt;font-family:Arial'>P</span><sub><span style='font-size:
10.0pt;font-family:Helvetica'>1</span></sub><span style='font-size:10.0pt;
font-family:Arial'> P</span><sub><span style='font-size:10.0pt;font-family:
Helvetica'>2</span></sub><span style='font-size:10.0pt;font-family:Arial'> .. P</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>n </span></sub><span
style='font-size:10.0pt;font-family:Arial'>T</span><sub><span style='font-size:
10.0pt;font-family:Helvetica'>m+n+1  </span></sub><span style='font-size:10.0pt;
font-family:Arial'>T</span><sub><span style='font-size:10.0pt;font-family:Helvetica'>m+n+2</span></sub><span
style='font-size:10.0pt;font-family:Arial'>…”, where ‘P</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>0</span></sub><span
style='font-size:10.0pt;font-family:Arial'>‘and ‘T</span><sub><span
style='font-size:10.0pt;font-family:Helvetica'>m </span></sub><span
style='font-size:10.0pt;font-family:Arial'>’ is to be swapped, a match will be
found at &lt;m, m+n&gt;.</span></p>

<ol style='margin-top:0in' start=3 type=1>
 <li class=MsoNormal style='margin-top:12.0pt;line-height:12.0pt'><b><span
     style='font-size:10.0pt;font-family:Arial'>Normalization Boundaries</span></b>
     </li>
</ol>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial'>Normalization, like the swapping of
characters described above, is done internally within collation</span><tt><span
style='font-size:10.0pt;font-family:Arial;color:black'>. For the same reason
that the internal collation structure is inaccessible to the user, the offsets
for the result matches may contain extra combining characters near the
beginning or the end of the match.</span></tt></p>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><tt><span
style='font-size:10.0pt;font-family:Arial;color:black'>If the start of the
match lies within a range of normalized characters, the start offset returned
will be one character after the immediate preceding base character. If the end
of the match lies within a range of normalized characters, the end offset
returned will be one character before the immediate following base character.</span></tt></p>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><tt><span
style='font-size:10.0pt;font-family:Arial;color:black'>Example: “\u0300\0325”
has a match in “A\u0300\u0301\u0326\u0325B” at &lt;1, 4&gt;.</span></tt></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal style='margin-top:12.0pt;line-height:12.0pt'><b><span
     style='font-size:10.0pt;font-family:Arial;color:black'>Contraction
     Boundaries</span></b><span style='font-size:10.0pt;font-family:Arial;
     color:black'> </span></li>
</ol>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial;color:black'>Suppose that the
collator has contractions, and that a contraction spans the boundary of the
match. Then it will not be regarded as a match.</span></p>

<p class=MsoBodyTextIndent3>So in Traditional Spanish (where &quot;ch&quot; is
a contraction), &quot;har&quot; will not match in &quot;uno charo&quot;.</p>

<p class=MsoBodyTextIndent3 style='margin-left:.25in'>Boundaries that are
discontiguous contractions will yield a match result similar to those described
in the above normalization boundaries, whereby the end of the match returned
will be one character before the immediate following base character. However,
if the pattern consists of prefix accents and a match with a starting
discontiguous boundary is found, the result start offset of the match could
include the initial base character in the discontiguous contraction or not
depending on the direction of search.</p>

<p class=MsoBodyTextIndent3 style='margin-left:.25in'>Example: Searching for
the accent “\u0319” in &quot;X\u0300\u0319\u0315&quot;, where “X\u0300\u0315”
is a contraction, gives a match at &lt;0, 4&gt; during a forward search but
&lt;1, 3&gt; during a backward search.</p>

<ol style='margin-top:0in' start=2 type=1>
 <li class=MsoNormal style='color:black;margin-top:12.0pt;line-height:12.0pt'><b><span
     style='font-size:10.0pt;font-family:Arial'>Double Matches </span></b></li>
</ol>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial;color:black'>Consider the search
pattern “\u0300” and the text “A\u0300\u0300”, due to normalization, the first
and <b><i>only</i></b> match will be found at &lt;1, 2&gt;. Even though there
is another match within &lt;1, 2&gt;, the same match result will only be
returned once during the entire search iteration.</span></p>

<ol style='margin-top:0in' start=3 type=1>
 <li class=MsoNormal style='color:black;margin-top:12.0pt;line-height:12.0pt'><b><span
     style='font-size:10.0pt;font-family:Arial'>Pre-composed Characters</span></b></li>
</ol>

<p class=MsoBodyTextIndent2 style='text-autospace:ideograph-other'>Pre-composed
characters are treated as their decomposed NFD counterparts. If “\u0300” is
looked for in the string “\u00C0”, a match will be found at &lt;0, 1&gt;.</p>

<p class=MsoBodyTextIndent2 style='text-autospace:ideograph-other'>Currently,
there is no existing pre-composed character that decomposes in NFD to a
character sequence with accents before a base character. <i>StringSearch</i>
makes use of this fact for boundary checks optimization. In the event, where
this is no longer true, <i>StringSearch</i> will be updated to handle it.</p>

<ol style='margin-top:0in' start=4 type=1>
 <li class=MsoNormal style='color:black;margin-top:12.0pt;line-height:12.0pt'><b><span
     style='font-size:10.0pt;font-family:Arial'>User Specified Conditions</span></b><span
     style='font-size:10.0pt;font-family:Arial'> </span></li>
</ol>

<p class=MsoBodyTextIndent2>Suppose that &quot;c&quot; is the pattern; is there
a match in &quot;c`&quot; (e.g. with a combining grave accent)? The above
example will always match, <b><i>however</i></b> the behaviour can overwritten
if a break iterator is provided to test the boundary. Thus if &quot;c&quot; in
&quot;abcd&quot; is not to match, supply a word-break iterator. If
&quot;c&quot; in &quot;abc`&quot; is not to match, provide a character-break
iterator.</p>

<ol style='margin-top:0in' start=5 type=1>
 <li class=MsoNormal style='color:black;margin-top:12.0pt;line-height:12.0pt'><b><span
     style='font-size:10.0pt;font-family:Arial'>Canonical Equivalence</span></b><span
     style='font-size:10.0pt;font-family:Arial'> </span></li>
</ol>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial;color:black'>Collation guarantees
that any strings will be compared under canonical equivalence if normalization
is on, but even if it is off, FCD text (<a
href="http://oss.software.ibm.com/develop/collation/fcd.html">http://oss.software.ibm.com/icu/develop/collation/ICU_collation_design16d.htm#CheckFCD</a>)
is guaranteed to sort correctly. This works fine in the interior of patterns
and the text sub-strings they match, since collation in ICU4C is done properly,
even with discontiguous contractions.</span></p>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial;color:black'>There is a bit of a
problem, though, at the boundaries. When pattern: &quot;¸c`&quot; (combining
cedilla, c, combining grave) is searched in text: &quot;a^¸c`&#731;e&quot; (a,
combining circumflex, combining underdot, c, combining grave, combining ogonek,
e), a match will be found. But if the same text is normalized, the result will
be &quot;a¸^c&#731;`e&quot;. In that normalized version and no further
processing, a match will not be found. </span></p>

<p class=MsoBodyTextIndent2>In order to ensure canonical equivalence, the same
answer should result in either case. Hence the user is provided with two
options to select for searching:</p>

<ul style='margin-top:0in' type=disc>
 <ol style='margin-top:0in' start=1 type=1>
  <li class=MsoNormal style='color:black;margin-top:12.0pt;line-height:12.0pt'><span
      style='font-size:10.0pt;font-family:Arial'>A match is found if <i>some</i>
      canonical equivalent of pattern matches in <i>some</i> canonical
      equivalent of text. </span></li>
  <li class=MsoNormal style='color:black;margin-top:12.0pt;line-height:12.0pt'><i><span
      style='font-size:10.0pt;font-family:Arial'>StringSearch</span></i><span
      style='font-size:10.0pt;font-family:Arial'> will bail out even when a
      pattern is matched in text if </span></li>
 </ol>
</ul>

<ol style='margin-top:0in' start=5 type=1>
 <ul style='margin-top:0in' type=circle>
  <ul style='margin-top:0in' type=square>
   <li class=MsoNormal style='color:black;margin-top:12.0pt;line-height:12.0pt'><span
       style='font-size:10.0pt;font-family:Arial'>the pattern starts with a
       combining mark, and there is an accent before the match, or </span></li>
   <li class=MsoNormal style='color:black;margin-top:12.0pt;line-height:12.0pt'><span
       style='font-size:10.0pt;font-family:Arial'>if the pattern ends with a
       combining mark, and there is an accent after the match. </span></li>
  </ul>
 </ul>
</ol>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><i><span
style='font-size:10.0pt;font-family:Arial;color:black'>Accents</span></i><span
style='font-size:10.0pt;font-family:Arial;color:black'> refers to characters
with non-zero canonical combining order <i>and</i> non-zero collation elements.
Remember that not all non-zero canonical combining order characters are
primary-ignorables, and vice versa. </span></p>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial;color:black'>A discontiguous match
might occur in option 1., in which case the match result &lt;start, end&gt; may
encompass a more accents at the ends of the match result than it is required.
For instance: When the pattern &quot;^c&#731;&quot; is searched in &quot;a^¸c`&#731;e&quot;
with normalization on, a match is found. But the characters that match have
gaps &quot;a<u>^</u>¸<u>c</u>`<u>&#731;</u>e&quot;.</span></p>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial;color:black'>Option 2. is more
restrictive. It would permit a search for an Arabic consonant, and match
against consonant + vowel. <i>But, </i>if a consonant + vowel1 is searched, it
would <b><i>not</i></b> match against consonant + vowel1 + vowel2.</span></p>

<p class=MsoNormal style='margin-top:12.0pt;margin-right:0in;margin-bottom:
0in;margin-left:.25in;margin-bottom:.0001pt;line-height:12.0pt'><span
style='font-size:10.0pt;font-family:Arial;color:black'>Hence this leads us to
the below definition of a match in <i>StringSearch</i>.</span></p>

<h1><span style='font-family:Arial'>&nbsp;</span></h1>

<p class=MsoNormal>&nbsp;</p>

<h1><span style='font-family:Arial'>Definition of a match</span></h1>

<p class=MsoNormal>&nbsp;</p>

<p style='margin:0in;margin-bottom:.0001pt'><span style='font-size:10.0pt;
font-family:Arial'>Let S’ be the sub-string of S at the offsets &lt;start,
end&gt;.</span></p>

<p style='margin:0in;margin-bottom:.0001pt'><span style='font-size:10.0pt;
font-family:Arial'>A pattern string P is considered to match a text string S at
the offsets <i>start</i> and <i>end</i>, <i>&lt;start, end&gt;</i> if and only
if either </span></p>

<ol style='margin-top:0in' start=1 type=1>
 <li class=MsoNormal style='color:black;margin-top:12.0pt;line-height:12.0pt'><i><span
     style='font-size:10.0pt;font-family:Arial'>ucol_strcoll(user specified
     collator, some canonical equivalent of P, some canonical equivalent of S’)
     == UCOL_EQUAL</span></i><span style='font-size:10.0pt;font-family:Arial'>.
     <b>or</b></span> </li>
 <li class=MsoNormal style='color:black;margin-top:12.0pt;line-height:12.0pt'><i><span
     style='font-size:10.0pt;font-family:Arial'>ucol_strcoll(user specified
     collator, P, S’) == UCOL_EQUAL</span></i><span style='font-size:10.0pt;
     font-family:Arial'> and if P starts or ends with a combining mark, there
     exists no non-ignorable combining mark before or after S’ in S
     respectively.</span> </li>
</ol>

<h1><span style='font-family:Arial'>&nbsp;</span></h1>

<h1><span style='font-family:Arial'>The Goals for StringSearch</span></h1>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>&nbsp;</span></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>ICU4J’s
     version of <i>StringSearch </i>will be used as a guideline for the design.</span>
     </li>
 <li class=MsoNormal><i><span style='font-size:10.0pt;font-family:Arial'>StringSearch</span></i><span
     style='font-size:10.0pt;font-family:Arial'> will look for language
     sensitive matches (see definition of a match above) of a Unicode pattern
     string within a Unicode text string.</span> </li>
 <li class=MsoNormal><i><span style='font-size:10.0pt;font-family:Arial'>StringSearch</span></i><span
     style='font-size:10.0pt;font-family:Arial'> will be able to perform the
     first, immediate next, immediate previous and last pattern match.</span> </li>
 <li class=MsoNormal><i><span style='font-size:10.0pt;font-family:Arial'>StringSearch</span></i><span
     style='font-size:10.0pt;font-family:Arial'> will allow options to handle
     overlapping match. E.g. In English, overlapping matches produces the
     result 0 and 2 for the pattern &quot;abab&quot; in the text &quot;ababab”,
     where else mutually exclusive matches only produce the result of 0.</span>
     </li>
 <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>Match
     restriction will be done by using a <i>BreakIterators </i>provided by the
     caller.</span> </li>
 <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>A locale
     or a collator can be used to specify the language sensitive rules.</span> </li>
 <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>If a
     locale is used to indicate the language sensitive rules in <i>StringSearch</i>,
     a collator will be created and <i>StringSearch</i> will retain the ownership,
     cleaning up the memory during destruction.</span> </li>
 <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>If a
     caller-created collator is used as the language sensitive rules, <i>StringSearch</i>
     will not claim ownership to the collator, neither will it attempt to clean
     up the collator during destruction.</span> </li>
 <li class=MsoNormal><i><span style='font-size:10.0pt;font-family:Arial'>StringSearch</span></i><span
     style='font-size:10.0pt;font-family:Arial'> will take into consideration
     all of the collation attributes during a match.</span> </li>
 <ul style='margin-top:0in' type=circle>
  <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>French
      secondary</span> </li>
  <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>Alternate
      handling</span> </li>
  <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>Case
      first</span> </li>
  <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>Case
      level</span> </li>
  <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>Normalization</span>
      </li>
  <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>Strength.
      </span></li>
 </ul>
</ul>

<p class=MsoNormal style='margin-left:.5in'><span style='font-size:10.0pt;
font-family:Arial'>However APIs will not be provided to set and get the
collator attributes. The caller would have to retrieve the collator from <i>StringSearch</i>
and sets them using the collation APIs.</span></p>

<ul style='margin-top:0in' type=disc>
 <li class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>Performing
     a change in direction in the middle of a search iteration will return a
     correct match if there is any.</span> </li>
 <li class=MsoNormal><i><span style='font-size:10.0pt;font-family:Arial'>StringSearch</span></i><span
     style='font-size:10.0pt;font-family:Arial'> will use the same version of
     the Unicode database as the rest of ICU4C, e.g. collation.</span> </li>
</ul>

<b><span style='font-size:10.0pt;font-family:"Times New Roman"'><br clear=all
style='page-break-before:always'>
</span></b>

<h1>&nbsp;</h1>

<h1><span style='font-family:Arial'>Proposed C header and API</span></h1>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * C Apis
for an engine that provides language-sensitive text searching based </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * on the
comparison rules defined in a &lt;tt&gt;UCollator&lt;/tt&gt; data struct,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * see
&lt;tt&gt;ucol.h&lt;/tt&gt;. This ensures that language eccentricity can be </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
handled, e.g. for the German collator, characters ß and SS will be matched </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * if
case is chosen to be ignored. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * See
the &lt;a href=http://oss.software.ibm.com/cvs/icu/~checkout~/icuhtml/design/collation/ICU_collation_design.htm&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&quot;ICU Collation Design Document&quot;&lt;/a&gt; for more information.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * The
algorithm implemented is a modified form of the Boyer Moore's search.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * For
more information  see </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * &lt;a href=http://icu.sourceforge.net/docs/papers/text-search.html&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&quot;Efficient Text Searching in Java&quot;&lt;/a&gt;, published in
&lt;i&gt;Java Report&lt;/i&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * in
February, 1999, for further information on the algorithm.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * There
are 2 match options for selection:&lt;br&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * Let S'
be the sub-string of a text string S between the offsets start and </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * end
&lt;start, end&gt;.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;br&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * A
pattern string P matches a text string S at the offsets &lt;start, end&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * if</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;pre&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * option
1. Some canonical equivalent of P matches some canonical equivalent </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *          
of S'</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * option
2. P matches S' and if P starts or ends with a combining mark, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *          
there exists no non-ignorable combining mark before or after S’ </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *          
in S respectively. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;/pre&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * Option
2. will be the default·</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * This
search has APIs similar to that of other text iteration mechanisms </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * such
as the break iterators in &lt;tt&gt;ubrk.h&lt;/tt&gt;. Using these </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * APIs,
it is easy to scan through text looking for all occurances of </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * a
given pattern. This search iterator allows changing of direction by </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
calling a &lt;tt&gt;reset&lt;/tt&gt; followed by a &lt;tt&gt;next&lt;/tt&gt; or
&lt;tt&gt;previous&lt;/tt&gt;. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * Though
a direction change can occur without calling &lt;tt&gt;reset&lt;/tt&gt; first, 
</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * this
operation comes with some speed penalty.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
Generally, match results in the forward direction will match the result </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
matches in the backwards direction in the reverse order</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;tt&gt;usearch.h&lt;/tt&gt; provides APIs to specify the starting position </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * within
the text string to be searched, e.g. &lt;tt&gt;usearch_setOffset&lt;/tt&gt;,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;tt&gt;usearch_preceding&lt;/tt&gt; and
&lt;tt&gt;usearch_following&lt;/tt&gt;. Since the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
starting position will be set as it is specified, please take note that </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * there
are some dangerous positions which the search may render incorrect </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
results:</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;ul&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;li&gt; The midst of a substring that requires normalization.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;li&gt; If the following match is to be found, the position should not be
the</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
second character which requires to be swapped with the preceding </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
character. Vice versa, if the preceding match is to be found, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
position to search from should not be the first character which </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
requires to be swapped with the next character. E.g certain Thai and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
Lao characters require swapping.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;li&gt; If a following pattern match is to be found, any position within a </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
contracting sequence except the first will fail. Vice versa if a </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
preceding pattern match is to be found, a invalid starting point </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *      would
be any character within a contracting sequence except the last.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;\ul&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * A
breakiterator can be used if only matches at logical breaks are desired.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
Options are provided to handle overlapping matches. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * E.g.
In English, overlapping matches produces the result 0 and 2 </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * for
the pattern &quot;abab&quot; in the text &quot;ababab&quot;, where else
mutually </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
exclusive matches only produce the result of 0.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * Though
collator attributes will be taken into consideration while </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
performing matches, there are no APIs here for setting and getting the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
attributes. These attributes can be set by getting the collator</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * from
&lt;tt&gt;usearch_getCollator&lt;/tt&gt; and using the APIs in
&lt;tt&gt;ucol.h&lt;/tt&gt;.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
Restriction: &lt;br&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
Currently there are no composite characters that consists of a</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
character with combining class &gt; 0 before a character with combining </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * class
== 0. However, if such a character exists in the future, the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * search
mechanism does not guarantee the results for option 1.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
Example of use:&lt;br&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;pre&gt;&lt;code&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * char
*tgtstr = &quot;The quick brown fox jumped over the lazy fox&quot;;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * char
*patstr = &quot;fox&quot;;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * UChar
target[64];</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * UChar
pattern[16];</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
UErrorCode status = U_ZERO_ERROR;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
u_uastrcpy(target, tgtstr);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
u_uastrcpy(pattern, patstr);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
UStringSearch *search = usearch_open(pattern, -1, target, -1,
&quot;en_US&quot;, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *                                 
&amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * if
(U_SUCCESS(status)) {</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *    
for (int pos = usearch_first(search); </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *          
                           pos != USEARCH_DONE; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *                                     
pos = usearch_next(search)) {</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *        
printf(&quot;Found match at %d pos, length is %d\n&quot;, pos, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *                                       
usearch_getMatchLength(search));</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     }</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * }</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;/code&gt;&lt;/pre&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* DONE is
returned by previous() and next() after all valid matches have </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* been
returned, and by first() and last() if there are no matches at all.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>#define
USEARCH_DONE -1</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Data
structure for searching</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>struct
UStringSearch;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>typedef
struct UStringSearch UStringSearch;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>typedef
enum {</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**
Option for overlapping matches */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
USEARCH_OVERLAP,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /** </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
Option for canonical matches. option 1 in header documentation.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    The
default value will be USEARCH_OFF</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
USEARCH_CANONICAL_MATCH,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
USEARCH_ATTRIBUTE_COUNT</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>}
USearchAttribute;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>typedef
enum {</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**
default value for any USearchAttribute */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
USEARCH_DEFAULT = -1,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**
value for USEARCH_OVERLAP and USEARCH_CANONICAL_MATCH */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    USEARCH_OFF,
</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**
value for USEARCH_OVERLAP and USEARCH_CANONICAL_MATCH */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
USEARCH_ON,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
USEARCH_ATTRIBUTE_VALUE_COUNT</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>}
USearchAttributeValue;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/* open
and close ------------------------------------------------------ */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
Creating a search iterator data struct using the argument locale language</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* rule
set. A collator will be created in the process, which will be owned by</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* this
search and will be deleted in &lt;tt&gt;usearch_close&lt;/tt&gt;.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
pattern for matching</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
patternlength length of the pattern, -1 for null-termination</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
text text string</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
textlength length of the text string, -1 for null-termination</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
locale name of locale for the rules to be used</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
breakiter A BreakIterator that will be used to restrict the points</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
at which matches are detected. If a match is found, but </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
the match's start or end index is not a boundary as </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt;, the match will </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
be rejected and another will be searched for. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
If this parameter is &lt;tt&gt;NULL&lt;/tt&gt;, no break detection is </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
attempted.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
search iterator data structure</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
UStringSearch * usearch_open(const UChar          *pattern, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                         
int32_t         patternlength, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                   
const UChar          *text, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                         
int32_t         textlength,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                   
const char           *locale,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                         
UBreakIterator *breakiter,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                         
UErrorCode     *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
Creating a search iterator data struct using the argument collator language</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* rule
set. Note, user retains the ownership of this collator, thus the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
responsibility of deletion lies with the user.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
pattern for matching</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
patternlength length of the pattern, -1 for null-termination</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
text text string</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
textlength length of the text string, -1 for null-termination</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
collator used for the language rules</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
breakiter A BreakIterator that will be used to restrict the points</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
at which matches are detected. If a match is found, but </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
the match's start or end index is not a boundary as </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt;, the match will </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
be rejected and another will be searched for. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
If this parameter is &lt;tt&gt;NULL&lt;/tt&gt;, no break detection is </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
attempted.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
search iterator data structure</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
UStringSearch * usearch_openFromCollator(const UChar *pattern, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                              
int32_t         patternlength,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                        
const UChar          *text, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                              
int32_t         textlength,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>           
                             const UCollator      *collator,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                              
UBreakIterator *breakiter,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                              
UErrorCode     *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
Destroying and cleaning up the search iterator data struct.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* If a
collator is created in usearch_open, it will be destroyed here.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
searchiter data struct to clean up</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
void usearch_close(UStringSearch *strsrch);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/* get
and set methods -------------------------------------------------- */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Sets
the current position in the text string which the next search will </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* start
from. Clears previous states. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* This
method takes the argument index and sets the position in the text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* string
accordingly without checking if the index is pointing to a </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* valid
starting point to begin searching. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Search
positions that may render incorrect results are highlighted in the</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* header
comments</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
position position to start next search from.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status error status if any.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
void usearch_setOffset(UStringSearch *strsrch, UTextOffset position,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                             
UErrorCode    *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Return
the current index in the string text being searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* If the
iteration has gone past the end of the text (or past the beginning </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* for a
backwards search), {@link #USEARCH_DONE} is returned.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
UTextOffset usearch_getOffset(const UStringSearch *strsrch);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Sets
the text searching attributes located in the enum USearchAttribute</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* with
values from the enum USearchAttributeValue.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
USEARCH_DEFAULT can be used for all attributes for resetting.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
attribute text attribute to be set</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
value text attribute value</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @see
#usearch_getAttribute</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
void usearch_setAttribute(UStringSearch         *strsrch, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                
USearchAttribute       attribute,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                
USearchAttributeValue  value,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                
UErrorCode            *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Gets
the text searching attributes.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
attribute text attribute to be retrieve</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
text attribute value</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @see
#usearch_setAttribute</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
USearchAttributeValue usearch_getAttribute(</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                        
const UStringSearch    *strsrch,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                       
       USearchAttribute  attribute);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Returns
the index to the match in the text string that was searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* This
call returns a valid result only after a successful call to </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* {@link
#usearch_first}, {@link #usearch_next}, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* {@link
#usearch_previous}, or {@link #usearch_last}.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Just
after construction, or after a searching method returns </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
&lt;tt&gt;USEARCH_DONE&lt;/tt&gt;, this method will return
&lt;tt&gt;USEARCH_DONE&lt;/tt&gt;.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Use
usearch_getMatchedLength to get the matched string length.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
index to a substring within the text string that is being </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*        
searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
UTextOffset usearch_getMatchedStart(const UStringSearch *strsrch);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Returns
the length of text in the string which matches the search pattern. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* This
call returns a valid result only after a successful call to </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* {@link
#usearch_first}, {@link #usearch_next}, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* {@link
#usearch_previous}, or {@link #usearch_last}.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Just
after construction, or after a searching method returns </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
&lt;tt&gt;USEARCH_DONE&lt;/tt&gt;, this method will return 0.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
The length of the match in the string text, or 0 if there is no </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*        
match currently.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
int32_t usearch_getMatchedLength(const UStringSearch *strsrch);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Returns
the text that was matched by the most recent call to </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* {@link
#usearch_first}, {@link #usearch_next}, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* {@link
#usearch_previous}, or {@link #usearch_last}.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* If the
iterator is not pointing at a valid match (e.g. just after </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
construction or after &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; has been returned,
returns</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* an
empty string. If result is not large enough to store the matched text,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* result
will be filled with the partial text and an U_BUFFER_OVERFLOW_ERROR </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* will be
returned in status. result will be null-terminated whenever </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
possible. If the buffer fits the matched text exactly, a null-termination </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* is not
possible, then a U_STRING_NOT_TERMINATED_ERROR set in status.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
Pre-flighting can be either done with length = 0 or the API </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
usearch_getMatchLength().</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
result UChar buffer to store the matched string</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
resultCapacity length of the result buffer</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status error returned if result is not large enough</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
exact length of the matched text, not counting the null-termination</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
int32_t usearch_getMatchedText(const UStringSearch *strsrch, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                           
UChar         *result, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>          
                                 int32_t        resultCapacity, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                           
UErrorCode    *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Set the
BreakIterator that will be used to restrict the points at which </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* matches
are detected.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
breakiter A BreakIterator that will be used to restrict the points</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
at which matches are detected. If a match is found, but </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
the match's start or end index is not a boundary as </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt;, the match will </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
be rejected and another will be searched for. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
If this parameter is &lt;tt&gt;NULL&lt;/tt&gt;, no break detection is </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*                 
attempted.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @see
#usearch_getBreakIterator</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
void usearch_setBreakIterator(UStringSearch  *strsrch, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                    
UBreakIterator *breakiter,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                    
UErrorCode     *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Returns
the BreakIterator that is used to restrict the points at which </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* matches
are detected. This will be the same object that was passed to the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
constructor or to &lt;tt&gt;usearch_setBreakIterator&lt;/tt&gt;. Note that </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
&lt;tt&gt;NULL&lt;/tt&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* is a
legal value; it means that break detection should not be attempted.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
break iterator used</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @see
#usearch_setBreakIterator</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
const UBreakIterator * usearch_getBreakIterator(</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>         
                                    const UStringSearch *strsrch);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Set the
string text to be searched. Text iteration will hence begin at the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* start
of the text string. This method is useful if you want to re-use an </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
iterator to search for the same pattern within a different body of text.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
text new string to look for match</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
textlength length of the new string, -1 for null-termination</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @see #usearch_getText</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
void usearch_setText(      UStringSearch *strsrch, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                           
const UChar         *text,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                 
int32_t        textlength,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                 
UErrorCode    *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Return
the string text to be searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
length returned string text length</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
string text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @see
#usearch_setText</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
const UChar * usearch_getText(const UStringSearch *strsrch, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                           int32_t      
*length);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Gets
the collator used for the language rules. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
Deleting the returned &lt;tt&gt;UCollator&lt;/tt&gt; before calling </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
&lt;tt&gt;usearch_close&lt;/tt&gt; would cause the string search to fail.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
&lt;tt&gt;usearch_close&lt;/tt&gt; will delete the collator if this search owns
it.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
collator</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
UCollator * usearch_getCollator(const UStringSearch *strsrch);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Sets
the collator used for the language rules. User retains the ownership </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* of this
collator, thus the responsibility of deletion lies with the user.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* This
method causes internal data such as Boyer-Moore shift tables to  </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* be
recalculated, but the iterator's position is unchanged.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
collator to be used</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
void usearch_setCollator(      UStringSearch *strsrch, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                               
const UCollator     *collator,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                           
          UErrorCode    *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Sets
the pattern used for matching.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
Internal data like the Boyer Moore table will be recalculated, but the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
iterator's position is unchanged.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
pattern string</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
patternlength pattern length, -1 for null-terminated string</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
void usearch_setPattern(      UStringSearch *strsrch, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                              
const UChar         *pattern,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                    
                int32_t        patternlength,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                    
UErrorCode    *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Gets
the search pattern</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
length return length of the pattern, -1 indicates that the pattern </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*              
is null-terminated</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
pattern string</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
const UChar * usearch_getPattern(const UStringSearch *strsrch, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                             
int32_t       *length);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/*
methods ------------------------------------------------------------- */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Returns
the first index at which the string text matches the search </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
pattern.  </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* The
iterator is adjusted so that its current index (as returned by </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* {@link
#usearch_getOffset}) is the match position if one was found.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* If a
match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* the
iterator will be adjusted to the index USEARCH_DONE.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
The character index of the first match, or </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
&lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
UTextOffset usearch_first(UStringSearch *strsrch, UErrorCode *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Returns
the first index greater than &lt;tt&gt;position&lt;/tt&gt; at which the string </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* matches
the search pattern. The iterator is adjusted so that its current </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* index
(as returned by {@link #usearch_getOffset}) is the match position if </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* one was
found.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* If a
match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* the
iterator will be adjusted to the index USEARCH_DONE</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Search
positions that may render incorrect results are highlighted in the</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* header
comments.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
position to start the search at</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
The character index of the first match following &lt;tt&gt;pos&lt;/tt&gt;,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*        
or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
UTextOffset usearch_following(UStringSearch *strsrch, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                
UTextOffset    position, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                
UErrorCode    *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Returns
the last index in the target text at which it matches the search </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
pattern. The iterator is adjusted so that its current </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* index
(as returned by {@link #usearch_getOffset}) is the match position if </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* one was
found.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* If a
match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* the
iterator will be adjusted to the index USEARCH_DONE.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
The index of the first match, or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*        
are no matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
UTextOffset usearch_last(UStringSearch *strsrch, UErrorCode *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Returns
the first index less than &lt;tt&gt;position&lt;/tt&gt; at which the string
text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* matches
the search pattern. The iterator is adjusted so that its current </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* index
(as returned by {@link #usearch_getOffset}) is the match position if </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* one was
found.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* If a
match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* the
iterator will be adjusted to the index USEARCH_DONE</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Search
positions that may render incorrect results are highlighted in the</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* header
comments.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
position index position the search is to begin at</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
The character index of the first match preceding &lt;tt&gt;pos&lt;/tt&gt;,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*        
or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
UTextOffset usearch_preceding(UStringSearch *strsrch, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                
UTextOffset    position, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                                
UErrorCode    *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Returns
the index of the next point at which the string text matches the</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* search
pattern, starting from the current position.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* The
iterator is adjusted so that its current </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* index
(as returned by {@link #usearch_getOffset}) is the match position if </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* one was
found.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* If a
match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* the
iterator will be adjusted to the index USEARCH_DONE</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
The index of the next match after the current position, or </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*        
&lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no more matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @see
#usearch_first</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
UTextOffset usearch_next(UStringSearch *strsrch, UErrorCode *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Returns
the index of the previous point at which the string text matches</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* the
search pattern, starting at the current position.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* The
iterator is adjusted so that its current </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* index
(as returned by {@link #usearch_getOffset}) is the match position if </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* one was
found.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* If a
match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* the
iterator will be adjusted to the index USEARCH_DONE</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @return
The index of the previous match before the current position,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*        
or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no more matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
UTextOffset usearch_previous(UStringSearch *strsrch, UErrorCode *status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/** </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Reset
the iteration.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Search
will begin at the start of the text string if a forward iteration </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* is
initiated before a backwards iteration. Otherwise if a backwards </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*
iteration is initiated before a forwards iteration, the search will begin</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* at the
end of the text string.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* @param
strsrch search iterator data struct</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>U_CAPI
void usearch_reset(UStringSearch *strsrch);</span></p>

<span style='font-size:10.0pt;font-family:Arial'><br clear=all
style='page-break-before:always'>
</span>

<p class=MsoNormal>&nbsp;</p>

<h1><span style='font-family:Arial'>Proposed C++ class design and API</span></h1>

<p class=MsoNormal>&nbsp;</p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Arial'>There are 2
classes are designed to support <i>StringSearch</i>: </span></p>

<p class=MsoNormal><i><span style='font-size:10.0pt;font-family:Arial'>SearchIterator</span></i><span
style='font-size:10.0pt;font-family:Arial'>, an abstract base class which all
search classes are to extend from, and <i>StringSearch</i>, the concrete
subclass of <i>SearchIterator </i>that provides language-sensitive text
searching based on the comparison rules defined RuleBasedCollator. </span></p>

<pre><span style='font-family:Arial'>&nbsp;</span></pre>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>#include
&quot;unicode/unistr.h&quot;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>#include
&quot;unicode/chariter.h&quot;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>#include
&quot;unicode/brkiter.h&quot;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>#include
&quot;unicode/usearch.h&quot;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;tt&gt;SearchIterator&lt;/tt&gt; is an abstract base class that provides </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
methods to search for a pattern within a text string. Instances of</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;tt&gt;SearchIterator&lt;/tt&gt; maintain a current position and scans over
the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * target
text, returning the indices the pattern is matched and the length </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * of
each match.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;tt&gt;SearchIterator&lt;/tt&gt; defines a protocol for text searching. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
Subclasses provide concrete implementations of various search algorithms. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * For
example, {@link StringSearch} implements language-sensitive pattern </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
matching based on the comparison rules defined in a </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * {@link
RuleBasedCollator} object. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * Other
options for searching includes using a BreakIterator to restrict </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * the
points at which matches are detected.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;tt&gt;SearchIterator&lt;/tt&gt; provides an API that is similar to that of</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * other
text iteration classes such as &lt;tt&gt;BreakIterator&lt;/tt&gt;. Using </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * this
class, it is easy to scan through text looking for all occurances of </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * a
given pattern. The following example uses a &lt;tt&gt;StringSearch&lt;/tt&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * object
to find all instances of &quot;fox&quot; in the target string. Any other </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
subclass of &lt;tt&gt;SearchIterator&lt;/tt&gt; can be used in an identical </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
manner.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;pre&gt;&lt;code&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
UnicodeString target(&quot;The quick brown fox jumped over the lazy fox&quot;);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
UnicodeString pattern(&quot;fox&quot;);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
SearchIterator *iter = new StringSearch(pattern, target);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * for
(int pos = iter-&gt;first(); pos != USEARCH_DONE; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *                              
pos = iter-&gt;next()) {</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *    
printf(&quot;Found match at %d pos, length is %d\n&quot;, pos, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *                                            
iter.getMatchLength());</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * }</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;/code&gt;&lt;/pre&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * @see
StringSearch</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>struct
USearch;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>typedef
struct USearch USearch;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>* Data
structure for searching</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>*/</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>class
U_I18N_API SearchIterator {</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>public:</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    //
public constructors and destructors -------------------------------</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /** </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
Copy constructor that creates a SearchIterator instance with the same </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
behavior, and iterating over the same text. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
@param other the SearchIterator instance to be copied.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
SearchIterator(const SearchIterator &amp;other);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Destructor. Cleans up the search iterator data struct.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual ~SearchIterator();</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    //
public get and set methods ----------------------------------------</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Sets the index to point to the given position, and clears any state </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
that's affected.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
This method takes the argument index and sets the position in the text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
string accordingly without checking if the index is pointing to a </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
valid starting point to begin searching. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param position within the text to be set</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual void setOffset(UTextOffset position, UErrorCode &amp;status) = 0;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Return the current index in the text being searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * If
the iteration has gone past the end of the text</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
(or past the beginning for a backwards search), {@link #USEARCH_DONE} </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * is
returned.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return current index in the text being searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual UTextOffset getOffset(void) const = 0;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
Sets the text searching attributes located in the enum </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
USearchAttribute with values from the enum USearchAttributeValue.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
USEARCH_DEFAULT can be used for all attributes for resetting.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
@param attribute text attribute (enum USearchAttribute) to be set</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
@param value text attribute value</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
@param status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    void
setAttribute(USearchAttribute       attribute,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>          
           USearchAttributeValue  value,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                     
UErrorCode            &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
/**    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
Gets the text searching attributes</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
@param attribute text attribute (enum USearchAttribute) to be retrieve</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
@return text attribute value</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
USearchAttributeValue getAttribute(USearchAttribute  attribute) const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
Returns the index to the match in the text string that was searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
This call returns a valid result only after a successful call to </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    * {@link
#first}, {@link #next}, {@link #previous}, or {@link #last}.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
Just after construction, or after a searching method returns </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
&lt;tt&gt;USEARCH_DONE&lt;/tt&gt;, this method will return
&lt;tt&gt;USEARCH_DONE&lt;/tt&gt;.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    * Use
getMatchedLength to get the matched string length.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
@return index of a substring within the text string that is being </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
*         searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
UTextOffset getMatchedStart(void) const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Returns the length of text in the string which matches the search </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
pattern. This call returns a valid result only after a successful call </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * to
{@link #first}, {@link #next}, {@link #previous}, or {@link #last}.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Just after construction, or after a searching method returns </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
&lt;tt&gt;USEARCH_DONE&lt;/tt&gt;, this method will return 0.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return The length of the match in the target text, or 0 if there</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*         is no match currently.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
int32_t getMatchedLength(void) const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Returns the text that was matched by the most recent call to </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
{@link #first}, {@link #next}, {@link #previous}, or {@link #last}.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * If
the iterator is not pointing at a valid match (e.g. just after </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
construction or after &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; has been returned, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
returns an empty string. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param result stores the matched string or an empty string if a match</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*        is not found.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    void
getMatchedText(UnicodeString &amp;result) const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Set the BreakIterator that will be used to restrict the points</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * at
which matches are detected. The user is responsible for deleting </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
the breakiterator.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param breakiter A BreakIterator that will be used to restrict the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                points at which matches are detected. If a match is </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                found, but the match's start or end index is not a </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                boundary as determined by the
&lt;tt&gt;BreakIterator&lt;/tt&gt;, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                the match will be rejected and another will be searched </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                for. If this parameter is &lt;tt&gt;NULL&lt;/tt&gt;, no break</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                detection is attempted.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param  status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    void
setBreakIterator(BreakIterator *breakiter, UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Returns the BreakIterator that is used to restrict the points at </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
which matches are detected.  This will be the same object that was </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
passed to the constructor or to &lt;tt&gt;setBreakIterator&lt;/tt&gt;.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Note that &lt;tt&gt;NULL&lt;/tt&gt; is a legal value; it means that break</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
detection should not be attempted.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return BreakIterator used to restrict matchings.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    const
BreakIterator * getBreakIterator(void) const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Set the string text to be searched. Text iteration will hence begin at </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
the start of the text string. This method is useful if you want to </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
re-use an iterator to search for the same pattern within a different </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
body of text. The user is responsible for deleting the text.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param text string to be searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual void setText(const UnicodeString &amp;text, UErrorCode &amp;status);   
</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Set the string text to be searched. Text iteration will hence begin at </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
the start of the text string. This method is useful if you want to </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
re-use an iterator to search for the same pattern within a different </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
body of text.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Note: No parsing of the text within the &lt;tt&gt;CharacterIterator&lt;/tt&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
will be done during searching for this version. The block of text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * in
&lt;tt&gt;CharacterIterator&lt;/tt&gt; will be used as it is.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
The user is responsible for deleting the text.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param text string iterator to be searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param  status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual void setText(CharacterIterator &amp;text, UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Return the string text to be searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return text string to be searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    const
UnicodeString &amp; getText(void) const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    //
operator overloading ----------------------------------------------</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Equality operator. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param that SearchIterator instance to be compared.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return TRUE if both BreakIterators are of the same class, have the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *        
same behavior, terates over the same text and have the same</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*         attributes. FALSE otherwise.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual UBool operator==(const SearchIterator &amp;that) const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Not-equal operator. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param that SearchIterator instance to be compared.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return FALSE if operator== returns TRUE, and vice versa.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    UBool
operator!=(const SearchIterator &amp;that) const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    //
public methods ----------------------------------------------------</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Returns a copy of SearchIterator with the same behavior, and </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
iterating over the same text, as this one. Note that all data will be</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
replicated, except for the text string to be searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return cloned object</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual SearchIterator* safeClone(void) const = 0;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Returns the first index at which the string text matches the search </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
pattern. The iterator is adjusted so that its current index (as </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
returned by {@link #usearch_getOffset}) is the match position if one </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
was found.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * If
a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
the iterator will be adjusted to the index USEARCH_DONE</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param  status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return The character index of the first match, or </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*         &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
UTextOffset first(UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Returns the first index greater than &lt;tt&gt;position&lt;/tt&gt; at which the
</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
string text matches the search pattern. The iterator is adjusted so </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
that its current index (as returned by {@link #getOffset}) is the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
match position if one was found. If a match is not found, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
&lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and the iterator will be </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
adjusted to the index USEARCH_DONE</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param  position where search if to start from</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param  status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return The character index of the first match following </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*         &lt;tt&gt;position&lt;/tt&gt;, or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;
if there are no </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*         matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
UTextOffset following(UTextOffset position, UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Returns the last index in the target text at which it matches the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
search pattern. The iterator is adjusted so that its current index </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
(as returned by {@link #getOffset}) is the match position if one was </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
found.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * If
a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
the iterator will be adjusted to the index USEARCH_DONE.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param  status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return The index of the first match, or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*         there are no matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
UTextOffset last(UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Returns the first index less than &lt;tt&gt;position&lt;/tt&gt; at which the
string </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
text matches the search pattern. The iterator is adjusted so that its </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
current index (as returned by {@link #getOffset}) is the match </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
position if one was found. If a match is not found, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
&lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and the iterator will be </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
adjusted to the index USEARCH_DONE</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param  position where search is to start from</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param  status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return The character index of the first match preceding </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*         &lt;tt&gt;position&lt;/tt&gt;, or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt;
if there are </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*         no matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
UTextOffset preceding(UTextOffset position, UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Returns the index of the next point at which the text matches the</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
search pattern, starting from the current position</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
The iterator is adjusted so that its current index (as returned by </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
{@link #getIndex}) is the match position if one was found.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * If
a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
the iterator will be adjusted to a position after the end of the text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
string.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param  status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return The index of the next match after the current position,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*          or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no more matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
UTextOffset next(UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Returns the index of the previous point at which the string text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
matches the search pattern, starting at the current position.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
The iterator is adjusted so that its current index (as returned by </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
{@link #getOffset}) is the match position if one was found.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * If
a match is not found, &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; will be returned and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
the iterator will be adjusted to the index USEARCH_DONE</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param  status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return The index of the previous match before the current position,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*          or &lt;tt&gt;USEARCH_DONE&lt;/tt&gt; if there are no more matches.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
UTextOffset previous(UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /** </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
Resets the iteration.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
Search will begin at the start of the text string if a forward </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
iteration is initiated before a backwards iteration. Otherwise if a </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
backwards iteration is initiated before a forwards iteration, the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
search will begin at the end of the text string.    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual void reset();</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>}</span></p>

<span style='font-size:10.0pt;font-family:Courier'><br clear=all
style='page-break-before:always'>
</span>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>#include
&quot;unicode/tblcoll.h&quot;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>#include
&quot;unicode/coleitr.h&quot;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>#include
&quot;unicode/search.h&quot;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>/**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;tt&gt;StringSearch&lt;/tt&gt; is a &lt;tt&gt;SearchIterator&lt;/tt&gt; that
provides</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
language-sensitive text searching based on the comparison rules defined</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * in a
{@link RuleBasedCollator} object.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
StringSearch ensures that language eccentricity can be </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
handled, e.g. for the German collator, characters ß and SS will be matched </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * if
case is chosen to be ignored. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * See
the &lt;a
href=http://oss.software.ibm.com/cvs/icu/~checkout~/icuhtml/design/collation/ICU_collation_design.htm&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&quot;ICU Collation Design Document&quot;&lt;/a&gt; for more information.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * The
algorithm implemented is a modified form of the Boyer Moore's search.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * For
more information  see </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * &lt;a
href=http://oss.software.ibm.com/icu/docs/papers/text-search.html&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&quot;Efficient Text Searching in Java&quot;&lt;/a&gt;, published in
&lt;i&gt;Java Report&lt;/i&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * in
February, 1999, for further information on the algorithm.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * There
are 2 match options for selection:&lt;br&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * Let S'
be the sub-string of a text string S between the offsets start and </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * end
&lt;start, end&gt;.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;br&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * A
pattern string P matches a text string S at the offsets &lt;start, end&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * if</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;pre&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * option
1. Some canonical equivalent of P matches some canonical equivalent </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *          
of S'</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * option
2. P matches S' and if P starts or ends with a combining mark, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *          
there exists no non-ignorable combining mark before or after S? </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *          
in S respectively. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;/pre&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * Option
2. will be the default·</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * This
search has APIs similar to that of other text iteration mechanisms </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * such
as the break iterators in &lt;tt&gt;BreakIterator&lt;/tt&gt;. Using these </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * APIs,
it is easy to scan through text looking for all occurances of </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * a
given pattern. This search iterator allows changing of direction by </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
calling a &lt;tt&gt;reset&lt;/tt&gt; followed by a &lt;tt&gt;next&lt;/tt&gt; or
&lt;tt&gt;previous&lt;/tt&gt;. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * Though
a direction change can occur without calling &lt;tt&gt;reset&lt;/tt&gt; first, 
</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * this
operation comes with some speed penalty.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * Match
results in the forward direction will match the result matches in </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * the
backwards direction in the reverse order</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;tt&gt;SearchIterator&lt;/tt&gt; provides APIs to specify the starting
position </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * within
the text string to be searched, e.g. &lt;tt&gt;setOffset&lt;/tt&gt;,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;tt&gt;preceding&lt;/tt&gt; and &lt;tt&gt;following&lt;/tt&gt;. Since the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
starting position will be set as it is specified, please take note that </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * there
are some danger points which the search may render incorrect </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
results:</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;ul&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;li&gt; The midst of a substring that requires normalization.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;li&gt; If the following match is to be found, the position should not be
the</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
second character which requires to be swapped with the preceding </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
character. Vice versa, if the preceding match is to be found, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
position to search from should not be the first character which </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
requires to be swapped with the next character. E.g certain Thai and</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
Lao characters require swapping.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;li&gt; If a following pattern match is to be found, any position within a </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
contracting sequence except the first will fail. Vice versa if a </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
preceding pattern match is to be found, a invalid starting point </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *     
would be any character within a contracting sequence except the last.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;\ul&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * A
breakiterator can be used if only matches at logical breaks are desired.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
Options are provided to handle overlapping matches. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * E.g.
In English, overlapping matches produces the result 0 and 2 </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * for
the pattern &quot;abab&quot; in the text &quot;ababab&quot;, where else
mutually </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
exclusive matches only produce the result of 0.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * Though
collator attributes will be taken into consideration while </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
performing matches, there are no APIs here for setting and getting the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
attributes. These attributes can be set by getting the collator</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * from
&lt;tt&gt;getCollator&lt;/tt&gt; and using the APIs in
&lt;tt&gt;coll.h&lt;/tt&gt;.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
Restriction: &lt;br&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
Currently there are no composite characters that consists of a</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
character with combining class &gt; 0 before a character with combining </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * class
== 0. However, if such a character exists in the future,  </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
StringSearch does not guarantee the results for option 1.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
Consult the &lt;tt&gt;SearchIterator&lt;/tt&gt; documentation for information
on</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * and
examples of how to use instances of this class to implement text</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
searching.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;pre&gt;&lt;code&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
UnicodeString target(&quot;The quick brown fox jumped over the lazy fox&quot;);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
UnicodeString pattern(&quot;fox&quot;);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
SearchIterator *iter = new StringSearch(pattern, target);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * for
(int pos = iter-&gt;first(); pos != USEARCH_DONE; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *                              
pos = iter-&gt;next()) {</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *    
printf(&quot;Found match at %d pos, length is %d\n&quot;, pos, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *                                            
iter.getMatchLength());</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * }</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> *
&lt;/code&gt;&lt;/pre&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * @see
SearchIterator</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> * @see
RuleBasedCollator</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'> */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>class
U_I18N_API StringSearch : public SearchIterator</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>{</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>public:</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    //
public constructors and destructors --------------------------------</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Creating a &lt;tt&gt;StringSearch&lt;/tt&gt; instance using the argument locale
</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
language rule set. A collator will be created in the process, which </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
will be owned by this instance and will be deleted in during </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
destruction</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param pattern The text for which this object will search.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param text    The text in which to search for the pattern.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param locale  A locale which defines the language-sensitive </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                comparison rules used to determine whether text in the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                pattern and target matches. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param breakiter A &lt;tt&gt;BreakIterator&lt;/tt&gt; object used to constrain </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                the matches that are found. Matches whose start and end </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                indices in the target text are not boundaries as </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *                determined
by the &lt;tt&gt;BreakIterator&lt;/tt&gt; are </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                ignored. If this behavior is not desired, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                &lt;tt&gt;NULL&lt;/tt&gt; can be passed in instead.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param status  for errors if any</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    StringSearch(const
UnicodeString &amp;pattern, const UnicodeString &amp;text,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                
const Locale        &amp;locale,       </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                      
BreakIterator *breakiter,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                      
UErrorCode    &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Creating a &lt;tt&gt;StringSearch&lt;/tt&gt; instance using the argument
collator </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
language rule set. Note, user retains the ownership of this collator, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * it
does not get destroyed during this instance's destruction.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param pattern The text for which this object will search.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param text    The text in which to search for the pattern.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param coll    A &lt;tt&gt;RuleBasedCollator&lt;/tt&gt; object which defines </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                the language-sensitive comparison rules used to </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                determine whether text in the pattern and target </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                matches. User is responsible for the clearing of this</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                object.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param breakiter A &lt;tt&gt;BreakIterator&lt;/tt&gt; object used to constrain </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                the matches that are found. Matches whose start and end </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                indices in the target text are not boundaries as </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt; are </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                ignored. If this behavior is not desired, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                &lt;tt&gt;NULL&lt;/tt&gt; can be passed in instead.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param status  for errors if any</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
StringSearch(const UnicodeString     &amp;pattern, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                
const UnicodeString     &amp;text,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                      
RuleBasedCollator *coll,       </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                       BreakIterator    
*breakiter,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                      
UErrorCode        &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Creating a &lt;tt&gt;StringSearch&lt;/tt&gt; instance using the argument locale
</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
language rule set. A collator will be created in the process, which </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
will be owned by this instance and will be deleted in during </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
destruction</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Note: No parsing of the text within the &lt;tt&gt;CharacterIterator&lt;/tt&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
will be done during searching for this version. The block of text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * in
&lt;tt&gt;CharacterIterator&lt;/tt&gt; will be used as it is.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param pattern The text for which this object will search.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param text    The text iterator in which to search for the pattern.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param locale  A locale which defines the language-sensitive </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                comparison rules used to determine whether text in the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                pattern and target matches. User is responsible for </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                the clearing of this object.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param breakiter A &lt;tt&gt;BreakIterator&lt;/tt&gt; object used to constrain </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                the matches that are found. Matches whose start and end </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                indices in the target text are not boundaries as </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt; are </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *               
ignored. If this behavior is not desired, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                &lt;tt&gt;NULL&lt;/tt&gt; can be passed in instead.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param status  for errors if any</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
StringSearch(const UnicodeString &amp;pattern, CharacterIterator &amp;text,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>          
      const Locale        &amp;locale, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                      
BreakIterator *breakiter,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                      
UErrorCode    &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Creating a &lt;tt&gt;StringSearch&lt;/tt&gt; instance using the argument
collator </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
language rule set. Note, user retains the ownership of this collator, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * it
does not get destroyed during this instance's destruction.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Note: No parsing of the text within the &lt;tt&gt;CharacterIterator&lt;/tt&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
will be done during searching for this version. The block of text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * in
&lt;tt&gt;CharacterIterator&lt;/tt&gt; will be used as it is.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param pattern The text for which this object will search.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param text    The text in which to search for the pattern.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param coll    A &lt;tt&gt;RuleBasedCollator&lt;/tt&gt; object which defines </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                the language-sensitive comparison rules used to </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                determine whether text in the pattern and target </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                matches. User is responsible for the clearing of this</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                object.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param breakiter A &lt;tt&gt;BreakIterator&lt;/tt&gt; object used to constrain </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                the matches that are found. Matches whose start and end </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                indices in the target text are not boundaries as </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                determined by the &lt;tt&gt;BreakIterator&lt;/tt&gt; are </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                ignored. If this behavior is not desired, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*                &lt;tt&gt;NULL&lt;/tt&gt; can be passed in instead.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param status  for errors if any</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    StringSearch(const
UnicodeString     &amp;pattern, CharacterIterator &amp;text,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                      
RuleBasedCollator *coll, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                      
BreakIterator     *breakiter,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>                      
UErrorCode        &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Copy constructor that creates a StringSearch instance with the same </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
behavior, and iterating over the same text.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param that StringSearch instance to be copied.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
StringSearch(const StringSearch &amp;that);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    *
Destructor. Cleans up the search iterator data struct.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    * If
a collator is created in the constructor, it will be destroyed here.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual ~StringSearch(void);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    //
operator overloading ---------------------------------------------</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Assignment operator. Sets this iterator to have the same behavior,</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
and iterate over the same text, as the one passed in.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param that instance to be copied.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual StringSearch &amp; operator=(const StringSearch &amp;that);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Equality operator. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param that instance to be compared.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return TRUE if both instances have the same attributes, </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*         breakiterators, collators and iterate over the same text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    
*         while looking for the same pattern.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    virtual
UBool operator==(const SearchIterator &amp;that) const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    //
public get and set methods ----------------------------------------</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Sets the index to point to the given position, and clears any state </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
that's affected.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
This method takes the argument index and sets the position in the text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
string accordingly without checking if the index is pointing to a </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
valid starting point to begin searching. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param position within the text to be set</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param status for errors if it occurs</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual void setOffset(UTextOffset position, UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Return the current index in the text being searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * If
the iteration has gone past the end of the text</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
(or past the beginning for a backwards search), {@link #USEARCH_DONE} </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * is
returned.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return current index in the text being searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual UTextOffset getOffset(void) const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Set the target text to be searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Text iteration will hence begin at the start of the text string. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
This method is </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
useful if you want to re-use an iterator to search for the same </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
pattern within a different body of text.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param text text string to be searched</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param status  for errors if any</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual void setText(const UnicodeString &amp;text, UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Set the target text to be searched.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Text iteration will hence begin at the start of the text string. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
This method is </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
useful if you want to re-use an iterator to search for the same </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
pattern within a different body of text.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Note: No parsing of the text within the &lt;tt&gt;CharacterIterator&lt;/tt&gt; </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
will be done during searching for this version. The block of text </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * in
&lt;tt&gt;CharacterIterator&lt;/tt&gt; will be used as it is.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param text text string to be searched</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param status  for errors if any</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual void setText(CharacterIterator &amp;text, UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Gets the collator used for the language rules. </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
&lt;p&gt;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Deleting the returned &lt;tt&gt;RuleBasedCollator&lt;/tt&gt; before calling </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
the destructor would cause the string search to fail.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
The destructor will delete the collator if this instance owns it</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return collator used for string search</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
RuleBasedCollator * getCollator() const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Sets the collator used for the language rules. User retains the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
ownership of this collator, thus the responsibility of deletion lies </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
with the user. This method causes internal data such as Boyer-Moore </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
shift tables to be recalculated, but the iterator's position is </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
unchanged.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param coll    collator </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param status  for errors if any</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    void
setCollator(RuleBasedCollator *coll, UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Sets the pattern used for matching.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Internal data like the Boyer Moore table will be recalculated, but </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
the iterator's position is unchanged.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param pattern search pattern to be found</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@param status for errors if any</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    void
setPattern(const UnicodeString &amp;pattern, UErrorCode &amp;status);</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Gets the search pattern.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return pattern used for matching</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    const
UnicodeString &amp; getPattern() const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    //
public methods ----------------------------------------------------</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /** </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Reset the iteration.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Search will begin at the start of the text string if a forward </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
iteration is initiated before a backwards iteration. Otherwise if </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     * a
backwards iteration is initiated before a forwards iteration, the </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
search will begin at the end of the text string.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual void reset();</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>&nbsp;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>    /**</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
Returns a copy of StringSearch with the same behavior, and </span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
iterating over the same text, as this one. Note that all data will be</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
replicated, except for the user-specified collator and the</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
breakiterator.</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     *
@return cloned object</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>     */</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>   
virtual SearchIterator * safeClone(void) const;</span></p>

<p class=MsoNormal><span style='font-size:10.0pt;font-family:Courier'>}</span></p>

</div>

</body>

</html>
