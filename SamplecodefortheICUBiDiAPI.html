<html><head><TITLE>Sample code for the ICU BiDi API</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  Sample code for the ICU BiDi API  </H2><A NAME="DOC.DOCU">
<BLOCKQUOTE>


<h2>Rendering a paragraph with the ICU BiDi API</h2>

This is (hypothetical) sample code that illustrates
how the ICU BiDi API could be used to render a paragraph of text.
Rendering code depends highly on the graphics system,
therefore this sample code must make a lot of assumptions,
which may or may not match any existing graphics system's properties.

<p>The basic assumptions are:</p>
<ul>
<li>Rendering is done from left to right on a horizontal line.</li>
<li>A run of single-style, unidirectional text can be rendered at once.</li>
<li>Such a run of text is passed to the graphics system with
characters (code units) in logical order.</li>
<li>The line-breaking algorithm is very complicated
and Locale-dependent -
and therefore its implementation omitted from this sample code.</li>
</ul>

<pre>
&nbsp; #include "ubidi.h"
&nbsp; 
&nbsp; typedef enum {
&nbsp;     styleNormal=0, styleSelected=1,
&nbsp;     styleBold=2, styleItalics=4,
&nbsp;     styleSuper=8, styleSub=16
&nbsp; } Style;
&nbsp; 
&nbsp; typedef struct { UTextOffset limit; Style style; } StyleRun;
&nbsp; 
&nbsp; int getTextWidth(const UChar *text, UTextOffset start, UTextOffset limit,
&nbsp;                  const StyleRun *styleRuns, int styleRunCount);
&nbsp; 
&nbsp; // set *pLimit and *pStyleRunLimit for a line
&nbsp; // from text[start] and from styleRuns[styleRunStart]
&nbsp; // using ubidi_getLogicalRun(para, ...)
&nbsp; void getLineBreak(const UChar *text, UTextOffset start, UTextOffset *pLimit,
&nbsp;                   UBiDi *para,
&nbsp;                   const StyleRun *styleRuns, int styleRunStart, int *pStyleRunLimit,
&nbsp;                   int *pLineWidth);
&nbsp; 
&nbsp; // render runs on a line sequentially, always from left to right
&nbsp; 
&nbsp; // prepare rendering a new line
&nbsp; void startLine(UBiDiDirection textDirection, int lineWidth);
&nbsp; 
&nbsp; // render a run of text and advance to the right by the run width
&nbsp; // the text[start..limit-1] is always in logical order
&nbsp; void renderRun(const UChar *text, UTextOffset start, UTextOffset limit,
&nbsp;                UBiDiDirection textDirection, Style style);
&nbsp; 
&nbsp; // We could compute a cross-product
&nbsp; // from the style runs with the directional runs
&nbsp; // and then reorder it.
&nbsp; // Instead, here we iterate over each run type
&nbsp; // and render the intersections -
&nbsp; // with shortcuts in simple (and common) cases.
&nbsp; // renderParagraph() is the main function.
&nbsp; 
&nbsp; // render a directional run with
&nbsp; // (possibly) multiple style runs intersecting with it
&nbsp; void renderDirectionalRun(const UChar *text,
&nbsp;                           UTextOffset start, UTextOffset limit,
&nbsp;                           UBiDiDirection direction,
&nbsp;                           const StyleRun *styleRuns, int styleRunCount) {
&nbsp;     int i;
&nbsp; 
&nbsp;     // iterate over style runs
&nbsp;     if(direction==UBIDI_LTR) {
&nbsp;         int styleLimit;
&nbsp; 
&nbsp;         for(i=0; i&lt;styleRunCount; ++i) {
&nbsp;             styleLimit=styleRun[i].limit;
&nbsp;             if(start&lt;styleLimit) {
&nbsp;                 if(styleLimit>limit) { styleLimit=limit; }
&nbsp;                 renderRun(text, start, styleLimit,
&nbsp;                           direction, styleRun[i].style);
&nbsp;                 if(styleLimit==limit) { break; }
&nbsp;                 start=styleLimit;
&nbsp;             }
&nbsp;         }
&nbsp;     } else {
&nbsp;         int styleStart;
&nbsp; 
&nbsp;         for(i=styleRunCount-1; i>=0; --i) {
&nbsp;             if(i>0) {
&nbsp;                 styleStart=styleRun[i-1].limit;
&nbsp;             } else {
&nbsp;                 styleStart=0;
&nbsp;             }
&nbsp;             if(limit>=styleStart) {
&nbsp;                 if(styleStart&lt;start) { styleStart=start; }
&nbsp;                 renderRun(text, styleStart, limit,
&nbsp;                           direction, styleRun[i].style);
&nbsp;                 if(styleStart==start) { break; }
&nbsp;                 limit=styleStart;
&nbsp;             }
&nbsp;         }
&nbsp;     }
&nbsp; }
&nbsp; 
&nbsp; // the line object represents text[start..limit-1]
&nbsp; void renderLine(UBiDi *line, const UChar *text,
&nbsp;                 UTextOffset start, UTextOffset limit,
&nbsp;                 const StyleRun *styleRuns, int styleRunCount) {
&nbsp;     UBiDiDirection direction=ubidi_getDirection(line);
&nbsp;     if(direction!=UBIDI_MIXED) {
&nbsp;         // unidirectional
&nbsp;         if(styleRunCount&lt;=1) {
&nbsp;             renderRun(text, start, limit, direction, styleRuns[0].style);
&nbsp;         } else {
&nbsp;             renderDirectionalRun(text, start, limit, 
&nbsp;                                  direction, styleRuns, styleRunCount);
&nbsp;         }
&nbsp;     } else {
&nbsp;         // mixed-directional
&nbsp;         UTextOffset count, i, length;
&nbsp;         UBiDiLevel level;
&nbsp; 
&nbsp;         count=ubidi_countRuns(para, pErrorCode);
&nbsp;         if(SUCCESS(*pErrorCode)) {
&nbsp;             if(styleRunCount&lt;=1) {
&nbsp;                 Style style=styleRuns[0].style;
&nbsp; 
&nbsp;                 // iterate over directional runs
&nbsp;                 for(i=0; i&lt;count; ++i) {
&nbsp;                     direction=ubidi_getVisualRun(para, i, &start, &length);
&nbsp;                     renderRun(text, start, start+length, direction, style);
&nbsp;                 }
&nbsp;             } else {
&nbsp;                 UTextOffset j;
&nbsp; 
&nbsp;                 // iterate over both directional and style runs
&nbsp;                 for(i=0; i&lt;count; ++i) {
&nbsp;                     direction=ubidi_getVisualRun(line, i, &start, &length);
&nbsp;                     renderDirectionalRun(text, start, start+length, 
&nbsp;                                          direction, styleRuns, styleRunCount);
&nbsp;                 }
&nbsp;             }
&nbsp;         }
&nbsp;     }
&nbsp; }
&nbsp; 
&nbsp; void renderParagraph(const UChar *text, UTextOffset length,
&nbsp;                      UBiDiDirection textDirection,
&nbsp;                      const StyleRun *styleRuns, int styleRunCount,
&nbsp;                      int lineWidth,
&nbsp;                      UErrorCode *pErrorCode) {
&nbsp;     UBiDi *para;
&nbsp; 
&nbsp;     if(pErrorCode==NULL || FAILURE(*pErrorCode) || length&lt;=0) {
&nbsp;         return;
&nbsp;     }
&nbsp; 
&nbsp;     para=ubidi_openSized(length, 0, pErrorCode);
&nbsp;     if(para==NULL) { return; }
&nbsp; 
&nbsp;     ubidi_setPara(para, text, length,
&nbsp;                   textDirection ? UBIDI_DEFAULT_RTL : UBIDI_DEFAULT_LTR,
&nbsp;                   NULL, pErrorCode);
&nbsp;     if(SUCCESS(*pErrorCode)) {
&nbsp;         UBiDiLevel paraLevel=1&ubidi_getParaLevel(para);
&nbsp;         StyleRun styleRun={ length, styleNormal };
&nbsp;         int width;
&nbsp; 
&nbsp;         if(styleRuns==NULL || styleRunCount&lt;=0) {
&nbsp;             styleRunCount=1;
&nbsp;             styleRuns=&styleRun;
&nbsp;         }
&nbsp; 
&nbsp;         // assume styleRuns[styleRunCount-1].limit>=length
&nbsp; 
&nbsp;         width=getTextWidth(text, 0, length, styleRuns, styleRunCount);
&nbsp;         if(width&lt;=lineWidth) {
&nbsp;             // everything fits onto one line
&nbsp; 
&nbsp;             // prepare rendering a new line from either left or right
&nbsp;             startLine(paraLevel, width);
&nbsp; 
&nbsp;             renderLine(para, text, 0, length,
&nbsp;                        styleRuns, styleRunCount);
&nbsp;         } else {
&nbsp;             UBiDi *line;
&nbsp; 
&nbsp;             // we need to render several lines
&nbsp;             line=ubidi_openSized(length, 0, pErrorCode);
&nbsp;             if(line!=NULL) {
&nbsp;                 UTextOffset start=0, limit;
&nbsp;                 int styleRunStart=0, styleRunLimit;
&nbsp; 
&nbsp;                 for(;;) {
&nbsp;                     limit=length;
&nbsp;                     styleRunLimit=styleRunCount;
&nbsp;                     getLineBreak(text, start, &limit, para,
&nbsp;                                  styleRuns, styleRunStart, &styleRunLimit,
&nbsp;                                  &width);
&nbsp;                     ubidi_setLine(para, start, limit, line, pErrorCode);
&nbsp;                     if(SUCCESS(*pErrorCode)) {
&nbsp;                         // prepare rendering a new line
&nbsp;                         // from either left or right
&nbsp;                         startLine(paraLevel, width);
&nbsp; 
&nbsp;                         renderLine(line, text, start, limit,
&nbsp;                                    styleRuns+styleRunStart,
&nbsp;                                    styleRunLimit-styleRunStart);
&nbsp;                     }
&nbsp;                     if(limit==length) { break; }
&nbsp;                     start=limit;
&nbsp;                     styleRunStart=styleRunLimit-1;
&nbsp;                     if(start>=styleRuns[styleRunStart].limit) {
&nbsp;                         ++styleRunStart;
&nbsp;                     }
&nbsp;                 }
&nbsp; 
&nbsp;                 ubidi_close(line);
&nbsp;             }
&nbsp;         }
&nbsp;     }
&nbsp; 
&nbsp;     ubidi_close(para);
&nbsp; }
</pre>
</BLOCKQUOTE>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
