<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<link rel="stylesheet" href="http://www.unicode.org/reports/reports.css" type="text/css">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>UTR #23: Character Property Model</title>
<style type="text/css">
<!--
td {padding:3px}
-->
</style>
</head>

<body style="margin: 1em">

<!-- Copyright 2005 -->
<p align="right"><b><font size="4">L2-xxx</font></b></p>
<dl>
  <dt>&nbsp;</dt>
  <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" id="AutoNumber6">
    <tr>
      <td>Re:</td>
      <td>Suggested changes in the Character Property Model (#23)</td>
    </tr>
    <tr>
      <td>From:</td>
      <td>Mark Davis</td>
    </tr>
    <tr>
      <td>Date:</td>
      <td>2007.07.28</td>
    </tr>
  </table>
</dl>
<p>I suggest the following changes in the Character Property Model (<a href="http://www.unicode.org/reports/tr23/">http://www.unicode.org/reports/tr23/</a>).</p>
<p>1. To make the definitions more accessible, supply an example for each one. This can be very 
short, just a sentence.</p>
<p>2. Make the following additional changes. Some of these are corrections, some clarifications, and 
some additional definitions that are useful in discussing Unicode properties and implementations.</p>
<p>&nbsp;</p>
<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1">
  <tr>
    <td width="50%"><b><i>Current</i></b></td>
    <td width="50%"><b><i>Suggested addition</i></b></td>
  </tr>
  <tr>
    <td width="50%">
    <dl>
      <dt>PD7. Single Valued (Boolean) Property</dt>
      <dd>A closed enumerated property whose set of values is limited to &#39;true&#39; and &#39;false&#39;.</dd>
    </dl>
    </td>
    <td width="50%">For a given boolean property P, the phrase &quot;the P code points&quot; denotes the set 
    of all code points whose property value for P is &#39;true&#39;. For example, the Pattern_Whitepace code 
    points are those with the Pattern_Whitespace property value &#39;true&#39;. Similarly, for a given 
    property P and value V, the phrase &quot;the P V code points&quot; denotes the set of all code points 
    whose property value for P is V. For example, the Line Break Alphabetic code points are all for 
    which the Line Break property value is Alphabetic.</td>
  </tr>
</table>
<p>&nbsp;</p>
<dl>
  <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber1">
    <tr>
      <td width="50%"><b><i>Current</i></b></td>
      <td width="50%"><b><i>Suggested replacement</i></b></td>
    </tr>
    <tr>
      <td width="50%">
      <dl>
        <dt>PD16. Context-independent Property</dt>
        <dd>A property that applies to a code point in isolation.</dd>
      </dl>
      <dl>
        <dt>&nbsp;</dt>
        <dt>PD17. Context-dependent Property</dt>
        <dd>A property that applies to a code point in the context of a longer code point sequence.&nbsp;<br>
        <br>
        See also PD33: <a href="#ContextDependentStringFunction"><i>C</i></a><i><a href="#ContextDependentStringFunction">ontext-dependent 
        String Function</a>.</i></dd>
      </dl>
      </td>
      <td width="50%">
      <dl>
        <dt>PD16. Context-Dependent Property</dt>
        <dd>A property whose value may vary depending on the context surrounding the character.</dd>
        <p>For example, the character property Final_Sigma used in Table 3-13 depends on characters 
        before and after the character in question.</dd>
      </dl>
      <dl>
        <dt>PD16. Context-Independent Property</dt>
        <dd>A property that is not context-dependent.</dd></dd>
        <dd>&nbsp;</dd>
        <dd>For example, the general category code point property does not depend on surrounding 
        code points.</dd>
      </dl>
      </td>
    </tr>
  </table>
</dl>
<dl>
  <dt>&nbsp;</dt>
  <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber2">
    <tr>
      <td width="50%"><b><i>Current</i></b></td>
      <td width="50%"><b><i>Suggested addition</i></b></td>
    </tr>
    <tr>
      <td>
      <dl>
        <dt>PD21. Immutable Property</dt>
        <dd>A fixed property that is also subject to a stability guarantee preventing <i>any</i> 
        change in the published listing of property values.<br>
        <br>
        An immutable property is trivially stable with respect to <i>all</i> context-free 
        algorithms. Example of immutable properties are the code point and Unicode character name.
        </dd>
      </dl>
      </td>
      <td>[Add note:]<blockquote>
        <p>Note: an immutable <i>character</i> property is different than an immutable <i>code point</i> 
        property. For example, Pattern_Syntax is an immutable code point property: it encompasses a 
        fixed set of code points that will never change. However, it is not an immutable <i>
        character</i> property: an unassigned code point in that range may be allocated as a 
        character in the future.</p>
      </blockquote>
      </td>
    </tr>
  </table>
</dl>
<p><br>
&nbsp;</p>
<dl>
  <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber3">
    <tr>
      <td width="50%"><b><i>Current</i></b></td>
      <td width="50%"><b><i>Suggested addition</i></b></td>
    </tr>
    <tr>
      <td>
      <dl>
        <dt>PD27. Property Value Alias</dt>
        <dd>A unique identifier for a particular enumerated value for a particular property. [D10a]</dd>
      </dl>
      </td>
      <td>
      <blockquote>
        <p>It is only unique within the set of values for that property, not across properties. Thus 
        AL is the Alphabetic value for the Line Break property, but is the Arabic Letter value for 
        the Bidi Class property.</p>
      </blockquote>
      </td>
    </tr>
  </table>
</dl>
<p>&nbsp;</p>
<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber4">
  <tr>
    <td width="50%"><b><i>Current</i></b></td>
    <td width="50%"><b><i>Suggested addition</i></b></td>
  </tr>
  <tr>
    <td>
    <h3>3.7 <a name="StringFunctionClassificationDefinitions">Classification of String Functions</a></h3>
    </td>
    <td>
    <dl>
      <li>Properties of strings and string functions extend to code points. For example, a code 
      point is Inert with respect to a transform if and only if the string containing that code 
      point is Inert with respect to that transform.</li>
    </dl>
    </td>
  </tr>
</table>
<p>&nbsp;</p>
<dl>
  <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber4">
    <tr>
      <td width="50%"><b><i>Current</i></b></td>
      <td width="50%"><b><i>Suggested replacement </i></b>[plus reordering, as above]</td>
    </tr>
    <tr>
      <td>
      <dl>
        <dt>PD34. <a name="ContextDependentStringFunction">Context-dependent String Function</a></dt>
        <dd>Given a string <i>S</i>, and offsets <i>a</i> and <i>b</i>, a context-dependent string 
        function is any string function <i>F</i> for which <i>F</i>(<i>S,a,b</i>) depends on the 
        content of <i>S </i>before <i>a</i> and after <i>b</i>.</dd>
      </dl>
      </td>
      <td>
      <dl>
        <dt>PD34. <a name="ContextDependentStringFunction">Context-dependent String Function</a></dt>
        <dl>
          <dd>A context-independent string function is a string function that is not 
          context-dependent.</dd>
        </dl>
      </dl>
      </td>
    </tr>
  </table>
  <dt>&nbsp;</dt>
</dl>
<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber5">
  <tr>
    <td width="50%"><b><i>Current</i></b></td>
    <td width="50%"><b><i>Suggested replacement</i></b></td>
  </tr>
  <tr>
    <td>
    <dl>
      <dt>PD35. Idempotent String Function</dt>
      <dd>A string function <i>F</i> whose output <i>F</i>(<i>S</i>) is itself a string, with the 
      property that repeated applications of the same function <i>F</i> produce the same output: <i>
      F</i>(<i>F</i>(<i>S</i>)) = <i>F</i>(<i>S</i>) for all input strings<i> S</i>.</dd>
      <dt>&nbsp;</dt>
      <dt>PD36. Folding Function</dt>
      <dd>A folding function is an idempotent string function that establishes a set of equivalence 
      classes that partitions all strings, where<i> X</i> â‰¡<i>Y</i> if and only if <i>F</i>(<i>X</i>) 
      = <i>F</i>(<i>Y</i>). For each equivalence class, a folding defines a target member. Applying 
      the folding replaces the input by the target member.</dd>
      <dd>&nbsp;</dd>
      <dd>A well known example of a folding function is case folding. For case folding, the 
      equivalence class consists of all case variations, including upper, lower, title case and 
      mixed case. The target member is often chosen to be the lower case. </dd>
      <dd>&nbsp;</dd>
      <dd>Folding functions may be context dependent. Normalization is an example of a context 
      dependent folding. </dd>
    </dl>
    </td>
    <td>
    <dt>PD35a. String Transform</dt>
    <dd>A string-valued string function</dd>
    <dt>&nbsp;</dt>
    <dt>PD36b. Idempotent String Transform</dt>
    <dd>A string transform <i>F</i>, with the property that repeated applications of the same 
    transform <i>F</i> produce the same output: <i>F(F(S)) = F(S)</i> for all input strings<i> S</i>. 
    Such a string transform is also called a <i>folding</i>.</dd>
    <dd>&nbsp;</dd>
    <dd>A folding establishes an equivalence relation, whereby <i>X</i> â‰¡<i>Y</i> if and only if <i>
    F(X) = F(Y)</i>. This equivalence relation partitions the set of all strings into the set of 
    equivalence classes for the relation.</dd>
    <dl>
      <dd>Conversely, any partition of strings can be used to generate a folding, by choosing one 
      element of each partition to be the &quot;target member&quot; that the members of that partition map to.
      <i>For examples, see PDx4 Closed</i>.</dd>
      <dd>&nbsp;</dd>
      <dd>It is common to use the syntax toX(s) for the folding, and isX(s) for the corresponding 
      binary function, defined such that isX(s) if and only if toX(s) = s. For example, toNFC() is 
      the folding that converts to NFC format, while isNFC() is the test for whether a string is in 
      that format.</dd>
    </dl>
    </dd>
    <dd>
    <dl>
    </dl>
    </dd>
    </td>
  </tr>
</table>
<p>&nbsp;</p>
<table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" bordercolor="#111111" width="100%" id="AutoNumber5">
  <tr>
    <td width="50%"><b><i>Suggested additions (not necessarily in this order)</i></b></td>
  </tr>
  <tr>
    <td>
    <dl>
      <dt>PDx0. Preservation</dt>
      <dd>A transform T <i>preserves</i> a property P when for all strings S, P(S) if and only if 
      P(T(S)). A transform T <i>preserves</i> a relation R when for all strings S1 and S2, R(S1, S2) 
      = R(T(S1), R(T(S2))</dd>
      <dd>&nbsp;</dd>
      <dd>For example, concatenation does not preserve normalization form, nor collation order. 
      However, the substring operation does preserve normalization: if S is normalized, then S[x,y] 
      is normalized.</dd>
    </dl>
    <p>Under certain conditions, strings and boundaries are &quot;inert&quot; with respect to a given 
    transform. This property can often be used in optimizing code, by skipping over characters or 
    detecting conditions where fast paths can be taken in code.</p>
    <dt>PDx1. Inert String</dt>
    <dd>A string S is inert with respect to a string transform T when the string is always unchanged 
    by the transform, and never affects the results for the surrounding characters. More formally, S 
    is inert w.r.t. T when for all strings x and y, T(x) + T(S) + T(y) = T(x + S + y).<p>Examples: 
    with respect to NFD, the character &#39;a&#39; is inert. The <i>&lt;combining diaeresis&gt; </i>is not, since
    </p>
    <p style="text-align: center">toNFD(<i>&lt;combining diaeresis&gt;</i>, <i>&lt;combining cedilla&gt;</i>)<br>
    <font face="Lucida Sans Unicode">â‰ <br>
    </font>toNFD(<i>&lt;combining diaeresis&gt;</i>) + toNFD(<i>&lt;combining cedilla&gt;</i>).</p>
    <p>Implementations can often use tests for inert characters in optimizing.</dd> </dd>
    </dd>
    </p>
    <p>PDx2. Inert Boundary<dl>
      <dd>A text boundary property P is inert with respect to a string transform T when the boundary 
      is unchanged by the transform. More formally, P is inert w.r.t. T when for all strings x and y 
      such that T(x) + T(y) = T(x + y), P(x + y, length(x)) = P(T(x,y), length(T(x))</dd>
      <dd>&nbsp;</dd>
      <dd>For example, grapheme cluster boundaries are inert with respect to all of the 
      normalization forms. Line break boundaries, however, are not.</dd>
      <dd>&nbsp;</dd>
      <dt>&nbsp;</dt>
      <dt>PDx3. Final-Inert String</dt>
      <dd>A string S is final-inert with respect to a string transform T when the string is always 
      unchanged by the transform, and never affects the results for following characters. More 
      formally, S is final-inert w.r.t. T when for all strings x and y, T(x + S) + T(y) = T(x + S + 
      y). </dd>
    </dl>
    <dl>
      <dt>PDx1. Initial-Inert String</dt>
      <dd>A string S is initial-inert with respect to a string transform T when the string is always 
      unchanged by the transform, and never affects the results for preceding characters. More 
      formally, S is initial-inert w.r.t. T when for all strings x and y, T(x) + T(S + y) = T(x + S 
      + y). </dd>
    </dl>
    <p>For example, these properties can be used for an optimized normalization concatenation. 
    Normal string concatenation does not preserve normalization. Thus the concatenation of two 
    normalized strings A and B is not guaranteed to be normalized. However, it is easy to write an 
    optimized normalized concatenation by breaking A into two parts A&#39; and A&quot; (where A&#39; ends with 
    the last final-inert character in A), and breaking B into two parts B&#39; and B&quot; (where B&quot; starts 
    with the first initial-inert character in B), then returning A&#39; + normalize(A&quot; + B&#39;) + B&quot;.<dl>
      <dt>PDx4. Closed</dt>
      <dd>The set S is closed under a relation R if for all elements x and y in S, if x is in X and 
      x R y, then y is in X.</dd>
      <dt>&nbsp;</dt>
      <dd>The closure of a set of strings is often useful in implementations. For example, in 
      implementing collation it is useful to pre-generate collation weights for the closure of each 
      of the tailored strings under NFD; that makes it unnecessary to normalize the text at runtime 
      in most cases.</dd>
      <dd>&nbsp;</dd>
      <dd>A relation can be used to generate a partition of elements where each partition is a 
      minimal set of elements closed under R. That partition can then be used to generate a folding. 
      For example, the closure of the relation x = toUppercase(y) OR x = toLowercase(y) OR x = 
      toTitlecase(y) is used used to generate the data for the Unicode case folding. Each partition 
      contains all possible case variations of a string including upper, lower, title case and mixed 
      case. The target member is chosen to be all lowercase.</dd>
    </dl>
    </dd>
    </td>
  </tr>
  <caption>
  <dd>
  <dl>
  </dl>
  </dd>
  </caption>
  </tr>
  <tr>
    <td>&nbsp;</td>
  </tr>
</table>

</body>

</html>
