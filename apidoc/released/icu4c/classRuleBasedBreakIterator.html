<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ICU 65.1: icu::RuleBasedBreakIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ICU 65.1
   &#160;<span id="projectnumber">65.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicu.html">icu</a></li><li class="navelem"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">icu::RuleBasedBreakIterator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A subclass of <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> whose behavior is specified using a list of rules.  
 <a href="classicu_1_1RuleBasedBreakIterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rbbi_8h_source.html">rbbi.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for icu::RuleBasedBreakIterator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classicu_1_1RuleBasedBreakIterator.png" usemap="#icu::RuleBasedBreakIterator_map" alt=""/>
  <map id="icu::RuleBasedBreakIterator_map" name="icu::RuleBasedBreakIterator_map">
<area href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text..." alt="icu::BreakIterator" shape="rect" coords="0,112,168,136"/>
<area href="classicu_1_1UObject.html" title="UObject is the common ICU &quot;boilerplate&quot; class. " alt="icu::UObject" shape="rect" coords="0,56,168,80"/>
<area href="classicu_1_1UMemory.html" title="UMemory is the common ICU base class. " alt="icu::UMemory" shape="rect" coords="0,0,168,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a976126b3070d56d23a67184b41e88141"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a976126b3070d56d23a67184b41e88141">RuleBasedBreakIterator</a> ()</td></tr>
<tr class="memdesc:a976126b3070d56d23a67184b41e88141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a976126b3070d56d23a67184b41e88141">More...</a><br /></td></tr>
<tr class="separator:a976126b3070d56d23a67184b41e88141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaaa98a62891cc8b6ef72c913a67a7b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#acaaa98a62891cc8b6ef72c913a67a7b6">RuleBasedBreakIterator</a> (const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;that)</td></tr>
<tr class="memdesc:acaaa98a62891cc8b6ef72c913a67a7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#acaaa98a62891cc8b6ef72c913a67a7b6">More...</a><br /></td></tr>
<tr class="separator:acaaa98a62891cc8b6ef72c913a67a7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34393c8272153f00eab8b3ba5dd8263"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#af34393c8272153f00eab8b3ba5dd8263">RuleBasedBreakIterator</a> (const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;rules, <a class="el" href="structUParseError.html">UParseError</a> &amp;parseError, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:af34393c8272153f00eab8b3ba5dd8263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules. ">RuleBasedBreakIterator</a> from a set of rules supplied as a string.  <a href="#af34393c8272153f00eab8b3ba5dd8263">More...</a><br /></td></tr>
<tr class="separator:af34393c8272153f00eab8b3ba5dd8263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe74962355b2cf5cf699ab2c98d0852d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afe74962355b2cf5cf699ab2c98d0852d">RuleBasedBreakIterator</a> (const uint8_t *compiledRules, uint32_t ruleLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:afe74962355b2cf5cf699ab2c98d0852d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules. ">RuleBasedBreakIterator</a> from a set of precompiled binary rules.  <a href="#afe74962355b2cf5cf699ab2c98d0852d">More...</a><br /></td></tr>
<tr class="separator:afe74962355b2cf5cf699ab2c98d0852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde71d5c99670342c9db9e67b7475822"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#adde71d5c99670342c9db9e67b7475822">RuleBasedBreakIterator</a> (<a class="el" href="udata_8h.html#acffec83601fda29bd4750b24f829f56b">UDataMemory</a> *image, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:adde71d5c99670342c9db9e67b7475822"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor uses the udata interface to create a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> whose internal tables live in a memory-mapped file.  <a href="#adde71d5c99670342c9db9e67b7475822">More...</a><br /></td></tr>
<tr class="separator:adde71d5c99670342c9db9e67b7475822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af171cfdce6f264ae7f7f18078248a08b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#af171cfdce6f264ae7f7f18078248a08b">~RuleBasedBreakIterator</a> ()</td></tr>
<tr class="memdesc:af171cfdce6f264ae7f7f18078248a08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#af171cfdce6f264ae7f7f18078248a08b">More...</a><br /></td></tr>
<tr class="separator:af171cfdce6f264ae7f7f18078248a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5e205b2cc4e2f0b1ea66f0c3b52293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a3e5e205b2cc4e2f0b1ea66f0c3b52293">operator=</a> (const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;that)</td></tr>
<tr class="memdesc:a3e5e205b2cc4e2f0b1ea66f0c3b52293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="#a3e5e205b2cc4e2f0b1ea66f0c3b52293">More...</a><br /></td></tr>
<tr class="separator:a3e5e205b2cc4e2f0b1ea66f0c3b52293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b4921dcac2850239ded74d4e1690c4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ab1b4921dcac2850239ded74d4e1690c4">operator==</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;that) const</td></tr>
<tr class="memdesc:ab1b4921dcac2850239ded74d4e1690c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="#ab1b4921dcac2850239ded74d4e1690c4">More...</a><br /></td></tr>
<tr class="separator:ab1b4921dcac2850239ded74d4e1690c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42126bcf7a30052e04be78566856066"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ae42126bcf7a30052e04be78566856066">operator!=</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;that) const</td></tr>
<tr class="memdesc:ae42126bcf7a30052e04be78566856066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not-equal operator.  <a href="#ae42126bcf7a30052e04be78566856066">More...</a><br /></td></tr>
<tr class="separator:ae42126bcf7a30052e04be78566856066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cb3bdf547a2e7f922ce62436d4dd9f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a59cb3bdf547a2e7f922ce62436d4dd9f">clone</a> () const</td></tr>
<tr class="memdesc:a59cb3bdf547a2e7f922ce62436d4dd9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly-constructed <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules. ">RuleBasedBreakIterator</a> with the same behavior, and iterating over the same text, as this one.  <a href="#a59cb3bdf547a2e7f922ce62436d4dd9f">More...</a><br /></td></tr>
<tr class="separator:a59cb3bdf547a2e7f922ce62436d4dd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfd1d9c7231c809fad160d0a76517d3"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afbfd1d9c7231c809fad160d0a76517d3">hashCode</a> (void) const</td></tr>
<tr class="memdesc:afbfd1d9c7231c809fad160d0a76517d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash code for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a>.  <a href="#afbfd1d9c7231c809fad160d0a76517d3">More...</a><br /></td></tr>
<tr class="separator:afbfd1d9c7231c809fad160d0a76517d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb1ee0b366ac18d7e1cc2bfc813a4ad9"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#adb1ee0b366ac18d7e1cc2bfc813a4ad9">getRules</a> (void) const</td></tr>
<tr class="memdesc:adb1ee0b366ac18d7e1cc2bfc813a4ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description used to create this iterator.  <a href="#adb1ee0b366ac18d7e1cc2bfc813a4ad9">More...</a><br /></td></tr>
<tr class="separator:adb1ee0b366ac18d7e1cc2bfc813a4ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38df4a3bb0a8269af594ff142141bdf5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a38df4a3bb0a8269af594ff142141bdf5">getText</a> (void) const</td></tr>
<tr class="separator:a38df4a3bb0a8269af594ff142141bdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f952ddea1c33924db8a75601405968"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a32f952ddea1c33924db8a75601405968">getUText</a> (<a class="el" href="structUText.html">UText</a> *fillIn, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const</td></tr>
<tr class="memdesc:a32f952ddea1c33924db8a75601405968"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="structUText.html" title="UText struct. ">UText</a> for the text being analyzed.  <a href="#a32f952ddea1c33924db8a75601405968">More...</a><br /></td></tr>
<tr class="separator:a32f952ddea1c33924db8a75601405968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af552e13c98aed9f2995fc0f8f066d6f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#af552e13c98aed9f2995fc0f8f066d6f1">adoptText</a> (<a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> *newText)</td></tr>
<tr class="memdesc:af552e13c98aed9f2995fc0f8f066d6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator to analyze a new piece of text.  <a href="#af552e13c98aed9f2995fc0f8f066d6f1">More...</a><br /></td></tr>
<tr class="separator:af552e13c98aed9f2995fc0f8f066d6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa751ea4cc941ed62585ac1d2de812ee6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aa751ea4cc941ed62585ac1d2de812ee6">setText</a> (const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;newText)</td></tr>
<tr class="memdesc:aa751ea4cc941ed62585ac1d2de812ee6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator to analyze a new piece of text.  <a href="#aa751ea4cc941ed62585ac1d2de812ee6">More...</a><br /></td></tr>
<tr class="separator:aa751ea4cc941ed62585ac1d2de812ee6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2725705885bda731102965658868d2b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a2725705885bda731102965658868d2b3">setText</a> (<a class="el" href="structUText.html">UText</a> *text, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a2725705885bda731102965658868d2b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct. ">UText</a>.  <a href="#a2725705885bda731102965658868d2b3">More...</a><br /></td></tr>
<tr class="separator:a2725705885bda731102965658868d2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae570e1d10c69d488add6ca6450185ff9"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ae570e1d10c69d488add6ca6450185ff9">first</a> (void)</td></tr>
<tr class="memdesc:ae570e1d10c69d488add6ca6450185ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current iteration position to the beginning of the text, position zero.  <a href="#ae570e1d10c69d488add6ca6450185ff9">More...</a><br /></td></tr>
<tr class="separator:ae570e1d10c69d488add6ca6450185ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76433bea39e818b36dd68fef2d923e9"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ae76433bea39e818b36dd68fef2d923e9">last</a> (void)</td></tr>
<tr class="memdesc:ae76433bea39e818b36dd68fef2d923e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current iteration position to the end of the text.  <a href="#ae76433bea39e818b36dd68fef2d923e9">More...</a><br /></td></tr>
<tr class="separator:ae76433bea39e818b36dd68fef2d923e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca41106d2b7697a8a88b5ede42bf96"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ad1ca41106d2b7697a8a88b5ede42bf96">next</a> (int32_t n)</td></tr>
<tr class="memdesc:ad1ca41106d2b7697a8a88b5ede42bf96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the iterator either forward or backward the specified number of steps.  <a href="#ad1ca41106d2b7697a8a88b5ede42bf96">More...</a><br /></td></tr>
<tr class="separator:ad1ca41106d2b7697a8a88b5ede42bf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d13c4995852cfad40af882452fbcba"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a81d13c4995852cfad40af882452fbcba">next</a> (void)</td></tr>
<tr class="memdesc:a81d13c4995852cfad40af882452fbcba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the iterator to the next boundary position.  <a href="#a81d13c4995852cfad40af882452fbcba">More...</a><br /></td></tr>
<tr class="separator:a81d13c4995852cfad40af882452fbcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b566ab3e2b8a8e49d2f0a0415f5a151"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a6b566ab3e2b8a8e49d2f0a0415f5a151">previous</a> (void)</td></tr>
<tr class="memdesc:a6b566ab3e2b8a8e49d2f0a0415f5a151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the iterator backwards, to the last boundary preceding this one.  <a href="#a6b566ab3e2b8a8e49d2f0a0415f5a151">More...</a><br /></td></tr>
<tr class="separator:a6b566ab3e2b8a8e49d2f0a0415f5a151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf540b2d0d834bea3b7953502e36c717"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#adf540b2d0d834bea3b7953502e36c717">following</a> (int32_t offset)</td></tr>
<tr class="memdesc:adf540b2d0d834bea3b7953502e36c717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the iterator to refer to the first boundary position following the specified position.  <a href="#adf540b2d0d834bea3b7953502e36c717">More...</a><br /></td></tr>
<tr class="separator:adf540b2d0d834bea3b7953502e36c717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7beaf4da856f4573e15fe756114e32d"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ac7beaf4da856f4573e15fe756114e32d">preceding</a> (int32_t offset)</td></tr>
<tr class="memdesc:ac7beaf4da856f4573e15fe756114e32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the iterator to refer to the last boundary position before the specified position.  <a href="#ac7beaf4da856f4573e15fe756114e32d">More...</a><br /></td></tr>
<tr class="separator:ac7beaf4da856f4573e15fe756114e32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a68042aa461be2eeb9940a3d00b37d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ac4a68042aa461be2eeb9940a3d00b37d">isBoundary</a> (int32_t offset)</td></tr>
<tr class="memdesc:ac4a68042aa461be2eeb9940a3d00b37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified position is a boundary position.  <a href="#ac4a68042aa461be2eeb9940a3d00b37d">More...</a><br /></td></tr>
<tr class="separator:ac4a68042aa461be2eeb9940a3d00b37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747f3b5bf76323d7c8e7983c9388e6b4"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a747f3b5bf76323d7c8e7983c9388e6b4">current</a> (void) const</td></tr>
<tr class="memdesc:a747f3b5bf76323d7c8e7983c9388e6b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current iteration position.  <a href="#a747f3b5bf76323d7c8e7983c9388e6b4">More...</a><br /></td></tr>
<tr class="separator:a747f3b5bf76323d7c8e7983c9388e6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937a421cdc0d779f73d4d3bbc3279a1f"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a937a421cdc0d779f73d4d3bbc3279a1f">getRuleStatus</a> () const</td></tr>
<tr class="memdesc:a937a421cdc0d779f73d4d3bbc3279a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status tag from the break rule that determined the boundary at the current iteration position.  <a href="#a937a421cdc0d779f73d4d3bbc3279a1f">More...</a><br /></td></tr>
<tr class="separator:a937a421cdc0d779f73d4d3bbc3279a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e5fa6fabba66a1b862eb3725f14b0d"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a49e5fa6fabba66a1b862eb3725f14b0d">getRuleStatusVec</a> (int32_t *fillInVec, int32_t capacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a49e5fa6fabba66a1b862eb3725f14b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status (tag) values from the break rule(s) that determined the boundary at the current iteration position.  <a href="#a49e5fa6fabba66a1b862eb3725f14b0d">More...</a><br /></td></tr>
<tr class="separator:a49e5fa6fabba66a1b862eb3725f14b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c49d712d0b77e6dbdf60fb0c118164a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a4c49d712d0b77e6dbdf60fb0c118164a">getDynamicClassID</a> (void) const</td></tr>
<tr class="memdesc:a4c49d712d0b77e6dbdf60fb0c118164a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unique class ID POLYMORPHICALLY.  <a href="#a4c49d712d0b77e6dbdf60fb0c118164a">More...</a><br /></td></tr>
<tr class="separator:a4c49d712d0b77e6dbdf60fb0c118164a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa27fd7b810caa0191f67504fef81c22"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aaa27fd7b810caa0191f67504fef81c22">createBufferClone</a> (void *stackBuffer, int32_t &amp;BufferSize, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:aaa27fd7b810caa0191f67504fef81c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated functionality.  <a href="#aaa27fd7b810caa0191f67504fef81c22">More...</a><br /></td></tr>
<tr class="separator:aaa27fd7b810caa0191f67504fef81c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb4fa90807c2e89ca7514db3a0e4f31"><td class="memItemLeft" align="right" valign="top">virtual const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aaeb4fa90807c2e89ca7514db3a0e4f31">getBinaryRules</a> (uint32_t &amp;length)</td></tr>
<tr class="memdesc:aaeb4fa90807c2e89ca7514db3a0e4f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the binary form of compiled break rules, which can then be used to create a new break iterator at some time in the future.  <a href="#aaeb4fa90807c2e89ca7514db3a0e4f31">More...</a><br /></td></tr>
<tr class="separator:aaeb4fa90807c2e89ca7514db3a0e4f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cefac1ccd59b8b0bb282c2df26ef73"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a42cefac1ccd59b8b0bb282c2df26ef73">refreshInputText</a> (<a class="el" href="structUText.html">UText</a> *input, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a42cefac1ccd59b8b0bb282c2df26ef73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the subject text string upon which the break iterator is operating without changing any other aspect of the matching state.  <a href="#a42cefac1ccd59b8b0bb282c2df26ef73">More...</a><br /></td></tr>
<tr class="separator:a42cefac1ccd59b8b0bb282c2df26ef73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88705f0fdbdaa71ec29a6204e09d4668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a88705f0fdbdaa71ec29a6204e09d4668">dumpCache</a> ()</td></tr>
<tr class="memdesc:a88705f0fdbdaa71ec29a6204e09d4668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging function only.  <a href="#a88705f0fdbdaa71ec29a6204e09d4668">More...</a><br /></td></tr>
<tr class="separator:a88705f0fdbdaa71ec29a6204e09d4668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581a3d53f5699e16a408cc6b85d30a58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a581a3d53f5699e16a408cc6b85d30a58">dumpTables</a> ()</td></tr>
<tr class="memdesc:a581a3d53f5699e16a408cc6b85d30a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging function only.  <a href="#a581a3d53f5699e16a408cc6b85d30a58">More...</a><br /></td></tr>
<tr class="separator:a581a3d53f5699e16a408cc6b85d30a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a026e38276ffa6c40d8953b4e3bc4bc01 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a026e38276ffa6c40d8953b4e3bc4bc01">~BreakIterator</a> ()</td></tr>
<tr class="memdesc:a026e38276ffa6c40d8953b4e3bc4bc01 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="classicu_1_1BreakIterator.html#a026e38276ffa6c40d8953b4e3bc4bc01">More...</a><br /></td></tr>
<tr class="separator:a026e38276ffa6c40d8953b4e3bc4bc01 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2822d71b88bb757857a413d3def51113 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a2822d71b88bb757857a413d3def51113">operator!=</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a2822d71b88bb757857a413d3def51113 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complement of the result of operator==.  <a href="classicu_1_1BreakIterator.html#a2822d71b88bb757857a413d3def51113">More...</a><br /></td></tr>
<tr class="separator:a2822d71b88bb757857a413d3def51113 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ce3ce8c87b0f5b11527caf0e824fbf inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a20ce3ce8c87b0f5b11527caf0e824fbf">isBufferClone</a> (void)</td></tr>
<tr class="memdesc:a20ce3ce8c87b0f5b11527caf0e824fbf inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> was created in user memory by <a class="el" href="classicu_1_1BreakIterator.html#ac0b126946521a209ec2c6d490b7db86e" title="Deprecated functionality. ">createBufferClone()</a>, and thus should not be deleted.  <a href="classicu_1_1BreakIterator.html#a20ce3ce8c87b0f5b11527caf0e824fbf">More...</a><br /></td></tr>
<tr class="separator:a20ce3ce8c87b0f5b11527caf0e824fbf inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771866e07e8c3396d98218a2073c0dc2 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicu_1_1Locale.html">Locale</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a771866e07e8c3396d98218a2073c0dc2">getLocale</a> (<a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a> type, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const</td></tr>
<tr class="memdesc:a771866e07e8c3396d98218a2073c0dc2 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the locale for this break iterator.  <a href="classicu_1_1BreakIterator.html#a771866e07e8c3396d98218a2073c0dc2">More...</a><br /></td></tr>
<tr class="separator:a771866e07e8c3396d98218a2073c0dc2 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f041a2b8725d4d3e0bae29dce765eaa inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a5f041a2b8725d4d3e0bae29dce765eaa">getLocaleID</a> (<a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a> type, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const</td></tr>
<tr class="memdesc:a5f041a2b8725d4d3e0bae29dce765eaa inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locale for this break iterator object.  <a href="classicu_1_1BreakIterator.html#a5f041a2b8725d4d3e0bae29dce765eaa">More...</a><br /></td></tr>
<tr class="separator:a5f041a2b8725d4d3e0bae29dce765eaa inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classicu_1_1UObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classicu_1_1UObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classicu_1_1UObject.html">icu::UObject</a></td></tr>
<tr class="memitem:af10026497704f510d3d1f2eff50acb18 inherit pub_methods_classicu_1_1UObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1UObject.html#af10026497704f510d3d1f2eff50acb18">~UObject</a> ()</td></tr>
<tr class="memdesc:af10026497704f510d3d1f2eff50acb18 inherit pub_methods_classicu_1_1UObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classicu_1_1UObject.html#af10026497704f510d3d1f2eff50acb18">More...</a><br /></td></tr>
<tr class="separator:af10026497704f510d3d1f2eff50acb18 inherit pub_methods_classicu_1_1UObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abda7c218cb044e5a9454751c7295eb42"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#abda7c218cb044e5a9454751c7295eb42">getStaticClassID</a> (void)</td></tr>
<tr class="memdesc:abda7c218cb044e5a9454751c7295eb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class ID for this class.  <a href="#abda7c218cb044e5a9454751c7295eb42">More...</a><br /></td></tr>
<tr class="separator:abda7c218cb044e5a9454751c7295eb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a1266dc4f44f0d8614b3060ece504f786 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a1266dc4f44f0d8614b3060ece504f786">createWordInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a1266dc4f44f0d8614b3060ece504f786 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> for word-breaks using the given locale.  <a href="classicu_1_1BreakIterator.html#a1266dc4f44f0d8614b3060ece504f786">More...</a><br /></td></tr>
<tr class="separator:a1266dc4f44f0d8614b3060ece504f786 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3d9612593db8fe5ec25c5c5210daea inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#ace3d9612593db8fe5ec25c5c5210daea">createLineInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:ace3d9612593db8fe5ec25c5c5210daea inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> for line-breaks using specified locale.  <a href="classicu_1_1BreakIterator.html#ace3d9612593db8fe5ec25c5c5210daea">More...</a><br /></td></tr>
<tr class="separator:ace3d9612593db8fe5ec25c5c5210daea inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adffa57ea9131c4a9e0cf8226c17d459a inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#adffa57ea9131c4a9e0cf8226c17d459a">createCharacterInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:adffa57ea9131c4a9e0cf8226c17d459a inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> for character-breaks using specified locale Returns an instance of a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> implementing character breaks.  <a href="classicu_1_1BreakIterator.html#adffa57ea9131c4a9e0cf8226c17d459a">More...</a><br /></td></tr>
<tr class="separator:adffa57ea9131c4a9e0cf8226c17d459a inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cfe6e08f720030beb29ff395066c3d8 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a0cfe6e08f720030beb29ff395066c3d8">createSentenceInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a0cfe6e08f720030beb29ff395066c3d8 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> for sentence-breaks using specified locale Returns an instance of a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> implementing sentence breaks.  <a href="classicu_1_1BreakIterator.html#a0cfe6e08f720030beb29ff395066c3d8">More...</a><br /></td></tr>
<tr class="separator:a0cfe6e08f720030beb29ff395066c3d8 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46067034b6b72745e816589d6692c716 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a46067034b6b72745e816589d6692c716">createTitleInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a46067034b6b72745e816589d6692c716 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> for title-casing breaks using the specified locale Returns an instance of a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> implementing title breaks.  <a href="classicu_1_1BreakIterator.html#a46067034b6b72745e816589d6692c716">More...</a><br /></td></tr>
<tr class="separator:a46067034b6b72745e816589d6692c716 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ececc0263be6fb1d2cec4a47eaad154 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classicu_1_1Locale.html">Locale</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a1ececc0263be6fb1d2cec4a47eaad154">getAvailableLocales</a> (int32_t &amp;count)</td></tr>
<tr class="memdesc:a1ececc0263be6fb1d2cec4a47eaad154 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of Locales for which TextBoundaries are installed.  <a href="classicu_1_1BreakIterator.html#a1ececc0263be6fb1d2cec4a47eaad154">More...</a><br /></td></tr>
<tr class="separator:a1ececc0263be6fb1d2cec4a47eaad154 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06789c46f4b192aced3b4ee568b6ea8 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#ab06789c46f4b192aced3b4ee568b6ea8">getDisplayName</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;objectLocale, const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;displayLocale, <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;name)</td></tr>
<tr class="memdesc:ab06789c46f4b192aced3b4ee568b6ea8 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the object for the desired <a class="el" href="classicu_1_1Locale.html" title="A Locale object represents a specific geographical, political, or cultural region. ">Locale</a>, in the desired language.  <a href="classicu_1_1BreakIterator.html#ab06789c46f4b192aced3b4ee568b6ea8">More...</a><br /></td></tr>
<tr class="separator:ab06789c46f4b192aced3b4ee568b6ea8 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0280f649fca63ddc353e0d17ab9bb4a8 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a0280f649fca63ddc353e0d17ab9bb4a8">getDisplayName</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;objectLocale, <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;name)</td></tr>
<tr class="memdesc:a0280f649fca63ddc353e0d17ab9bb4a8 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the object for the desired <a class="el" href="classicu_1_1Locale.html" title="A Locale object represents a specific geographical, political, or cultural region. ">Locale</a>, in the language of the default locale.  <a href="classicu_1_1BreakIterator.html#a0280f649fca63ddc353e0d17ab9bb4a8">More...</a><br /></td></tr>
<tr class="separator:a0280f649fca63ddc353e0d17ab9bb4a8 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03207fda29e7eab8adf59fb1788b2cf inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="umisc_8h.html#ab5905d79ed3b979840cee1d5fd48b4fb">URegistryKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#af03207fda29e7eab8adf59fb1788b2cf">registerInstance</a> (<a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *toAdopt, const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;locale, <a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a> kind, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:af03207fda29e7eab8adf59fb1788b2cf inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new break iterator of the indicated kind, to use in the given locale.  <a href="classicu_1_1BreakIterator.html#af03207fda29e7eab8adf59fb1788b2cf">More...</a><br /></td></tr>
<tr class="separator:af03207fda29e7eab8adf59fb1788b2cf inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89b591636b40ec7a1037d02bfe8d832 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#ac89b591636b40ec7a1037d02bfe8d832">unregister</a> (<a class="el" href="umisc_8h.html#ab5905d79ed3b979840cee1d5fd48b4fb">URegistryKey</a> key, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:ac89b591636b40ec7a1037d02bfe8d832 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a previously-registered <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> using the key returned from the register call.  <a href="classicu_1_1BreakIterator.html#ac89b591636b40ec7a1037d02bfe8d832">More...</a><br /></td></tr>
<tr class="separator:ac89b591636b40ec7a1037d02bfe8d832 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715fcfc47c6961a67541d6e7b5d83773 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1StringEnumeration.html">StringEnumeration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a715fcfc47c6961a67541d6e7b5d83773">getAvailableLocales</a> (void)</td></tr>
<tr class="memdesc:a715fcfc47c6961a67541d6e7b5d83773 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classicu_1_1StringEnumeration.html" title="Base class for &#39;pure&#39; C++ implementations of uenum api. ">StringEnumeration</a> over the locales available at the time of the call, including registered locales.  <a href="classicu_1_1BreakIterator.html#a715fcfc47c6961a67541d6e7b5d83773">More...</a><br /></td></tr>
<tr class="separator:a715fcfc47c6961a67541d6e7b5d83773 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a2ad6052587787523f902a4503693dbe6"><td class="memItemLeft" align="right" valign="top">RBBIDataWrapper *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a2ad6052587787523f902a4503693dbe6">fData</a></td></tr>
<tr class="memdesc:a2ad6052587787523f902a4503693dbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rule data for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> instance.  <a href="#a2ad6052587787523f902a4503693dbe6">More...</a><br /></td></tr>
<tr class="separator:a2ad6052587787523f902a4503693dbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a17ce03f12f5fa8688859b25e2bf60938"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a17ce03f12f5fa8688859b25e2bf60938">RBBIRuleBuilder</a></td></tr>
<tr class="separator:a17ce03f12f5fa8688859b25e2bf60938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbb7407696454879cf016b20a0380f0"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a5fbb7407696454879cf016b20a0380f0">BreakIterator</a></td></tr>
<tr class="separator:a5fbb7407696454879cf016b20a0380f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a0174c4360d0cb8d21ecc3e4cea71d035 inherit pub_types_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classicu_1_1BreakIterator.html#a0174c4360d0cb8d21ecc3e4cea71d035af9daa8410e7f8dc1631f8fc6a8a8115c">DONE</a> = (int32_t)-1
 }</td></tr>
<tr class="separator:a0174c4360d0cb8d21ecc3e4cea71d035 inherit pub_types_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a151b3d5496d7ca586c331f8521446755 inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a151b3d5496d7ca586c331f8521446755">BreakIterator</a> ()</td></tr>
<tr class="separator:a151b3d5496d7ca586c331f8521446755 inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a44745041bbe7e3ec41bc1e2a880c80 inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a0a44745041bbe7e3ec41bc1e2a880c80">BreakIterator</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;other)</td></tr>
<tr class="separator:a0a44745041bbe7e3ec41bc1e2a880c80 inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094580dacf6cc3f251fb4844278a61ce inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a094580dacf6cc3f251fb4844278a61ce">BreakIterator</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;valid, const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;actual)</td></tr>
<tr class="separator:a094580dacf6cc3f251fb4844278a61ce inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029005b4e479e5fc90bf11e74eb6c0d4 inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a029005b4e479e5fc90bf11e74eb6c0d4">operator=</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;other)</td></tr>
<tr class="separator:a029005b4e479e5fc90bf11e74eb6c0d4 inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A subclass of <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> whose behavior is specified using a list of rules. </p>
<p>Instances of this class are most commonly created by the factory methods of <a class="el" href="classicu_1_1BreakIterator.html#a1266dc4f44f0d8614b3060ece504f786" title="Create BreakIterator for word-breaks using the given locale. ">BreakIterator::createWordInstance()</a>, <a class="el" href="classicu_1_1BreakIterator.html#ace3d9612593db8fe5ec25c5c5210daea" title="Create BreakIterator for line-breaks using specified locale. ">BreakIterator::createLineInstance()</a>, etc., and then used via the abstract API in class <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a></p>
<p>See the ICU User Guide for information on Break Iterator Rules.</p>
<p>This class is not intended to be subclassed.</p>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00055">55</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a976126b3070d56d23a67184b41e88141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976126b3070d56d23a67184b41e88141">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty shell of an iterator, with no rules or text to iterate over. Object can subsequently be assigned to. </p><dl class="stable"><dt><b><a class="el" href="stable.html#_stable000567">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a id="acaaa98a62891cc8b6ef72c913a67a7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaaa98a62891cc8b6ef72c913a67a7b6">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Will produce a break iterator with the same behavior, and which iterates over the same text, as the one passed in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules. ">RuleBasedBreakIterator</a> passed to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000568">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="af34393c8272153f00eab8b3ba5dd8263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34393c8272153f00eab8b3ba5dd8263">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUParseError.html">UParseError</a> &amp;&#160;</td>
          <td class="paramname"><em>parseError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules. ">RuleBasedBreakIterator</a> from a set of rules supplied as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rules</td><td>The break rules to be used. </td></tr>
    <tr><td class="paramname">parseError</td><td>In the event of a syntax error in the rules, provides the location within the rules of the problem. </td></tr>
    <tr><td class="paramname">status</td><td>Information on any errors encountered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000569">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a id="afe74962355b2cf5cf699ab2c98d0852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe74962355b2cf5cf699ab2c98d0852d">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>compiledRules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ruleLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules. ">RuleBasedBreakIterator</a> from a set of precompiled binary rules. </p>
<p>Binary rules are obtained from RulesBasedBreakIterator::getBinaryRules(). Construction of a break iterator in this way is substantially faster than construction from source rules.</p>
<p>Ownership of the storage containing the compiled rules remains with the caller of this function. The compiled rules must not be modified or deleted during the life of the break iterator.</p>
<p>The compiled rules are not compatible across different major versions of ICU. The compiled rules are compatible only between machines with the same byte ordering (little or big endian) and the same base character set family (ASCII or EBCDIC).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aaeb4fa90807c2e89ca7514db3a0e4f31" title="Return the binary form of compiled break rules, which can then be used to create a new break iterator...">getBinaryRules</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compiledRules</td><td>A pointer to the compiled break rules to be used. </td></tr>
    <tr><td class="paramname">ruleLength</td><td>The length of the compiled break rules, in bytes. This corresponds to the length value produced by <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aaeb4fa90807c2e89ca7514db3a0e4f31" title="Return the binary form of compiled break rules, which can then be used to create a new break iterator...">getBinaryRules()</a>. </td></tr>
    <tr><td class="paramname">status</td><td>Information on any errors encountered, including invalid binary rules. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000570">Stable:</a></b></dt><dd>ICU 4.8 </dd></dl>

</div>
</div>
<a id="adde71d5c99670342c9db9e67b7475822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde71d5c99670342c9db9e67b7475822">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="udata_8h.html#acffec83601fda29bd4750b24f829f56b">UDataMemory</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This constructor uses the udata interface to create a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> whose internal tables live in a memory-mapped file. </p>
<p>"image" is an ICU UDataMemory handle for the pre-compiled break iterator tables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>handle to the memory image for the break iterator data. Ownership of the UDataMemory handle passes to the Break Iterator, which will be responsible for closing it when it is no longer needed. </td></tr>
    <tr><td class="paramname">status</td><td>Information on any errors encountered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="udata_8h.html#a3d908d77900b182403a375793ad35a86" title="Convenience function. ">udata_open</a> </dd>
<dd>
<a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aaeb4fa90807c2e89ca7514db3a0e4f31" title="Return the binary form of compiled break rules, which can then be used to create a new break iterator...">getBinaryRules</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000571">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a id="af171cfdce6f264ae7f7f18078248a08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af171cfdce6f264ae7f7f18078248a08b">&#9670;&nbsp;</a></span>~RuleBasedBreakIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual icu::RuleBasedBreakIterator::~RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000572">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af552e13c98aed9f2995fc0f8f066d6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af552e13c98aed9f2995fc0f8f066d6f1">&#9670;&nbsp;</a></span>adoptText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void icu::RuleBasedBreakIterator::adoptText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> *&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the iterator to analyze a new piece of text. </p>
<p>This function resets the current iteration position to the beginning of the text. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>An iterator over the text to analyze. The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> takes ownership of the character iterator. The caller MUST NOT delete it! </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000581">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a1fd72184b59936bb62b07af071e2b0c1">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a59cb3bdf547a2e7f922ce62436d4dd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cb3bdf547a2e7f922ce62436d4dd9f">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a>* icu::RuleBasedBreakIterator::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a newly-constructed <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules. ">RuleBasedBreakIterator</a> with the same behavior, and iterating over the same text, as this one. </p>
<p>Differs from the copy constructor in that it is polymorphic, and will correctly clone (copy) a derived class. <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a59cb3bdf547a2e7f922ce62436d4dd9f" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> is thread safe. Multiple threads may simultaneously clone the same source break iterator. </p><dl class="section return"><dt>Returns</dt><dd>a newly-constructed <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules. ">RuleBasedBreakIterator</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000576">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a1e2694eb976e034f1287a1eb4899cf33">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="aaa27fd7b810caa0191f67504fef81c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa27fd7b810caa0191f67504fef81c22">&#9670;&nbsp;</a></span>createBufferClone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a>* icu::RuleBasedBreakIterator::createBufferClone </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>BufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated functionality. </p>
<p>Use <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a59cb3bdf547a2e7f922ce62436d4dd9f" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> instead.</p>
<p>Create a clone (copy) of this break iterator in memory provided by the caller. The idea is to increase performance by avoiding a storage allocation. Use of this function is NOT RECOMMENDED. Performance gains are minimal, and correct buffer management is tricky. Use <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a59cb3bdf547a2e7f922ce62436d4dd9f" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stackBuffer</td><td>The pointer to the memory into which the cloned object should be placed. If NULL, allocate heap memory for the cloned object. </td></tr>
    <tr><td class="paramname">BufferSize</td><td>The size of the buffer. If zero, return the required buffer size, but do not clone the object. If the size was too small (but not zero), allocate heap storage for the cloned object.</td></tr>
    <tr><td class="paramname">status</td><td>Error status. U_SAFECLONE_ALLOCATED_WARNING will be returned if the provided buffer was too small, and the clone was therefore put on the heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the clone object. This may differ from the stackBuffer address if the byte alignment of the stack buffer was not suitable or if the stackBuffer was too small to hold the clone. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>ICU 52. Use <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a59cb3bdf547a2e7f922ce62436d4dd9f" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> instead. </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#ac0b126946521a209ec2c6d490b7db86e">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a747f3b5bf76323d7c8e7983c9388e6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747f3b5bf76323d7c8e7983c9388e6b4">&#9670;&nbsp;</a></span>current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current iteration position. </p>
<p>Note that UBRK_DONE is never returned from this function; if iteration has run to the end of a string, <a class="el" href="classicu_1_1BreakIterator.html#af6ad53a2e16b52b8d746f81d2ffdf231" title="Return character index of the current iterator position within the text. ">current()</a> will return the length of the string while <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a81d13c4995852cfad40af882452fbcba" title="Advances the iterator to the next boundary position. ">next()</a> will return UBRK_DONE). </p><dl class="section return"><dt>Returns</dt><dd>The current iteration position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000592">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#af6ad53a2e16b52b8d746f81d2ffdf231">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a88705f0fdbdaa71ec29a6204e09d4668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88705f0fdbdaa71ec29a6204e09d4668">&#9670;&nbsp;</a></span>dumpCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icu::RuleBasedBreakIterator::dumpCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging function only. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000105">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a id="a581a3d53f5699e16a408cc6b85d30a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581a3d53f5699e16a408cc6b85d30a58">&#9670;&nbsp;</a></span>dumpTables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icu::RuleBasedBreakIterator::dumpTables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging function only. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000106">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a id="ae570e1d10c69d488add6ca6450185ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae570e1d10c69d488add6ca6450185ff9">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current iteration position to the beginning of the text, position zero. </p>
<dl class="section return"><dt>Returns</dt><dd>The offset of the beginning of the text, zero. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000584">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#abc6bb155a2ec664f63df79a80f8b43e5">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="adf540b2d0d834bea3b7953502e36c717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf540b2d0d834bea3b7953502e36c717">&#9670;&nbsp;</a></span>following()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::following </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the iterator to refer to the first boundary position following the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The position from which to begin searching for a break position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the first break after the current position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000589">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#ae4178f880af4875ae5e30a716331fbaf">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="aaeb4fa90807c2e89ca7514db3a0e4f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb4fa90807c2e89ca7514db3a0e4f31">&#9670;&nbsp;</a></span>getBinaryRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const uint8_t* icu::RuleBasedBreakIterator::getBinaryRules </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the binary form of compiled break rules, which can then be used to create a new break iterator at some time in the future. </p>
<p>Creating a break iterator from pre-compiled rules is much faster than building one from the source form of the break rules.</p>
<p>The binary data can only be used with the same version of ICU and on the same platform type (processor endian-ness)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Returns the length of the binary data. (Out parameter.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the binary (compiled) rule data. The storage belongs to the RulesBasedBreakIterator object, not the caller, and must not be modified or deleted. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000597">Stable:</a></b></dt><dd>ICU 4.8 </dd></dl>

</div>
</div>
<a id="a4c49d712d0b77e6dbdf60fb0c118164a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c49d712d0b77e6dbdf60fb0c118164a">&#9670;&nbsp;</a></span>getDynamicClassID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a> icu::RuleBasedBreakIterator::getDynamicClassID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a unique class ID POLYMORPHICALLY. </p>
<p>Pure virtual override. This method is to implement a simple version of RTTI, since not all C++ compilers support genuine RTTI. Polymorphic <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ab1b4921dcac2850239ded74d4e1690c4" title="Equality operator. ">operator==()</a> and <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a59cb3bdf547a2e7f922ce62436d4dd9f" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> methods call this method.</p>
<dl class="section return"><dt>Returns</dt><dd>The class ID for this object. All objects of a given class have the same class ID. Objects of other classes have different class IDs. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000595">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a5515a96ff2f8ade4e3c2ce581ffe839b">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="adb1ee0b366ac18d7e1cc2bfc813a4ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb1ee0b366ac18d7e1cc2bfc813a4ad9">&#9670;&nbsp;</a></span>getRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a>&amp; icu::RuleBasedBreakIterator::getRules </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the description used to create this iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>the description used to create this iterator </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000578">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a937a421cdc0d779f73d4d3bbc3279a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937a421cdc0d779f73d4d3bbc3279a1f">&#9670;&nbsp;</a></span>getRuleStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::getRuleStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the status tag from the break rule that determined the boundary at the current iteration position. </p>
<p>For break rules that do not specify a status, a default value of 0 is returned. If more than one break rule would cause a boundary to be located at some position in the text, the numerically largest of the applicable status values is returned. </p>
<p>Of the standard types of ICU break iterators, only word break and line break provide status values. The values are defined in the header file <a class="el" href="ubrk_8h.html" title="C API: BreakIterator. ">ubrk.h</a>. For Word breaks, the status allows distinguishing between words that contain alphabetic letters, "words" that appear to be numbers, punctuation and spaces, words containing ideographic characters, and more. For Line Break, the status distinguishes between hard (mandatory) breaks and soft (potential) break positions. </p>
<p><code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a937a421cdc0d779f73d4d3bbc3279a1f" title="Return the status tag from the break rule that determined the boundary at the current iteration posit...">getRuleStatus()</a></code> can be called after obtaining a boundary position from <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a81d13c4995852cfad40af882452fbcba" title="Advances the iterator to the next boundary position. ">next()</a></code>, <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a6b566ab3e2b8a8e49d2f0a0415f5a151" title="Moves the iterator backwards, to the last boundary preceding this one. ">previous()</a></code>, or any other break iterator functions that returns a boundary position. </p>
<p>Note that <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a937a421cdc0d779f73d4d3bbc3279a1f" title="Return the status tag from the break rule that determined the boundary at the current iteration posit...">getRuleStatus()</a></code> returns the value corresponding to <code><a class="el" href="classicu_1_1BreakIterator.html#af6ad53a2e16b52b8d746f81d2ffdf231" title="Return character index of the current iterator position within the text. ">current()</a></code> index even after <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a81d13c4995852cfad40af882452fbcba" title="Advances the iterator to the next boundary position. ">next()</a></code> has returned DONE. </p>
<p>When creating custom break rules, one is free to define whatever status values may be convenient for the application. </p>
<dl class="section return"><dt>Returns</dt><dd>the status from the break rule that determined the boundary at the current iteration position.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#afc5d4d3f7f4207d27081409e4b1b6c9a" title="Enum constants for the word break tags returned by getRuleStatus(). ">UWordBreak</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000593">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

<p>Reimplemented from <a class="el" href="classicu_1_1BreakIterator.html#a1920d04ad1b7d0966b2ff7863df77a74">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a49e5fa6fabba66a1b862eb3725f14b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e5fa6fabba66a1b862eb3725f14b0d">&#9670;&nbsp;</a></span>getRuleStatusVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::getRuleStatusVec </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>fillInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the status (tag) values from the break rule(s) that determined the boundary at the current iteration position. </p>
<p>The returned status value(s) are stored into an array provided by the caller. The values are stored in sorted (ascending) order. If the capacity of the output array is insufficient to hold the data, the output will be truncated to the available length, and a U_BUFFER_OVERFLOW_ERROR will be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillInVec</td><td>an array to be filled in with the status values. </td></tr>
    <tr><td class="paramname">capacity</td><td>the length of the supplied vector. A length of zero causes the function to return the number of status values, in the normal way, without attempting to store any values. </td></tr>
    <tr><td class="paramname">status</td><td>receives error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of rule status values from the rules that determined the boundary at the current iteration position. In the event of a U_BUFFER_OVERFLOW_ERROR, the return value is the total number of status values that were available, not the reduced number that were actually returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a937a421cdc0d779f73d4d3bbc3279a1f" title="Return the status tag from the break rule that determined the boundary at the current iteration posit...">getRuleStatus</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000594">Stable:</a></b></dt><dd>ICU 3.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classicu_1_1BreakIterator.html#af3bf12df7434e65041447bef51264e13">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="abda7c218cb044e5a9454751c7295eb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda7c218cb044e5a9454751c7295eb42">&#9670;&nbsp;</a></span>getStaticClassID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a> icu::RuleBasedBreakIterator::getStaticClassID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the class ID for this class. </p>
<p>This is useful only for comparing to a return value from <a class="el" href="classicu_1_1BreakIterator.html#a5515a96ff2f8ade4e3c2ce581ffe839b" title="Return a polymorphic class ID for this object. ">getDynamicClassID()</a>. For example: </p><pre class="fragment"> Base* polymorphic_pointer = createPolymorphicObject();
 if (polymorphic_pointer-&gt;getDynamicClassID() ==
     Derived::getStaticClassID()) ...
</pre><dl class="section return"><dt>Returns</dt><dd>The class ID for all objects of this class. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000596">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a38df4a3bb0a8269af594ff142141bdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38df4a3bb0a8269af594ff142141bdf5">&#9670;&nbsp;</a></span>getText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a>&amp; icu::RuleBasedBreakIterator::getText </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classicu_1_1CharacterIterator.html" title="Abstract class that defines an API for iteration on text objects. ">CharacterIterator</a> over the text being analyzed. The returned character iterator is owned by the break iterator, and must not be deleted by the caller. Repeated calls to this function may return the same <a class="el" href="classicu_1_1CharacterIterator.html" title="Abstract class that defines an API for iteration on text objects. ">CharacterIterator</a>. </p>
<p>The returned character iterator must not be used concurrently with the break iterator. If concurrent operation is needed, clone the returned character iterator first and operate on the clone. </p>
<p>When the break iterator is operating on text supplied via a <a class="el" href="structUText.html" title="UText struct. ">UText</a>, this function will fail. Lacking any way to signal failures, it returns an <a class="el" href="classicu_1_1CharacterIterator.html" title="Abstract class that defines an API for iteration on text objects. ">CharacterIterator</a> containing no text. The function <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a32f952ddea1c33924db8a75601405968" title="Get a UText for the text being analyzed. ">getUText()</a> provides similar functionality, is reliable, and is more efficient. </p>
<p>TODO: deprecate this function?</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator over the text being analyzed. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000579">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a290f5be64b2dffdfd707b4cdb602379b">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a32f952ddea1c33924db8a75601405968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f952ddea1c33924db8a75601405968">&#9670;&nbsp;</a></span>getUText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* icu::RuleBasedBreakIterator::getUText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>fillIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="structUText.html" title="UText struct. ">UText</a> for the text being analyzed. </p>
<p>The returned <a class="el" href="structUText.html" title="UText struct. ">UText</a> is a shallow clone of the <a class="el" href="structUText.html" title="UText struct. ">UText</a> used internally by the break iterator implementation. It can safely be used to access the text without impacting any break iterator operations, but the underlying text itself must not be altered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillIn</td><td>A <a class="el" href="structUText.html" title="UText struct. ">UText</a> to be filled in. If NULL, a new <a class="el" href="structUText.html" title="UText struct. ">UText</a> will be allocated to hold the result. </td></tr>
    <tr><td class="paramname">status</td><td>receives any error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="structUText.html" title="UText struct. ">UText</a> for this break iterator. If an input <a class="el" href="structUText.html" title="UText struct. ">UText</a> was provided, it will always be returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000580">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#af57b33540abfb9c41e9f1e54974d0559">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="afbfd1d9c7231c809fad160d0a76517d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfd1d9c7231c809fad160d0a76517d3">&#9670;&nbsp;</a></span>hashCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::hashCode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a hash code for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000577">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="ac4a68042aa461be2eeb9940a3d00b37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a68042aa461be2eeb9940a3d00b37d">&#9670;&nbsp;</a></span>isBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> icu::RuleBasedBreakIterator::isBoundary </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified position is a boundary position. </p>
<p>As a side effect, leaves the iterator pointing to the first boundary position at or after "offset". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if "offset" is a boundary position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000591">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#aaf997425386eae9c50cd5c208dbef214">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="ae76433bea39e818b36dd68fef2d923e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76433bea39e818b36dd68fef2d923e9">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::last </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current iteration position to the end of the text. </p>
<dl class="section return"><dt>Returns</dt><dd>The text's past-the-end offset. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000585">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a2ecbdcabef74105eb7f0747011d05e01">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="ad1ca41106d2b7697a8a88b5ede42bf96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ca41106d2b7697a8a88b5ede42bf96">&#9670;&nbsp;</a></span>next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::next </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the iterator either forward or backward the specified number of steps. </p>
<p>Negative values move backward, and positive values move forward. This is equivalent to repeatedly calling <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a81d13c4995852cfad40af882452fbcba" title="Advances the iterator to the next boundary position. ">next()</a> or <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a6b566ab3e2b8a8e49d2f0a0415f5a151" title="Moves the iterator backwards, to the last boundary preceding this one. ">previous()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of steps to move. The sign indicates the direction (negative is backwards, and positive is forwards). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character offset of the boundary position n boundaries away from the current one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000586">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a971257b3ed9676ec02890187025caf1b">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a81d13c4995852cfad40af882452fbcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d13c4995852cfad40af882452fbcba">&#9670;&nbsp;</a></span>next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::next </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the iterator to the next boundary position. </p>
<dl class="section return"><dt>Returns</dt><dd>The position of the first boundary after this one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000587">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a13468dd341e9f0eb92c61f25e88a5154">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="ae42126bcf7a30052e04be78566856066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42126bcf7a30052e04be78566856066">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> icu::RuleBasedBreakIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not-equal operator. </p>
<p>If operator== returns TRUE, this returns FALSE, and vice versa. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> to be compared for inequality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if both BreakIterators are not same. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000575">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00693">693</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

<p class="reference">References <a class="el" href="classicu_1_1BreakIterator.html#a5e65e03f2e505ff1dc01311b01790abc">icu::BreakIterator::operator==()</a>.</p>

</div>
</div>
<a id="a3e5e205b2cc4e2f0b1ea66f0c3b52293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5e205b2cc4e2f0b1ea66f0c3b52293">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a>&amp; icu::RuleBasedBreakIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Sets this iterator to have the same behavior, and iterate over the same text, as the one passed in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The RuleBasedBreakItertor passed in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules. ">RuleBasedBreakIterator</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000573">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="ab1b4921dcac2850239ded74d4e1690c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b4921dcac2850239ded74d4e1690c4">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> icu::RuleBasedBreakIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Returns TRUE if both BreakIterators are of the same class, have the same behavior, and iterate over the same text. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> to be compared for equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TRUE if both BreakIterators are of the same class, have the same behavior, and iterate over the same text. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000574">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a5e65e03f2e505ff1dc01311b01790abc">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="ac7beaf4da856f4573e15fe756114e32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7beaf4da856f4573e15fe756114e32d">&#9670;&nbsp;</a></span>preceding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::preceding </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the iterator to refer to the last boundary position before the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The position to begin searching for a break from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the last boundary before the starting position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000590">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a980f8e8fbe1d37827cacc24f9606399f">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a6b566ab3e2b8a8e49d2f0a0415f5a151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b566ab3e2b8a8e49d2f0a0415f5a151">&#9670;&nbsp;</a></span>previous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::previous </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the iterator backwards, to the last boundary preceding this one. </p>
<dl class="section return"><dt>Returns</dt><dd>The position of the last boundary position preceding this one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000588">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#aeede95a59db8408760b106724dfb7a4d">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a42cefac1ccd59b8b0bb282c2df26ef73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cefac1ccd59b8b0bb282c2df26ef73">&#9670;&nbsp;</a></span>refreshInputText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a>&amp; icu::RuleBasedBreakIterator::refreshInputText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the subject text string upon which the break iterator is operating without changing any other aspect of the matching state. </p>
<p>The new and previous text strings must have the same content.</p>
<p>This function is intended for use in environments where ICU is operating on strings that may move around in memory. It provides a mechanism for notifying ICU that the string has been relocated, and providing a new <a class="el" href="structUText.html" title="UText struct. ">UText</a> to access the string in its new position.</p>
<p>Note that the break iterator implementation never copies the underlying text of a string being processed, but always operates directly on the original text provided by the user. Refreshing simply drops the references to the old text and replaces them with references to the new.</p>
<p>Caution: this function is normally used only by very specialized, system-level code. One example use case is with garbage collection that moves the text in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The new (moved) text string. </td></tr>
    <tr><td class="paramname">status</td><td>Receives errors detected by this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000598">Stable:</a></b></dt><dd>ICU 49 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a88ac5ff907f98e814783267b7fe082a5">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="aa751ea4cc941ed62585ac1d2de812ee6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa751ea4cc941ed62585ac1d2de812ee6">&#9670;&nbsp;</a></span>setText() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void icu::RuleBasedBreakIterator::setText </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the iterator to analyze a new piece of text. </p>
<p>This function resets the current iteration position to the beginning of the text.</p>
<p>The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> will retain a reference to the supplied string. The caller must not modify or delete the text while the <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> retains the reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>The text to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000582">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a8b894129fb567fded3ed85a7e8ead942">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a2725705885bda731102965658868d2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2725705885bda731102965658868d2b3">&#9670;&nbsp;</a></span>setText() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void icu::RuleBasedBreakIterator::setText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct. ">UText</a>. </p>
<p>The iterator position is reset to the start.</p>
<p>This function makes a shallow clone of the supplied <a class="el" href="structUText.html" title="UText struct. ">UText</a>. This means that the caller is free to immediately close or otherwise reuse the Utext that was passed as a parameter, but that the underlying text itself must not be altered while being referenced by the break iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The <a class="el" href="structUText.html" title="UText struct. ">UText</a> used to change the text. </td></tr>
    <tr><td class="paramname">status</td><td>Receives any error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000583">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a3110dd5111286cd514ea6896ddd8c5bd">icu::BreakIterator</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a5fbb7407696454879cf016b20a0380f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbb7407696454879cf016b20a0380f0">&#9670;&nbsp;</a></span>BreakIterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000099">Internal:</a></b></dt><dd>Do not use.</dd></dl>
<p>This API is for internal use only. </p>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00162">162</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a id="a17ce03f12f5fa8688859b25e2bf60938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ce03f12f5fa8688859b25e2bf60938">&#9670;&nbsp;</a></span>RBBIRuleBuilder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class RBBIRuleBuilder</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000098">Internal:</a></b></dt><dd>Do not use.</dd></dl>
<p>This API is for internal use only. </p>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00160">160</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a2ad6052587787523f902a4503693dbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad6052587787523f902a4503693dbe6">&#9670;&nbsp;</a></span>fData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RBBIDataWrapper* icu::RuleBasedBreakIterator::fData</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The rule data for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text...">BreakIterator</a> instance. </p>
<p>Not for general use; Public only for testing purposes. </p><dl class="internal"><dt><b><a class="el" href="internal.html#_internal000093">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00072">72</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="rbbi_8h_source.html">rbbi.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
