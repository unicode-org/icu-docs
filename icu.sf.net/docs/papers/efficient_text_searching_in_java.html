<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<title>Unicode Text Searching in Java</title>
</head>

<body LINK="#0000ff" VLINK="#800080">
<font FACE="Arial" SIZE="5"><b>

<p ALIGN="CENTER">Efficient Text Searching in Java</p>
</b></font><p ALIGN="CENTER">

<font FACE="Arial" SIZE="2"><br>
By </font><a HREF="#about_author"><font FACE="Arial" SIZE="2">Laura Werner</font></a></p>
<p ALIGN="CENTER">

<font face="Arial" size="2">(appeared in </font><i><a HREF="http://www.javareport.com/"><font
FACE="Arial" SIZE="2">Java Report</font></a></i><font FACE="Arial" SIZE="2">, February
1999)<br>
</font></p><font FACE="Arial" SIZE="2">

<p>Text searching and sorting is one of the most well researched areas in computer
science. It is covered in an introductory algorithms course in nearly every engineering
school, and there are entire books devoted to the subject. Why, you might ask, am I
writing yet another article about searching?</p>

</font><p><font FACE="Arial" SIZE="2">The answer is that most of the well-known, efficient search algorithms don&#146;t work
very well in Unicode, which includes the </font><code>char</code><font FACE="Arial"
SIZE="2"> type in Java. Algorithms such as Knuth-Morris-Pratt and Boyer-Moore utilize
tables that tell them what to do when a particular character is seen in the text being
searched. That&#146;s fine for a traditional character set such as ASCII or ISO Latin-1
where there are only 128 or 256 possible characters.</font></p><font FACE="Arial"
SIZE="2">

<p>Java, however, uses Unicode as its character set. In Unicode, there are 65,535 distinct
characters that cover all modern languages of the world, including ideographic languages
such as Chinese. In general, this is good; it makes the task of developing global
applications a great deal easier. However, algorithms like Boyer-Moore that rely on an
array indexed by character codes are very wasteful of memory and take a long time to
initialize in this environment. </p>

<p>And it gets worse. Sorting and searching non-English text presents number of challenges
that many English speakers are not even aware of. The primary source of difficulty is
accents, which have very different meanings in different languages, and sometimes even
within the same language:

<ul>
  <li>Many accented letters, such as &quot;é&quot; in &quot;café&quot;, are treated as minor
    variants on the letter that is accented, in this case &quot;e&quot;.</li>
  <li>Sometimes the accented form of a letter is treated as a distinct letter for the purposes
    of comparison. For example, &quot;Å&quot; in Danish is treated as a separate letter that
    sorts just after &quot;Z&quot;.</li>
  <li>In some cases, an accented letter is treated as if it were <i>two</i> letters. In
    traditional German, for example, &quot;ä&quot; is compared as if it were &quot;ae&quot;.</li>
</ul>

<p>Other difficulties arise when multiple characters compare as if they were one, such as
in traditional Spanish where &quot;ch&quot; is treated as a single letter that sorts just
after &quot;c&quot; and before &quot;d&quot;, or when single characters such as the
&quot;Æ&quot; ligature or the German &quot;ß&quot; are treated as if they were spelled
out as &quot;AE&quot; or &quot;ss&quot;.</p>

</font><p><font FACE="Arial"
SIZE="2">All of the above might make the problem of sorting and searching international text
seem hopeless. While not impossible, it <i>is</i> a difficult problem. Do not despair,
however. Starting in JDK 1.1, the class </font><code>java.text.Collator</code><font
FACE="Arial" SIZE="2"> is here to help.</font></p>
<font FACE="Arial" SIZE="4"><b>

<p>Collators Made Simple</p>
</b></font><font FACE="Arial" SIZE="2">

<p>For JDK 1.1, Taligent, which has since been absorbed into IBM, contributed a number of
international support classes to the Java Class Libraries. These classes are now
maintained and enhanced by engineers at the IBM Center for Java Technology in Cupertino,
California. In combination with work done by Sun, they provide a powerful foundation for
developing truly global applications.</p>

</font><p><font FACE="Arial" SIZE="2">Among the new classes introduced in JDK 1.1 were </font><code>Collator</code><font
FACE="Arial" SIZE="2"> and </font><code>RuleBasedCollator</code><font FACE="Arial"
SIZE="2">, both in the </font><code>java.text</code><font FACE="Arial" SIZE="2"> package. </font><code>Collator</code><font
FACE="Arial" SIZE="2"> provides an abstract interface for comparing text, while </font><code>RuleBasedCollator</code><font
FACE="Arial" SIZE="2"> is a concrete subclass that implements the comparison using a
rule-driven algorithm. </font></p><font
FACE="Arial" SIZE="2">

<p>Using these classes to compare two strings is quite straightforward:</p>
</font>

<pre>
    Collator c = Collator.getInstance();
    if (c.compare(string1, string2) == 0) {
	// Strings are the same
    }</pre>
<p>

<font FACE="Arial" SIZE="2">In a real program, of course, you would only call </font><code>Collator.getInstance</code><font
FACE="Arial" SIZE="2"> once and would then use the same collator object to perform as many
comparisons as you wanted. Behind the scenes, </font><code>getInstance</code><font
FACE="Arial" SIZE="2"> determines the current default Locale, loads the appropriate
collation rules, and constructs a </font><code>Collator</code><font FACE="Arial" SIZE="2">
object that it returns. Currently, this object is always a </font><code>RuleBasedCollator</code><font
FACE="Arial" SIZE="2">. However, in the future different locales may require different
classes with customized behavior, which is why you use a factory method to create
instances of the more abstract </font><code>Collator</code><font FACE="Arial" SIZE="2">
class.</font></p>
<font FACE="Arial" SIZE="4"><b>

<p>Under the Hood</p>
</b></font><p>

<font FACE="Arial" SIZE="2">Internally, </font><code>RuleBasedCollator.compare</code><font FACE="Arial" SIZE="2">
has an awful lot of bookkeeping to do. A byte-by-byte string comparison function like
C&#146;s </font><code>strcmp</code><font FACE="Arial" SIZE="2"> can walk though strings
one character at a time and compare the bytes, but if Collator did something that simple
it would rapidly get out of sync the first time it saw a contracting character like the
Spanish &quot;ch&quot; or an expanding character like &quot;Æ&quot;.</font></p><p>

<font FACE="Arial" SIZE="2">To keep track of this, </font><code>RuleBasedCollator</code><font FACE="Arial" SIZE="2">
first translates strings into a series of collation <i>elements</i>, which correspond to
single entities in the input string. In English, each character in the input maps to a
collation element, but &quot;Æ&quot; produces two elements and the Spanish &quot;ch&quot;
produces just one. This translation is done by the utility class </font><code>CollationElementIterator</code><font
FACE="Arial" SIZE="2">, which uses a set of mapping tables built from the rules passed to
the collator&#146;s constructor.</font></p>
<p>

<code>CollationElementIterator</code><font FACE="Arial" SIZE="2"> is a public class, and you
can use it yourself to do searches, as we will see below. As an introduction, let&#146;s
use it to iterate over the elements for a simple string: </font></p>


<pre>
    RuleBasedCollator c = (RuleBasedCollator)Collator.getInstance();
    CollationElementIterator iter = c.getCollationElementIterator(&quot;Foo&quot;);

    int element;
    while ((element = iter.next()) != CollationElementIterator.NULLORDER) {
	System.out.println(&quot;Collation element is: &quot; + 
        	              Integer.toString(e,16) );
    }</pre>
<p>

<font FACE="Arial" SIZE="2">As you can see from the above example, a collation element is a fairly simple creature;
it&#146;s an </font><code>int</code><font FACE="Arial" SIZE="2"> that describes where a
character or group of characters falls in the sorting sequence. Higher-numbered elements
are sorted after lower-numbered ones.</font></p><font FACE="Arial" SIZE="2">

<p>Of course, it&#146;s really a bit more complicated than that. Each collation element
can be broken down into three components (also known as weights or orders<i>)</i>: <i>primary</i>,
<i>secondary</i>, and <i>tertiary</i>. The primary component of a collation element
corresponds to which base letter the order represents, so &quot;A&quot; and &quot;B&quot;
will have different primary weights. The secondary components typically correspond to
accents, so &quot;á&quot; and &quot;é&quot; will have the same secondary weight, which
is different from the secondary weight of &quot;a&quot;. The tertiary components usually
represent the case of a character, so &quot;a&quot; and &quot;A&quot; will have different
tertiary weighting. (There is a fourth level, the normalized original string itself, which
can be used for a final comparison, but you usually don't need to worry about this level.)</p>
</font><div align="center"><center>

<table CELLSPACING="0" BORDER="0" CELLPADDING="7" WIDTH="348">
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><b><p ALIGN="CENTER">Character</b></font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><b><p ALIGN="CENTER">Primary</b></font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><b><p ALIGN="CENTER">Secondary</b></font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><b><p ALIGN="CENTER">Tertiary</b></font></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">a</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">1</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">0</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">0</font></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">á</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">1</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">1</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">0</font></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">A</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">1</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">0</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">1</font></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">...</font></td>
    <td WIDTH="25%" VALIGN="TOP"></td>
    <td WIDTH="25%" VALIGN="TOP"></td>
    <td WIDTH="25%" VALIGN="TOP"></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">B</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">2</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">0</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">1</font></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">...</font></td>
    <td WIDTH="25%" VALIGN="TOP"></td>
    <td WIDTH="25%" VALIGN="TOP"></td>
    <td WIDTH="25%" VALIGN="TOP"></td>
  </tr>
  <tr>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">é</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">5</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">1</font></td>
    <td WIDTH="25%" VALIGN="TOP"><font FACE="Arial" SIZE="1"><p ALIGN="CENTER">0</font></td>
  </tr>
</table>
</center></div><font FACE="Arial" SIZE="2">

<p>&nbsp;</p>

<p>The above table uses simple, made-up numbers to illustrate the components of a
collation element. In practice, the numbers are usually larger, since most collators have
many more possible elements. To see what real collation orders look like, you can modify
the last code example as follows. The following code will print out the collation elements
for the string &quot;Foo&quot;:</p>
</font>

<pre>
    RuleBasedCollator c = (RuleBasedCollator)Collator.getInstance();
    CollationElementIterator iter = c.getCollationElementIterator(&quot;Foo&quot;);

    int element;
    while ((element = iter.next()) != CollationElementIterator.NULLORDER) {
        System.out.println(&quot;Collation element is: &quot; + element);
        System.out.println(&quot; primary:   &quot; + Integer.toString(
                CollationElementIterator.primaryOrder(element), 16) );
        System.out.println(&quot; secondary: &quot; + Integer.toString(
                CollationElementIterator.secondaryOrder(element), 16) );
        System.out.println(&quot; tertiary:  &quot; + Integer.toString(
                CollationElementIterator.tertiaryOrder(element), 16) );
    }
</pre>
<p>

<font FACE="Arial" SIZE="2">While this notion of three ordering levels seems complicated at first, it actually
makes some tasks easier. If you want to do a case-insensitive comparison, you simply
ignore the tertiary component of each collation element. If you also don&#146;t want to
include accents, you can ignore the secondary component too. </font><code>Collator</code><font
FACE="Arial" SIZE="2"> handles this by allowing you to set different strength levels using
the </font><code>setStrength</code><font FACE="Arial" SIZE="2"> method and constants such
as </font><code>Collator.PRIMARY</code><font FACE="Arial" SIZE="2">.</font></p>


<pre>    Collator c = Collator.getInstance();
    c.setStrength(Collator.PRIMARY);		// Ignore case and accents
    if (c.compare(string1, string2) == 0) {
	  ...					// Strings matched
    }</pre>
<font FACE="Arial" SIZE="4"><b>

<p>Text Searching in JDK 1.1</p>
</b></font><p>

<font FACE="Arial" SIZE="2">Now that you&#146;re familiar with the concepts behind collators and collation
elements, we can put some of that knowledge to use. The same collation elements that </font><code>RuleBasedCollator</code><font
FACE="Arial" SIZE="2"> uses to perform string comparisons can be used to do string
searching as well. The basic concept is quite simple: instead of searching through the
characters in the string, we&#146;ll search through its collation elements.</font></p><p>

<font
FACE="Arial" SIZE="2">Fast string-searching algorithms such as KMP and Boyer-Moore require the ability to
back up or perform random access in the text being searched. Unfortunately, you can&#146;t
do this with international text in JDK 1.1, because CollationElementIterator does not
allow random access. It only has a </font><code>next</code><font FACE="Arial" SIZE="2">
method and is lacking </font><code>setOffset</code><font FACE="Arial" SIZE="2"> and </font><code>previous</code><font
FACE="Arial" SIZE="2">. This means that Boyer-Moore searching cannot be implemented
without a complicated buffering scheme that is very tricky to get right.</font></p><font
FACE="Arial" SIZE="2">

<p>However, a traditional, brute-force string search is quite possible using the JDK 1.1
API. Essentially this comes down to comparing the search pattern against each individual
character position in the text being searched. If the collation elements for the search
pattern match the collation elements for that substring of text being searched, we&#146;ve
found a match. The outer loop looks like this:</p>
</font>

<pre>
    String pattern = &quot;for&quot;;                            // What to search for
    String text = &quot;Now is the time for all good men&quot;;  // Text being searched

    RuleBasedCollator c = (RuleBasedCollator)collator.getInstance();
    CollationElementIterator patIter =
                             c.getCollationElementIterator(pattern);

    for (int i = 0; i &lt; text.length(); i++) {
        String substr = text.substring(i);
        CollationElementIterator textIter = 
                            c.getCollationElementIterator(substr);
        patIter.reset();
        if (match(patIter, textIter)) {
            // They matched!  Do something.
        }
    }
</pre>
<p>

<font FACE="Arial" SIZE="2">Of course, I left out the hard part, the function </font><font FACE="Courier New"
SIZE="2">match</font><font FACE="Arial" SIZE="2"> that decides whether two sequences of
collation elements are equivalent. A simple, naive implementation would loop through both
iterators and ensure that the elements they return are the same:</font></p>


<pre>
    boolean match(CollationElementIterator text,
                  CollationElementIterator pattern)
    {
        while (true) {
            int patternElement = pattern.next();
            int targetElement  = text.next();
            if (patternElement = CollationElementIterator.NULLORDER) {
                break;           // End of the pattern
            } else if (patternElement != targetElement) {
                return false;    // Mismatch
            }
        }
        return true;             // No mismatches
    }
</pre>
<p>

<font FACE="Arial" SIZE="2">This will work, but only if you want to treat <i>any</i> difference, be it primary,
secondary, or tertiary, as significant. In most applications, that is not enough; users
will want an &quot;Ignore Case&quot; option, and possibly an &quot;Ignore Case and
Accents&quot; option as well. Fortunately, this is not very hard to do. </font><code>Collator</code><font
FACE="Arial" SIZE="2"> provides the constants </font><code>PRIMARY</code><font
FACE="Arial" SIZE="2">, </font><code>SECONDARY</code><font FACE="Arial" SIZE="2">, and </font><code>TERTIARY</code><font
FACE="Arial" SIZE="2"> that you can use to represent the level of comparison you want, and
</font><code>CollationElementIterator</code><font FACE="Arial" SIZE="2"> provides methods
to break down a collation order into its three components.</font></p><p>

<font FACE="Arial" SIZE="2">All we need to do is create a variable, e.g. </font><code>weight</code><font
FACE="Arial" SIZE="2">, that stores the desired level of comparison. If </font><code>weight</code><font
FACE="Arial" SIZE="2"> is </font><code>PRIMARY</code><font FACE="Arial" SIZE="2">, we
check only the primary component of each collation element. If </font><code>weight</code><font
FACE="Arial" SIZE="2"> is </font><code>SECONDARY</code><font FACE="Arial" SIZE="2">, we
check both the primary and secondary components, and if it is </font><code>TERTIARY</code><font
FACE="Arial" SIZE="2"> we check all three. Fortunately, these values of these constants
are in ascending numerical order, so we can use simple comparisons such as &quot;</font><code>if
(weight &gt; Collator.PRIMARY) ...</code><font FACE="Arial" SIZE="2">&quot;</font></p><p>

<font FACE="Arial" SIZE="2">To add this extra functionality we have to modify our </font><code>match</code><font
FACE="Arial" SIZE="2"> function a bit, but it is still fairly simple. Since the
documentation for CollationElementIterator promises that &quot;the first 16 bits of a
collation order is its primary order; the next 8 bits is the secondary order and the last
8 bits is the tertiary order,&quot; we can simply mask away the portions of the collation
element that we&#146;re not interested in.</font></p>


<pre>    
    // Return a mask for the part of the order we're interested in
    static final int getMask(int weight) {
        switch (weight) {
            case Collator.PRIMARY:
                return 0xFFFF0000;
            case Collator.SECONDARY:
                return 0xFFFFFF00;
            default: 
                return 0xFFFFFFFF;
        }
    }

    boolean match(CollationElementIterator text,
                  CollationElementIterator pattern)
    {
        int mask = getMask(weight);
        int done = CollationElementIterator.NULLORDER &amp; mask;
      
        while (true) {
            int patternElement = pattern.next() &amp; mask;
            int targetElement  = text.next()    &amp; mask;
            
            if (patternElement == done) {
		break;            // End of pattern
            } else if (patternElement != targetElement) {
		return false;     // Mismatch
            }
        }
        return true;              // No mismatches
    }
</pre>
<font FACE="Arial" SIZE="4"><b>

<p>Ignore That Character!</p>
</b></font><font FACE="Arial" SIZE="2">

<p>As you&#146;ve probably guessed, I left something out again. There&#146;s one last
complication: <i>ignorable</i> characters. In Unicode, an accented character can be
represented in two different ways. The single Unicode character \u00e1 represents
&quot;á&quot;, but the pair of Unicode values \u0061\u0301 also represents
&quot;á&quot;. The \u0061 is just a lowercase &quot;a&quot;, but the \u0301 is special.
It&#146;s a &quot;combining acute accent&quot; that combines with the value before it to
create the single &quot;user-level&quot; character &quot;á&quot;.</p>

<p>These combining characters need special processing during a comparison. Since \u0301 is
<i>only</i> an accent, its collation element has a secondary component but no primary or
tertiary component. In a comparison that does not involve accents, we must ignore this
element entirely. If we did not, we might end up comparing an accent in one string to a
base letter in another string, which would give invalid results. For example, when doing
an accent-insensitive comparison &quot;a\u0301b&quot; and &quot;ab&quot;, we want to skip
the &quot;\u0301&quot; and go on to the next character; otherwise we&#146;d compare
&quot;\u0301&quot; and &quot;b&quot;.</p>

</font><p><font FACE="Arial" SIZE="2">This logic is relatively straightforward, but it does make the code a bit more
complicated. The </font><code>boolean</code><font FACE="Arial" SIZE="2"> variables </font><code>getTarget</code><font
FACE="Arial" SIZE="2"> and </font><code>getPattern</code><font FACE="Arial" SIZE="2"> are
used to decide whether to fetch the next collation element in the text and the pattern
each time through the loop. Normally both variables are </font><code>true</code><font
FACE="Arial" SIZE="2">, but one or the other of them can be set to </font><code>false</code><font
FACE="Arial" SIZE="2"> if we want to skip an element. For example, setting </font><code>getPattern</code><font
FACE="Arial" SIZE="2"> to </font><code>false</code><font FACE="Arial" SIZE="2"> and </font><code>getTarget</code><font
FACE="Arial" SIZE="2"> to </font><code>true</code><font FACE="Arial" SIZE="2"> causes the
current pattern element to be re-used and compared with the next text element, thus
skipping the current text element.</font></p>


<pre>
    boolean match(CollationElementIterator text,
                  CollationElementIterator pattern)
    {
        int mask = getMask(weight);
        int done = CollationElementIterator.NULLORDER &amp; mask;
      
        boolean getPattern = true, getTarget = true;
        int patternElement = 0, targetElement = 0;

        while (true) {
            if (getPattern) patternElement = pattern.next() &amp; mask;
            if (getTarget) targetElement   = text.next()    &amp; mask;
            getTarget = getPattern = true;  // By default get both
    
            if (patternElement == done) {
                break;			            // End of pattern
            } else if (targetElement == 0) {
              getPattern = false;		    // skip targetElement
            } else if (patternElement == 0) {
              getTarget = false;		    // skip patternElement
            } else if (targetElement != patternElement) {
              return false;                         // Mismatch
            }
        }
        return true;                                // No mismatches
    }</pre>
<p>

<font FACE="Arial" SIZE="2">This is about the best you can do with the JDK 1.1 API. You can add bells and whistles,
such as searching backward though text by reversing the order of the outer loop that calls
</font><code>match</code><font FACE="Arial" SIZE="2">, but you can&#146;t really implement
a more efficient search without a lot of work. </font></p>
<font FACE="Arial" SIZE="4"><b>

<p>It&#146;s Better in 1.2</p>
</b></font><p>

<font FACE="Arial" SIZE="2">In JDK 1.2, we are making quite a few improvements to the international classes in </font><code>java.text</code><font
FACE="Arial" SIZE="2"> and </font><code>java.util</code><font FACE="Arial" SIZE="2">.
Among them are enhancements to </font><code>CollationElementIterator</code><font
FACE="Arial" SIZE="2"> that make it possible to write faster and more powerful search
routines. These changes are present in JDK 1.2beta3 and later and will be in JDK 1.2 final
when it ships. If you&#146;d like to try them out now, you can download the latest beta
from the Java Developer Connection at </font><a HREF="http://java.sun.com/"><font
FACE="Arial" SIZE="2">java.sun.com</font></a><font FACE="Arial" SIZE="2">.</font></p><font FACE="Arial" SIZE="2">

<p>There are two major problems with the searching mechanism outlined above. First, it
uses an inefficient algorithm that can, at worst, compare every character of the pattern
against every character of the target, requiring a number of comparisons that is
proportional to the size of the text being searched multiplied by the size of the pattern.
(In practice, it&#146;s usually not quite that bad, however.) In computer science terms,
if the size of the text is T and the size of the pattern is P, the search time is
proportional to T·P, or is <i>O</i>(TP). Modern searching algorithms can do much better.</p>

</font><p><font FACE="Arial" SIZE="2">The second, and more obvious problem is that there is an awful lot of object creation
going on in the last few examples. Every time through the outer loop we call </font><code>substring</code><font
FACE="Arial" SIZE="2">, which creates a new </font><code>String</code><font FACE="Arial"
SIZE="2"> object, and then we create a new </font><code>CollationElementIterator</code><font
FACE="Arial" SIZE="2">. This happens at every single position in the target string, which
is woefully inefficient given the cost of object creation in Java (and in most other
languages, for that matter).</font></p><font
FACE="Arial" SIZE="2">

<p>This second problem is solved by two new CollationElementIterator methods that we have
added in JDK 1.2:</p>
</font>

<pre>
    public void setOffset(int newOffset)
    public int  getOffset()
</pre>
<p>

<font FACE="Arial" SIZE="2">These methods allow you to change the text position to which an iterator points and to
retrieve its current position. With this flexibility, we can avoid all of the calls to </font><code>substring</code><font
FACE="Arial" SIZE="2"> and all of the extra iterator objects that we were creating before.
The outer searching loop now looks like this:</font></p>


<pre>    String pat = &quot;for&quot;;                               // What to search for
    String text = &quot;Now is the time for all good men&quot;; // Text to search in

    RuleBasedCollator c = (RuleBasedCollator)Collator.getInstance();
    CollationElementIterator patIter = c.getCollationElementIterator(pat);
    CollationElementIterator targIter = c.getCollationElementIterator(text);

    for (int i = 0; i &lt; text.length(); i++) {
        targIter.setOffset(i);
        patIter.reset();                    // Or setOffset(0)
        if (match(patIter, targIter)) {
            // They matched!  Do something.
        }
    }</pre>
<font FACE="Arial" SIZE="2">

<p>This will be <i>much</i> faster, because we&#146;re no longer creating new objects each
time through the loop. The algorithm is still <i>O</i>(TP), but the overhead per iteration
is considerably lower, so the running time will a lot better.</p>
</font><font FACE="Arial" SIZE="4"><b>

<p>Optimized Searching</p>
</b></font><font FACE="Arial" SIZE="2">

<p>We&#146;ve solved the easier of our two efficiency problems; now it&#146;s time for the
hard one. As I explained above, the brute-force algorithm we&#146;re using is <i>O</i>(TP).
String searching is a well-researched area, and there are algorithms that can do
considerably better. Perhaps the best is the Boyer-Moore method, which is never worse than
<i>O</i>(T+P) and in practice is often proportional to T/P. That&#146;s right: the size of
the text <i>divided by</i> the size of the pattern. Rather than forcing us to examine
characters in the text multiple times, this algorithm actually lets us <i>skip</i>
characters.</p>

<p>Boyer-Moore can be a little bit tricky to explain, but once you &quot;get&quot; it, it
seems almost too obvious. The trick is that instead of comparing the strings starting at
the beginning of the pattern, you compare them starting at the end. If the characters
don&#146;t match, we&#146;ve still gleaned a bit of useful information: we now know what
character occurs at that position in the text being searched. Often, we can take advantage
of that information to skip several characters in the target text rather than simply
sliding the pattern along by one position and trying again.</p>

<p>An example will make this more clear. Imagine that you&#146;re searching for the word
&quot;string&quot; inside the phrase &quot;silly spring string&quot;. To start off, you
line up the beginning of the pattern with the beginning of the target, but you start
comparing at the end, like so:</font>

<dir>
  <dir>
    <pre>silly<b> </b>spring string

strin<b>g</b></pre>
  </dir>
</dir>
<p>

<font FACE="Arial" SIZE="2">We compare the </font><code>g</code><font FACE="Arial" SIZE="2"> in the pattern with a
space character in the target, and there&#146;s no match. So far, there&#146;s nothing
special. However, we know something else as well: the character at index 5 in the target
is a space, and there are no space characters anywhere in the pattern we&#146;re searching
for. Combining these two facts, we can slide the pattern over by six characters and try
again:</font>

<dir>
  <dir>
    <pre>silly<b> </b>s<b>pring</b> string

      s<b>tring</b></pre>
  </dir>
</dir>
<p>

<font FACE="Arial" SIZE="2">This time, there is a match between the pattern and the text. Since we&#146;re going
backwards, we now compare the </font><code>n</code><font FACE="Arial" SIZE="2">, </font><code>i</code><font
FACE="Arial" SIZE="2">, and </font><code>r</code><font FACE="Arial" SIZE="2"> and find
that they match too. However, the </font><code>p</code><font FACE="Arial" SIZE="2"> and
the </font><code>t</code><font FACE="Arial" SIZE="2"> do not. We know that there is not a </font><code>p</code><font
FACE="Arial" SIZE="2"> anywhere in the pattern, so we can slide it over again:</font>

<dir>
  <dir>
    <pre>silly<b> </b>spring <b>s</b>tring

        strin<b>g</b></pre>
  </dir>
</dir>
<p>

<font FACE="Arial" SIZE="2">This time, we see an </font><code>s</code><font FACE="Arial" SIZE="2"> in the text.
It&#146;s not a match, but we do know that there is an </font><code>s</code><font
FACE="Arial" SIZE="2"> at the beginning of the pattern. Therefore, we slide the pattern
over five spaces. Now we have the following, which gives us a match.</font>

<dir>
  <dir>
    <pre>silly<b> </b>spring <b>string</b>

             <b>string</b></pre>
  </dir>
</dir>
<font FACE="Arial" SIZE="2">

<p>To implement this efficiently, you need to have a table that, for each possible
character in the text, tells you how far from the end of the pattern that character first
occurs. This is the distance by which the pattern can be shifted when that particular
character is seen in the input. For the above example, the table would look like this:</p>
</font><div align="center"><center>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" WIDTH="145">
  <tr>
    <td WIDTH="59%" VALIGN="TOP"><font FACE="Arial" SIZE="2">s<br>
    t<br>
    r<br>
    i<br>
    n<br>
    g<br>
    others: </font></td>
    <td WIDTH="41%" VALIGN="TOP"><font FACE="Arial" SIZE="2">5<br>
    4<br>
    3<br>
    2<br>
    1<br>
    0<br>
    6</font></td>
  </tr>
</table>
</center></div><font FACE="Arial" SIZE="2">

<p>This table can be computed once, before the search is started, by making a single pass
through the pattern. After that, it can be used each time we search for that pattern,
leading to a huge performance win. </p>
</font><font FACE="Arial" SIZE="4"><b>

<p>Boyer-Moore vs. Unicode</p>
</b></font><font FACE="Arial" SIZE="2">

<p>But wait! At the very beginning of this article, I said that this kind of algorithm
doesn&#146;t work well with Unicode because it has 65,535 possible character values, which
would make the table too large. Actually, it&#146;s worse, because we&#146;re concerned
with collation elements, which are 32-bit integers, not with the Unicode values
themselves. That&#146;s true, but (of course) there&#146;s another trick...</p>

<p>First, consider what happens when a letter occurs twice in the search pattern. There
are two possible shift distances for that letter, one for each occurrence. To make the
Boyer-Moore algorithm work, we always want to enter the smaller of the two shift distances
in the table. If we used the larger one, we might shift the pattern too far and miss a
match. In a sense, the shift table is not required to be perfectly accurate, and
conservative estimates of shift distances are OK. As long as we don&#146;t shift the
pattern too far, we&#146;re fine.</p>

<p>This realization leads to a simple technique for applying the algorithm to Java
collation elements: simply map all possible elements down to a much smaller set of shift
table indices (say, 256). If two or more elements in your pattern happen to collide and
end up with the same index, it&#146;s not a problem as long as you enter the smaller of
the shift distances in the table.</p>

<p>A simple way to map the collation elements to 256 values is to use the low byte of the
element&#146;s primary component. There are other approaches that will lead to a better
distribution of values throughout the shift table and will thus give slightly better
performance, but in practice this approach is usually good enough.</p>

</font><p><font FACE="Arial" SIZE="2">To implement Boyer-Moore searching with JDK 1.2, we first need to construct a shift
table that tells us how far to shift the pattern when a particular collation element is
seen in the text. The </font><code>hash</code><font FACE="Arial" SIZE="2"> function is
used to map from a 32-bit collation order down to an index in the 256-element array.</font></p>


<pre>
    // Member variables for storing precomputed pattern data
    private int   patLen;
    private int[] patElem;
    private int[] shifts;
    
    // Map a collation element to an array index
    int hash(int order) {
        return CollationElementIterator.primaryOrder(order) % 256;
    }
    
    // Initialize the Boyer-Moore shift tables
    void initialize(RuleBasedCollator c, String pat)
    {
        // First find out how many elements we're dealing with
        patLen = 0;
        CollationElementIterator iter = c.getCollationElementIterator(pat);
        while (iter.next() != CollationElementIterator.NULLORDER)
            patLen++;

        // Allocate space to store the pattern elements and the shift tables
        patElem = new int[patLen];
        shifts = new int[256];

        // Elements not found in the pattern get the maximum shift distance
        for (int i = 0; i &lt; 256; i++) {
            shifts[i] = patLen;
        }

        // Now compute the shift distances for the elements in the pattern.
        // While we're at it, save the elements themselves for quick access.
        // The &quot;-1&quot; is in the calculation because Java indices are 0-based.
        iter.reset();
        for (int i = 0; i &lt; patLen; i++) {
            patElem[i] = iter.next();
            int index = hash(patElem[i]);
            shifts[index] = Math.min(shifts[index], patLen - i - 1);
        }
    }
</pre>
<p>

<font FACE="Arial" SIZE="2">Once we have the tables, the search routine is straightforward. It uses another new JDK
1.2 method: </font><code>CollationElementIterator.previous</code><font FACE="Arial"
SIZE="2">. Also note that there is no longer an outer loop that calls a separate </font><code>match</code><font
FACE="Arial" SIZE="2"> method, since that only worked well when we were marching through
the text one character at a time. Now that we can skip ahead an arbitrary distance through
the text, it is easier to combine all of the logic into one method.</font></p>


<pre>    public int find(String text, String pattern)
    {
        RuleBasedCollator coll = (RuleBasedCollator)Collator.getInstance();
        CollationElementIterator targIter = 
                             coll.getCollationElementIterator(text);
        
	// build the shift table and the constants we need
        initialize(coll, pattern);
        int mask = getMask(weight);
        int done = CollationElementIterator.NULLORDER &amp; mask;

	// Start at the text position corresponding to the end of the pattern
        int textIndex = pattern.length();

        while (textIndex &lt;= text.length()) {
            boolean getPattern = true, getTarget = true;
            int targetElement=0, patternElement=0;

            iter.setOffset(textIndex);
            int patIndex = pattern.length();

            // Iterate backward until we hit the beginning of the pattern
            while (patIndex &gt; 0)
            {
                if (getTarget)  targetElement  = targIter.previous() &amp; mask;
                if (getPattern) patternElement = patElem[--patIndex] &amp; mask;
                getTarget = getPattern = true;

                if (targetElement == 0) {
                    getPattern = false;            // skip targetElement
                } else if (patternElement == 0) {
                    getTarget = false;             // skip patternElement
                } else if (targetElement != patternElement) {
                    // There is a mismatch at this position.  Decide how far
                    // over to shift the pattern, then try again.
                    textIndex = iter.getOffset() +
                                shifts[hash(targetElement)];
                    break;
                }
            }
            if (patIndex == 0) {
                // We made it back to the beginning of the pattern,
                // which means we matched it all.  Return the location.
                return targIter.getOffset();
            }
            // Otherwise, we're here because of a mismatch, so keep going....
        }
        return -1;            // No match.
    }</pre>
<font FACE="Arial" SIZE="2">

<p>There you have it: a way to do fast, linear-time, international-friendly string
searching in Java.</p>
</font><font FACE="Arial" SIZE="4"><b>

<p>The Real Stuff</p>
</b></font><font FACE="Arial" SIZE="2">

<p>I hope this article has given you a good idea of how you can use collators to add
language-sensitive sorting and searching to your own Java applications. It is not that
hard, and the benefits can be enormous, because global markets are becoming increasingly
more important to the computer industry. For example, according to IBM&#146;s first
quarter 1998 financial statement over half of IBM&#146;s revenue came from outside North
America. Using the international features of the JDK can help you begin to tap into this
huge market.</p>

</font><p><font FACE="Arial" SIZE="2">The code examples in this article were intended primarily for their educational value,
but they do work. However, for clarity I have ignored a few remaining issues to make the
code easier to understand. Expanding (&quot;ä&quot; to &quot;ae&quot;) characters in the
pattern are the chief difficulty. If the shorter, non-expanded version of the character
occurs in the text being searched, you can end up shifting too far and missing a possible
match. However, it is not too hard to compensate for this by using the </font><code>getMaxExpansion</code><font
FACE="Arial" SIZE="2"> method (also new in JDK 1.2) of </font><code>CollationElementIterator</code><font
FACE="Arial" SIZE="2"> to decrease the shift distances when expanded characters are seen
in the pattern.</font></p><p>

<font
FACE="Arial" SIZE="2">The other major feature I have left out is the ability to tell how much of the text
matched the pattern. All of the code examples search for location in the text where a
match starts, but they do not return the length of the text that matched. You would need
to know this if you were writing a search and replace function in an editor, for example.
In JDK 1.2, it is easy to tell where the match ends: just call the iterator&#146;s </font><code>getOffset</code><font
FACE="Arial" SIZE="2"> method. With the JDK 1.1 API, it is harder; you basically have to
resort to the brute-force technique of comparing longer and longer substrings of the text
to the pattern and stopping when the collator says that they are equal.</font></p><p>

<font
FACE="Arial" SIZE="2">If you want to see real, production-quality code that uses the same algorithms and
solves these last few problems, visit </font><a HREF="http://www.alphaworks.ibm.com/"><font
FACE="Arial" SIZE="2">www.alphaworks.ibm.com</font></a><font FACE="Arial" SIZE="2"> and
download our fully-functional text searching class based on the JDK collation API. It
supports case- and accent-insensitive searches, backward searches, and &quot;whole
word&quot; searching, among other features. AlphaWorks also contains several other Java
internationalization utilities that you might find useful, as well as a large number of
JavaBeans, utility classes, and even a free XML parser written in Java.</font></p>
<font FACE="Arial" SIZE="4"><b>

<p>Acknowledgements</p>
</b></font><font FACE="Arial" SIZE="2">

<p>The patented technique for applying the Boyer-Moore search algorithm to collation
elements was developed by Dr. Mark Davis of IBM. Kathleen Wilson, the manager of the text
and international groups at IBM&#146;s Center for Java Technology in Silicon Valley, was
very indulgent of the time I spent working on this article and the accompanying code. I
would also like to thank Mark, Kathleen, Michael Pogue, John Raley, and Helena Shih Chapman for
reviewing drafts of this article. </p>
</font><font FACE="Arial" SIZE="4"><b>

<p>References</p>
</b></font><font FACE="Arial" SIZE="2"><p>

<i>Algorithms in C, 3rd edition</i>, by Robert Sedgewick (Addison-Wesley, 1997) has a good
overview of the Boyer-Moore search algorithm as applied to small character sets. He also
covers a number of other search algorithms.</p>
<p>

<i>The Java Class Libraries, 2nd Edition</i>, vol. 1, by Chan, Lee, and Kramer
(Addison-Wesley, 1998) has a nice description of CollationElementIterator.</p>
</font><p><font FACE="Arial" SIZE="2">

<i>Making your Java/C++/C Applications Global</i>, at </font><a
HREF="http://www-105.ibm.com/developerworks/education.nsf/dw/java-onlinecourse-bytitle"><font
FACE="Arial" SIZE="2">www.ibm.com/java/education/international-unicode/unicode1.html</font></a><font
FACE="Arial" SIZE="2"> is a good overview of some of the issues involved in writing global
applications.</font></p><font
FACE="Arial" SIZE="2">
<p>

<i>The Unicode Standard, Version 2.0</i>, (Addison-Wesley, 1996) has lots of useful
information on processing international text. In particular, section 5.15 covers sorting
and searching.</p>

</font><p><font
FACE="Arial" SIZE="2">The Unicode Consortium web site at </font><a HREF="http://www.unicode.org/"><font
FACE="Arial" SIZE="2">www.unicode.org</font></a><font FACE="Arial" SIZE="2"> has lots of
good information. If you want an even more detailed explanation of Unicode collation, see </font><a
HREF="http://www.unicode.org/unicode/reports/tr10/"><font FACE="Arial" SIZE="2">www.unicode.org/unicode/reports/tr10/</font></a><font
FACE="Arial" SIZE="2">.</font></p>
<font FACE="Arial" SIZE="4"><b> </b></font>
<hr>
<font FACE="Arial" SIZE="4"><b>
<p><a NAME="about_author">About the Author</a></p>
</b></font> 
<p> <font FACE="Arial" SIZE="2">Laura Werner is a Senior Software Engineer and 
  Project Leader for the Java Internationalization effort at the IBM Center for 
  Java Technology in Cupertino, CA. After receiving Bachelor&#146;s degrees in 
  Geological Sciences and Integrated Science (an honors, interdisciplinary program) 
  from Northwestern University, she worked at SPSS, Inc. and UC Berkeley before 
  joining Taligent in 1994. There, she helped port Taligent&#146;s C++ frameworks 
  to Windows NT, wrote the OpenClass file system framework, and participated in 
  the initial design of the Java international frameworks. Now at IBM, she is 
  responsible for maintaining and enhancing the JDK collation classes, leading 
  other Java international projects, and working on occasional side projects such 
  as this paper. </font></p>
</body>
</html>
