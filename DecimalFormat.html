<html><head><TITLE>DecimalFormat</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  U_I18N_API DecimalFormat : public <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A> </H2><BLOCKQUOTE>

Concrete class for formatting decimal numbers, allowing a variety
of parameters, and localization to Western, Arabic, or Indic numbers
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=95>
<param name=classes value="CFormat,MFormat.html,CNumberFormat,MNumberFormat.html,CDecimalFormat,MDecimalFormat.html">
<param name=before value="M,M,M">
<param name=after value="Md_SP,Md_,M">
<param name=indent value="0,1,2">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Fields</h3><DD><DT><A HREF="#DOC.10.59"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>  <B>fgNumberPatterns</B> </B>
 <DD><I>
The resource tags we use to retrieve decimal format data from
locale resource bundles</I>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.10.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DecimalFormat</B>(<!2><A HREF="#DOC.301">UErrorCode</A>& status) </B>
 <DD><I>
Create a DecimalFormat using the default pattern and symbols
for the default locale</I>
<DT><A HREF="#DOC.10.2"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DecimalFormat</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.301">UErrorCode</A>& status) </B>
 <DD><I>
Create a DecimalFormat from the given pattern and the symbols
for the default locale</I>
<DT><A HREF="#DOC.10.3"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DecimalFormat</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!1><A HREF="DecimalFormatSymbols.html">DecimalFormatSymbols</A>* symbolsToAdopt, <!2><A HREF="#DOC.301">UErrorCode</A>& status) </B>
 <DD><I>
Create a DecimalFormat from the given pattern and symbols</I>
<DT><A HREF="#DOC.10.4"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DecimalFormat</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, const <!1><A HREF="DecimalFormatSymbols.html">DecimalFormatSymbols</A>& symbols, <!2><A HREF="#DOC.301">UErrorCode</A>& status) </B>
 <DD><I>
Create a DecimalFormat from the given pattern and symbols</I>
<DT><A HREF="#DOC.10.56"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DecimalFormat</B>(const <!2><A HREF="DecimalFormat.html#DOC.10.1">DecimalFormat</A>& source) </B>
 <DD><I>
Copy constructor</I>
<DT><A HREF="#DOC.10.57"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DecimalFormat.html#DOC.10.1">DecimalFormat</A>&  <B>operator=</B>(const <!2><A HREF="DecimalFormat.html#DOC.10.1">DecimalFormat</A>& rhs) </B>
 <DD><I>
Assignment operator</I>
<DT><A HREF="#DOC.10.58"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <B>~DecimalFormat</B>() </B>
 <DD><I>
Destructor</I>
<DT><A HREF="#DOC.10.5"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!2><A HREF="Format.html#DOC.14.8">Format</A>*  <B>clone</B>(void) const  </B>
 <DD><I>
Clone this Format object polymorphically</I>
<DT><A HREF="#DOC.10.6"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>operator==</B>(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const  </B>
 <DD><I>
Return true if the given Format objects are semantically equal</I>
<DT><A HREF="#DOC.10.7"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>(double number, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos) const  </B>
 <DD><I>
Format a double or long number using base-10 representation</I>
<DT><A HREF="#DOC.10.8"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>parse</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parsePosition) const  </B>
 <DD><I>
Parse the given string using this object's choices</I>
<DT><A HREF="#DOC.10.9"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  const  <!1><A HREF="DecimalFormatSymbols.html">DecimalFormatSymbols</A>*  <B>getDecimalFormatSymbols</B>(void) const  </B>
 <DD><I>
Returns the decimal format symbols, which is generally not changed
by the programmer or user</I>
<DT><A HREF="#DOC.10.10"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>adoptDecimalFormatSymbols</B>(<!1><A HREF="DecimalFormatSymbols.html">DecimalFormatSymbols</A>* symbolsToAdopt) </B>
 <DD><I>
Sets the decimal format symbols, which is generally not changed
by the programmer or user</I>
<DT><A HREF="#DOC.10.11"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setDecimalFormatSymbols</B>(const <!1><A HREF="DecimalFormatSymbols.html">DecimalFormatSymbols</A>& symbols) </B>
 <DD><I>
Sets the decimal format symbols, which is generally not changed
by the programmer or user</I>
<DT><A HREF="#DOC.10.12"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getPositivePrefix</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Get the positive prefix</I>
<DT><A HREF="#DOC.10.13"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setPositivePrefix</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& newValue) </B>
 <DD><I>
Set the positive prefix</I>
<DT><A HREF="#DOC.10.14"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getNegativePrefix</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Get the negative prefix</I>
<DT><A HREF="#DOC.10.15"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setNegativePrefix</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& newValue) </B>
 <DD><I>
Set the negative prefix</I>
<DT><A HREF="#DOC.10.16"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getPositiveSuffix</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Get the positive suffix</I>
<DT><A HREF="#DOC.10.17"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setPositiveSuffix</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& newValue) </B>
 <DD><I>
Set the positive suffix</I>
<DT><A HREF="#DOC.10.18"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getNegativeSuffix</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Get the negative suffix</I>
<DT><A HREF="#DOC.10.19"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setNegativeSuffix</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& newValue) </B>
 <DD><I>
Set the positive suffix</I>
<DT><A HREF="#DOC.10.20"> <IMG BORDER=0 SRC=icon1.gif></A> int32_t  <B>getMultiplier</B>(void) const  </B>
 <DD><I>
Get the multiplier for use in percent, permill, etc</I>
<DT><A HREF="#DOC.10.21"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setMultiplier</B>(int32_t newValue) </B>
 <DD><I>
Set the multiplier for use in percent, permill, etc</I>
<DT><A HREF="#DOC.10.22"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  double  <B>getRoundingIncrement</B>(void) </B>
 <DD><I>
Get the rounding increment</I>
<DT><A HREF="#DOC.10.23"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setRoundingIncrement</B>(double newValue) </B>
 <DD><I>
Set the rounding increment</I>
<DT><A HREF="#DOC.10.24"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  ERoundingMode  <B>getRoundingMode</B>(void) </B>
 <DD><I>
Get the rounding mode</I>
<DT><A HREF="#DOC.10.25"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setRoundingMode</B>(ERoundingMode roundingMode) </B>
 <DD><I>
Set the rounding mode</I>
<DT><A HREF="#DOC.10.26"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  int32_t  <B>getFormatWidth</B>(void) </B>
 <DD><I>
Get the width to which the output of <code>format()</code> is padded</I>
<DT><A HREF="#DOC.10.27"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setFormatWidth</B>(int32_t width) </B>
 <DD><I>
Set the width to which the output of <code>format()</code> is padded</I>
<DT><A HREF="#DOC.10.28"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  UChar  <B>getPadCharacter</B>(void) </B>
 <DD><I>
Get the character used to pad to the format width</I>
<DT><A HREF="#DOC.10.29"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setPadCharacter</B>(UChar padChar) </B>
 <DD><I>
Set the character used to pad to the format width</I>
<DT><A HREF="#DOC.10.30"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  EPadPosition  <B>getPadPosition</B>(void) </B>
 <DD><I>
Get the position at which padding will take place</I>
<DT><A HREF="#DOC.10.31"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setPadPosition</B>(EPadPosition padPos) </B>
 <DD><I>
<strong><font face=helvetica color=red>NEW</font></strong>
Set the position at which padding will take place</I>
<DT><A HREF="#DOC.10.32"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>isScientificNotation</B>(void) </B>
 <DD><I>
Return whether or not scientific notation is used</I>
<DT><A HREF="#DOC.10.33"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setScientificNotation</B>(bool_t useScientific) </B>
 <DD><I>
Set whether or not scientific notation is used</I>
<DT><A HREF="#DOC.10.34"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  int8_t  <B>getMinimumExponentDigits</B>(void) </B>
 <DD><I>
Return the minimum exponent digits that will be shown</I>
<DT><A HREF="#DOC.10.35"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setMinimumExponentDigits</B>(int8_t minExpDig) </B>
 <DD><I>
Set the minimum exponent digits that will be shown</I>
<DT><A HREF="#DOC.10.36"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>isExponentSignAlwaysShown</B>(void) </B>
 <DD><I>
Return whether the exponent sign is always shown</I>
<DT><A HREF="#DOC.10.37"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setExponentSignAlwaysShown</B>(bool_t expSignAlways) </B>
 <DD><I>
Set whether the exponent sign is always shown</I>
<DT><A HREF="#DOC.10.38"> <IMG BORDER=0 SRC=icon1.gif></A> int32_t  <B>getGroupingSize</B>(void) const  </B>
 <DD><I>
Return the grouping size</I>
<DT><A HREF="#DOC.10.39"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setGroupingSize</B>(int32_t newValue) </B>
 <DD><I>
Set the grouping size</I>
<DT><A HREF="#DOC.10.40"> <IMG BORDER=0 SRC=icon1.gif></A> bool_t  <B>isDecimalSeparatorAlwaysShown</B>(void) const  </B>
 <DD><I>
Allows you to get the behavior of the decimal separator with integers</I>
<DT><A HREF="#DOC.10.41"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setDecimalSeparatorAlwaysShown</B>(bool_t newValue) </B>
 <DD><I>
Allows you to set the behavior of the decimal separator with integers</I>
<DT><A HREF="#DOC.10.42"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>toPattern</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Synthesizes a pattern string that represents the current state
of this Format object</I>
<DT><A HREF="#DOC.10.43"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>toLocalizedPattern</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Synthesizes a localized pattern string that represents the current
state of this Format object</I>
<DT><A HREF="#DOC.10.44"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>applyPattern</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.301">UErrorCode</A>& status) </B>
 <DD><I>
Apply the given pattern to this Format object</I>
<DT><A HREF="#DOC.10.45"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>applyLocalizedPattern</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.301">UErrorCode</A>& status) </B>
 <DD><I>
Apply the given pattern to this Format object</I>
<DT><A HREF="#DOC.10.46"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setMaximumIntegerDigits</B>(int32_t newValue) </B>
 <DD><I>
Sets the maximum number of digits allowed in the integer portion of a
number</I>
<DT><A HREF="#DOC.10.47"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setMinimumIntegerDigits</B>(int32_t newValue) </B>
 <DD><I>
Sets the minimum number of digits allowed in the integer portion of a
number</I>
<DT><A HREF="#DOC.10.48"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setMaximumFractionDigits</B>(int32_t newValue) </B>
 <DD><I>
Sets the maximum number of digits allowed in the fraction portion of a
number</I>
<DT><A HREF="#DOC.10.49"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setMinimumFractionDigits</B>(int32_t newValue) </B>
 <DD><I>
Sets the minimum number of digits allowed in the fraction portion of a
number</I>
<DT><A HREF="#DOC.10.50"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!1><A HREF="ClassID.html">ClassID</A>  <B>getStaticClassID</B>(void) </B>
 <DD><I>
Return the class ID for this class</I>
<DT><A HREF="#DOC.10.51"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="ClassID.html">ClassID</A>  <B>getDynamicClassID</B>(void) const  </B>
 <DD><I>
Returns a unique class ID POLYMORPHICALLY</I>
</DL></DL>
<hr><H3>Inherited from <A HREF="NumberFormat.html">NumberFormat:</A></h3>

<DL>
<DL>
<DT><h3>Public Classes</h3><DD><DT><IMG SRC=icon2.gif>  enum  <B>EAlignmentFields</B>

<DL>
<DT><A HREF="#DOC.19.1.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>INTEGER_FIELD</B> </B>
 <DD><I>
These constants are provided for backwards compatibility only,
and are deprecated</I>

</DL>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><IMG SRC=icon2.gif> virtual  void  <B>parseObject</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parse_pos) const 
<DT><IMG SRC=icon2.gif> bool_t  <B>isParseIntegerOnly</B>(void) const 
<DT><IMG SRC=icon2.gif> virtual  void  <B>setParseIntegerOnly</B>(bool_t value)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createInstance</B>(<!2><A HREF="#DOC.301">UErrorCode</A>&)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createInstance</B>(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createCurrencyInstance</B>(<!2><A HREF="#DOC.301">UErrorCode</A>&)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createCurrencyInstance</B>(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createPercentInstance</B>(<!2><A HREF="#DOC.301">UErrorCode</A>&)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createPercentInstance</B>(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createScientificInstance</B>(<!2><A HREF="#DOC.301">UErrorCode</A>&)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createScientificInstance</B>(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&)
<DT><IMG SRC=icon2.gif> static  const  Locale*  <B>getAvailableLocales</B>(int32_t& count)
<DT><IMG SRC=icon2.gif> bool_t  <B>isGroupingUsed</B>(void) const 
<DT><IMG SRC=icon2.gif> virtual  void  <B>setGroupingUsed</B>(bool_t newValue)
<DT><IMG SRC=icon2.gif> int32_t  <B>getMaximumIntegerDigits</B>(void) const 
<DT><IMG SRC=icon2.gif> int32_t  <B>getMinimumIntegerDigits</B>(void) const 
<DT><IMG SRC=icon2.gif> int32_t  <B>getMaximumFractionDigits</B>(void) const 
<DT><IMG SRC=icon2.gif> int32_t  <B>getMinimumFractionDigits</B>(void) const 
</DL></DL>
<hr><H3>Inherited from <A HREF = "Format.html"> Format:</A></h3>

<DL>
<DL>
<DT><h3>Public Methods</h3><DD><DT><IMG SRC=icon2.gif> bool_t  <B>operator!=</B>(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const 
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

Concrete class for formatting decimal numbers, allowing a variety
of parameters, and localization to Western, Arabic, or Indic numbers.
<P>
Normally, you get the proper NumberFormat for a specific locale
(including the default locale) using the NumberFormat factory methods,
rather than constructing a DecimalNumberFormat directly.
<P>
Either the prefixes or the suffixes must be different for the parse
to distinguish positive from negative.  Parsing will be unreliable
if the digits, thousands or decimal separators are the same, or if
any of them occur in the prefixes or suffixes.
<P>
[Special cases:] 
<P>
NaN is formatted as a single character, typically \\uFFFD.
<P>
+/-Infinity is formatted as a single character, typically \\u221E,
plus the positive and negative pre/suffixes.
<P>
Note: this class is designed for common users; for very large or small
numbers, use a format that can express exponential values.
<P>
[Example:] 
<pre>
.    // normally we would have a GUI with a menu for this
.    int32_t locCount;
.    const Locale* locales = NumberFormat::getAvailableLocales(locCount);
.    if (locCount > 12) locCount = 12;  //limit output
.
.    double myNumber = -1234.56;
.    UErrorCode success = ZERO_ERROR;
.    NumberFormat* form; //= NumberFormat::createInstance(success);
.
.    // just for fun, we print out a number with the locale number, currency
.    // and percent format for each locale we can.
.    UnicodeString countryName;
.    UnicodeString displayName;
.    UnicodeString str;
.    UnicodeString pattern;
.    Formattable fmtable;
.    for (int32_t j = 0; j < 3; ++j) {
.        cout << endl << "FORMAT " << j << endl;
.        for (int32_t i = 0; i < locCount; ++i) {
.            if (locales[i].getCountry(countryName).size() == 0) {
.                // skip language-only
.                continue;
.            }
.            switch (j) {
.            default:
.                form = NumberFormat::createInstance(locales[i], success ); break;
.            case 1:
.                form = NumberFormat::createCurrencyInstance(locales[i], success ); break;
.            case 0:
.                form = NumberFormat::createPercentInstance(locales[i], success ); break;
.            }
.            if (form) {
.                str.remove();
.                pattern = ((DecimalFormat*)form)->toPattern(pattern);
.                cout << locales[i].getDisplayName(displayName) << ": " << pattern;
.                cout << "  ->  " << form->format(myNumber,str) << endl;
.                form->parse(form->format(myNumber,str), fmtable, success);
.                //cout << "   parsed: " << fmtable << endl;
.                delete form;  
.            }
.        }
.    }
</pre>
[The following shows the structure of the pattern.] 
<pre>
.    pattern    := subpattern{;subpattern}
.    subpattern := {prefix}integer{.fraction}{suffix}
.    
.    prefix     := '\\u0000'..'\\uFFFD' - specialCharacters
.    suffix     := '\\u0000'..'\\uFFFD' - specialCharacters
.    integer    := '#'* '0'* '0'
.    fraction   := '0'* '#'*

Notation:
.    X*       0 or more instances of X
.    (X | Y)  either X or Y.
.    X..Y     any character from X up to Y, inclusive.
.    S - T    characters in S, except those in T
</pre>
The first subpattern is for positive numbers. The second (optional)
subpattern is used for negative numbers. (In both cases, ',' can
occur inside the integer portion--it is just too messy to indicate
in BNF.)  For the second subpattern, only the PREFIX and SUFFIX are
noted; other attributes are taken only from the first subpattern.
<P>
Here are the special characters used in the parts of the
subpattern, with notes on their usage.
<pre>
.    Symbol   Meaning
.      0      a digit, showing up a zero if it is zero
.      #      a digit, supressed if zero
.      .      placeholder for decimal separator
.      ,      placeholder for grouping separator.
.      E      separates mantissa and exponent for exponential formats.
.      ;      separates formats.
.      -      default negative prefix.
.      %      multiply by 100 and show as percentage
.      \u2030 multiply by 1000 and show as per mille
.      \u00A4 currency sign; replaced by currency symbol; if
.             doubled, replaced by international currency symbol.
.             If present in a pattern, the monetary decimal separator
.             is used instead of the decimal separator.
.      X      any other characters can be used in the prefix or suffix
.      '      used to quote special characters in a prefix or suffix.
</pre>
[Notes] 
<P>
If there is no explicit negative subpattern, - is prefixed to the
positive form. That is, "0.00" alone is equivalent to "0.00;-0.00".
<P>
Illegal formats, such as "#.#.#" in the same format, will cause a
failing UErrorCode to be returned. 
<P>
The grouping separator is commonly used for thousands, but in some
countries for ten-thousands. The interval is a constant number of
digits between the grouping characters, such as 100,000,000 or 1,0000,0000.
If you supply a pattern with multiple grouping characters, the interval
between the last one and the end of the integer is the one that is
used. So "#,##,###,####" == "######,####" == "##,####,####".
<P>
This class only handles localized digits where the 10 digits are
contiguous in Unicode, from 0 to 9. Other digits sets (such as
superscripts) would need a different subclass.

</BLOCKQUOTE>
<DL>

<A NAME="DecimalFormat">
<A NAME ="DOC.10.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DecimalFormat(<!2><A HREF="#DOC.301">UErrorCode</A>& status)</B></TT>
<DD>
Create a DecimalFormat using the default pattern and symbols
for the default locale. This is a convenient way to obtain a
DecimalFormat when internationalization is not the main concern.
<P>
To obtain standard formats for a given locale, use the factory methods
on NumberFormat such as getNumberInstance. These factories will
return the most appropriate sub-class of NumberFormat for a given
locale.

<DL><DT><B>Parameters:</B><DD><B>status</B> -     Output param set to success/failure code. If the
pattern is invalid this will be set to a failure code.<br></DL><P>
<A NAME="DecimalFormat">
<A NAME ="DOC.10.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DecimalFormat(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.301">UErrorCode</A>& status)</B></TT>
<DD>
Create a DecimalFormat from the given pattern and the symbols
for the default locale. This is a convenient way to obtain a
DecimalFormat when internationalization is not the main concern.
<P>
To obtain standard formats for a given locale, use the factory methods
on NumberFormat such as getNumberInstance. These factories will
return the most appropriate sub-class of NumberFormat for a given
locale.

<DL><DT><B>Parameters:</B><DD><B>pattern</B> -    A non-localized pattern string.
<br><B>status</B> -     Output param set to success/failure code. If the
pattern is invalid this will be set to a failure code.<br></DL><P>
<A NAME="DecimalFormat">
<A NAME ="DOC.10.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DecimalFormat( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!1><A HREF="DecimalFormatSymbols.html">DecimalFormatSymbols</A>* symbolsToAdopt, <!2><A HREF="#DOC.301">UErrorCode</A>& status)</B></TT>
<DD>
Create a DecimalFormat from the given pattern and symbols.
Use this constructor when you need to completely customize the
behavior of the format.
<P>
To obtain standard formats for a given
locale, use the factory methods on NumberFormat such as
getInstance or getCurrencyInstance. If you need only minor adjustments
to a standard format, you can modify the format returned by
a NumberFormat factory method.


<DL><DT><B>Parameters:</B><DD><B>pattern</B> -            a non-localized pattern string
<br><B>symbolsToAdopt</B> -     the set of symbols to be used.  The caller should not
delete this object after making this call.
<br><B>status</B> -             Output param set to success/failure code. If the
pattern is invalid this will be set to a failure code.<br></DL><P>
<A NAME="DecimalFormat">
<A NAME ="DOC.10.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DecimalFormat( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, const <!1><A HREF="DecimalFormatSymbols.html">DecimalFormatSymbols</A>& symbols, <!2><A HREF="#DOC.301">UErrorCode</A>& status)</B></TT>
<DD>
Create a DecimalFormat from the given pattern and symbols.
Use this constructor when you need to completely customize the
behavior of the format.
<P>
To obtain standard formats for a given
locale, use the factory methods on NumberFormat such as
getInstance or getCurrencyInstance. If you need only minor adjustments
to a standard format, you can modify the format returned by
a NumberFormat factory method.


<DL><DT><B>Parameters:</B><DD><B>pattern</B> -            a non-localized pattern string
<br><B>symbols</B> -    the set of symbols to be used
<br><B>status</B> -             Output param set to success/failure code. If the
pattern is invalid this will be set to a failure code.<br></DL><P>
<A NAME="DecimalFormat">
<A NAME ="DOC.10.56">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DecimalFormat(const <!2><A HREF="DecimalFormat.html#DOC.10.1">DecimalFormat</A>& source)</B></TT>
<DD>
Copy constructor
<DL></DL><P>
<A NAME="operator=">
<A NAME ="DOC.10.57">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DecimalFormat.html#DOC.10.1">DecimalFormat</A>&  operator=(const <!2><A HREF="DecimalFormat.html#DOC.10.1">DecimalFormat</A>& rhs)</B></TT>
<DD>
Assignment operator
<DL></DL><P>
<A NAME="~DecimalFormat">
<A NAME ="DOC.10.58">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  ~DecimalFormat()</B></TT>
<DD>
Destructor
<DL></DL><P>
<A NAME="clone">
<A NAME ="DOC.10.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!2><A HREF="Format.html#DOC.14.8">Format</A>*  clone(void) const </B></TT>
<DD>
Clone this Format object polymorphically. The caller owns the
result and should delete it when done.
<DL></DL><P>
<A NAME="operator==">
<A NAME ="DOC.10.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  operator==(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const </B></TT>
<DD>
Return true if the given Format objects are semantically equal.
Objects of different subclasses are considered unequal.
<DL></DL><P>
<A NAME="format">
<A NAME ="DOC.10.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format(double number, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos) const </B></TT>
<DD>
Format a double or long number using base-10 representation.


<DL><DT><B>Returns:</B><DD>A reference to 'toAppendTo'.
<DT><B>Parameters:</B><DD><B>number</B> -      The value to be formatted.
<br><B>toAppendTo</B> -  The string to append the formatted string to.
This is an output parameter.
<br><B>pos</B> -         On input: an alignment field, if desired.
On output: the offsets of the alignment field.
<br></DL><P>
<A NAME="parse">
<A NAME ="DOC.10.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  parse(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parsePosition) const </B></TT>
<DD>
Parse the given string using this object's choices. The method
does string comparisons to try to find an optimal match.
If no object can be parsed, index is unchanged, and NULL is
returned.


<DL><DT><B>Parameters:</B><DD><B>text</B> -            The text to be parsed.
<br><B>result</B> -          Formattable to be set to the parse result.
If parse fails, return contents are undefined.
<br><B>parsePosition</B> -   The position to start parsing at on input.
On output, moved to after the last successfully
parse character. On parse failure, does not change.<br></DL><P>
<A NAME="getDecimalFormatSymbols">
<A NAME ="DOC.10.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  const  <!1><A HREF="DecimalFormatSymbols.html">DecimalFormatSymbols</A>*  getDecimalFormatSymbols(void) const </B></TT>
<DD>
Returns the decimal format symbols, which is generally not changed
by the programmer or user
<DL><DT><B>Returns:</B><DD>desired DecimalFormatSymbols

<DT><B>See Also:</B><DD><!1><A HREF="DecimalFormatSymbols.html">DecimalFormatSymbols</A><br></DL><P>
<A NAME="adoptDecimalFormatSymbols">
<A NAME ="DOC.10.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  adoptDecimalFormatSymbols(<!1><A HREF="DecimalFormatSymbols.html">DecimalFormatSymbols</A>* symbolsToAdopt)</B></TT>
<DD>
Sets the decimal format symbols, which is generally not changed
by the programmer or user
<DL><DT><B>Parameters:</B><DD><B>symbolsToAdopt</B> -  DecimalFormatSymbols to be adopted.<br></DL><P>
<A NAME="setDecimalFormatSymbols">
<A NAME ="DOC.10.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setDecimalFormatSymbols(const <!1><A HREF="DecimalFormatSymbols.html">DecimalFormatSymbols</A>& symbols)</B></TT>
<DD>
Sets the decimal format symbols, which is generally not changed
by the programmer or user
<DL><DT><B>Parameters:</B><DD><B>symbols</B> -  DecimalFormatSymbols.<br></DL><P>
<A NAME="getPositivePrefix">
<A NAME ="DOC.10.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getPositivePrefix(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Get the positive prefix.

Examples: +123, $123, sFr123
<DL></DL><P>
<A NAME="setPositivePrefix">
<A NAME ="DOC.10.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setPositivePrefix(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& newValue)</B></TT>
<DD>
Set the positive prefix.

Examples: +123, $123, sFr123
<DL></DL><P>
<A NAME="getNegativePrefix">
<A NAME ="DOC.10.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getNegativePrefix(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Get the negative prefix.

Examples: -123, ($123) (with negative suffix), sFr-123
<DL></DL><P>
<A NAME="setNegativePrefix">
<A NAME ="DOC.10.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setNegativePrefix(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& newValue)</B></TT>
<DD>
Set the negative prefix.

Examples: -123, ($123) (with negative suffix), sFr-123
<DL></DL><P>
<A NAME="getPositiveSuffix">
<A NAME ="DOC.10.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getPositiveSuffix(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Get the positive suffix.

Example: 123%
<DL></DL><P>
<A NAME="setPositiveSuffix">
<A NAME ="DOC.10.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setPositiveSuffix(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& newValue)</B></TT>
<DD>
Set the positive suffix.

Example: 123%
<DL></DL><P>
<A NAME="getNegativeSuffix">
<A NAME ="DOC.10.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getNegativeSuffix(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Get the negative suffix.

Examples: -123%, ($123) (with positive suffixes)
<DL></DL><P>
<A NAME="setNegativeSuffix">
<A NAME ="DOC.10.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setNegativeSuffix(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& newValue)</B></TT>
<DD>
Set the positive suffix.

Examples: 123%
<DL></DL><P>
<A NAME="getMultiplier">
<A NAME ="DOC.10.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int32_t  getMultiplier(void) const </B></TT>
<DD>
Get the multiplier for use in percent, permill, etc.
For a percentage, set the suffixes to have "%" and the multiplier to be 100.
(For Arabic, use arabic percent symbol).
For a permill, set the suffixes to have "\u2031" and the multiplier to be 1000.

Examples: with 100, 1.23 -> "123", and "123" -> 1.23
<DL></DL><P>
<A NAME="setMultiplier">
<A NAME ="DOC.10.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setMultiplier(int32_t newValue)</B></TT>
<DD>
Set the multiplier for use in percent, permill, etc.
For a percentage, set the suffixes to have "%" and the multiplier to be 100.
(For Arabic, use arabic percent symbol).
For a permill, set the suffixes to have "\u2031" and the multiplier to be 1000.

Examples: with 100, 1.23 -> "123", and "123" -> 1.23
<DL></DL><P>
<A NAME="getRoundingIncrement">
<A NAME ="DOC.10.22">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  double  getRoundingIncrement(void)</B></TT>
<DD>
Get the rounding increment
<DL><DT><B>Returns:</B><DD>A positive rounding increment, or 0.0 if rounding
is not in effect.

<DT><B>See Also:</B><DD><A HREF="#setRoundingIncrement">setRoundingIncrement</A>
<br><A HREF="#getRoundingMode">getRoundingMode</A>
<br><A HREF="#setRoundingMode">setRoundingMode</A><br></DL><P>
<A NAME="setRoundingIncrement">
<A NAME ="DOC.10.23">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setRoundingIncrement(double newValue)</B></TT>
<DD>
Set the rounding increment.  This method also controls whether
rounding is enabled.

<DL><DT><B>Parameters:</B><DD><B>newValue</B> -  A positive rounding increment, or 0.0 to disable rounding.
Negative increments are equivalent to 0.0.
<br><DT><B>See Also:</B><DD><A HREF="#getRoundingIncrement">getRoundingIncrement</A>
<br><A HREF="#getRoundingMode">getRoundingMode</A>
<br><A HREF="#setRoundingMode">setRoundingMode</A><br></DL><P>
<A NAME="getRoundingMode">
<A NAME ="DOC.10.24">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  ERoundingMode  getRoundingMode(void)</B></TT>
<DD>
Get the rounding mode
<DL><DT><B>Returns:</B><DD>A rounding mode

<DT><B>See Also:</B><DD><A HREF="#setRoundingIncrement">setRoundingIncrement</A>
<br><A HREF="#getRoundingIncrement">getRoundingIncrement</A>
<br><A HREF="#setRoundingMode">setRoundingMode</A><br></DL><P>
<A NAME="setRoundingMode">
<A NAME ="DOC.10.25">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setRoundingMode(ERoundingMode roundingMode)</B></TT>
<DD>
Set the rounding mode.  This has no effect unless the rounding
increment is greater than zero.

<DL><DT><B>Parameters:</B><DD><B>roundingMode</B> -  A rounding mode
<br><DT><B>See Also:</B><DD><A HREF="#setRoundingIncrement">setRoundingIncrement</A>
<br><A HREF="#getRoundingIncrement">getRoundingIncrement</A>
<br><A HREF="#getRoundingMode">getRoundingMode</A><br></DL><P>
<A NAME="getFormatWidth">
<A NAME ="DOC.10.26">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  int32_t  getFormatWidth(void)</B></TT>
<DD>
Get the width to which the output of <code>format()</code> is padded
<DL><DT><B>Returns:</B><DD>the format width, or zero if no padding is in effect

<DT><B>See Also:</B><DD><A HREF="#setFormatWidth">setFormatWidth</A>
<br><A HREF="#getPadCharacter">getPadCharacter</A>
<br><A HREF="#setPadCharacter">setPadCharacter</A>
<br><A HREF="#getPadPosition">getPadPosition</A>
<br><A HREF="#setPadPosition">setPadPosition</A><br></DL><P>
<A NAME="setFormatWidth">
<A NAME ="DOC.10.27">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setFormatWidth(int32_t width)</B></TT>
<DD>
Set the width to which the output of <code>format()</code> is padded.
This method also controls whether padding is enabled.

<DL><DT><B>Parameters:</B><DD><B>width</B> -  the width to which to pad the result of
<code>format()</code>, or zero to disable padding.  A negative
width is equivalent to 0.
<br><DT><B>See Also:</B><DD><A HREF="#getFormatWidth">getFormatWidth</A>
<br><A HREF="#getPadCharacter">getPadCharacter</A>
<br><A HREF="#setPadCharacter">setPadCharacter</A>
<br><A HREF="#getPadPosition">getPadPosition</A>
<br><A HREF="#setPadPosition">setPadPosition</A><br></DL><P>
<A NAME="getPadCharacter">
<A NAME ="DOC.10.28">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  UChar  getPadCharacter(void)</B></TT>
<DD>
Get the character used to pad to the format width.  The default is ' '.

<DL><DT><B>Returns:</B><DD>the pad character

<DT><B>See Also:</B><DD><A HREF="#setFormatWidth">setFormatWidth</A>
<br><A HREF="#getFormatWidth">getFormatWidth</A>
<br><A HREF="#setPadCharacter">setPadCharacter</A>
<br><A HREF="#getPadPosition">getPadPosition</A>
<br><A HREF="#setPadPosition">setPadPosition</A><br></DL><P>
<A NAME="setPadCharacter">
<A NAME ="DOC.10.29">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setPadCharacter(UChar padChar)</B></TT>
<DD>
Set the character used to pad to the format width.  This has no effect
unless padding is enabled.

<DL><DT><B>Parameters:</B><DD><B>padChar</B> -  the pad character
<br><DT><B>See Also:</B><DD><A HREF="#setFormatWidth">setFormatWidth</A>
<br><A HREF="#getFormatWidth">getFormatWidth</A>
<br><A HREF="#getPadCharacter">getPadCharacter</A>
<br><A HREF="#getPadPosition">getPadPosition</A>
<br><A HREF="#setPadPosition">setPadPosition</A><br></DL><P>
<A NAME="getPadPosition">
<A NAME ="DOC.10.30">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  EPadPosition  getPadPosition(void)</B></TT>
<DD>
Get the position at which padding will take place.  This is the location
at which padding will be inserted if the result of <code>format()</code>
is shorter than the format width.

<DL><DT><B>Returns:</B><DD>the pad position, one of <code>kPadBeforePrefix</code>,
<code>kPadAfterPrefix</code>, <code>kPadBeforeSuffix</code>, or
<code>kPadAfterSuffix</code>.

<DT><B>See Also:</B><DD><A HREF="#setFormatWidth">setFormatWidth</A>
<br><A HREF="#getFormatWidth">getFormatWidth</A>
<br><A HREF="#setPadCharacter">setPadCharacter</A>
<br><A HREF="#getPadCharacter">getPadCharacter</A>
<br><A HREF="#setPadPosition">setPadPosition</A>
<br><A HREF="#kPadBeforePrefix">kPadBeforePrefix</A>
<br><A HREF="#kPadAfterPrefix">kPadAfterPrefix</A>
<br><A HREF="#kPadBeforeSuffix">kPadBeforeSuffix</A>
<br><A HREF="#kPadAfterSuffix">kPadAfterSuffix</A><br></DL><P>
<A NAME="setPadPosition">
<A NAME ="DOC.10.31">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setPadPosition(EPadPosition padPos)</B></TT>
<DD>
<strong><font face=helvetica color=red>NEW</font></strong>
Set the position at which padding will take place.  This is the location
at which padding will be inserted if the result of <code>format()</code>
is shorter than the format width.  This has no effect unless padding is
enabled.

<DL><DT><B>Parameters:</B><DD><B>padPos</B> -  the pad position, one of <code>kPadBeforePrefix</code>,
<code>kPadAfterPrefix</code>, <code>kPadBeforeSuffix</code>, or
<code>kPadAfterSuffix</code>.
<br><DT><B>See Also:</B><DD><A HREF="#setFormatWidth">setFormatWidth</A>
<br><A HREF="#getFormatWidth">getFormatWidth</A>
<br><A HREF="#setPadCharacter">setPadCharacter</A>
<br><A HREF="#getPadCharacter">getPadCharacter</A>
<br><A HREF="#getPadPosition">getPadPosition</A>
<br><A HREF="#kPadBeforePrefix">kPadBeforePrefix</A>
<br><A HREF="#kPadAfterPrefix">kPadAfterPrefix</A>
<br><A HREF="#kPadBeforeSuffix">kPadBeforeSuffix</A>
<br><A HREF="#kPadAfterSuffix">kPadAfterSuffix</A><br></DL><P>
<A NAME="isScientificNotation">
<A NAME ="DOC.10.32">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  isScientificNotation(void)</B></TT>
<DD>
Return whether or not scientific notation is used
<DL><DT><B>Returns:</B><DD>TRUE if this object formats and parses scientific notation

<DT><B>See Also:</B><DD><A HREF="#setScientificNotation">setScientificNotation</A>
<br><A HREF="#getMinimumExponentDigits">getMinimumExponentDigits</A>
<br><A HREF="#setMinimumExponentDigits">setMinimumExponentDigits</A>
<br><A HREF="#isExponentSignAlwaysShown">isExponentSignAlwaysShown</A>
<br><A HREF="#setExponentSignAlwaysShown">setExponentSignAlwaysShown</A><br></DL><P>
<A NAME="setScientificNotation">
<A NAME ="DOC.10.33">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setScientificNotation(bool_t useScientific)</B></TT>
<DD>
Set whether or not scientific notation is used
<DL><DT><B>Parameters:</B><DD><B>useScientific</B> -  TRUE if this object formats and parses scientific
notation
<br><DT><B>See Also:</B><DD><A HREF="#isScientificNotation">isScientificNotation</A>
<br><A HREF="#getMinimumExponentDigits">getMinimumExponentDigits</A>
<br><A HREF="#setMinimumExponentDigits">setMinimumExponentDigits</A>
<br><A HREF="#isExponentSignAlwaysShown">isExponentSignAlwaysShown</A>
<br><A HREF="#setExponentSignAlwaysShown">setExponentSignAlwaysShown</A><br></DL><P>
<A NAME="getMinimumExponentDigits">
<A NAME ="DOC.10.34">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  int8_t  getMinimumExponentDigits(void)</B></TT>
<DD>
Return the minimum exponent digits that will be shown
<DL><DT><B>Returns:</B><DD>the minimum exponent digits that will be shown

<DT><B>See Also:</B><DD><A HREF="#setScientificNotation">setScientificNotation</A>
<br><A HREF="#isScientificNotation">isScientificNotation</A>
<br><A HREF="#setMinimumExponentDigits">setMinimumExponentDigits</A>
<br><A HREF="#isExponentSignAlwaysShown">isExponentSignAlwaysShown</A>
<br><A HREF="#setExponentSignAlwaysShown">setExponentSignAlwaysShown</A><br></DL><P>
<A NAME="setMinimumExponentDigits">
<A NAME ="DOC.10.35">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setMinimumExponentDigits(int8_t minExpDig)</B></TT>
<DD>
Set the minimum exponent digits that will be shown.  This has no
effect unless scientific notation is in use.

<DL><DT><B>Parameters:</B><DD><B>minExpDig</B> -  a value >= 1 indicating the fewest exponent digits
that will be shown.  Values less than 1 will be treated as 1.
<br><DT><B>See Also:</B><DD><A HREF="#setScientificNotation">setScientificNotation</A>
<br><A HREF="#isScientificNotation">isScientificNotation</A>
<br><A HREF="#getMinimumExponentDigits">getMinimumExponentDigits</A>
<br><A HREF="#isExponentSignAlwaysShown">isExponentSignAlwaysShown</A>
<br><A HREF="#setExponentSignAlwaysShown">setExponentSignAlwaysShown</A><br></DL><P>
<A NAME="isExponentSignAlwaysShown">
<A NAME ="DOC.10.36">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  isExponentSignAlwaysShown(void)</B></TT>
<DD>
Return whether the exponent sign is always shown
<DL><DT><B>Returns:</B><DD>TRUE if the exponent is always prefixed with either the
localized minus sign or the localized plus sign, false if only negative
exponents are prefixed with the localized minus sign.

<DT><B>See Also:</B><DD><A HREF="#setScientificNotation">setScientificNotation</A>
<br><A HREF="#isScientificNotation">isScientificNotation</A>
<br><A HREF="#setMinimumExponentDigits">setMinimumExponentDigits</A>
<br><A HREF="#getMinimumExponentDigits">getMinimumExponentDigits</A>
<br><A HREF="#setExponentSignAlwaysShown">setExponentSignAlwaysShown</A><br></DL><P>
<A NAME="setExponentSignAlwaysShown">
<A NAME ="DOC.10.37">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setExponentSignAlwaysShown(bool_t expSignAlways)</B></TT>
<DD>
Set whether the exponent sign is always shown.  This has no effect
unless scientific notation is in use.

<DL><DT><B>Parameters:</B><DD><B>expSignAlways</B> -  TRUE if the exponent is always prefixed with either
the localized minus sign or the localized plus sign, false if only
negative exponents are prefixed with the localized minus sign.
<br><DT><B>See Also:</B><DD><A HREF="#setScientificNotation">setScientificNotation</A>
<br><A HREF="#isScientificNotation">isScientificNotation</A>
<br><A HREF="#setMinimumExponentDigits">setMinimumExponentDigits</A>
<br><A HREF="#getMinimumExponentDigits">getMinimumExponentDigits</A>
<br><A HREF="#isExponentSignAlwaysShown">isExponentSignAlwaysShown</A><br></DL><P>
<A NAME="getGroupingSize">
<A NAME ="DOC.10.38">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int32_t  getGroupingSize(void) const </B></TT>
<DD>
Return the grouping size. Grouping size is the number of digits between
grouping separators in the integer portion of a number.  For example,
in the number "123,456.78", the grouping size is 3.

<DL><DT><B>See Also:</B><DD><!2><A HREF="DecimalFormat.html#DOC.10.39">setGroupingSize</A>
<br><!2><A HREF="NumberFormat.html#DOC.19.13">NumberFormat::isGroupingUsed</A>
<br><!2><A HREF="DecimalFormatSymbols.html#DOC.9.4">DecimalFormatSymbols::getGroupingSeparator</A><br></DL><P>
<A NAME="setGroupingSize">
<A NAME ="DOC.10.39">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setGroupingSize(int32_t newValue)</B></TT>
<DD>
Set the grouping size. Grouping size is the number of digits between
grouping separators in the integer portion of a number.  For example,
in the number "123,456.78", the grouping size is 3.

<DL><DT><B>See Also:</B><DD><!2><A HREF="DecimalFormat.html#DOC.10.38">getGroupingSize</A>
<br><!2><A HREF="NumberFormat.html#DOC.19.14">NumberFormat::setGroupingUsed</A>
<br>DecimalFormatSymbols::setGroupingSeparator<br></DL><P>
<A NAME="isDecimalSeparatorAlwaysShown">
<A NAME ="DOC.10.40">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool_t  isDecimalSeparatorAlwaysShown(void) const </B></TT>
<DD>
Allows you to get the behavior of the decimal separator with integers.
(The decimal separator will always appear with decimals.)

Example: Decimal ON: 12345 -> 12345.; OFF: 12345 -> 12345
<DL></DL><P>
<A NAME="setDecimalSeparatorAlwaysShown">
<A NAME ="DOC.10.41">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setDecimalSeparatorAlwaysShown(bool_t newValue)</B></TT>
<DD>
Allows you to set the behavior of the decimal separator with integers.
(The decimal separator will always appear with decimals.)

Example: Decimal ON: 12345 -> 12345.; OFF: 12345 -> 12345
<DL></DL><P>
<A NAME="toPattern">
<A NAME ="DOC.10.42">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  toPattern(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Synthesizes a pattern string that represents the current state
of this Format object
<DL><DT><B>See Also:</B><DD><!2><A HREF="DecimalFormat.html#DOC.10.52">applyPattern</A><br></DL><P>
<A NAME="toLocalizedPattern">
<A NAME ="DOC.10.43">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  toLocalizedPattern(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Synthesizes a localized pattern string that represents the current
state of this Format object.


<DL><DT><B>See Also:</B><DD><!2><A HREF="DecimalFormat.html#DOC.10.52">applyPattern</A><br></DL><P>
<A NAME="applyPattern">
<A NAME ="DOC.10.44">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  applyPattern(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.301">UErrorCode</A>& status)</B></TT>
<DD>
Apply the given pattern to this Format object.  A pattern is a
short-hand specification for the various formatting properties.
These properties can also be changed individually through the
various setter methods.
<P>
There is no limit to integer digits are set
by this routine, since that is the typical end-user desire;
use setMaximumInteger if you want to set a real value.
For negative numbers, use a second pattern, separated by a semicolon
<pre>
.      Example "#,#00.0#" -> 1,234.56
</pre>
This means a minimum of 2 integer digits, 1 fraction digit, and
a maximum of 2 fraction digits.
<pre>
.      Example: "#,#00.0#;(#,#00.0#)" for negatives in parantheses.
</pre>
In negative patterns, the minimum and maximum counts are ignored;
these are presumed to be set in the positive pattern.


<DL><DT><B>Parameters:</B><DD><B>pattern</B> -    The pattern to be applied.
<br><B>status</B> -     Output param set to success/failure code on
exit. If the pattern is invalid, this will be
set to a failure result.<br></DL><P>
<A NAME="applyLocalizedPattern">
<A NAME ="DOC.10.45">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  applyLocalizedPattern(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.301">UErrorCode</A>& status)</B></TT>
<DD>
Apply the given pattern to this Format object.  The pattern
is assumed to be in a localized notation. A pattern is a
short-hand specification for the various formatting properties.
These properties can also be changed individually through the
various setter methods.
<P>
There is no limit to integer digits are set
by this routine, since that is the typical end-user desire;
use setMaximumInteger if you want to set a real value.
For negative numbers, use a second pattern, separated by a semicolon
<pre>
.      Example "#,#00.0#" -> 1,234.56
</pre>
This means a minimum of 2 integer digits, 1 fraction digit, and
a maximum of 2 fraction digits.

Example: "#,#00.0#;(#,#00.0#)" for negatives in parantheses.

In negative patterns, the minimum and maximum counts are ignored;
these are presumed to be set in the positive pattern.


<DL><DT><B>Parameters:</B><DD><B>pattern</B> -    The localized pattern to be applied.
<br><B>status</B> -     Output param set to success/failure code on
exit. If the pattern is invalid, this will be
set to a failure result.<br></DL><P>
<A NAME="setMaximumIntegerDigits">
<A NAME ="DOC.10.46">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setMaximumIntegerDigits(int32_t newValue)</B></TT>
<DD>
Sets the maximum number of digits allowed in the integer portion of a
number. This override limits the integer digit count to 309.

<DL><DT><B>See Also:</B><DD><A HREF="NumberFormat.html#setMaximumIntegerDigits">setMaximumIntegerDigits</A><br></DL><P>
<A NAME="setMinimumIntegerDigits">
<A NAME ="DOC.10.47">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setMinimumIntegerDigits(int32_t newValue)</B></TT>
<DD>
Sets the minimum number of digits allowed in the integer portion of a
number. This override limits the integer digit count to 309.

<DL><DT><B>See Also:</B><DD><A HREF="NumberFormat.html#setMinimumIntegerDigits">setMinimumIntegerDigits</A><br></DL><P>
<A NAME="setMaximumFractionDigits">
<A NAME ="DOC.10.48">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setMaximumFractionDigits(int32_t newValue)</B></TT>
<DD>
Sets the maximum number of digits allowed in the fraction portion of a
number. This override limits the fraction digit count to 340.

<DL><DT><B>See Also:</B><DD><A HREF="NumberFormat.html#setMaximumFractionDigits">setMaximumFractionDigits</A><br></DL><P>
<A NAME="setMinimumFractionDigits">
<A NAME ="DOC.10.49">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setMinimumFractionDigits(int32_t newValue)</B></TT>
<DD>
Sets the minimum number of digits allowed in the fraction portion of a
number. This override limits the fraction digit count to 340.

<DL><DT><B>See Also:</B><DD><A HREF="NumberFormat.html#setMinimumFractionDigits">setMinimumFractionDigits</A><br></DL><P>
<A NAME="fgNumberPatterns">
<A NAME ="DOC.10.59">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>  fgNumberPatterns</B></TT>
<DD>
The resource tags we use to retrieve decimal format data from
locale resource bundles
<DL></DL><P>
<A NAME="getStaticClassID">
<A NAME ="DOC.10.50">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!1><A HREF="ClassID.html">ClassID</A>  getStaticClassID(void)</B></TT>
<DD>
Return the class ID for this class.  This is useful only for
comparing to a return value from getDynamicClassID().  For example:
<pre>
.      Base* polymorphic_pointer = createPolymorphicObject();
.      if (polymorphic_pointer->getDynamicClassID() ==
.          Derived::getStaticClassID()) ...
</pre>

<DL><DT><B>Returns:</B><DD>The class ID for all objects of this class.
</DL><P>
<A NAME="getDynamicClassID">
<A NAME ="DOC.10.51">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="ClassID.html">ClassID</A>  getDynamicClassID(void) const </B></TT>
<DD>
Returns a unique class ID POLYMORPHICALLY.  Pure virtual override.
This method is to implement a simple version of RTTI, since not all
C++ compilers support genuine RTTI.  Polymorphic operator==() and
clone() methods call this method.


<DL><DT><B>Returns:</B><DD>The class ID for this object. All objects of a
given class have the same class ID.  Objects of
other classes have different class IDs.
</DL><P></DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
