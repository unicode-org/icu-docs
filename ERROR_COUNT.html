<html><head><TITLE>ERROR_COUNT</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A> T_CTEST_EXPORT_API  extern  int  ERROR_COUNT  </H2><BLOCKQUOTE>

Count of errors from all tests
</BLOCKQUOTE>

<hr>
<DL>
 <DT><A HREF="#DOC.8.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>UnicodeConverterCPP</B>() </B>
 <DD><I>
Creates Unicode Conversion Object will default to LATIN1 <-> encoding
</I>
<DT><A HREF="#DOC.8.2"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>UnicodeConverterCPP</B>(const char* name, <!2><A HREF="#DOC.320">UErrorCode</A>& err) </B>
 <DD><I>
Creates Unicode Conversion Object by specifying the codepage name</I>
<DT><A HREF="#DOC.8.3"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>UnicodeConverterCPP</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& name, <!2><A HREF="#DOC.320">UErrorCode</A>& err) </B>
 <DD><I>
Creates a UnicodeConverter object with the names specified as unicode strings</I>
<DT><A HREF="#DOC.8.4"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>UnicodeConverterCPP</B>(int32_t codepageNumber, UConverterPlatform platform, <!2><A HREF="#DOC.320">UErrorCode</A>& err) </B>
 <DD><I>
Creates Unicode Conversion Object using the codepage ID number</I>
<DT><A HREF="#DOC.8.5"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>fromUnicodeString</B>(char* target, int32_t& targetSize, const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!2><A HREF="#DOC.320">UErrorCode</A>& err) const  </B>
 <DD><I>
Transcodes the source UnicodeString to the target string in a codepage encoding
with the specified Unicode converter</I>
<DT><A HREF="#DOC.8.6"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>toUnicodeString</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& target, const char* source, int32_t sourceSize, <!2><A HREF="#DOC.320">UErrorCode</A>& err) const  </B>
 <DD><I>
Transcode the source string in codepage encoding to the target string in
Unicode encoding</I>
<DT><A HREF="#DOC.8.7"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>fromUnicode</B>(char*& target, const char* targetLimit, const UChar*& source, const UChar* sourceLimit, int32_t * offsets, bool_t flush, <!2><A HREF="#DOC.320">UErrorCode</A>& err) </B>
 <DD><I>
Transcodes an array of unicode characters to an array of codepage characters</I>
<DT><A HREF="#DOC.8.8"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>toUnicode</B>(UChar*& target, const UChar* targetLimit, const char*& source, const char* sourceLimit, int32_t * offsets, bool_t flush, <!2><A HREF="#DOC.320">UErrorCode</A>& err) </B>
 <DD><I>
Converts an array of codepage characters into an array of unicode characters</I>
<DT><A HREF="#DOC.8.9"> <IMG BORDER=0 SRC=icon1.gif></A> int8_t  <B>getMinBytesPerChar</B>(void) const  </B>
 <DD><I>
Returns the minimum byte length for characters in this codepage</I>
<DT><A HREF="#DOC.8.10"> <IMG BORDER=0 SRC=icon1.gif></A> UConverterType  <B>getType</B>(void) const  </B>
 <DD><I>
Gets the type of conversion associated with the converter
e</I>
<DT><A HREF="#DOC.8.11"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>getStarters</B>(bool_t starters[256], <!2><A HREF="#DOC.320">UErrorCode</A>& err) const  </B>
 <DD><I>
Gets the "starter" bytes for the converters of type MBCS
will fill in an <TT>U_ILLEGAL_ARGUMENT_ERROR</TT> if converter passed in
is not MBCS</I>
<DT><A HREF="#DOC.8.12"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>getSubstitutionChars</B>(char* subChars, int8_t& len, <!2><A HREF="#DOC.320">UErrorCode</A>& err) const  </B>
 <DD><I>
Fills in the output parameter, subChars, with the substitution characters
as multiple bytes</I>
<DT><A HREF="#DOC.8.13"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setSubstitutionChars</B>(const char* subChars, int8_t len, <!2><A HREF="#DOC.320">UErrorCode</A>& err) </B>
 <DD><I>
Sets the substitution chars when converting from unicode to a codepage</I>
<DT><A HREF="#DOC.8.14"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>resetState</B>(void) </B>
 <DD><I>
Resets the state of stateful conversion to the default state</I>
<DT><A HREF="#DOC.8.15"> <IMG BORDER=0 SRC=icon1.gif></A> const  char*  <B>getName</B>( <!2><A HREF="#DOC.320">UErrorCode</A>& err) const  </B>
 <DD><I>
Gets the name of the converter (zero-terminated)</I>
<DT><A HREF="#DOC.8.16"> <IMG BORDER=0 SRC=icon1.gif></A> int32_t  <B>getCodepage</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& err) const  </B>
 <DD><I>
Gets a codepage number associated with the converter</I>
<DT><A HREF="#DOC.8.17"> <IMG BORDER=0 SRC=icon1.gif></A> UConverterToUCallback  <B>getMissingCharAction</B>(void) const  </B>
 <DD><I>
Returns the current setting action taken when a character from a codepage
is missing</I>
<DT><A HREF="#DOC.8.18"> <IMG BORDER=0 SRC=icon1.gif></A> UConverterFromUCallback  <B>getMissingUnicodeAction</B>(void) const  </B>
 <DD><I>
Return the current setting action taken when a unicode character is missing</I>
<DT><A HREF="#DOC.8.19"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setMissingCharAction</B>(UConverterToUCallback action, <!2><A HREF="#DOC.320">UErrorCode</A>& err) </B>
 <DD><I>
Sets the current setting action taken when a character from a codepage is
missing</I>
<DT><A HREF="#DOC.8.20"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setMissingUnicodeAction</B>(UConverterFromUCallback action, <!2><A HREF="#DOC.320">UErrorCode</A>& err) </B>
 <DD><I>
Sets the current setting action taken when a unicode character is missing</I>
<DT><A HREF="#DOC.8.21"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>getDisplayName</B>(const Locale& displayLocale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& displayName) const  </B>
 <DD><I>
Returns the localized name of the UnicodeConverter, if for any reason it is
available, the internal name will be returned instead</I>
<DT><A HREF="#DOC.8.22"> <IMG BORDER=0 SRC=icon1.gif></A> UConverterPlatform  <B>getCodepagePlatform</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& err) const  </B>
 <DD><I>
Returns the T_UnicodeConverter_platform (ICU defined enum) of a UnicodeConverter
available, the internal name will be returned instead</I>
<DT><A HREF="#DOC.8.23"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  char*  const*  <B>getAvailableNames</B>(int32_t& num, <!2><A HREF="#DOC.320">UErrorCode</A>& err) </B>
 <DD><I>
Returns the available names</I>
<DT><A HREF="#DOC.8.24"> <IMG BORDER=0 SRC=icon1.gif></A> static  int32_t  <B>flushCache</B>(void) </B>
 <DD><I>
Iterates through every cached converter and frees all the unused ones
</I>
</DL><A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

Count of errors from all tests. May be reset.

</BLOCKQUOTE>
<DL>

<A NAME="UnicodeConverterCPP">
<A NAME ="DOC.8.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  UnicodeConverterCPP()</B></TT>
<DD>
Creates Unicode Conversion Object will default to LATIN1 <-> encoding

<DL><DT><B>Returns:</B><DD>An object Handle if successful or a NULL if the creation failed
</DL><P>
<A NAME="UnicodeConverterCPP">
<A NAME ="DOC.8.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  UnicodeConverterCPP(const char* name, <!2><A HREF="#DOC.320">UErrorCode</A>& err)</B></TT>
<DD>
Creates Unicode Conversion Object by specifying the codepage name.  The name
string is in ASCII format.

<DL><DT><B>Returns:</B><DD>An object Handle if successful or a NULL if the creation failed
<DT><B>Parameters:</B><DD><B>code_set</B> -  the pointer to a char[] object containing a codepage name. (I)
<br><B>UErrorCode</B> -  Error status (I/O) IILLEGAL_ARGUMENT_ERROR will be returned if the string is empty.
If the internal program does not work correctly, for example, if there's no such codepage,
U_INTERNAL_PROGRAM_ERROR will be returned.
<br></DL><P>
<A NAME="UnicodeConverterCPP">
<A NAME ="DOC.8.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  UnicodeConverterCPP(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& name, <!2><A HREF="#DOC.320">UErrorCode</A>& err)</B></TT>
<DD>
Creates a UnicodeConverter object with the names specified as unicode strings. The name should be limited to
the ASCII-7 alphanumerics. Dash and underscore characters are allowed for readability, but are ignored in the
search.

<DL><DT><B>Returns:</B><DD>the created Unicode converter object
<DT><B>Parameters:</B><DD><B>code_set</B> -  name of the uconv table in Unicode string (I)
<br><B>err</B> -  error status (I/O) IILLEGAL_ARGUMENT_ERROR will be returned if the string is empty.  If the internal
program does not work correctly, for example, if there's no such codepage, U_INTERNAL_PROGRAM_ERROR will be
returned.
<br></DL><P>
<A NAME="UnicodeConverterCPP">
<A NAME ="DOC.8.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  UnicodeConverterCPP(int32_t codepageNumber, UConverterPlatform platform, <!2><A HREF="#DOC.320">UErrorCode</A>& err)</B></TT>
<DD>
Creates Unicode Conversion Object using the codepage ID number
<DL><DT><B>Returns:</B><DD>An object Handle if successful or a NULL if failed

<DT><B>Parameters:</B><DD><B>code_set</B> -  a codepage # (I)
@UErrorCode Error status (I/O) IILLEGAL_ARGUMENT_ERROR will be returned if the string is empty.
If the internal program does not work correctly, for example, if there's no such codepage,
U_INTERNAL_PROGRAM_ERROR will be returned.
<br></DL><P>
<A NAME="fromUnicodeString">
<A NAME ="DOC.8.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  fromUnicodeString(char* target, int32_t& targetSize, const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!2><A HREF="#DOC.320">UErrorCode</A>& err) const </B></TT>
<DD>
Transcodes the source UnicodeString to the target string in a codepage encoding
with the specified Unicode converter.  For example, if a Unicode to/from JIS
converter is specified, the source string in Unicode will be transcoded to JIS
encoding.  The result will be stored in JIS encoding.


<DL><DT><B>Parameters:</B><DD><B>source</B> -  the source Unicode string
<br><B>target</B> -  the target string in codepage encoding
<br><B>targetSize</B> -  Input the number of bytes available in the "target" buffer, Output the number of bytes copied to it
<br><B>err</B> -  the error status code.  U_MEMORY_ALLOCATION_ERROR will be returned if the
the internal process buffer cannot be allocated for transcoding.  U_ILLEGAL_ARGUMENT_ERROR
is returned if the converter is null or the source or target string is empty.<br></DL><P>
<A NAME="toUnicodeString">
<A NAME ="DOC.8.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  toUnicodeString(<!1><A HREF="UnicodeString.html">UnicodeString</A>& target, const char* source, int32_t sourceSize, <!2><A HREF="#DOC.320">UErrorCode</A>& err) const </B></TT>
<DD>
Transcode the source string in codepage encoding to the target string in
Unicode encoding.  For example, if a Unicode to/from JIS
converter is specified, the source string in JIS encoding will be transcoded
to Unicode encoding.  The result will be stored in Unicode encoding.

<DL><DT><B>Parameters:</B><DD><B>source</B> -  the source string in codepage encoding
<br><B>target</B> -  the target string in Unicode encoding
<br><B>targetSize</B> -  : I/O parameter, Input size buffer, Output # of bytes copied to it
<br><B>err</B> -  the error status code U_MEMORY_ALLOCATION_ERROR will be returned if the
the internal process buffer cannot be allocated for transcoding.  U_ILLEGAL_ARGUMENT_ERROR
is returned if the converter is null or the source or target string is empty.<br></DL><P>
<A NAME="fromUnicode">
<A NAME ="DOC.8.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  fromUnicode(char*& target, const char* targetLimit, const UChar*& source, const UChar* sourceLimit, int32_t * offsets, bool_t flush, <!2><A HREF="#DOC.320">UErrorCode</A>& err)</B></TT>
<DD>
Transcodes an array of unicode characters to an array of codepage characters.
The source pointer is an I/O parameter, it starts out pointing at the place
to begin translating, and ends up pointing after the first sequence of the bytes
that it encounters that are semantically invalid.
if T_UnicodeConverter_setMissingCharAction is called with an action other than STOP
before a call is made to this API, consumed and source should point to the same place
(unless target ends with an imcomplete sequence of bytes and flush is FALSE).

<DL><DT><B>Parameters:</B><DD><B>target</B> -  : I/O parameter. Input : Points to the beginning of the buffer to copy
codepage characters to. Output : points to after the last codepage character copied
to target.
<br><B>targetLimit</B> -  the pointer to the end of the target array
<br><B>source</B> -  the source Unicode character array
<br><B>sourceLimit</B> -  the pointer to the end of the source array
<br><B>flush</B> -  TRUE if the buffer is the last buffer and the conversion will finish
in this call, FALSE otherwise.  (future feature pending)
<br><B>UErrorCode</B> -  the error status.  U_ILLEGAL_ARGUMENT_ERROR will be returned if the
converter is null.<br></DL><P>
<A NAME="toUnicode">
<A NAME ="DOC.8.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  toUnicode(UChar*& target, const UChar* targetLimit, const char*& source, const char* sourceLimit, int32_t * offsets, bool_t flush, <!2><A HREF="#DOC.320">UErrorCode</A>& err)</B></TT>
<DD>
Converts an array of codepage characters into an array of unicode characters.
The source pointer is an I/O parameter, it starts out pointing at the place
to begin translating, and ends up pointing after the first sequence of the bytes
that it encounters that are semantically invalid.
if T_UnicodeConverter_setMissingUnicodeAction is called with an action other than STOP
before a call is made to this API, consumed and source should point to the same place
(unless target ends with an imcomplete sequence of bytes and flush is FALSE).

<DL><DT><B>Parameters:</B><DD><B>target</B> -  : I/O parameter. Input : Points to the beginning of the buffer to copy
Unicode characters to. Output : points to after the last UChar copied to target.
<br><B>targetLimit</B> -  the pointer to the end of the target array
<br><B>source</B> -  the source codepage character array
<br><B>sourceLimit</B> -  the pointer to the end of the source array
<br><B>flush</B> -  TRUE if the buffer is the last buffer and the conversion will finish
in this call, FALSE otherwise.  (future feature pending)
<br><B>err</B> -  the error code status  U_ILLEGAL_ARGUMENT_ERROR will be returned if the
converter is null, targetLimit < target, sourceLimit < source<br></DL><P>
<A NAME="getMinBytesPerChar">
<A NAME ="DOC.8.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int8_t  getMinBytesPerChar(void) const </B></TT>
<DD>
Returns the minimum byte length for characters in this codepage. This is either
1 or 2 for all supported codepages.

<DL><DT><B>Returns:</B><DD>the minimum number of byte per codepage character
</DL><P>
<A NAME="getType">
<A NAME ="DOC.8.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UConverterType  getType(void) const </B></TT>
<DD>
Gets the type of conversion associated with the converter
e.g. SBCS, MBCS, DBCS, UTF8, UTF16_BE, UTF16_LE, ISO_2022, EBCDIC_STATEFUL, LATIN_1

<DL><DT><B>Returns:</B><DD>the type of the converter
</DL><P>
<A NAME="getStarters">
<A NAME ="DOC.8.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  getStarters(bool_t starters[256], <!2><A HREF="#DOC.320">UErrorCode</A>& err) const </B></TT>
<DD>
Gets the "starter" bytes for the converters of type MBCS
will fill in an <TT>U_ILLEGAL_ARGUMENT_ERROR</TT> if converter passed in
is not MBCS.
fills in an array of boolean, with the value of the byte as offset to the array.
At return, if TRUE is found in at offset 0x20, it means that the byte 0x20 is a starter byte
in this converter.

<DL><DT><B>Parameters:</B><DD><B>starters</B> - : an array of size 256 to be filled in
<br><B>err</B> - : an array of size 256 to be filled in
<br><DT><B>See Also:</B><DD><!1><A HREF="ucnv_getType.html">ucnv_getType</A><br></DL><P>
<A NAME="getSubstitutionChars">
<A NAME ="DOC.8.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  getSubstitutionChars(char* subChars, int8_t& len, <!2><A HREF="#DOC.320">UErrorCode</A>& err) const </B></TT>
<DD>
Fills in the output parameter, subChars, with the substitution characters
as multiple bytes
<DL><DT><B>Parameters:</B><DD><B>subChars</B> -  the subsitution characters
<br><B>len</B> -  the number of bytes of the substitution character array
<br><B>err</B> -  the error status code.  U_ILLEGAL_ARGUMENT_ERROR will be returned if
the converter is null.  If the substitution character array is too small, an
U_INDEX_OUTOFBOUNDS_ERROR will be returned.<br></DL><P>
<A NAME="setSubstitutionChars">
<A NAME ="DOC.8.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setSubstitutionChars(const char* subChars, int8_t len, <!2><A HREF="#DOC.320">UErrorCode</A>& err)</B></TT>
<DD>
Sets the substitution chars when converting from unicode to a codepage. The
substitution is specified as a string of 1-4 bytes, and may contain null byte.
The fill-in parameter err will get the error status on return.

<DL><DT><B>Parameters:</B><DD><B>cstr</B> -  the substitution character array to be set with
<br><B>len</B> -  the number of bytes of the substitution character array and upon return will contain the
number of bytes copied to that buffer
<br><B>err</B> -  the error status code.  U_ILLEGAL_ARGUMENT_ERROR if the converter is
null.   or if the number of bytes provided are not in the codepage's range (e.g length 1 for ucs-2)<br></DL><P>
<A NAME="resetState">
<A NAME ="DOC.8.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  resetState(void)</B></TT>
<DD>
Resets the state of stateful conversion to the default state. This is used
in the case of error to restart a conversion from a known default state.
<DL></DL><P>
<A NAME="getName">
<A NAME ="DOC.8.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> const  char*  getName( <!2><A HREF="#DOC.320">UErrorCode</A>& err) const </B></TT>
<DD>
Gets the name of the converter (zero-terminated).
the name will be the internal name of the converter

<DL><DT><B>Parameters:</B><DD><B>converter</B> -  the Unicode converter
<br><B>err</B> -  the error status code. U_INDEX_OUTOFBOUNDS_ERROR in the converterNameLen is too
small to contain the name.<br></DL><P>
<A NAME="getCodepage">
<A NAME ="DOC.8.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int32_t  getCodepage(<!2><A HREF="#DOC.320">UErrorCode</A>& err) const </B></TT>
<DD>
Gets a codepage number associated with the converter. This is not guaranteed
to be the one used to create the converter. Some converters do not represent
IBM registered codepages and return zero for the codepage number.
The error code fill-in parameter indicates if the codepage number is available.

<DL><DT><B>Returns:</B><DD>If any error occurrs, null will be returned.
<DT><B>Parameters:</B><DD><B>err</B> -  the error status code.  U_ILLEGAL_ARGUMENT_ERROR will returned if
the converter is null or if converter's data table is null.
<br></DL><P>
<A NAME="getMissingCharAction">
<A NAME ="DOC.8.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UConverterToUCallback  getMissingCharAction(void) const </B></TT>
<DD>
Returns the current setting action taken when a character from a codepage
is missing. (Currently STOP or SUBSTITUTE).

<DL><DT><B>Returns:</B><DD>the action constant when a Unicode character cannot be converted to a
codepage equivalent
</DL><P>
<A NAME="getMissingUnicodeAction">
<A NAME ="DOC.8.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UConverterFromUCallback  getMissingUnicodeAction(void) const </B></TT>
<DD>
Return the current setting action taken when a unicode character is missing.
(Currently STOP or SUBSTITUTE).

<DL><DT><B>Returns:</B><DD>the action constant when a codepage character cannot be converted to a
Unicode eqivalent
</DL><P>
<A NAME="setMissingCharAction">
<A NAME ="DOC.8.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setMissingCharAction(UConverterToUCallback action, <!2><A HREF="#DOC.320">UErrorCode</A>& err)</B></TT>
<DD>
Sets the current setting action taken when a character from a codepage is
missing. (Currently STOP or SUBSTITUTE).

<DL><DT><B>Parameters:</B><DD><B>action</B> -  the action constant if an equivalent codepage character is missing<br></DL><P>
<A NAME="setMissingUnicodeAction">
<A NAME ="DOC.8.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setMissingUnicodeAction(UConverterFromUCallback action, <!2><A HREF="#DOC.320">UErrorCode</A>& err)</B></TT>
<DD>
Sets the current setting action taken when a unicode character is missing.
(currently T_UnicodeConverter_MissingUnicodeAction is either STOP or SUBSTITUTE,
SKIP, CLOSEST_MATCH, ESCAPE_SEQ may be added in the future).

<DL><DT><B>Parameters:</B><DD><B>action</B> -  the action constant if an equivalent Unicode character is missing
<br><B>err</B> -  the error status code<br></DL><P>
<A NAME="getDisplayName">
<A NAME ="DOC.8.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  getDisplayName(const Locale& displayLocale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& displayName) const </B></TT>
<DD>
Returns the localized name of the UnicodeConverter, if for any reason it is
available, the internal name will be returned instead
<DL><DT><B>Parameters:</B><DD><B>displayLocale</B> -  the valid Locale, from which we want to localize
<br><B>displayString</B> -  a UnicodeString that is going to be filled in.<br></DL><P>
<A NAME="getCodepagePlatform">
<A NAME ="DOC.8.22">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UConverterPlatform  getCodepagePlatform(<!2><A HREF="#DOC.320">UErrorCode</A>& err) const </B></TT>
<DD>
Returns the T_UnicodeConverter_platform (ICU defined enum) of a UnicodeConverter
available, the internal name will be returned instead
<DL><DT><B>Returns:</B><DD>the codepages platform
<DT><B>Parameters:</B><DD><B>err</B> -  the error code status
<br></DL><P>
<A NAME="getAvailableNames">
<A NAME ="DOC.8.23">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  char*  const*  getAvailableNames(int32_t& num, <!2><A HREF="#DOC.320">UErrorCode</A>& err)</B></TT>
<DD>
Returns the available names. Lazy evaluated, Library owns the storage

<DL><DT><B>Returns:</B><DD>the name array
<DT><B>Parameters:</B><DD><B>num</B> -  the number of available converters
<br><B>err</B> -  the error code status
<br></DL><P>
<A NAME="flushCache">
<A NAME ="DOC.8.24">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  int32_t  flushCache(void)</B></TT>
<DD>
Iterates through every cached converter and frees all the unused ones

<DL><DT><B>Returns:</B><DD>the number of cached converters successfully deleted
</DL><P></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
