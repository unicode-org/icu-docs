<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Delta Collation Design Issues</title>
</head>

<body>

<h1 align="center">Delta Collation Design Issues</h1>
<table cellspacing="0" width="100%" border="1">
  <tr>
    <td class="white" height="27"><i>Summary:</i></td>
    <td class="white" height="27">This document describes prospective designs
      for particular collation issues.</td>
  </tr>
  <tr>
    <td class="white" height="27"><i>Date:</i></td>
    <td class="white" height="27">2003-05-08</td>
  </tr>
  <tr>
    <td class="white" height="25"><i>Author:</i></td>
    <td class="white" height="25">Mark Davis</td>
  </tr>
  <tr>
    <td class="white" height="27"><i>Latest Version:</i></td>
    <td class="white" height="27"><a href="http://oss.software.ibm.com/cvs/icu/~checkout~/icuhtml/design/collation/delta_issues.html">http://oss.software.ibm.com/cvs/icu/~checkout~/icuhtml/design/collation/delta_issues.html</a></td>
  </tr>
  <tr>
    <td class="white" height="27"><i>Previous Versions:</i></td>
    <td class="white" height="27"><a href="http://oss.software.ibm.com/cvs/icu/icuhtml/design/collation/delta_issues.html">http://oss.software.ibm.com/cvs/icu/icuhtml/design/collation/delta_issues.html</a></td>
  </tr>
</table>
<h2>Numeric Ordering</h2>
<p>If numbers are sorted alphabetically, “A-10” comes before “A-2”,
which is often not desired. This feature allows that to be changed, under
control by an attribute. The goals are to:</p>
<ul>
  <li>enable numeric ordering if the attribute flag is on</li>
  <li>not affect performance or storage of any any strings that do not contain
    numbers</li>
  <li>not affect the performance of sorting significantly if the flag is off,
    and</li>
  <li>have reasonable performance/storage if the flag is on.</li>
  <li>only allow for integer sequences in the first version of this feature, but
    any sequence of Decimal Digits (Nd) will work.</li>
</ul>
<p>The way that collation is set up, each of the weight levels can have
arbitrary numbers of bytes.&nbsp; That is, I could have a 4-byte primary, 2 byte
secondary, and 3-byte tertiary. Now as far as the rules go, we don't generate
any weight levels that require storing an arbitrarily long primary weight
sequence, but for something like numbers, generated programmatically, that can
easily be done.</p>
<p>The main restriction on the bytes is that for any character, for each level,
*no* weight sequence can be an initial subsequence of a weight sequence for
another character. That is, if X had the primary weight sequence &lt;11 22
33&gt;, then there can be no character that has a primary weight sequence &lt;11
22 33 XX&gt;. There are a few other restrictions on weights, that you can read
about in <a href="http://oss.software.ibm.com/cvs/icu/~checkout~/icuhtml/design/collation/ICU_collation_design.htm#Fractional_Collation_Elements">http://oss.software.ibm.com/cvs/icu/~checkout~/icuhtml/design/collation/ICU_collation_design.htm#Fractional_Collation_Elements</a></p>
<p>Here a sketch of the design. The first part (A) is to find a &quot;base&quot;
primary position where we can put the numbers. That can be done when the
collator is built. The second change (B) is to generate the weight strings at
runtime (when the flag is on, of course).</p>
<p><b>A. Finding the Position.</b> If you look at Fractional UCA, you see that
DIGIT ZERO has a weight at</p>
<p>0030; [1A 90, 05, 05] # [0A0B.0020.0002] * DIGIT ZERO</p>
<p>and the last digit with unique primary weight is at:</p>
<p>2468; [1A A2, 05, 0D] # [0A14.0020.0006] * CIRCLED DIGIT NINE</p>
<p>There is then a gap up to</p>
<p>0061; [1D, 05, 05] # [0A15.0020.0002] * LATIN SMALL LETTER A</p>
<p>So notice that the bytes 1B and 1C are empty. Now, you can't depend on these
exact values, but there are functions that will back-map from a character
(e.g.&quot;9&quot;) back to a collation element, and you can go forwards to find
the last primary weight. (This is a little more complicated with tailorings;
might be worth just adding some syntax to say &quot;put numbers here&quot;.
Vladimir can comment.)</p>
<blockquote>
  <p>It is easier if we allocate an anchor in the FractionalUCA the position
  that number ordering goes, the NUMBER_ORDERING_ANCHOR. That way we can save
  ourselves from having to search for a good position in tailorings, and we can
  make sure that untailored positions are single bytes. This value should be
  stored in the UCA collator similarly to how we store the variable top value.
  However, we have to make sure that this primary value is reserved in the
  inverse UCA in the same way we do for 'homeless CEs' (see the end of
  FractionalUCA.txt - search for 'homeless'). This would also allow us to be
  able to tailor NUMBER_ORDERING_ANCHOR similarly to&nbsp; how we can tailor
  variable top.</p>
</blockquote>
<p>Lets assume that 1B is the value we determine, for the sake of this example.
Then as long as we follow the &quot;no initial subsequence overlap&quot; rule,
and work within the byte ranges for trailing bytes of a primary weight (03..FF,
I believe), then we can have arbitrarily long (or short) sequences that start
with 1B.</p>
<p>This will not be done by modifying FractionalUCA.txt. All the processing
should be done in builder. The table building intervention should happen in
uprv_uca_addAnElement function in ucol_elm.cpp. This is where SPECIALS are
marked, according to the stuff contained in the passed elements. (Upper and
lower case are handled differently, as they are just modifications to the CE
contents.) All characters of type Nd will be caught and made into
NUMBER_SPECIALS, with&nbsp; the regular value of the element in the expansions
table (this is where stuff is that is not context sensitive). For more examples,
check how the expansions table is used to stuff Thai data there.</p>
<p><b>B. Generate the Weights. </b>Here is one way to do that. Generate a
primary weight sequence as follows. The first byte of the weight string will be
1B. Transform the number you find into IEEE format, which is binary-sortable:</p>
<p>&lt;sign&gt; &lt;exp-sign&gt; &lt;exp bits&gt; &lt;mantissa bits&gt;</p>
<p>For each subsequence byte, break up the IEEE format up into bytes by taking
the bits 6 at at a time, and adding 0xC0 to each one. After this is all done,
remove any trailing 0x80 bytes (these represented trailing zeros in the IEEE),
and mask off 0x80 from the last byte to terminate it. Examples:</p>
<pre>Number: -5.0
IEEE:   1100000000010100000000000000000000000000000000000000000000000000
Broken: 11110000 11000001 11010000
Bytes:  1B F0 C1 50

Number: 0.0
IEEE:   0
Broken: &lt;none&gt;
Bytes:  1B 40

Number: 5.0
IEEE:   100000000010100000000000000000000000000000000000000000000000000
Broken: 11010000 11000001 11010000
Bytes:  1B D0 C1 50

Number: 500.0
IEEE:   100000001111111010000000000000000000000000000000000000000000000
Broken: 11010000 11000111 11111101
Bytes:  1B D0 C7 7D

Number: 5,000,000.0
IEEE:   100000101010011000100101101000000000000000000000000000000000000
Broken: 11010000 11010101 11001100 11010010 11110100
Bytes:  1B D0 D5 CC D2 74</pre>
<p>Since the trailing byte is strictly less than any other byte, there can be no
overlap, and the final byte is also less than the byte in that position in any
longer sequence. Since we always turn on the 0x40 bit, we are always in the
allowable range (03..FF). While one could compress this further, I think that
would be diminishing returns.</p>
<p>This doesn't not require any real IEEE processing (important for us cross
platform); we just need to be able to get the exponent and mantissa. If we only
do integers to start with, that is pretty simple.</p>
<p>The secondary and tertiary bytes can be each simply one byte (the default
value for each level). That way, the final sort key is probably comparable to
the number of bytes with the Numeric Sort option turned off.</p>
<p>These values are used as follows. When the NUMBER_SPECIAL is detected, and
the NUMERIC_ORDER flag is on, then we generate the above, and stuff all but the
first CE in the CE buffer in our collation structure - this is where we keep CEs
that were generated by previous calls to getNextCE. Usually we use this
buffer&nbsp; to stash expansion and continuation CEs, but we also use it when we
generate Hangul sequences. If the NUMERIC_ORDER flag is off, we just get the
original value from the expansion buffer.</p>
<blockquote>
  <p><b>Possible Optimization</b>. If the regular CE of the digit character is a
  simple 32-bit word with a&nbsp; &quot;common&quot; (05) tertiary, we could
  just store its primary and secondary&nbsp; weights in the special digit CE,
  bits 23..0. We would need a marker bit or threshold value that tells us if
  it's an offset into the expansion table instead. This would be faster and use
  much less space for normal digit sorting while still allowing arbitrarily
  complex weights.</p>
</blockquote>
<p><b>API: </b>add an attribute for NUMERIC_ORDER.</p>
<p><b>Syntax: </b>add rule syntax for [numeric order: on/off/default]</p>
<p>(For an example of how to add these, see the hiragana quaternary setting -
that was added to the already finished framework.)</p>
<h2>Hangul Sorting</h2>
<p>There is a problem with Hangul Sorting; see <a href="http://www.unicode.org/reports/tr10/#Trailing_Weights">UTS
#10, in Trailing Weights</a>, when Hangul Syllables are immediately followed by
characters with higher primary weights.</p>
<p>ICU's data table is not subject to this problem with Han characters because
those are all tailored to be interleaved with Hangul, it would happen with other
sets like Katakana:</p>
<div align="center">
  <center>
  <table border="1" cellspacing="0" cellpadding="4">
    <tr>
      <th>Sample</th>
      <th>&nbsp;</th>
      <th colspan="4">Internal Order</th>
    </tr>
    <tr>
      <td><b><font color="#0000FF">&#44032;</font></b></td>
      <td>&#8594;</td>
      <td>&#4352;</td>
      <td>&#4449;</td>
      <td>&nbsp;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><b><font color="#FF0000">&#44033;</font></b></td>
      <td>&#8594;</td>
      <td>&#4352;</td>
      <td>&#4449;</td>
      <td>&#4520;</td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <td><b><font color="#FF0000">&#44033;</font>&#12450;</b></td>
      <td>&#8594;</td>
      <td>&#4352;</td>
      <td>&#4449;</td>
      <td>&#4520;</td>
      <td>&#12450;</td>
    </tr>
    <tr>
      <td><b><font color="#0000FF">&#44032;</font>&#12450;</b></td>
      <td>&#8594;</td>
      <td>&#4352;</td>
      <td>&#4449;</td>
      <td>&#12450;</td>
      <td>&nbsp;</td>
    </tr>
  </table>
  </center>
</div>
<p>If this issue is important to any implementation, then the work-around in ICU
is to tailor the weights for the Korean locale: all of the Jamo must be tailored
to be in the Trailing Weights area. This is not done for the standard release,
since there are negative performance/storage implications.</p>
<p>There are two possible fixes that we are considering.</p>
<ol>
  <li><i>Implement Script Reordering. </i>This solves the problem for modern
    Hangul, but requires that Hangul always be at the end, and does not handle
    non-modern Hangul.</li>
  <li><i>Terminator Primary Weight. </i>This is our current preferred choice,
    since it handles all cases.
    <ol type="a">
      <li>We tailor all Jamo so that for all L, V, T: T &lt; V &lt; L.</li>
      <li>All V and T will be JAMO_SPECIAL.</li>
      <li>Whenever they occur (also as part of an LV or LVT), we will do a
        one-character look-ahead. If a V is not followed by V or T, or a T is
        not followed by a T, we will insert a special, single-byte primary
        weight (one that is less than all Ls, Vs, and Ts).</li>
    </ol>
  </li>
</ol>
<blockquote>
  <p><b>Note: </b>2a is done so that multiple jamo of the same type, which can
  occur in non-modern Hangul, will work correctly. We then get the ordering:</p>
</blockquote>
<center>
<table border="1" cellspacing="0" cellpadding="4">
  <tr>
    <td>L<sub>1</sub>V...</td>
    <td>&#8594;</td>
    <td>L<sub>1</sub></td>
    <td>V</td>
    <td>...&nbsp;</td>
    <td>&nbsp;</td>
    <td rowspan="2">Because V &lt; L, for all L, V</td>
  </tr>
  <tr>
    <td>L<sub>1</sub>L...</td>
    <td>&#8594;</td>
    <td>L<sub>1</sub></td>
    <td>L</td>
    <td>...</td>
    <td>&nbsp;</td>
  </tr>
  <tr>
    <td colspan="7">
      <p align="center">and</td>
  </tr>
  <tr>
    <td>LV<sub>1</sub>T...</td>
    <td>&#8594;</td>
    <td>L</td>
    <td>V<sub>1</sub></td>
    <td>T</td>
    <td>...</td>
    <td rowspan="2">Because T &lt; V, for all V, T</td>
  </tr>
  <tr>
    <td>LV<sub>1</sub>V...</td>
    <td>&#8594;</td>
    <td>L</td>
    <td>V<sub>1</sub></td>
    <td>V</td>
    <td>...</td>
  </tr>
</table>
</center>

</body>

</html>
