<html><head><TITLE>NumberFormat</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  U_I18N_API NumberFormat : public <!2><A HREF="Format.html#DOC.14.8">Format</A> </H2><BLOCKQUOTE>

Abstract base class for all number formats
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=125>
<param name=classes value="CFormat,MFormat.html,CNumberFormat,MNumberFormat.html,CDecimalFormat,MDecimalFormat.html,CChoiceFormat,MChoiceFormat.html">
<param name=before value="M,M,M|_,Mr_">
<param name=after value="Md_,M,M,M">
<param name=indent value="0,1,1,1">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Classes</h3><DD><DT><A HREF="#DOC.19.1"> <IMG BORDER=0 SRC=icon1.gif></A>  enum  <B>EAlignmentFields</B> </B>
 <DD><I>
Alignment Field constants used to construct a FieldPosition object</I>

<DL>
<DT><A HREF="#DOC.19.1.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>INTEGER_FIELD</B> </B>
 <DD><I>
These constants are provided for backwards compatibility only,
and are deprecated</I>

</DL>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.19.2"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>operator==</B>(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const  </B>
 <DD><I>
Return true if the given Format objects are semantically equal</I>
<DT><A HREF="#DOC.19.3"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const  </B>
 <DD><I>
Format an object to produce a string</I>
<DT><A HREF="#DOC.19.4"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>parseObject</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parse_pos) const  </B>
 <DD><I>
Parse a string to produce an object</I>
<DT><A HREF="#DOC.19.5"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>( double number, <!1><A HREF="UnicodeString.html">UnicodeString</A>& output) const  </B>
 <DD><I>
Format a double or long number</I>
<DT><A HREF="#DOC.19.6"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>(double number, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos) const  </B>
 <DD><I>
Format a double or long number</I>
<DT><A HREF="#DOC.19.7"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>parse</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parsePosition) const  </B>
 <DD><I>
Return a long if possible (e</I>
<DT><A HREF="#DOC.19.8"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>parse</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!1><A HREF="Formattable.html">Formattable</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const  </B>
 <DD><I>
Parse a string as a numeric value, and return a Formattable
numeric object</I>
<DT><A HREF="#DOC.19.9"> <IMG BORDER=0 SRC=icon1.gif></A> bool_t  <B>isParseIntegerOnly</B>(void) const  </B>
 <DD><I>
Return true if this format will parse numbers as integers
only</I>
<DT><A HREF="#DOC.19.10"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setParseIntegerOnly</B>(bool_t value) </B>
 <DD><I>
Sets whether or not numbers should be parsed as integers only</I>
<DT><A HREF="#DOC.19.11"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createInstance</B>(<!2><A HREF="#DOC.301">UErrorCode</A>&) </B>
 <DD><I>
Returns the default number format for the current default
locale</I>
<DT><A HREF="#DOC.19.12"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createInstance</B>(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&) </B>
 <DD><I>
Returns the default number format for the specified locale</I>
<DT><A HREF="#DOC.19.25"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createCurrencyInstance</B>(<!2><A HREF="#DOC.301">UErrorCode</A>&) </B>
 <DD><I>
Returns a currency format for the current default locale</I>
<DT><A HREF="#DOC.19.26"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createCurrencyInstance</B>(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&) </B>
 <DD><I>
Returns a currency format for the specified locale</I>
<DT><A HREF="#DOC.19.27"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createPercentInstance</B>(<!2><A HREF="#DOC.301">UErrorCode</A>&) </B>
 <DD><I>
Returns a percentage format for the current default locale</I>
<DT><A HREF="#DOC.19.28"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createPercentInstance</B>(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&) </B>
 <DD><I>
Returns a percentage format for the specified locale</I>
<DT><A HREF="#DOC.19.29"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createScientificInstance</B>(<!2><A HREF="#DOC.301">UErrorCode</A>&) </B>
 <DD><I>
Returns a scientific format for the current default locale</I>
<DT><A HREF="#DOC.19.30"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  <B>createScientificInstance</B>(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&) </B>
 <DD><I>
Returns a scientific format for the specified locale</I>
<DT><A HREF="#DOC.19.31"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  Locale*  <B>getAvailableLocales</B>(int32_t& count) </B>
 <DD><I>
Get the set of Locales for which NumberFormats are installed</I>
<DT><A HREF="#DOC.19.13"> <IMG BORDER=0 SRC=icon1.gif></A> bool_t  <B>isGroupingUsed</B>(void) const  </B>
 <DD><I>
Returns true if grouping is used in this format</I>
<DT><A HREF="#DOC.19.14"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setGroupingUsed</B>(bool_t newValue) </B>
 <DD><I>
Set whether or not grouping will be used in this format</I>
<DT><A HREF="#DOC.19.15"> <IMG BORDER=0 SRC=icon1.gif></A> int32_t  <B>getMaximumIntegerDigits</B>(void) const  </B>
 <DD><I>
Returns the maximum number of digits allowed in the integer portion of a
number</I>
<DT><A HREF="#DOC.19.16"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setMaximumIntegerDigits</B>(int32_t newValue) </B>
 <DD><I>
Sets the maximum number of digits allowed in the integer portion of a
number</I>
<DT><A HREF="#DOC.19.17"> <IMG BORDER=0 SRC=icon1.gif></A> int32_t  <B>getMinimumIntegerDigits</B>(void) const  </B>
 <DD><I>
Returns the minimum number of digits allowed in the integer portion of a
number</I>
<DT><A HREF="#DOC.19.18"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setMinimumIntegerDigits</B>(int32_t newValue) </B>
 <DD><I>
Sets the minimum number of digits allowed in the integer portion of a
number</I>
<DT><A HREF="#DOC.19.19"> <IMG BORDER=0 SRC=icon1.gif></A> int32_t  <B>getMaximumFractionDigits</B>(void) const  </B>
 <DD><I>
Returns the maximum number of digits allowed in the fraction portion of a
number</I>
<DT><A HREF="#DOC.19.20"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setMaximumFractionDigits</B>(int32_t newValue) </B>
 <DD><I>
Sets the maximum number of digits allowed in the fraction portion of a
number</I>
<DT><A HREF="#DOC.19.21"> <IMG BORDER=0 SRC=icon1.gif></A> int32_t  <B>getMinimumFractionDigits</B>(void) const  </B>
 <DD><I>
Returns the minimum number of digits allowed in the fraction portion of a
number</I>
<DT><A HREF="#DOC.19.22"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setMinimumFractionDigits</B>(int32_t newValue) </B>
 <DD><I>
Sets the minimum number of digits allowed in the fraction portion of a
number</I>
<DT><A HREF="#DOC.19.23"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!1><A HREF="ClassID.html">ClassID</A>  <B>getStaticClassID</B>(void) </B>
 <DD><I>
Return the class ID for this class</I>
<DT><A HREF="#DOC.19.24"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="ClassID.html">ClassID</A>  <B>getDynamicClassID</B>(void) const  </B>
 <DD><I>
Override Calendar
Returns a unique class ID POLYMORPHICALLY</I>
</DL><DL>
<DT><h3>Protected Methods</h3><DD><DT><A HREF="#DOC.19.32"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>NumberFormat</B>() </B>
 <DD><I>
Default constructor for subclass use only</I>
<DT><A HREF="#DOC.19.33"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>NumberFormat</B>(const <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>&) </B>
 <DD><I>
Copy constructor</I>
<DT><A HREF="#DOC.19.34"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>&  <B>operator=</B>(const <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>&) </B>
 <DD><I>
Assignment operator</I>
</DL></DL>
<hr><H3>Inherited from <A HREF="Format.html">Format:</A></h3>

<DL>
<DL>
<DT><h3>Public Methods</h3><DD><DT><IMG SRC=icon2.gif> bool_t  <B>operator!=</B>(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const 
<DT><IMG SRC=icon2.gif> virtual  <!2><A HREF="Format.html#DOC.14.8">Format</A>*  <B>clone</B>() const 
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

Abstract base class for all number formats.  Provides interface for
formatting and parsing a number.  Also provides methods for
determining which locales have number formats, and what their names
are.
<P>
NumberFormat helps you to format and parse numbers for any locale.
Your code can be completely independent of the locale conventions
for decimal points, thousands-separators, or even the particular
decimal digits used, or whether the number format is even decimal.
<P>
To format a number for the current Locale, use one of the static
factory methods:
<pre>
.   double myNumber = 7.0;
.   UnicodeString myString;
.   UErrorCode success = ZERO_ERROR;
.   NumberFormat* nf = NumberFormat::createInstance(success)
.   nf->format(myNumber, myString);
.   cout &lt;&lt; " Example 1: " &lt;&lt; myString &lt;&lt; endl;
</pre>
If you are formatting multiple numbers, it is more efficient to get
the format and use it multiple times so that the system doesn't
have to fetch the information about the local language and country
conventions multiple times.
<pre>
.    UnicodeString myString;
.    UErrorCode success = ZERO_ERROR;
.    nf = NumberFormat::createInstance( success );
.    int32_t a[] = { 123, 3333, -1234567 };
.    const int32_t a_len = sizeof(a) / sizeof(a[0]);
.    myString.remove();
.    for (int32_t i = 0; i < a_len; i++) {
.        nf->format(a[i], myString);
.        myString += " ; ";
.    }
.    cout &lt;&lt; " Example 2: " &lt;&lt; myString &lt;&lt; endl;
</pre>
To format a number for a different Locale, specify it in the
call to createInstance().
<pre>
.    nf = NumberFormat::createInstance( Locale::FRENCH, success );
</pre>
You can use a NumberFormat to parse also.
<pre>
.   UErrorCode success;
.   Formattable result(-999);  // initialized with error code
.   nf->parse(myString, result, success);
</pre>
Use createInstance to get the normal number format for that country.
There are other static factory methods available.  Use getCurrency
to get the currency number format for that country.  Use getPercent
to get a format for displaying percentages. With this format, a
fraction from 0.53 is displayed as 53%.
<P>
You can also control the display of numbers with such methods as
getMinimumFractionDigits.  If you want even more control over the
format or parsing, or want to give your users more control, you can
try casting the NumberFormat you get from the factory methods to a
DecimalNumberFormat. This will work for the vast majority of
countries; just remember to put it in a try block in case you
encounter an unusual one.
<P>
You can also use forms of the parse and format methods with
ParsePosition and FieldPosition to allow you to:
<ul type=round>
<li>(a) progressively parse through pieces of a string.
<li>(b) align the decimal point and other areas.
</ul>
For example, you can align numbers in two ways.
<P>
If you are using a monospaced font with spacing for alignment, you
can pass the FieldPosition in your format call, with field =
INTEGER_FIELD. On output, getEndIndex will be set to the offset
between the last character of the integer and the decimal. Add
(desiredSpaceCount - getEndIndex) spaces at the front of the
string.
<P>
If you are using proportional fonts, instead of padding with
spaces, measure the width of the string in pixels from the start to
getEndIndex.  Then move the pen by (desiredPixelWidth -
widthToAlignmentPoint) before drawing the text.  It also works
where there is no decimal, but possibly additional characters at
the end, e.g. with parentheses in negative numbers: "(12)" for -12.

</BLOCKQUOTE>
<DL>

<A NAME="EAlignmentFields">
<A NAME ="DOC.19.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  enum  EAlignmentFields</B></TT>
<DD>
Alignment Field constants used to construct a FieldPosition object.
Signifies that the position of the integer part or fraction part of
a formatted number should be returned.


<DL><DT><B>See Also:</B><DD><!1><A HREF="FieldPosition.html">FieldPosition</A><br></DL><P><DL>

<A NAME="INTEGER_FIELD">
<A NAME ="DOC.19.1.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  INTEGER_FIELD</B></TT>
<DD>
These constants are provided for backwards compatibility only,
and are deprecated.  Please use the C++ style constants defined above.
<DL></DL><P></DL>

<A NAME="operator==">
<A NAME ="DOC.19.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  operator==(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const </B></TT>
<DD>
Return true if the given Format objects are semantically equal.
Objects of different subclasses are considered unequal.
<DL></DL><P>
<A NAME="format">
<A NAME ="DOC.19.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const </B></TT>
<DD>
Format an object to produce a string.  This method handles
Formattable objects with numeric types. If the Formattable
object type is not a numeric type, then it returns a failing
UErrorCode.


<DL><DT><B>Returns:</B><DD>The value passed in as toAppendTo (this allows chaining,
as with UnicodeString::append())
<DT><B>Parameters:</B><DD><B>obj</B> -            The object to format.
<br><B>toAppendTo</B> -     Where the text is to be appended.
<br><B>pos</B> -            On input: an alignment field, if desired.
On output: the offsets of the alignment field.
<br><B>status</B> -         Output param filled with success/failure status.
<br></DL><P>
<A NAME="parseObject">
<A NAME ="DOC.19.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  parseObject(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parse_pos) const </B></TT>
<DD>
Parse a string to produce an object.  This methods handles
parsing of numeric strings into Formattable objects with numeric
types.
<P>
Before calling, set parse_pos.index to the offset you want to
start parsing at in the source. After calling, parse_pos.index
is the end of the text you parsed.  If error occurs, index is
unchanged.
<P>
When parsing, leading whitespace is discarded (with successful
parse), while trailing whitespace is left as is.
<P>
See Format::parseObject() for more.


<DL><DT><B>Returns:</B><DD>A newly created Formattable* object, or NULL
on failure.  The caller owns this and should
delete it when done.
<DT><B>Parameters:</B><DD><B>source</B> -     The string to be parsed into an object.
<br><B>result</B> -     Formattable to be set to the parse result.
If parse fails, return contents are undefined.
<br><B>parse_pos</B> -  The position to start parsing at. Upon return
this param is set to the position after the
last character successfully parsed. If the
source is not parsed successfully, this param
will remain unchanged.
<br></DL><P>
<A NAME="format">
<A NAME ="DOC.19.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format( double number, <!1><A HREF="UnicodeString.html">UnicodeString</A>& output) const </B></TT>
<DD>
Format a double or long number. These methods call the NumberFormat
pure virtual format() methods with the default FieldPosition.


<DL><DT><B>Returns:</B><DD>A reference to 'output' param.
<DT><B>Parameters:</B><DD><B>number</B> -     The value to be formatted.
<br><B>output</B> -     Output param with the formatted string.
<br></DL><P>
<A NAME="format">
<A NAME ="DOC.19.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format(double number, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos) const </B></TT>
<DD>
Format a double or long number. Concrete subclasses must implement
these pure virtual methods.


<DL><DT><B>Returns:</B><DD>A reference to 'toAppendTo'.
<DT><B>Parameters:</B><DD><B>number</B> -      The value to be formatted.
<br><B>toAppendTo</B> -  The string to append the formatted string to.
This is an output parameter.
<br><B>pos</B> -         On input: an alignment field, if desired.
On output: the offsets of the alignment field.
<br></DL><P>
<A NAME="parse">
<A NAME ="DOC.19.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  parse(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parsePosition) const </B></TT>
<DD>
Return a long if possible (e.g. within range LONG_MAX,
LONG_MAX], and with no decimals), otherwise a double.  If
IntegerOnly is set, will stop at a decimal point (or equivalent;
e.g. for rational numbers "1 2/3", will stop after the 1).
<P>
If no object can be parsed, index is unchanged, and NULL is
returned.
<P>
This is a pure virtual which concrete subclasses must implement.


<DL><DT><B>Returns:</B><DD>A Formattable object of numeric type.  The caller
owns this an must delete it.  NULL on failure.
<DT><B>Parameters:</B><DD><B>text</B> -            The text to be parsed.
<br><B>result</B> -          Formattable to be set to the parse result.
If parse fails, return contents are undefined.
<br><B>parsePosition</B> -   The position to start parsing at on input.
On output, moved to after the last successfully
parse character. On parse failure, does not change.
<br></DL><P>
<A NAME="parse">
<A NAME ="DOC.19.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  parse( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!1><A HREF="Formattable.html">Formattable</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const </B></TT>
<DD>
Parse a string as a numeric value, and return a Formattable
numeric object. This method parses integers only if IntegerOnly
is set.


<DL><DT><B>Returns:</B><DD>A Formattable object of numeric type.  The caller
owns this an must delete it.  NULL on failure.

<DT><B>Parameters:</B><DD><B>text</B> -           The text to be parsed.
<br><B>result</B> -         Formattable to be set to the parse result.
If parse fails, return contents are undefined.
<br><B>status</B> -         Success or failure output parameter.
<br><DT><B>See Also:</B><DD><!2><A HREF="NumberFormat.html#DOC.19.9">NumberFormat::isParseIntegerOnly</A><br></DL><P>
<A NAME="isParseIntegerOnly">
<A NAME ="DOC.19.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool_t  isParseIntegerOnly(void) const </B></TT>
<DD>
Return true if this format will parse numbers as integers
only.  For example in the English locale, with ParseIntegerOnly
true, the string "1234." would be parsed as the integer value
1234 and parsing would stop at the "." character.  Of course,
the exact format accepted by the parse operation is locale
dependant and determined by sub-classes of NumberFormat.
<DL></DL><P>
<A NAME="setParseIntegerOnly">
<A NAME ="DOC.19.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setParseIntegerOnly(bool_t value)</B></TT>
<DD>
Sets whether or not numbers should be parsed as integers only
<DL><DT><B>See Also:</B><DD><!2><A HREF="NumberFormat.html#DOC.19.9">isParseIntegerOnly</A><br></DL><P>
<A NAME="createInstance">
<A NAME ="DOC.19.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  createInstance(<!2><A HREF="#DOC.301">UErrorCode</A>&)</B></TT>
<DD>
Returns the default number format for the current default
locale.  The default format is one of the styles provided by
the other factory methods: getNumberInstance,
getCurrencyInstance or getPercentInstance.  Exactly which one
is locale dependant.
<DL></DL><P>
<A NAME="createInstance">
<A NAME ="DOC.19.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  createInstance(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&)</B></TT>
<DD>
Returns the default number format for the specified locale.
The default format is one of the styles provided by the other
factory methods: getNumberInstance, getCurrencyInstance or
getPercentInstance.  Exactly which one is locale dependant.
<DL></DL><P>
<A NAME="createCurrencyInstance">
<A NAME ="DOC.19.25">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  createCurrencyInstance(<!2><A HREF="#DOC.301">UErrorCode</A>&)</B></TT>
<DD>
Returns a currency format for the current default locale
<DL></DL><P>
<A NAME="createCurrencyInstance">
<A NAME ="DOC.19.26">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  createCurrencyInstance(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&)</B></TT>
<DD>
Returns a currency format for the specified locale
<DL></DL><P>
<A NAME="createPercentInstance">
<A NAME ="DOC.19.27">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  createPercentInstance(<!2><A HREF="#DOC.301">UErrorCode</A>&)</B></TT>
<DD>
Returns a percentage format for the current default locale
<DL></DL><P>
<A NAME="createPercentInstance">
<A NAME ="DOC.19.28">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  createPercentInstance(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&)</B></TT>
<DD>
Returns a percentage format for the specified locale
<DL></DL><P>
<A NAME="createScientificInstance">
<A NAME ="DOC.19.29">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  createScientificInstance(<!2><A HREF="#DOC.301">UErrorCode</A>&)</B></TT>
<DD>
Returns a scientific format for the current default locale
<DL></DL><P>
<A NAME="createScientificInstance">
<A NAME ="DOC.19.30">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>*  createScientificInstance(const Locale& inLocale, <!2><A HREF="#DOC.301">UErrorCode</A>&)</B></TT>
<DD>
Returns a scientific format for the specified locale
<DL></DL><P>
<A NAME="getAvailableLocales">
<A NAME ="DOC.19.31">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  Locale*  getAvailableLocales(int32_t& count)</B></TT>
<DD>
Get the set of Locales for which NumberFormats are installed
<DL></DL><P>
<A NAME="isGroupingUsed">
<A NAME ="DOC.19.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool_t  isGroupingUsed(void) const </B></TT>
<DD>
Returns true if grouping is used in this format. For example,
in the English locale, with grouping on, the number 1234567
might be formatted as "1,234,567". The grouping separator as
well as the size of each group is locale dependant and is
determined by sub-classes of NumberFormat.

<DL><DT><B>See Also:</B><DD><!2><A HREF="NumberFormat.html#DOC.19.14">setGroupingUsed</A><br></DL><P>
<A NAME="setGroupingUsed">
<A NAME ="DOC.19.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setGroupingUsed(bool_t newValue)</B></TT>
<DD>
Set whether or not grouping will be used in this format
<DL><DT><B>See Also:</B><DD>getGroupingUsed<br></DL><P>
<A NAME="getMaximumIntegerDigits">
<A NAME ="DOC.19.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int32_t  getMaximumIntegerDigits(void) const </B></TT>
<DD>
Returns the maximum number of digits allowed in the integer portion of a
number
<DL><DT><B>See Also:</B><DD><!2><A HREF="NumberFormat.html#DOC.19.16">setMaximumIntegerDigits</A><br></DL><P>
<A NAME="setMaximumIntegerDigits">
<A NAME ="DOC.19.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setMaximumIntegerDigits(int32_t newValue)</B></TT>
<DD>
Sets the maximum number of digits allowed in the integer portion of a
number. maximumIntegerDigits must be >= minimumIntegerDigits.  If the
new value for maximumIntegerDigits is less than the current value
of minimumIntegerDigits, then minimumIntegerDigits will also be set to
the new value.


<DL><DT><B>See Also:</B><DD><!2><A HREF="NumberFormat.html#DOC.19.15">getMaximumIntegerDigits</A><br></DL><P>
<A NAME="getMinimumIntegerDigits">
<A NAME ="DOC.19.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int32_t  getMinimumIntegerDigits(void) const </B></TT>
<DD>
Returns the minimum number of digits allowed in the integer portion of a
number
<DL><DT><B>See Also:</B><DD><!2><A HREF="NumberFormat.html#DOC.19.18">setMinimumIntegerDigits</A><br></DL><P>
<A NAME="setMinimumIntegerDigits">
<A NAME ="DOC.19.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setMinimumIntegerDigits(int32_t newValue)</B></TT>
<DD>
Sets the minimum number of digits allowed in the integer portion of a
number. minimumIntegerDigits must be &lt;= maximumIntegerDigits.  If the
new value for minimumIntegerDigits exceeds the current value
of maximumIntegerDigits, then maximumIntegerDigits will also be set to
the new value.

<DL><DT><B>See Also:</B><DD><!2><A HREF="NumberFormat.html#DOC.19.17">getMinimumIntegerDigits</A><br></DL><P>
<A NAME="getMaximumFractionDigits">
<A NAME ="DOC.19.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int32_t  getMaximumFractionDigits(void) const </B></TT>
<DD>
Returns the maximum number of digits allowed in the fraction portion of a
number
<DL><DT><B>See Also:</B><DD><!2><A HREF="NumberFormat.html#DOC.19.20">setMaximumFractionDigits</A><br></DL><P>
<A NAME="setMaximumFractionDigits">
<A NAME ="DOC.19.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setMaximumFractionDigits(int32_t newValue)</B></TT>
<DD>
Sets the maximum number of digits allowed in the fraction portion of a
number. maximumFractionDigits must be >= minimumFractionDigits.  If the
new value for maximumFractionDigits is less than the current value
of minimumFractionDigits, then minimumFractionDigits will also be set to
the new value.

<DL><DT><B>See Also:</B><DD><!2><A HREF="NumberFormat.html#DOC.19.19">getMaximumFractionDigits</A><br></DL><P>
<A NAME="getMinimumFractionDigits">
<A NAME ="DOC.19.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int32_t  getMinimumFractionDigits(void) const </B></TT>
<DD>
Returns the minimum number of digits allowed in the fraction portion of a
number
<DL><DT><B>See Also:</B><DD><!2><A HREF="NumberFormat.html#DOC.19.22">setMinimumFractionDigits</A><br></DL><P>
<A NAME="setMinimumFractionDigits">
<A NAME ="DOC.19.22">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setMinimumFractionDigits(int32_t newValue)</B></TT>
<DD>
Sets the minimum number of digits allowed in the fraction portion of a
number. minimumFractionDigits must be &lt;= maximumFractionDigits.   If the
new value for minimumFractionDigits exceeds the current value
of maximumFractionDigits, then maximumIntegerDigits will also be set to
the new value

<DL><DT><B>See Also:</B><DD><!2><A HREF="NumberFormat.html#DOC.19.21">getMinimumFractionDigits</A><br></DL><P>
<A NAME="getStaticClassID">
<A NAME ="DOC.19.23">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!1><A HREF="ClassID.html">ClassID</A>  getStaticClassID(void)</B></TT>
<DD>
Return the class ID for this class.  This is useful only for
comparing to a return value from getDynamicClassID().  For example:
<pre>
.   Base* polymorphic_pointer = createPolymorphicObject();
.   if (polymorphic_pointer->getDynamicClassID() ==
.       Derived::getStaticClassID()) ...
</pre>

<DL><DT><B>Returns:</B><DD>The class ID for all objects of this class.
</DL><P>
<A NAME="getDynamicClassID">
<A NAME ="DOC.19.24">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="ClassID.html">ClassID</A>  getDynamicClassID(void) const </B></TT>
<DD>
Override Calendar
Returns a unique class ID POLYMORPHICALLY.  Pure virtual override.
This method is to implement a simple version of RTTI, since not all
C++ compilers support genuine RTTI.  Polymorphic operator==() and
clone() methods call this method.
<P>

<DL><DT><B>Returns:</B><DD>The class ID for this object. All objects of a
given class have the same class ID.  Objects of
other classes have different class IDs.
</DL><P>
<A NAME="NumberFormat">
<A NAME ="DOC.19.32">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  NumberFormat()</B></TT>
<DD>
Default constructor for subclass use only
<DL></DL><P>
<A NAME="NumberFormat">
<A NAME ="DOC.19.33">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  NumberFormat(const <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>&)</B></TT>
<DD>
Copy constructor
<DL></DL><P>
<A NAME="operator=">
<A NAME ="DOC.19.34">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>&  operator=(const <!2><A HREF="NumberFormat.html#DOC.19.33">NumberFormat</A>&)</B></TT>
<DD>
Assignment operator
<DL></DL><P></DL>
<hr>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="DecimalFormat.html"> DecimalFormat </A><br>
<A HREF="ChoiceFormat.html"> ChoiceFormat </A><br>
</DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
