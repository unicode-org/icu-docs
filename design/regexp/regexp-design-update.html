<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>


  
  
  <meta content="text/html;charset=UTF-8" http-equiv="Content-Type">
<!-- Copyright (C) 2007 International Business Machines Corporation, Google, and others. All Rights Reserved -->


  
  
  
  
  <title>ICU Regular Expressions Update</title>
  <meta content="Andy Heninger" name="author">
</head>


<body>





<h2> ICU Regular Expression Revisions for Improved Java
Compatibility
</h2>





<br>





Here is a proposal for an update to ICU regular expressions to improve
compatibility with Java regular expressions.&nbsp; ICU is actually pretty close to Java
already, and
these changes will clean up most of the remaining differences.<br>





<br>
11/14/2007 Draft 0.3 &nbsp;Add plain C APIs<br>





10/02/2007 Draft 0.2 <br>





Andy Heninger<br>





<h3> Modes
</h3>





ICU could support multiple modes for regular expressions - a Java
compatible
mode, a Perl compatible mode, a classic ICU mode, and possibly
more.&nbsp;
However, this complicates both the API and the
implementation.&nbsp; And there
is no "good" choice for the default mode -- if it is not classic ICU we
run the
risk of breaking existing users anyhow, and if it is classic ICU we
continue to
trip up users with ICU's non-standard behavior.<br>





<br>





The bottom line:&nbsp; No modes.&nbsp; All of ICU's existing
Regular Expression
functionality remains available, with some minor syntax differences.<br>





<br>





<h3> Proposed ICU Regular Expression Syntax
</h3>





Most of the syntax for ICU regular expressions will exactly follow the
Java
specification, and it isn't repeated here. &nbsp;Java Regular
Expressions are described here: <a href="http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html">http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html</a>
<br>





<br>





Because there are differences with Java in the area of character class
expressions, the proposed ICU syntax is described here.<br>





<br>





<p> <b> ICU Set Expressions </b>
</p>





<br>





Here is the approximate grammar of an ICU set, or bracket,
expression.&nbsp; There are
some constraints that are not easily expressed in this kind of syntax
notation
that are described in text at the end.<br>





<br>





<br>





<div>
<table id="gov." border="1" bordercolor="#666666" cellpadding="3" cellspacing="0">





  <tbody>





    <tr>





      <td> set expression<br>





      </td>





      <td> '['&nbsp; '^'?&nbsp; ']'?&nbsp;
[intersection or difference]?&nbsp; ']'<br>





      </td>





      <td> notes 1, 2<br>





      </td>





    </tr>





    <tr>





      <td> intersection or difference<br>





      </td>





      <td> term (('&amp;' | '&amp;&amp;' | '-' |
'--') term)*<br>





      </td>





      <td> note 3, 4<br>





      </td>





    </tr>





    <tr>





      <td> term<br>





      </td>





      <td> (property expression |<br>





range |<br>





single char |<br>





set expression) +<br>





      <br>





      </td>





      <td><br>





      </td>





    </tr>





    <tr>





      <td> property expression<br>





      </td>





      <td> '\p{' property '}' |<br>





'\P{' property '}' |<br>





'[:' property ':]'&nbsp; &nbsp; |<br>




'[:^' property ':]' |<br>





'\d' | '\D' |<br>





'\s' | '\S' |<br>





'\w | '\W'<br>





      </td>





      <td> <br>





      </td>





    </tr>





    <tr>





      <td> range<br>





      </td>





      <td> single char '-' single char<br>





      </td>





      <td> note 5<br>





      </td>





    </tr>





    <tr>





      <td> single char<br>





      </td>





      <td><span style="font-style: italic;">z</span>&nbsp;&nbsp;&nbsp;
The character z, for all characters other than '\'<br>





\\&nbsp;&nbsp;&nbsp; The backslash character<br>





\<span style="font-style: italic;">z</span> &nbsp;&nbsp;
For ASCII letters and digits, either<br>





&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
a special meaning, listed separately, or<br>





&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
an error.<br>





&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; For characters other
than ASCII letters and digits,<br>





&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <span style="font-style: italic;">z</span>,
the character itself.<br>





      <br>





\uhhhh or \Uhhhhhhhh&nbsp; <br>




\xhh &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (exactly two hex digits)<br>




\x{hhhhhh} &nbsp; &nbsp; (1 to 6 hex digits)<br>





\N{Unicode Character Name}<br>





\0ooo&nbsp;&nbsp;&nbsp; (1 to 3 octal digits)<br>





\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(tab)<br>





\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(new line)<br>





\r&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(carriage return<br>





\f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(form feed)<br>





\a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(bell, \u0007)<br>





\e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(escape)<br>





\cx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; the
control character corresponding to x<br>


\b &nbsp; &nbsp; &nbsp; &nbsp;(back space) (Java compatibility warning)<br>


\v &nbsp; &nbsp; &nbsp; &nbsp;(vertical tab) (Java compatibility warning)<br>





      <br>





      <br>





      </td>





      <td> note 6<br>





      </td>





    </tr>





    <tr>





      <td> property<br>





      </td>





      <td> Anything recognized by the ICU property APIs, plus<br>





&nbsp;- POSIX compatibility property names from<br>





&nbsp;&nbsp;
http://www.unicode.org/reports/tr18/#Compatibility_Properties<br>





&nbsp;- Alternate names for Unicode Blocks of the form<br>





&nbsp;&nbsp; InBlockName<br>





      <br>





      </td>





      <td> <br>





      </td>





    </tr>





  
  
  
  
  </tbody>
</table>





<br>





Notes<br>





<ol>





  <li> Negation (^) can only appear immediately following an
opening bracket, and applies to the entire expression within the
matching brackets.&nbsp; In other locations within a set
expression0, a '^' is treated as a literal character. </li>





  <li> A ']' as the first character in a set is treated as a
literal, and does not close the set.&nbsp; No other characters have
special behavior in this opening position. </li>





  <li> A '-' or '&amp;' is recognized as a difference or
intersection operator only when appearing between closing and opening
brackets.&nbsp; Note that a '-' can mean three different things,
depending on the context:&nbsp; 1) a set difference operation, as
described here, 2) part of a range, i.e. [a-z], and 3) a character
literal.&nbsp;&nbsp; The single '-' and '&amp;' forms of
the set difference and intersection are included for compatibility with
original ICU behavior. The double dash '--' set difference operator is
new to this proposal, and is included to maintain symmetry with Java's
'&amp;&amp;' operator. </li>





  <li> Intersection and Difference operators have the same
precedence and are evaluated left to right.<br>





  </li>





  <li> Ranges are based on Unicode code point values.&nbsp; A
range with the lower bound greater than the upper bound is an error.</li>





  <li>This set of single character escapes exactly matches those
supported by Java.</li>





</ol>





<br>





<br>





Precedence of Character Class operators<br>





<br>





<div>
<table id="dwkq" border="1" bordercolor="#666666" cellpadding="3" cellspacing="0">





  <tbody>





    <tr>





      <td> 1&nbsp;&nbsp;<br>





      </td>





      <td> escaping<br>





      </td>





      <td> \$<br>





      </td>





    </tr>





    <tr>





      <td> 2<br>





      </td>





      <td> grouping<br>





      </td>





      <td> [...]<br>





      </td>





    </tr>





    <tr>





      <td> 3<br>





      </td>





      <td> range<br>





      </td>





      <td> a-z<br>





      </td>





    </tr>





    <tr>





      <td> 4<br>





      </td>





      <td> union<br>





      </td>





      <td> \p{Letter}\p{Number}<br>





      </td>





    </tr>





    <tr>





      <td> 5<br>





      </td>





      <td> intersection and difference&nbsp;&nbsp;<br>





      </td>





      <td> \p{Letter}&amp;&amp;\p{script=Hebrew}<br>





      </td>





    </tr>





  
  
  
  
  </tbody>
</table>





</div>





<br>




<br>




<h3>API Additions</h3>




Most of the proposed new functions correspond directly to methods added to Java regular expressions in Java 1.5<br>




<br>




In file uregex.h (the plain C API)<br>




<br>




<br style="font-family: monospace;">




<div style="margin-left: 40px;"><span style="font-family: monospace;"><span style="color: rgb(102, 102, 102);">/**</span><br style="color: rgb(102, 102, 102);">
<span style="color: rgb(102, 102, 102);">&nbsp;* Constants for Regular Expression Match Modes.</span><br style="color: rgb(102, 102, 102);">
<span style="color: rgb(102, 102, 102);">&nbsp;* @stable ICU 2.4</span><br style="color: rgb(102, 102, 102);">
<span style="color: rgb(102, 102, 102);">&nbsp;*/</span><br style="color: rgb(102, 102, 102);">
<span style="color: rgb(102, 102, 102);">typedef enum URegexpFlag{</span><br style="color: rgb(102, 102, 102);">
<br>
&nbsp; &nbsp; /**&nbsp; If set, only '\n' line terminator is recognized in the behavior of ., ^ and $.</span><br>




<span style="font-family: monospace;">&nbsp; &nbsp; &nbsp; * &nbsp;The embedded pattern flag 'd' will also enable this mode.</span><br>




<span style="font-family: monospace;">&nbsp; &nbsp; &nbsp; * &nbsp;This option is provided primarily for compatibility with Java regular expressions.</span><br style="font-family: monospace;">




<span style="font-family: monospace;"></span><span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *&nbsp; @draft ICU 4.0 */</span><br style="font-family: monospace;">




&nbsp;<span style="font-family: monospace;">&nbsp;&nbsp; UREGEX_UNIX_LINES &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; = 16,<br>
<br>
<span style="font-style: italic;">[----snip----]<br>
<br>
</span>



<br>




/** Sets the limits of the matching region for this URegularExpression.<br>
&nbsp; * The region is the part of the input string that will be considered when matching.<br>
&nbsp; * Invoking this method resets any saved state from the previous match, <br>
&nbsp; * then sets the region to start at the index specified by the start parameter<br>
&nbsp; * and end at the index specified by the end parameter.<br>
&nbsp; *<br>
&nbsp; * Depending on the transparency and anchoring being used (see useTransparentBounds<br>
&nbsp; * and useAnchoringBounds), certain constructs such as anchors may behave differently<br>
&nbsp; * at or around the boundaries of the region<br>
&nbsp; *<br>
&nbsp; * The function will fail if start is greater than limit, or if either index<br>
&nbsp; *&nbsp; is less than zero or greater than the length of the string being matched.<br>
&nbsp; *<br>
&nbsp; * @param regexp The compiled regular expression.<br>
&nbsp; * @param start&nbsp; The index to begin searches at.<br>
&nbsp; * @param limit&nbsp; The index to end searches at (exclusive).<br>
&nbsp; * @param status A reference to a UErrorCode to receive any errors.<br>
&nbsp; * @draft ICU 4.0<br>
&nbsp; */<br>
U_DRAFT void U_EXPORT2<br>
uregex_setRegion(URegularExpression&nbsp;&nbsp; *regexp,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
regionStart,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
regionLimit,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>
/**<br>
&nbsp; * Reports the start index of the matching region. Any matches found are limited to<br>
&nbsp; * to the region bounded by regionStart (inclusive) and regionEnd (exclusive).<br>
&nbsp; *<br>
&nbsp; * @return The starting index of this matcher's region.<br>
&nbsp; * @draft ICU 4.0<br>
&nbsp; */<br>
U_DRAFT int32_t U_EXPORT2<br>
uregex_regionStart(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);<br>
<br>
<br>
<br>
/**<br>
&nbsp; * Reports the end index (exclusive) of the matching region for this URegularExpression.<br>
&nbsp; * Any matches found are limited to to the region bounded by regionStart (inclusive)<br>
&nbsp; * and regionEnd (exclusive).<br>
&nbsp; *<br>
&nbsp; * @return The ending point of this matcher's region.<br>
&nbsp; * @draft ICU 4.0<br>
&nbsp; */<br>
U_DRAFT int32_t U_EXPORT2<br>
uregex_regionEnd(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);<br>
<br>
/**<br>
&nbsp; * Queries the transparency of region bounds for this URegularExpression.<br>
&nbsp; * See useTransparentBounds for a description of transparent and opaque bounds.<br>
&nbsp; * By default, matching boundaries are opaque.<br>
&nbsp; *<br>
&nbsp; * @return TRUE if this matcher is using opaque bounds, false if it is not.<br>
&nbsp; * @draft ICU 4.0<br>
&nbsp; */<br>
U_DRAFT UBool U_EXPORT2<br>
uregex_hasTransparentBounds(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);<br>
<br>
<br>
/**<br>
&nbsp; * Sets the transparency of region bounds for this URegularExpression.<br>
&nbsp; * Invoking this function with an argument of TRUE will set matches to use transparent bounds.<br>
&nbsp; * If the boolean argument is FALSE, then opaque bounds will be used.<br>
&nbsp; *<br>
&nbsp; * Using transparent bounds, the boundaries of the matching region are transparent<br>
&nbsp; * to lookahead, lookbehind, and boundary matching constructs. Those constructs can<br>
&nbsp; * see text beyond the boundaries of the region while checking for a match.<br>
&nbsp; *<br>
&nbsp; * With opaque bounds, no text outside of the matching region is visible to lookahead,<br>
&nbsp; * lookbehind, and boundary matching constructs.<br>
&nbsp; *<br>
&nbsp; * By default, a matcher uses opaque bounds.<br>
&nbsp; *<br>
&nbsp; * @param&nbsp;&nbsp; b TRUE for transparent bounds; FALSE for opaque bounds<br>
&nbsp; * @return&nbsp; This Matcher;<br>
&nbsp; * @draft&nbsp;&nbsp; ICU 4.0<br>
&nbsp; **/<br>
U_DRAFT void U_EXPORT2&nbsp; <br>
uregex_useTransparentBounds(URegularExpression&nbsp;&nbsp; *regexp, <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
b,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);<br>
<br>
&nbsp; <br>
/**<br>
&nbsp; * Return true if this matcher is using anchoring bounds.<br>
&nbsp; * By default, matchers use anchoring region boounds.<br>
&nbsp; *<br>
&nbsp; * @return TRUE if this matcher is using anchoring bounds.<br>
&nbsp; * @draft&nbsp; ICU 4.0<br>
&nbsp; */&nbsp;&nbsp;&nbsp; <br>
U_DRAFT UBool U_EXPORT2<br>
uregex_hasAnchoringBounds(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);<br>
<br>
<br>
/**<br>
&nbsp; * Set whether this URegularExpression is using Anchoring Bounds for its region.<br>
&nbsp; * With anchoring bounds, pattern anchors such as ^ and $ will match at the start<br>
&nbsp; * and end of the region.&nbsp; Without Anchoring Bounds, anchors will only match at<br>
&nbsp; * the positions they would in the complete text.<br>
&nbsp; *<br>
&nbsp; * Anchoring Bounds are the default for regions.<br>
&nbsp; *<br>
&nbsp; * @param b TRUE if to enable anchoring bounds; FALSE to disable them.<br>
&nbsp; * @return&nbsp; This Matcher<br>
&nbsp; * @draft&nbsp;&nbsp; ICU 4.0<br>
&nbsp; */<br>
U_DRAFT void U_EXPORT2<br>
uregex_useAnchoringBounds(URegularExpression&nbsp;&nbsp; *regexp,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
b,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);<br>
<br>
/**<br>
&nbsp; * Return TRUE if the most recent matching operation touched the<br>
&nbsp; *&nbsp; end of the text being processed.&nbsp; In this case, additional input text could<br>
&nbsp; *&nbsp; change the results of that match.<br>
&nbsp; *<br>
&nbsp; *&nbsp; @return&nbsp; TRUE if the most recent match hit the end of input<br>
&nbsp; *&nbsp; @draft&nbsp;&nbsp; ICU 4.0<br>
&nbsp; */<br>
U_DRAFT UBool U_EXPORT2<br>
uregex_hitEnd(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);<br>
<br>
/**<br>
&nbsp; * Return TRUE the most recent match succeeded and additional input could cause<br>
&nbsp; * it to fail. If this function returns false and a match was found, then more input<br>
&nbsp; * might change the match but the match won't be lost. If a match was not found,<br>
&nbsp; * then requireEnd has no meaning.<br>
&nbsp; *<br>
&nbsp; * @return TRUE if more input could cause the most recent match to no longer match.<br>
&nbsp; * @draft&nbsp; ICU 4.0<br>
&nbsp; */<br>
U_DRAFT UBool U_EXPORT2&nbsp;&nbsp; <br>
uregex_requireEnd(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);<br>
<br>
<br>
<span style="color: rgb(204, 0, 0);"></span><br>




<br style="font-family: monospace;">




</span></div>




<br>




In file regex.h, <br>




<br>




<div style="margin-left: 40px;"><span style="font-family: monospace;">class U_I18N_API RegexMatcher: public UObject {</span><br style="font-family: monospace;">




<span style="font-family: monospace;">public:<br>




<br>




<br>




&nbsp; &nbsp;/** Sets the limits of this matcher's region. <br>




&nbsp; &nbsp; &nbsp;* The region is the part of the input string that will be searched to find a match.<br>




&nbsp; &nbsp; &nbsp;* Invoking this method resets the matcher, and then sets the region to start<br>




&nbsp; &nbsp; &nbsp;* at the index specified by the start parameter and end at the index specified<br>




&nbsp; &nbsp; &nbsp;* by the end parameter.<br>




&nbsp; &nbsp; &nbsp;*<br>




&nbsp; &nbsp; &nbsp;* Depending on the transparency and anchoring being used (see useTransparentBounds<br>




&nbsp; &nbsp; &nbsp;* and useAnchoringBounds), certain constructs such as anchors may behave differently<br>




&nbsp; &nbsp; &nbsp;* at or around the boundaries of the region<br>




&nbsp; &nbsp; &nbsp;*<br>




&nbsp; &nbsp; &nbsp;* The function will fail if start is greater than limit, or if either index<br>




&nbsp; &nbsp; &nbsp;* &nbsp;is less than zero or greater than the length of the string being matched.<br>




&nbsp; &nbsp; &nbsp;*<br>




&nbsp; &nbsp; &nbsp;* @param start &nbsp;The index to begin searches at.<br>




&nbsp; &nbsp; &nbsp;* @param limit &nbsp;The index to end searches at (exclusive).<br>




&nbsp; &nbsp; &nbsp;* @param status A reference to a UErrorCode to receive any errors.<br>




&nbsp; &nbsp; &nbsp;* @draft ICU 4.0<br>




&nbsp; &nbsp; &nbsp;*/<br>




&nbsp; &nbsp; &nbsp;virtual RegexMatcher &amp;region(int32_t start, int32_t limit, UErrorCode &amp;status);<br>




<br>




<br>




&nbsp; &nbsp;/**<br>




&nbsp; &nbsp; &nbsp;* Reports the start index of this matcher's region. The searches this matcher<br>




&nbsp; &nbsp; &nbsp;* conducts are limited to finding matches within regionStart (inclusive) and <br>




&nbsp; &nbsp; &nbsp;* regionEnd (exclusive).<br>




&nbsp; &nbsp; &nbsp;*<br>




&nbsp; &nbsp; &nbsp;* @return The starting index of this matcher's region.<br>




</span><span style="font-family: monospace;">&nbsp; &nbsp; &nbsp;* @draft ICU 4.0</span><br>




<span style="font-family: monospace;">&nbsp; &nbsp; &nbsp;*/<br>




&nbsp; &nbsp; &nbsp;virtual int regionStart() const;<br>




<br>




<br>




&nbsp; &nbsp; /**<br>




&nbsp; &nbsp; &nbsp; * Reports the end (limit) index (exclusive) of this matcher's region. The searches<br>




&nbsp; &nbsp; &nbsp; * this matcher conducts are limited to finding matches within regionStart<br>




&nbsp; &nbsp; &nbsp; * (inclusive) and regionEnd (exclusive).<br>




&nbsp; &nbsp; &nbsp; *<br>




&nbsp; &nbsp; &nbsp; * @return The ending point of this matcher's region.<br>




</span><span style="font-family: monospace;">&nbsp; &nbsp; &nbsp; * @draft ICU 4.0</span><br>




<span style="font-family: monospace;">&nbsp; &nbsp; &nbsp; */<br>




&nbsp; &nbsp; &nbsp; virtual int regionEnd() const;<br>




<br>




<br>




&nbsp; &nbsp; /**<br>




&nbsp;&nbsp;&nbsp; &nbsp; * Queries the transparency of region bounds for this matcher.<br>




&nbsp;&nbsp;&nbsp; &nbsp; * See useTransparentBounds for a description of transparent and opaque bounds.<br>




&nbsp;&nbsp;&nbsp; &nbsp; * By default, a matcher uses opaque region boundaries.<br>




&nbsp; &nbsp; &nbsp; *<br>




&nbsp; &nbsp; &nbsp; * @return TRUE if this matcher is using opaque bounds, false if it is not.<br>




&nbsp; &nbsp; &nbsp; * @draft ICU 4.0<br>




&nbsp; &nbsp; &nbsp; */<br>




&nbsp; &nbsp; &nbsp; virtual UBool hasTransparentBounds() const;<br>




<br>




&nbsp; &nbsp; /**<br>




&nbsp; &nbsp; &nbsp; * Sets the transparency of region bounds for this matcher.<br>




&nbsp; &nbsp; &nbsp; * Invoking this function with an argument of true will set this matcher to use transparent bounds.<br>




&nbsp; &nbsp; &nbsp; * If the boolean argument is false, then opaque bounds will be used.<br>




&nbsp; &nbsp; &nbsp; *<br>




&nbsp; &nbsp; &nbsp; * Using transparent bounds, the boundaries of this matcher's region are transparent<br>




&nbsp; &nbsp; &nbsp; * to lookahead, lookbehind, and boundary matching constructs. Those constructs can<br>




&nbsp; &nbsp; &nbsp; * see text beyond the boundaries of the region while checking for a match.<br>




&nbsp; &nbsp; &nbsp; *<br>




&nbsp; &nbsp; &nbsp; * With opaque bounds, no text outside of the matcher's region is visible to lookahead,<br>




&nbsp; &nbsp; &nbsp; * lookbehind, and boundary matching constructs.<br>




&nbsp; &nbsp; &nbsp; *<br>




&nbsp; &nbsp; &nbsp; * By default, a matcher uses opaque bounds. <br>




&nbsp; &nbsp; &nbsp; *<br>




&nbsp; &nbsp; &nbsp; * @param &nbsp; b TRUE for transparent bounds; FALSE for opaque bounds<br>




&nbsp; &nbsp; &nbsp; * @return &nbsp;This Matcher;<br>




&nbsp; &nbsp; &nbsp; * @draft &nbsp; ICU 4.0<br>




&nbsp; &nbsp; &nbsp; **/<br>




&nbsp; &nbsp; &nbsp; virtual RegexMatcher &amp;useTransparentBounds(UBool b);<br>




<br>




&nbsp; &nbsp; &nbsp;<br>




&nbsp; &nbsp; /**<br>




&nbsp; &nbsp;&nbsp; &nbsp;* Return true if this matcher is using anchoring bounds.<br>




&nbsp; &nbsp; &nbsp; * By default, matchers use anchoring region boounds.<br>




&nbsp; &nbsp;&nbsp; &nbsp;*<br>




&nbsp; &nbsp; &nbsp; * @return TRUE if this matcher is using anchoring bounds.<br>




&nbsp; &nbsp; &nbsp; * @draft &nbsp;ICU 4.0<br>




&nbsp; &nbsp; &nbsp; */&nbsp;&nbsp; &nbsp; <br>




&nbsp; &nbsp; &nbsp; virtual UBool hasAnchoringBounds() const;<br>




<br>




&nbsp; &nbsp; /**<br>




&nbsp; &nbsp; &nbsp; * Set whether this matcher is using Anchoring Bounds for its region.<br>




&nbsp; &nbsp; &nbsp; * With anchoring bounds, pattern anchors such as ^ and $ will match at the start<br>




&nbsp; &nbsp; &nbsp; * and end of the region. &nbsp;Without Anchoring Bounds, anchors will only match at<br>




&nbsp; &nbsp; &nbsp; * the positions they would in the complete text.<br>




&nbsp; &nbsp; &nbsp; *<br>




&nbsp; &nbsp; &nbsp; * Anchoring Bounds are the default for regions.<br>




&nbsp; &nbsp; &nbsp; *<br>




&nbsp; &nbsp; &nbsp; * @param b TRUE if to enable anchoring bounds; FALSE to disable them.<br>




&nbsp; &nbsp; &nbsp; * @return &nbsp;This Matcher<br>




&nbsp; &nbsp; &nbsp; * @draft &nbsp; ICU 4.0<br>




&nbsp; &nbsp; &nbsp; */<br>




&nbsp; &nbsp; &nbsp; virtual RegexMatcher &amp;useAnchoringBounds(UBool b);<br>




<br>




&nbsp; &nbsp; /**<br>




&nbsp; &nbsp; &nbsp; * Return&nbsp;</span><span style="font-family: monospace;">TRUE</span><span style="font-family: monospace;"> if the most recent matching operation touched the end of the<br>




&nbsp; &nbsp; &nbsp; * &nbsp;end of the text being processed. &nbsp;In this case, additional input text could <br>




&nbsp; &nbsp; &nbsp; * &nbsp;change the results of that match.<br>




&nbsp; &nbsp; &nbsp; *<br>




&nbsp; &nbsp; &nbsp; * &nbsp; (TODO: &nbsp;how does this interact with transparent bounds and look-ahead?)<br>




&nbsp; &nbsp; &nbsp; *<br>




&nbsp; &nbsp; &nbsp; * &nbsp;@return &nbsp;TRUE if the most recent match hit the end of input<br>




&nbsp; &nbsp; &nbsp; * &nbsp;@draft &nbsp; ICU 4.0<br>




&nbsp; &nbsp; &nbsp; */<br>




&nbsp; &nbsp; &nbsp; virtual UBool hitEnd() const;<br>




<br>




&nbsp; &nbsp; /**<br>




&nbsp; &nbsp; &nbsp; * Return TRUE the most recent match succeeded and additional input could cause<br>




&nbsp; &nbsp; &nbsp; * it to fail. If this method returns false and a match was found, then more input<br>




&nbsp; &nbsp; &nbsp; * might change the match but the match won't be lost. If a match was not found,<br>




&nbsp; &nbsp; &nbsp; * then requireEnd has no meaning. <br>




&nbsp; &nbsp; &nbsp; *<br>




&nbsp; &nbsp; &nbsp; * @return TRUE if more input could cause the most recent match to no longer match.<br>




&nbsp; &nbsp; &nbsp; * @draft &nbsp;ICU 4.0<br>




&nbsp; &nbsp; &nbsp; */<br>




&nbsp; &nbsp; &nbsp; virtual UBool requireEnd() const;<br>




<br>




<br>




<br>




</span><span style="font-family: monospace;"></span></div>





In file urgegex.h (The<br>
<br>
<span style="font-family: monospace;"></span>
<div style="margin-left: 40px;"><span style="font-family: monospace;">/** Sets the limits of the matching region for this URegularExpression.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * The region is the part of the input string that will be considered when matching.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Invoking this method resets any saved state from the previous match, </span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * then sets the region to start at the index specified by the start parameter</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * and end at the index specified by the end parameter.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Depending on the transparency and anchoring being used (see useTransparentBounds</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * and useAnchoringBounds), certain constructs such as anchors may behave differently</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * at or around the boundaries of the region</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * The function will fail if start is greater than limit, or if either index</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *&nbsp; is less than zero or greater than the length of the string being matched.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @param regexp The compiled regular expression.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @param start&nbsp; The index to begin searches at.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @param limit&nbsp; The index to end searches at (exclusive).</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @param status A reference to a UErrorCode to receive any errors.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @draft ICU 4.0</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; */</span><br style="font-family: monospace;">
<span style="font-family: monospace;">U_DRAFT void U_EXPORT2</span><br style="font-family: monospace;">
<span style="font-family: monospace;">uregex_setRegion(URegularExpression&nbsp;&nbsp; *regexp,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
regionStart,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int32_t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
regionLimit,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><br style="font-family: monospace;">
<span style="font-family: monospace;">/**</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Reports the start index of the matching region. Any matches found are limited to</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * to the region bounded by regionStart (inclusive) and regionEnd (exclusive).</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @return The starting index of this matcher's region.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @draft ICU 4.0</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; */</span><br style="font-family: monospace;">
<span style="font-family: monospace;">U_DRAFT int32_t U_EXPORT2</span><br style="font-family: monospace;">
<span style="font-family: monospace;">uregex_regionStart(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">/**</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Reports the end index (exclusive) of the matching region for this URegularExpression.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Any matches found are limited to to the region bounded by regionStart (inclusive)</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * and regionEnd (exclusive).</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @return The ending point of this matcher's region.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @draft ICU 4.0</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; */</span><br style="font-family: monospace;">
<span style="font-family: monospace;">U_DRAFT int32_t U_EXPORT2</span><br style="font-family: monospace;">
<span style="font-family: monospace;">uregex_regionEnd(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">/**</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Queries the transparency of region bounds for this URegularExpression.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * See useTransparentBounds for a description of transparent and opaque bounds.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * By default, matching boundaries are opaque.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @return TRUE if this matcher is using opaque bounds, false if it is not.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @draft ICU 4.0</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; */</span><br style="font-family: monospace;">
<span style="font-family: monospace;">U_DRAFT UBool U_EXPORT2</span><br style="font-family: monospace;">
<span style="font-family: monospace;">uregex_hasTransparentBounds(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">/**</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Sets the transparency of region bounds for this URegularExpression.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Invoking this function with an argument of TRUE will set matches to use transparent bounds.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * If the boolean argument is FALSE, then opaque bounds will be used.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Using transparent bounds, the boundaries of the matching region are transparent</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * to lookahead, lookbehind, and boundary matching constructs. Those constructs can</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * see text beyond the boundaries of the region while checking for a match.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * With opaque bounds, no text outside of the matching region is visible to lookahead,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * lookbehind, and boundary matching constructs.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * By default, a matcher uses opaque bounds.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @param&nbsp;&nbsp; b TRUE for transparent bounds; FALSE for opaque bounds</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @return&nbsp; This Matcher;</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @draft&nbsp;&nbsp; ICU 4.0</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; **/</span><br style="font-family: monospace;">
<span style="font-family: monospace;">U_DRAFT void U_EXPORT2&nbsp; </span><br style="font-family: monospace;">
<span style="font-family: monospace;">uregex_useTransparentBounds(URegularExpression&nbsp;&nbsp; *regexp, </span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
b,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; </span><br style="font-family: monospace;">
<span style="font-family: monospace;">/**</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Return true if this matcher is using anchoring bounds.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * By default, matchers use anchoring region boounds.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @return TRUE if this matcher is using anchoring bounds.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @draft&nbsp; ICU 4.0</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; */&nbsp;&nbsp;&nbsp; </span><br style="font-family: monospace;">
<span style="font-family: monospace;">U_DRAFT UBool U_EXPORT2</span><br style="font-family: monospace;">
<span style="font-family: monospace;">uregex_hasAnchoringBounds(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">/**</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Set whether this URegularExpression is using Anchoring Bounds for its region.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * With anchoring bounds, pattern anchors such as ^ and $ will match at the start</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * and end of the region.&nbsp; Without Anchoring Bounds, anchors will only match at</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * the positions they would in the complete text.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Anchoring Bounds are the default for regions.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @param b TRUE if to enable anchoring bounds; FALSE to disable them.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @return&nbsp; This Matcher</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @draft&nbsp;&nbsp; ICU 4.0</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; */</span><br style="font-family: monospace;">
<span style="font-family: monospace;">U_DRAFT void U_EXPORT2</span><br style="font-family: monospace;">
<span style="font-family: monospace;">uregex_useAnchoringBounds(URegularExpression&nbsp;&nbsp; *regexp,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UBool&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
b,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">/**</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Return TRUE if the most recent matching operation touched the</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *&nbsp; end of the text being processed.&nbsp; In this case, additional input text could</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *&nbsp; change the results of that match.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *&nbsp; @return&nbsp; TRUE if the most recent match hit the end of input</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *&nbsp; @draft&nbsp;&nbsp; ICU 4.0</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; */</span><br style="font-family: monospace;">
<span style="font-family: monospace;">U_DRAFT UBool U_EXPORT2</span><br style="font-family: monospace;">
<span style="font-family: monospace;">uregex_hitEnd(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<span style="font-family: monospace;">/**</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * Return TRUE the most recent match succeeded and additional input could cause</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * it to fail. If this function returns false and a match was found, then more input</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * might change the match but the match won't be lost. If a match was not found,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * then requireEnd has no meaning.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; *</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @return TRUE if more input could cause the most recent match to no longer match.</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; * @draft&nbsp; ICU 4.0</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp; */</span><br style="font-family: monospace;">
<span style="font-family: monospace;">U_DRAFT UBool U_EXPORT2&nbsp;&nbsp; </span><br style="font-family: monospace;">
<span style="font-family: monospace;">uregex_requireEnd(const&nbsp; URegularExpression&nbsp;&nbsp; *regexp,</span><br style="font-family: monospace;">
<span style="font-family: monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
UErrorCode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*status);</span><br style="font-family: monospace;">
<br style="font-family: monospace;">
<br style="font-family: monospace;">
</div>
<br>
<br>




<h3>
Differences between this Proposal and Java</h3>





<br>





<ol>





  <li> Recognize&nbsp; POSIX style syntax for character
classes, e.g. [:Alpha:].&nbsp; This is in addition to the Java/Perl
style of \p{Alpha}&nbsp; </li>





  <li> POSIX compatibility character classes operate over the
entire Unicode range; they are not limited to ASCII.</li>




  <li>Case-insensitive matching always works over the full Unicode
character set. &nbsp; By default, Java case insensitive matching
assumes that only characters in the US-ASCII charset are being
matched.&nbsp; The Java embedded flag (?u), which enables case
insensitive matching over all Unicode, is ignored. &nbsp;There is
nothing corresponding to Java's UNICODE_CASE flag value for use in API
functions.</li>





  <li> Add support for all Unicode properties.<br>





  </li>





  <li> Add the set difference operator '--'.&nbsp;
Incompatibility is minimal, the operator would look like part of a
highly improbable range expression in Java.<br>





  </li>





  <li> No support for CANON_EQ, but Java's support appears to be
broken anyhow. </li>





  <li> Add \N{UNICODE CHARACTER NAME} </li>





  <li> Add \X which is a test for a grapheme cluster boundary.</li>




  <li>Add \x{hhhhhh} hex escape form (from Perl)</li>
  <li>Unknown embedded flags in a pattern are errors. &nbsp;(Java
treats them as literals, but they are almost certain to be user errors.)</li>





</ol>





<br>




<h3>
Differences with classic ICU</h3>





<br>





<ol>





  <li>Add new API corresponding to the functions added in Java 1.5.</li>




  <li> Backslash escapes of ASCII letters and digits with no
special meaning are taken as the literal ASCII character in old
ICU.&nbsp; (Perl behavior) </li>





  


  <li>Auto-escape of ']' at the first position in a set. &nbsp; This is a pattern compile error now.</li>





  <li>\b and \v (backspace and vertical tab) are not recognized
escapes within set expressions.</li>




  


  <li> No strings in sets.&nbsp; Strings in ICU sets were
enclosed
in {curly brackets}. &nbsp;They were recognized syntactically, then
ignored during matching. &nbsp; Current behavior is essentially a bug. </li>





  <li> &amp;&amp; and -- are recognized in addition to &amp; and -
for set intersection and difference; operands do not need to be
bracketed for the
&amp;&amp; and -- forms. </li>





  




  <li> \p{InBlockName} is added for Unicode Blocks, in addition
to the standard form of [:block=BlockName:] for block names. &nbsp;Add
\p{javaLowerCase, \p{javaWhiteSpace} and other properties from Java. </li>





  <li> $ appearing as the last element of a set is no longer ignored.
&nbsp;(The trailing $ has special meaning for ICU UnicodeSets used with
transliterators.) &nbsp;Current behavior is essentially a bug. </li>





  




  <li> A '-' in a set will be treated as a literal if it can not
be interpreted as a set difference operator or as part of a range.</li>




  



  <li>Add a UNIX_LINES option, and the corresponding 'd' pattern flag,
with which only line feed is recognized as a new-line during matching.</li>




  <li>Octal escapes (\0123) are implemented according to Java
conventions. &nbsp;Existing ICU does not support Octal outside of set
expressions.</li>





</ol>





<br>




<h3>
Differences with Perl.</h3>




Perl regular expression syntax is described at <a href="http://perldoc.perl.org/perlre.html">http://perldoc.perl.org/perlre.html</a><br>





<ol>





  <li>Perl will recognize \p{properties} without the brackets.
&nbsp;\pL for letters, for example.</li>

  <li>Perl does not support nested character classes. &nbsp;In Perl,
[abc[d-f]], the nested '[' is literal and the first ']' closes the set.
&nbsp;In ICU, this is a nested set.</li>





  <li>Java and ICU lack Perl's&nbsp;&nbsp; \l, \u, \L, \U &nbsp;(upper and lower casing of pattern)</li>





  <li>Java and ICU lack Perl's &nbsp;<span style="font-family: monospace;">(?&gt;pattern)</span>
&nbsp;. &nbsp;Equivalent with ICU or Java would be <span style="font-family: monospace;">p(?:pattern){1}+</span></li>





  <li><span style="font-family: monospace;"></span>Java
and ICU lack Perl's conditional expressions, i.e. <span style="font-style: italic;">(?(condition)A|B). &nbsp;</span>There
is nothing directly equivalent in Java.</li>





  <li><code class="inline"></code>Octal escaping is different. &nbsp; In Java and in this
proposal, octal escapes must begin with \0, to distinguish them from
back references.&nbsp;</li>





  <li>ICU supports possessive quantifiers, and set intersection
(&amp;&amp;) and difference (--); Perl does not.</li>





  <li>Perl's \X is not exactly a grapheme cluster. &nbsp;It
is \P{M}\p{M}* . &nbsp; Note this does not match at all when starting on a Mark. &nbsp;ICU's \X will never fail to match.</li>





</ol>





<br>





</div>





<br>





</body>
</html>
