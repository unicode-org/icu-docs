<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Collation Design Document</title>
<style>
<!--
body         { font-family: Times New Roman }
.primary     { background-color: #80FF80; text-align: Center; font-size: 80% }
.secondary   { background-color: #8080FF; text-align: Center; font-size: 80% }
.tertiary    { background-color: #FF8080; text-align: Center; font-size: 80% }
.case        { background-color: #80FFFF; text-align: Center; font-size: 80% }
.flag        { background-color: #FF0000; text-align: Center; font-size: 80% }
.q           { font-style: italic; font-weight: bold }
p            { font-family: Times New Roman }
li           { font-family: Times New Roman }
th           { background-color: #CCCCFF }
-->
</style>
</head>

<body>

<h1 align="center">ICU Collation Design Documentation</h1>
<h2 align="center">Draft #14, MD/2000-01-17</h2>
<h2 align="center"><font color="#0000FF">See <a href="#Modifications">Modifications</a></font></h2>
This document describes the proposed revisions to Collation in ICU. Readers 
should already be familiar with <a
href="http://www.unicode.org/unicode/reports/tr10/">UTS #10: Unicode Collation 
Algorithm</a> (UCA) before proceeding. Examples from the current UCA table can 
be seen at <a
href="http://www.unicode.org/unicode/reports/tr10/charts/Collation00.html">Collation 
Charts</a>.
<p>This document is liberally sprinkled with code fragments. These are meant to 
be illustrative, and will not necessarily match the final implementation. The 
organization of the text could be improved, but we probably won't take the time 
to do it until later.</p>
<h2>Contents</h2>
<p><i>Note: Not all subsections are listed in the contents.</i></p>
<ul>
  <li><a href="#Requirements">Requirements</a></li>
  <li><a href="#Performance">Performance</a></li>
  <li><a href="#Data_Tables">Data Tables</a>
    <ul>
      <li><a href="#Compression">Compression</a></li>
    </ul>
  </li>
  <li><a href="#Forming_Sort_Keys">Forming Sort Keys</a></li>
  <li><a href="#Fetching_CEs">Fetching CEs</a>
    <ul>
      <li><a href="#Implicit_CEs">Implicit CEs</a></li>
    </ul>
  </li>
  <li><a href="#Flat_File">Flat File</a>
    <ul>
      <li><a href="#Details_on_Generation">Details on Generation</a></li>
    </ul>
  </li>
  <li><a href="#UCA_Processing">UCA Processing</a></li>
  <li><a href="#Rule_Syntax">Rule Syntax</a></li>
  <li><a href="#Versioning">Versioning</a></li>
  <li><a href="#API">API</a></li>
  <li><a href="#Issues">Issues</a></li>
  <li><a href="#FAQ">FAQ</a></li>
  <li><a href="#Appendix_1">Appendix 1: Japanese Sort Order</a></li>
  <li><a href="#Appendix_2">Appendix 2: Compressing Primary Weights</a></li>
  <li>Appendix 3: Data Files</li>
  <li><a href="#Modifications">Modifications</a></li>
</ul>
<h2><a name="Requirements">Requirements</a></h2>
<p>The rest of the document proceeds as if all the following requirements and 
options are being done, so that the architecture is complete for the future. 
However, options will only be considered in the 1.7/1.8 timeframe if 
implementation falls out of the rearchitecture work.&nbsp; (Some 1.8 
functionality may be in 1.7, if it is easier to integrate then.)</p>
<h3>1.7 Requirements <font size="3">—</font> Not in priority order</h3>
<ol>
  <li>All of the current features will be maintained (with one semantic change 
    -- see API).</li>
  <li>Improve performance to the requisite level. First priority is string 
    compare, next is sortkey. (perf)</li>
  <li>Fix Japanese tailoring data to be more MS Office compatible [but see 1.8 
    for complete story] (data)
    <ul>
      <li>Level 1 = base letters,</li>
      <li>Level 2 = plain, daku-ten, handaku-ten</li>
      <li>Level 3 = small (katakana, hiragana, choo-on kigoo), large (katakana, 
        hiragana, choo-on kigoo)</li>
    </ul>
  </li>
  <li>Add SafeClone API (multi-thread)</li>
  <li>Allow sort-keys to be valid C-Strings: e.g. avoid null bytes, add 
    null-byte terminator.
    <ul>
      <li>This makes our sort keys comparable with strcmp() in addition to 
        memcmp(). It is like ANSI C strxfrm() and Win32 LCMapString().</li>
    </ul>
  </li>
  <li>Add all API and rule syntax, even if it is not functional in this release</li>
  <li><b>Binary Compatibility of Sort Keys</b>
    <ol>
      <li><b>1.7 is an enhancement release, not a reference release.</b></li>
      <li><b>1.7 sort keys are only for testing, not for release products.</b></li>
      <li><b>1.7 sort keys will not be compatible with 1.6 sort keys or 1.8 sort 
        keys.</b></li>
    </ol>
  </li>
</ol>
<h3>1.8 Requirements <font size="3">—</font> Not in priority order</h3>
<ol>
  <li>Be fully conformant to the UCA (function)</li>
  <li>Allow the main UCA table to be flat: static, read-only, and shared among 
    languages. (footprint, perf)</li>
  <li>Other performance improvements as described in this document. (perf)</li>
  <li>Reduce A-Z primaries to single byte weight (perf, footprint)</li>
  <li>Add complete versioning (function)</li>
  <li>Support additional Japanese case level. (for MS Office compatibility)
    <ol>
      <li>Level 1 = base letters,</li>
      <li>Level 2 = plain, daku-ten, handaku-ten</li>
      <li>Level 3 = small, large</li>
      <li>Level 4 = katakana, hiragana, choo-on kigoo</li>
    </ol>
  </li>
  <li>Provide parametric case reversal, e.g. upper before lower or lower before 
    upper (function: for Danish std)</li>
  <li>Ignore accents (actually ignore all levels <i><b>except</b></i> Primary 
    and Case Level) (function)</li>
  <li>Provide better surrogate support (req. for GB 18030 and Unicode 3.1)</li>
  <li>Use compression techniques for shorter sort-keys, reducing memory and 
    database footprint (perf, footprint)</li>
  <li><b>Binary Compatibility of Sort Keys</b></li>
  <ol>
    <li><b>1.8 sort keys will not be compatible with 1.6 sort keys or 1.7 sort 
      keys.</b></li>
    <li><b>However, all future versions will provide a mechanism for generating 
      1.8-binary-compatible sort keys.</b></li>
  </ol>
</ol>
<h3>Options</h3>
<ol>
  <li>Charset Sorting (special value in rules indicates codes are sorted by 
    charset values): (footprint, maintenance)</li>
  <li>Script Order (allow parametric rearrangement of scripts, e.g. Japanese 
    &lt; Latin &lt; Greek vs. Latin &lt; Greek &lt; Japanese) (function)</li>
  <li>Registration of Collations.</li>
  <li>Tailoring to add characters <i>before</i> other characters.</li>
</ol>
<p>These options are not completely described here, but sufficient information 
should be provided so that we don't make design decisions that would make them 
harder (or impossible) to do in the future.</p>
<h2><a name="Performance">Performance</a></h2>
Main items (not in priority order)
<ul>
  <li>Coding style
    <ul>
      <li>Rewrite core code in C. C++ API will wrap the C core code.</li>
      <li>Avoid use of objects.</li>
      <li>Avoid function calls.</li>
      <li>Fast-path Latin1.</li>
    </ul>
  </li>
  <li>Restructure tables
    <ul>
      <li>Use flat-file to speed initialization, share memory</li>
      <li>Use static UCA with separate tailoring to minimize memory usage</li>
    </ul>
  </li>
  <li>Rearchitect CE fetching, sort-key generation
    <ul>
      <li>Change to use newer fetch/sort-key generation from CEs, as described 
        below.</li>
      <li>Use stack memory buffers for common case (with expansion if 
        necessary).</li>
      <li>Don't use two-pass to find size first.</li>
      <li>Speed up Collation Element retrieval (see Architecture).</li>
    </ul>
  </li>
  <li>Speed up Normalization performance
    <ul>
      <li>Avoid normalization where possible. Use QuickCheck for this.</li>
      <li>Use fast-path for non-normalization case.</li>
      <li>Speed up the main normalization code.</li>
    </ul>
  </li>
  <li>Comparisons will be done against Win32 SDK CompareString() and LCMapString() 
    APIs, to judge performance quality.</li>
</ul>
<h2><a name="Data_Tables">Data Tables</a></h2>
<p>A collation table, whether UCA or a tailored table, contains the following 
subtables. It is in a flattened form that can be loaded as a DLL or into 
read-only shared memory. The header contains offsets to all the other subtables, 
plus the number of items in each subtable, plus various information that is used 
in processing, such as the maximumPrimaryFactor. A CE is a uint32_t. A UChar is 
16 bits.</p>
<blockquote>
  <p><b>NOTE: we make the processing faster by having offsets everywhere in the 
  table be from the very start of the whole table, not from the start of the 
  each subtable!</b></p>
  <p><b>The order of the subtables is not determined: with one exception: 
  because the offsets to the Expansion table have only 20 bits, we put that one 
  first. The position of each table would be determined by looking up the offset 
  in the header.</b></p>
</blockquote>
<table border="0" cellspacing="0" cellpadding="4">
  <tr>
    <td align="center" valign="top">
      <table border="1" width="1%">
        <tr>
          <th width="100%">Header</th>
        </tr>
        <tr>
          <td width="100%">info...</td>
        </tr>
        <tr>
          <td width="100%">Expansions offset</td>
        </tr>
        <tr>
          <td width="100%">Expansions count</td>
        </tr>
        <tr>
          <td width="100%">Main·Index offset</td>
        </tr>
        <tr>
          <td width="100%">Main·Index count</td>
        </tr>
        <tr>
          <td width="100%">Main·Data offset</td>
        </tr>
        <tr>
          <td width="100%">Main·Data count</td>
        </tr>
        <tr>
          <td width="100%">...</td>
        </tr>
      </table>
    </td>
    <td align="center" valign="top">
      <table border="1" width="1%">
        <tr>
          <th width="100%">Expansions</th>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">...</td>
        </tr>
      </table>
    </td>
    <td align="center" valign="top">
      <table border="1" width="1%">
        <tr>
          <th width="100%">Main·Index</th>
        </tr>
        <tr>
          <td width="100%">index</td>
        </tr>
        <tr>
          <td width="100%">index</td>
        </tr>
        <tr>
          <td width="100%">...</td>
        </tr>
      </table>
    </td>
    <td align="center" valign="top">
      <table border="1" width="1%">
        <tr>
          <th width="100%">Main·Data</th>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">...</td>
        </tr>
      </table>
    </td>
    <td align="center" valign="top">
      <table border="1" width="1%">
        <tr>
          <th width="100%">Contraction UChars</th>
        </tr>
        <tr>
          <td width="100%">c1</td>
        </tr>
        <tr>
          <td width="100%">c2</td>
        </tr>
        <tr>
          <td width="100%">c2</td>
        </tr>
        <tr>
          <td width="100%">...</td>
        </tr>
        <tr>
          <td width="100%">&nbsp;</td>
        </tr>
      </table>
    </td>
    <td align="center" valign="top">
      <table border="1" width="1%">
        <tr>
          <th width="100%">Contraction Results</th>
        </tr>
        <tr>
          <td width="100%">CE1</td>
        </tr>
        <tr>
          <td width="100%">CE2</td>
        </tr>
        <tr>
          <td width="100%">CE3</td>
        </tr>
        <tr>
          <td width="100%">...</td>
        </tr>
        <tr>
          <td width="100%">&nbsp;</td>
        </tr>
      </table>
    </td>
    <td align="center" valign="top">
      <table border="1" width="1%">
        <tr>
          <th width="100%">Surrogate Trie·Index</th>
        </tr>
        <tr>
          <td width="100%">index</td>
        </tr>
        <tr>
          <td width="100%">index</td>
        </tr>
        <tr>
          <td width="100%">...</td>
        </tr>
      </table>
    </td>
    <td align="center" valign="top">
      <table border="1" width="1%">
        <tr>
          <th width="100%">Surrogate Trie·Data</th>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">CE</td>
        </tr>
        <tr>
          <td width="100%">...</td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<h3 align="left"><a name="CollationElements">Collation Elements</a></h3>
<center>
<p align="left">The fundamental building block for collation is the collation 
element. ICU uses a single 32-bit value in the code and tables to represent 
this. Sometimes the values are overloaded in the tables, depending where they 
are used.</p>
<p align="left">All of these are mechanisms for encoding a fractional collation 
element (FCE: see <a href="#Fractional_Collation_Elements">Long Collation 
Elements</a>) into 32-bit chunks, in a way that can be easily used in generating 
sort keys. The different forms of CE are distinguished by a Flag bit (F). In the 
following diagrams, P = primary, S = secondary, C = case, T = tertiary, F = 
Flag1, G = Flag2.</p>
<h4 align="left">Unflagged (F = 0)</h4>
<p align="left">The normal CE is of the following form. The Case bit can be used 
to form an extra Japanese weight level, or considered part of the tertiary 
weight. In either case, a parameter can be used to invert it, thus changing 
whether small is before large or the reverse. That parameter can be either set 
in the rules or by a set call. The first nybble of the primary can never be F; 
this constraint is maintained by the data builder.</p>
<div align="center">
  <center>
  <table border="1" cellspacing="1">
    <tr>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="flag"><font size="2">F</font></td>
      <td class="case"><font size="2">C</font></td>
      <td class="tertiary"><font size="2">T</font></td>
      <td class="tertiary"><font size="2">T</font></td>
      <td class="tertiary"><font size="2">T</font></td>
      <td class="tertiary"><font size="2">T</font></td>
      <td class="tertiary"><font size="2">T</font></td>
      <td class="tertiary"><font size="2">T</font></td>
    </tr>
    <tr>
      <td colspan="16" class="primary">16b</td>
      <td colspan="8" class="secondary">8b</td>
      <td class="flag">&nbsp;0</td>
      <td class="case">&nbsp;?</td>
      <td colspan="6" class="tertiary">7b</td>
    </tr>
  </table>
  </center>
</div>
<blockquote>
  <p align="left"><i>Note: </i>to meet validity constraints, a tertiary can only 
  be zero (IGNORE) if the primary and secondary are non-zero; the secondary can 
  only be zero if the primary is zero. This constraint is managed by the data 
  builder.</p>
</blockquote>
<h4 align="left">Continuation (F = 1, G = 0)</h4>
<p align="left">The Continuation CE is of the following form.Continuation CEs 
can <i>only</i> occur in Expansions (although not all Expansion CEs will be 
Continuations). The case bit is never necessary in Continuations.</p>
<div align="center">
  <table border="1" cellspacing="1">
    <tr>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="primary"><font size="2">P</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="secondary"><font size="2">S</font></td>
      <td class="flag"><font size="2">F</font></td>
      <td class="flag"><font size="2">G</font></td>
      <td class="tertiary"><font size="2">T</font></td>
      <td class="tertiary"><font size="2">T</font></td>
      <td class="tertiary"><font size="2">T</font></td>
      <td class="tertiary"><font size="2">T</font></td>
      <td class="tertiary"><font size="2">T</font></td>
      <td class="tertiary"><font size="2">T</font></td>
    </tr>
    <tr>
      <td colspan="16" class="primary">16b</td>
      <td colspan="8" class="secondary">8b</td>
      <td class="flag">&nbsp;1</td>
      <td class="flag">0</td>
      <td colspan="6" class="tertiary">6b</td>
    </tr>
  </table>
</div>
<h4 align="left">Long Primary (F = 1, G = 1)</h4>
<p align="left">The Long Primary CE is of the following form. The value of the 
secondary and case are implicit.</p>
<table border="1" cellspacing="1">
  <tr>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="primary">P</td>
    <td class="flag"><font size="2">F</font></td>
    <td class="flag"><font size="2">G</font></td>
    <td bgcolor="#FFFF66" class="tertiary"><font size="2">T</font></td>
    <td bgcolor="#FFFF66" class="tertiary"><font size="2">T</font></td>
    <td bgcolor="#FFFF66" class="tertiary"><font size="2">T</font></td>
    <td bgcolor="#FFFF66" class="tertiary"><font size="2">T</font></td>
    <td bgcolor="#FFFF66" class="tertiary"><font size="2">T</font></td>
    <td bgcolor="#FFFF66" class="tertiary"><font size="2">T</font></td>
  </tr>
  <tr>
    <td colspan="24" class="primary">24b</td>
    <td class="flag">1</td>
    <td class="flag">1</td>
    <td bgcolor="#FFFF66" colspan="6" class="tertiary">6b</td>
  </tr>
</table>
<p align="left">This form will <i>never</i> be generated unless:</p>
<ul>
  <li>
    <p align="left">a 24-bit primary weight is required,</li>
  <li>
    <p align="left">the tertiary fixs in 6 bits,</li>
  <li>
    <p align="left">the secondary is UNMARKED</li>
  <li>
    <p align="left">the case is ZERO.</li>
</ul>
<p align="left">This constraint is managed by the data builder. That also 
ensures that it meets UCA validity constraints.</p>
<h4 align="left">Special</h4>
<p align="left">The special CE is of the following form (where T = tag, d = 
data). The first nybble is F, to distinguish it from a Primary or Long Primary. 
These are only used internal to the data table.</p>
<table border="1" cellspacing="1">
  <tr>
    <td class="flag">F</td>
    <td class="flag">F</td>
    <td class="flag">F</td>
    <td class="flag">F</td>
    <td class="case">T</td>
    <td class="case">T</td>
    <td class="case">T</td>
    <td class="case">T</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
    <td class="primary">d</td>
  </tr>
  <tr>
    <td colspan="4" class="flag">4b</td>
    <td colspan="4" class="case">4b Tag</td>
    <td colspan="24" class="primary">24 bit data</td>
  </tr>
</table>
<p>The tags have the values:</p>
<table border="1">
  <tr>
    <th align="left">NOT_FOUND_TAG</th>
    <td><b>0</b></td>
  </tr>
  <tr>
    <th align="left">EXPANSION_TAG</th>
    <td><b>1</b></td>
  </tr>
  <tr>
    <th align="left">CONTRACTION_TAG</th>
    <td><b>2</b></td>
  </tr>
  <tr>
    <th align="left">THAI_TAG</th>
    <td><b>3</b></td>
  </tr>
  <tr>
    <th align="left">CHARSET_TAG</th>
    <td><b>4</b></td>
  </tr>
  <tr>
    <th align="left">SURROGATE_TAG</th>
    <td><b>5</b></td>
  </tr>
  <tr>
    <th align="left">reserved</th>
    <td><b>6+</b></td>
  </tr>
</table>
</center>
<p align="left">To test whether a ce is an extension CE, we use:</p>
<div align="left">
  <pre align="left">if (ce &gt;= MIN_SPECIAL) ...</pre>
</div>
<h2 align="left"><a name="Forming_Sort_Keys">Forming Sort Keys</a></h2>
<pre align="left">const int FLAG_MASK = 0x80;
const int FLAG_MASK2 = 0x40;
const int CASE_MASK = FLAG_MASK2;
const int FLAGS_MASK = FLAG_MASK | FLAG_MASK2;
const int CONTINUATION_MASK = FLAG_MASK;
const int LONG_PRIMARY_MASK = FLAG_MASK | FLAG2_MASK;

const int MIN_SPECIAL = 0xF0000000;
const int MIN_VALUE = 0x02;
const int UNMARKED = 0x03;
</pre>
<p align="left">The following sample shows how this would work in practice. (ScriptOrder 
will be explained later).</p>
<div align="left">
  <pre>// once we have a cc. Special CEs have already been handled.

wt = ce &amp; 0xFF;
ws = (ce &gt;&gt; 8) &amp; 0xFF;
wp3 = 0;
wp2 = (ce &gt;&gt; 16) &amp; 0xFF; // second primary byte
wp1 = (ce &gt;&gt; 24); // first primary byte

if (ce &amp; FLAG_MASK) {
  if (ce &amp; FLAG_MASK2) { // long primary
    wp3 = ws;
    ws = UNMARKED;
    if (scriptOrder != null) {
      wp1 = scriptOrder[wp1];
    }
  } // otherwise it would be continuation
  wt &amp;= ~FLAGS_MASK; // clear bits in tertiary
} else { // normal CE
  if (caseUpper) wt ^= CASE_MASK; // invert upper/lower
  if (scriptOrder != null) {
    wp1 = scriptOrder[wp1];
  }
}

if (alternate == SHIFTED &amp;&amp; wp1 &lt; VARIABLE_MAX &amp;&amp; wp1 &gt; 0) {
  // all other values are skipped
  *quarternary++ = wp1;
  if (wp2 != 0) *quarternary++ = wp2;
} else { // normal
  if (wp1 != 0) *primary++ = wp1;
  if (wp2 != 0) *primary++ = wp2;
  if (strength &gt;= SECONDARY) {
    if (ws != 0) *secondary++ = ws;
    if (strength &gt;= TERTIARY) {
      if (wt != 0) *tertiary++
      if (strength &gt;= QUARTERNARY 
       &amp;&amp; alternate == SHIFTED &amp;&amp; wp1 &gt; 0) *quarternary++ = 0xFF;
    }
  }
}</pre>
</div>
<p align="left"><i><b>One twist. </b></i>If the FrenchSecondary flag is turned 
on, then the secondary values in the continuation CEs are reversed. This is so 
that when the secondary buffer itself is reversed (see below), the continuation 
values come out in the right order. This is done by the following pseudocode 
(where specialHandling is above)</p>
<div align="left">
  <pre align="left">if ((ce &amp; FLAGS_MASK) == CONTINUATION_MASK) {
  if (frenchStartPtr == null) frenchStartPtr = secondary - 1;
  frenchEndPtr = secondary + 1;
} else if (frenchStartPtr != null) {
  //reverse secondaries from frenchStartPtr up to frenchEndPtr
}</pre>
</div>
<p align="left">plus some code at the very end, after processing all CEs, to 
catch the final case.</p>
<div align="left">
  <pre align="left">if (frenchStartPtr != null) {
  //reverse secondaries from frenchStartPtr up to frenchEndPtr
}</pre>
</div>
<blockquote>
  <p align="left"><b>Note: </b>In incrementally comparing strings, as opposed to 
  sort keys, more work has to be done with French secondaries. Essentially, all 
  the secondaries are buffered up, and if there is no primary difference they 
  are compared in reverse order.</p>
</blockquote>
<h4 align="left">Variables and Quarternary</h4>
<p align="left">In the collation table, there is a value VARIABLE_MAX. All CEs 
with primary weights between zero and VARIABLE_MAX&nbsp; are considered to be 
variable. (This saves having a bit per CE!) If a CE is variable, we support the 
Shifted Option from the UCA in constructing . We can process the table to ensure 
that VARIABLE_MAX&nbsp; has a zero second byte. That means we only have to test 
wp1 above</p>
<p align="left">The quarternary is computed based on the setting. With shifted, 
then it is skipped if the ce is entirely zero, equal to the primary if variable, 
and otherwise equal to FF. (In the UCA this is FFFF, but we can make it a 
single-byte weight.)</p>
<h4 align="left">Appending Levels</h4>
<p align="left">Once we have the level keys, we put them into the sort key. If 
any one of them overflows the outputBuffer, then we set the appropriate error, 
but we also return the length that it would have had (for preflighting).</p>
<div align="left">
  <pre>if (strength &gt;= SECONDARY) { 
  // append LEVEL_SEPERATOR, append secondary
  // if FrenchSecondary is on, then append in reverse order.
}
if (caseLevel) {
  // append LEVEL_SEPERATOR, append case
}
if (strength &gt;= TERTIARY) { 
  // append LEVEL_SEPERATOR, append tertiary
  if (strength &gt;= QUARTERNARY) {
    if (strength == QUARTERNARY &amp;&amp; alternate != NON_IGNORABLE) {
      // append LEVEL_SEPERATOR, append quad
    }
    if (strength == IDENTICAL) {
      // append normalized source, fixed a la Markus for codepoints
    }
  }
}</pre>
</div>
<p align="left">It is easy to do preflighting. If the primary + sep + secondary 
+... all fit into the outputBuffer, the correct string is returned. If not, the 
sizes can be easily calculated, and a truncated version returned.</p>
<blockquote>
  <p align="left"><b>Note: </b>LEVEL_SEPERATOR is 01, not (as before) 00. All 
  sort weights are constructed to avoid the 01 bytes so that 01 can be used as 
  the separator. This allows the resulting sort key to be a C string (no null 
  bytes except for a terminating null byte).</p>
</blockquote>
<h4 align="left">Case Level</h4>
<p align="left">For a small/large difference for Japanese, we change the code as 
follows. Since we know that the case occupies exactly one bit, we optimize this 
(at the expense of some code) by storing it bit at a time (with one bit overhead 
per byte). That is, 7 or fewer letters in the string only take 1 byte; 14 or 
fewer 2 bytes, etc. The reason we have the extra bit is so that the separator 
value between levels is distinguished. The code will look something like:</p>
<pre>// when creating the level keys

int caseShift = 0;
...
if (caseLevel) {
  if (caseShift  == 0) {
    *case++ = 0x80;
    caseShift = 7;
  }
  case[-1] |= (wt &amp; 0x80) &gt;&gt; caseShift--;
}</pre>
<h3 align="left">Identical Strength</h3>
<p>For IDENTICAL strength, we append the (normalized) string to the end of the 
sort key. We already process that string to normalize it (if normalization is 
on) and to swap surrogates up to the top of the value space. Since we also have 
to avoid zero bytes, we do one additional modification: when we hit 00 or 01 
byte, we emit 01 01 or 01 02 respectively instead (e.g. we &quot;quote&quot; the 
byte).</p>
<p>The IDENTICAL strength is not recommended. Some people believe that it makes 
the sort stable. That is a misnomer: a stable sort is one where equal records 
come out in the same order as they were put in. This requires more than simply 
distinguishing strings that are the same for the primary, secondary and tertiary 
weights. A common solution is to append the record number to the sort key. If 
this were done, a similar kind of &quot;quoting&quot; would need to be done.</p>
<h3 align="left"><a name="Compression">Compression</a></h3>
<p align="left">We will use the technique discussed in UCA to reduce the length 
of sort keys that contain a series of common weights in non-primary positions. 
This produces very significant reductions in sort key size, since most 
secondary, tertiary, and quarternary weights are UNMARKED. <i>For compression of 
primary weights weights, see <a href="#Appendix_2">Appendix_2</a>.</i></p>
<p align="left">We make sure there are no real weights that are both greater 
than COMMON (abbreviated by C below) and less than or equal to COMMON_TOP (abbr. 
T). Then look at a series of COMMON bytes followed by bytes H (higher than C) or 
L (lower than C), or nothing. Here is the ordering, and the compression that 
also produces that ordering. For illustration, the gap between T and has been 
artificially set to a small number to illustrate what happens if the normal 
compression range is exceeded.</p>
<div align="center">
  <center>
  <table border="1" cellspacing="1" cellpadding="4">
    <tr>
      <th colspan="5">Original</th>
      <th colspan="3">Result</th>
    </tr>
    <tr>
      <td class="secondary" width="12%">C</td>
      <td class="secondary" width="12%">H</td>
      <td class="secondary" width="12%">&nbsp;</td>
      <td class="secondary" width="12%">&nbsp;</td>
      <td class="secondary" width="12%">&nbsp;</td>
      <td class="case" width="12%">T</td>
      <td class="case" width="12%">H</td>
      <td class="case" width="12%">&nbsp;</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">H</td>
      <td class="secondary">&nbsp;</td>
      <td class="secondary">&nbsp;</td>
      <td class="case">T-1</td>
      <td class="case">H</td>
      <td class="case">&nbsp;</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">H</td>
      <td class="secondary">&nbsp;</td>
      <td class="case">T-2</td>
      <td class="case">H</td>
      <td class="case">&nbsp;</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">H</td>
      <td class="case">T-3</td>
      <td class="case">C</td>
      <td class="case">H</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">L</td>
      <td class="case">C+3</td>
      <td class="case">C</td>
      <td class="case">L</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">&nbsp;</td>
      <td class="case">C+3</td>
      <td class="case">C</td>
      <td class="case">&nbsp;</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">L</td>
      <td class="secondary">&nbsp;</td>
      <td class="case">C+2</td>
      <td class="case">L</td>
      <td class="case">&nbsp;</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">L</td>
      <td class="secondary">&nbsp;</td>
      <td class="case">C+2</td>
      <td class="case">L</td>
      <td class="case">&nbsp;</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">&nbsp;</td>
      <td class="secondary">&nbsp;</td>
      <td class="case">C+2</td>
      <td class="case">&nbsp;</td>
      <td class="case">&nbsp;</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">L</td>
      <td class="secondary">&nbsp;</td>
      <td class="secondary">&nbsp;</td>
      <td class="case">C+1</td>
      <td class="case">L</td>
      <td class="case">&nbsp;</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">C</td>
      <td class="secondary">&nbsp;</td>
      <td class="secondary">&nbsp;</td>
      <td class="secondary">&nbsp;</td>
      <td class="case">C+1</td>
      <td class="case">&nbsp;</td>
      <td class="case">&nbsp;</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">L</td>
      <td class="secondary">&nbsp;</td>
      <td class="secondary">&nbsp;</td>
      <td class="secondary">&nbsp;</td>
      <td class="case">C</td>
      <td class="case">L</td>
      <td class="case">&nbsp;</td>
    </tr>
    <tr>
      <td class="secondary">C</td>
      <td class="secondary">&nbsp;</td>
      <td class="secondary">&nbsp;</td>
      <td class="secondary">&nbsp;</td>
      <td class="secondary">&nbsp;</td>
      <td class="case">C</td>
      <td class="case">&nbsp;</td>
      <td class="case">&nbsp;</td>
    </tr>
  </table>
  </center>
</div>
<p align="left">To do this in code, we replace a statement like:</p>
<div align="left">
  <pre>*secondary++ = ws;</pre>
</div>
<p align="left">we write:</p>
<div align="left">
  <pre>if (ws  == COMMON2) {
  ++count2;
} else {
  if (count2 &gt; 0) {
    writeCompressed2();
    count2 = 0;
  }
  *secondary++ = ws;
}

void writeCompressed2() {
  if (ws &gt; COMMON2) { // not necessary for 4th level.
    while (count2 &gt;= MAX_TOP2) {
      *secondary++ = COMMON_TOP2 - TOP_COUNT2;
      count2 -= TOP_COUNT2;
    }
    *secondary++ = COMMON_TOP2 - count2;
  } else {
    while (count2 &gt;= BOT_COUNT2) {
      *secondary++ = COMMON_BOT2 + BOT_COUNT2;
      count2 -= BOT_COUNT2;
    }
    *secondary++ = COMMON_BOT2 + count2;
  }
}</pre>
</div>
<p align="left"><b>Note: if count2 &gt; 0, then </b>writeCompressed <b>also</b> 
needs to be called at the very end of the sortkey generation. Similar code is 
used for tertiaries and quarternaries, with different values for the constants. 
MAX_TOP is derived from the other values:</p>
<ul>
  <li>
    <p align="left">BOT_COUNT = COMMON_TOP - COMMON_BOT - 1 - TOP_COUNT</li>
</ul>
<p align="left">The choice of how much space to put in MAX_TOP vs MAX_BOT 
depends on the relative frequency of H vs L bytes following. Remember that 
&quot;nothing&quot; counts as an L byte. Here are the values (in hex).</p>
<div align="center">
  <center>
  <table border="1" cellspacing="1" cellpadding="4">
    <tr>
      <th>const</th>
      <th>Secondary</th>
      <th>Tertiary</th>
      <th>Quarternaries</th>
    </tr>
    <tr>
      <th>COMMON</th>
      <td>03</td>
      <td>03</td>
      <td>FF</td>
    </tr>
    <tr>
      <th>COMMON_TOP</th>
      <td>81</td>
      <td>84</td>
      <td>FF</td>
    </tr>
    <tr>
      <th>COMMON_BOT</th>
      <td>03</td>
      <td>03</td>
      <td>2A*</td>
    </tr>
    <tr>
      <th>TOP_COUNT</th>
      <td>40</td>
      <td>40</td>
      <td>0</td>
    </tr>
  </table>
  </center>
</div>
<p align="left">Secondaries</p>
<ul>
  <li>
    <p align="left">In the processing of the secondaries for the Fractional UCA, 
    we will allocate the above gap.</li>
</ul>
<p align="left">Tertiaries</p>
<ul>
  <li>
    <p align="left">We will take the 7 bits from tertiaries (including the case 
    bits) from a CE, and add 0x80 to all values above 03. That will produce the 
    gap.</li>
</ul>
<p align="left">Quarternaries:</p>
<ul>
  <li>
    <p align="left">Since there are never any higher bytes than FF, TOP_COUNT in 
    that case is zero, and the code could be slightly simpler (</li>
  <li>
    <p align="left">TOP_COUNT is computed from VariableTop. Take the first byte 
    of VariableTop, and add 1 to it.</li>
</ul>
<h3 align="left">Stack Buffers</h3>
<p align="left">We can use stack buffers for almost all cases. The vast majority 
of sorted strings are fairly small, so we optimize for that. Here's how.</p>
<div align="left">
  <pre>// allocate buffers
#define BUFFER_SIZE 1000
char primaryBuffer[BUFFER_SIZE];
char secondaryBuffer[BUFFER_SIZE];
char tertiaryBuffer[BUFFER_SIZE];
char caseBuffer[BUFFER_SIZE];
char quarternaryBuffer[BUFFER_SIZE];

// initialize buffers, normally to stack
int max;
boolean allocatedPrimary = false, allocatedSecondary = false...

char* primary  = *primaryStart = outputBuffer; // write into output buffer, if large enough
max = getMaxPrimaryFactor() * sourceLength;
if (max &gt; BUFFER_SIZE) primary = primaryStart = malloc(max);
else if (max &gt; outputLength) primary = primaryStart = primaryBuffer;

char* secondary = secondaryBuffer;
max = getMaxSecondaryFactor() * sourceLength;
if (max &gt; BUFFER_SIZE) secondary = secondaryStart = malloc(max);</pre>
</div>
<div align="left">
  <pre>// tertiary, case, quarternary like secondary.</pre>
</div>
<div align="left">
  <pre>...// do code</pre>
</div>
<div align="left">
  <pre>// clean up after copying contents to output</pre>
</div>
<div align="left">
  <pre>if (primaryStart != outputBuffer &amp;&amp; primaryStart != primaryBuffer) delete(primaryStart);
if (secondaryStart != secondaryBuffer) delete(secondaryStart);
if (tertiaryStart != tertiaryBuffer) delete(tertiaryStart);
if (caseStart != caseBuffer) delete(caseStart);
if (quarternaryStart != quarternaryBuffer) delete(quarternaryStart);</pre>
</div>
<p align="left">By handling it this way, we don't need to do any error checking 
in the loop for buffers being too small.</p>
<blockquote>
  <p align="left"><b>Note:</b> if the strength is IDENTICAL, then we copy the 
  source string (normalized, if normalization is on) to the end of the sort key 
  (after a level separator). This source string is modified so that surrogates 
  sort in codepoint order. (See Markus's paper).</p>
</blockquote>
<h2 align="left"><a name="Fetching_CEs">Fetching CEs</a></h2>
<p align="left">getCE is a function that gets a single CE, based on a source 
buffer. It is used by both the sort-key generator and for the incremental string 
comparison. Because two strings are &quot;live&quot; at the same time in 
comparison, we will pass in a parameter block (allocated on the stack) with 
state information for each string. This is called a <a name="Context">Context</a>:<o:p>
  </o:p>                                                         
</p> 
<table border="1" cellspacing="0" cellpadding="2">
  <tr>
    <th align="left">source</th>
    <td>The source character position</td>
  </tr>
  <tr>
    <th align="left">sourceEnd</th>
    <td>To know when to end</td>
  </tr>
  <tr>
    <th align="left">ceBuffer</th>
    <td>For CEs that are results of expansion</td>
  </tr>
  <tr>
    <th align="left">ceBufferStart</th>
    <td>The start index for CEs in the buffer.</td>
  </tr>
  <tr>
    <th align="left">ceBufferEnd</th>
    <td>The limit index for CEs in the buffer</td>
  </tr>
  <tr>
    <th align="left">isThai</th>
    <td>Have we encountered Thai pre-vowel?</td>
  </tr>
</table>
<h4 align="left">ceBuffer</h4>
<p align="left">For each string, we keep a ceBuffer for expansions. This is a 
FIFO queue, allocated on the stack. It is large enough to handle all reasonable 
expansions (e.g. up to 100). We will not build longer expansions in the table.</p>
<p align="left">There are two pointers: ceBufferStart and ceBufferEnd that point 
to the contents. The function is demonstrated below.</p>
<h4 align="left">Fetching chars</h4>
<p align="left">If normalization is off, we fetch characters directly from the 
source buffer. If not, we check the source buffer using the Normalization 
QuickCheck. If it comes back as unnormalized, then we normalize into a stack 
buffer (if possible), and fetch from there.</p>
<div align="left">
  <pre>// initialize
uchar* sourceBuffer [BUFFER_SIZE];
uchar* source, *sourceStart;
source = sourceStart = inputBuffer;
if (normalization_on) {
  // normalize into sourceBuffer if possible,  resetting source, sourceStart
  // if too big, allocate memory, resetting source, sourceStart
}
uchar* sourceEnd = source + sourceLength;
....
// cleanup
if (sourceStart != inputBuffer &amp;&amp; sourceStart != sourceBuffer) delete(sourceStart);</pre>
</div>
<h4 align="left">Special CEs</h4>
<p align="left">If the CE is of the form Ftyyyyyy, then it has a special 
interpretation. There are two cases:
<blockquote>
  <p align="left"><b>A. First in a table = Special</b></p>
  <p align="left"><b>B. Element of a Continuation. In this case, it just 
  indicates a continuation CE (see FAQ).</b></p>
</blockquote>
<p align="left">For specials,&nbsp; t is used as a switch, and yyyyyy is an 
offset. By choosing this value, and making this range adjacent to the NOT_FOUND 
marker, we save on switches. The following is a pseudocode sample of how this 
would work:</p>
<div align="left">
  <pre>int getCE(...) {

  // get it out of buffer, if available
  if (ceBufferStart &lt; ceBufferEnd) {
    ce = *ceBufferStart;
    if (ceBufferStart == ceBufferEnd) {// reset!
      ceBufferStart = ceBufferEnd = ceBuffer;
  }

  // return if done
  if (source &gt;= sourceEnd) return EOS;

  // get character, and do simple mapping
  ch = *source++;
  if (ch &lt; 0xFF) {
    ce = tailoredData[ch]; // Latin1 is always here!
  } else {
    ce = tailoredData[tailoredIndex[(ch &gt;&gt;&gt; 8)] + (ch &amp; 0xFF)]; // trie
  }
  if (ce &gt;= NOT_FOUND) { // NOT_FOUND or SPECIAL
    if (ce &gt; NOT_FOUND) { // handle special casing
      getSpecialCE(tailoredSpecials, ...);
    }
    // if still not found, then try in the main table
    if (ce == NOT_FOUND) {
      ce = UcaData[UcaIndex[(ch &gt;&gt;&gt; 8)] + (ch &amp; 0xFF)]; // trie
      if (ce &gt; NOT_FOUND) {
        getSpecialCE(UcaSpecials, ...);
      }
      if (ce == NOT_FOUND) {
      // make artificial CE from codepoint, as in UCA
      }
    }
  }
  return ce;
}
const int NOT_FOUND = F0000000;</pre>
</div>
<p align="left">Note that NOT_FOUND is higher than all non-SPECIAL CEs, and less 
than all non-specials.</p>
<p align="left">Note that every tailoring table is built to have <b><i>all</i></b> 
Latin1 characters, even when they are identical with the UCA table. That way the 
Latin1 case is as fast as possible.</p>
<h3 align="left">GetSpecialCE</h3>
<p align="left">In the case that we do have specials, it falls into certain 
cases: Contraction, Expansion, Thai, Charset, and Surrogate. For processing 
these, we would do something like the following pseudocode:</p>
<div align="left">
  <pre>while (true)
  // special ce is has these fields: 
  // first nybble (4 bits) is F, next nybble (4 bits) is type
  int type = (ce &gt;&gt; 24) &amp; 0xF;
  // next 24 bits are data
  int data = ce &amp; 0x00FFFFFF; // remove F, type
  switch (type) {
    case NOT_FOUND_TAG: break;// never happens

    case SURROGATE_TAG: // use offset, ch and *source to for trie with dataTable.extendedData
      ...
    case THAI_TAG: // do Thai, Lao rearrangement
      ...
    case CONTRACTION_TAG: // do contraction thing
      ...
    case EXPANSION_TAG: // do expansion thing
      // put extra CEs into ceBuffer
      ...
    case CHARSET_TAG:
      // do 
      ce = (ce &lt;&lt; 8) | 0x0303; // charsets only used for primary differences, so use middle 16 bits
      // the 0303 is to make a well-formed CE.
      charConverter[charSetNum].getOrdering(ch, ceBuffer, ceBufferTop);
      break;
  }
  if (ce &lt;= NOT_FOUND) break; // normal return
}</pre>
</div>
<h3 align="left">Expansion (max size 2<sup>20</sup>)</h3>
<p align="left">The expansion table is simply a list of CEs. Internally it is 
broken into sections. The longer ones are null terminated: the others use an 
external length, based on the data from above.</p>
<table border="1" width="1%">
  <tr>
    <th width="100%">
      <p align="left">Expansions</p>
    </th>
  </tr>
  <tr>
    <td width="100%">
      <p align="left">CE</p>
    </td>
  </tr>
  <tr>
    <td width="100%">
      <p align="left">CE</p>
    </td>
  </tr>
  <tr>
    <td width="100%">
      <p align="left">CE</p>
    </td>
  </tr>
  <tr>
    <td width="100%">
      <p align="left">....</p>
    </td>
  </tr>
</table>
<p align="left">The data is broken into two pieces: 4 bits for length, 20 bits 
for offset. A length value of 0 means that the actual length didn't fit in 4 
bits, and the expansions are instead terminated by 00000000. Otherwise, the 
length is used to determine the number of CEs to add to the ceBuffer. E.g.</p>
<div align="left">
  <pre>len = ce &amp; 0xF;
offset = ce &gt;&gt; 8;
if (len == 0) // go until terminated
  ce = expansionTable[offset++]; // get first one. Never 0
  loop {
    item = ExpansionTable[offset++];
    if (item == 0) break;
    ceBuffer[ceBufferTop++] = item;
  }
} else {
  ce = expansionTable[offset++]; // get first one.
  for (int i = len-2; i &gt; 0; --i) {
    ceBuffer[ceBufferEnd++] = ExpansionTable[offset++];
  }
}</pre>
</div>
<table border="1" width="100%">
  <tr>
    <td width="100%" bgcolor="#FFFF66">
      <p align="left"><b><font color="#FF0000">Important: </font></b>when 
      processing backwards, expansion CEs have to be fed out backwards as well. 
      This is where the continuations are important: unlike the others they are <b><i>not</i></b> 
      reversed. That is, if an expansion consists of&nbsp; <code><b>A B B2 B3 C 
      D</b></code> (where <code><b>B2</b></code> and <code><b>B3</b></code> are 
      continuations), then the reversed order is <code><b>D C B B2 B3 A</b></code>!</td>
  </tr>
</table>
<h3 align="left">Contraction (max size 2<sup>24</sup>)</h3>
<p align="left">[TBD] The contraction tables consist of two parts, one 16 bits 
wide (uchars) and the other 32 bits wide (CEs). The first uchar in each section 
is actually a delta offset, not a uchar. It is to be added to the current 
position in the table to get to the real offset.</p>
<table border="0" cellspacing="0" cellpadding="4">
  <tr>
    <td width="25%" align="center" valign="top">
      <table border="1">
        <tr>
          <th width="100%">
            <p align="left">Contraction UChars</p>
          </th>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">...</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">...</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">backward offset</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">char_n1</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">char_n2</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">char_n3</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">FFFF</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">....</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">backward offsetm</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">char_m1</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">char_m2</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">FFFF</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">...</p>
          </td>
        </tr>
      </table>
    </td>
    <td width="25%" align="center" valign="top">
      <table border="1">
        <tr>
          <th width="100%">
            <p align="left">Contraction Results</p>
          </th>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">...</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">...</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">defaultCEn</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">CEn1</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">CEn2</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">CEn3</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">defaultCEn</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">...</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">defaultCEm</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">CEm1</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">CEm2</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">defaultCEm</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">...</p>
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<p align="left">From the original CE, we use the data as an offset into the 
Contraction UChars table. If backwards is on (a programmatic setting for 
searching), we add the backwards offset delta to out position, otherwise we 
advance one. We grab a character from the source. We search the characters 
(which are in sorted order). If a target char &gt;= source char, return the 
defaultCE (which may be expansion) If target char == source char, get the 
corresponding result. If it is a contraction, extract the offset and keep 
looping. Otherwise return that result (may be expansion).</p>
<p align="left">The defaultCE needs to be the concatenation of the CEs we would 
have gotten if we had not had a contraction. Sample pseudo code:</p>
<div align="left">
  <pre>// only do backwards check first time. Cast to signed int delta if we are.
if (backwardsSearch) offset += contractionUChars[(int16_t)offset]; else ++offset;

// loop over multiple contractions
while (true) {
  if (source &gt;= sourceEnd) {
    contractionUChars[--offset]; // return default if end of string
    break;
  }
  uchar schar = source++;
  int startPosition = offset;
  uchar tchar;
  while (schar &gt; tchar = contractionUChars[offset++]); // loop til found or done
  if (schar != tchar) offset = startPosition - 1;      // use default if not found
  ce = contractionResult[offset];
  if (ce &lt; LOWEST_CONTRACTION) break;
  offset = ce &amp; 0x00FFFFFF;	// get new offset and keep looping
}

// we've broken out of the loop
if (ce &lt; LOWEST_EXPANSION) return ce;
else // do expansion thing</pre>
</div>
<p align="left">We know the inner loop terminates, since we always end each list 
of chars with FFFF. If the user happens to use a malformed string containing 
FFFF, we are still safe, since we store defaultCE in the corresponding result 
position.</p>
<h3 align="left">Thai</h3>
<p align="left">Certain Thai, Lao character rearrange (see UCA). In UCA if x is 
a Thai vowel, &quot;xyz&quot; should behave as if it were &quot;yxz&quot;. To 
avoid overhead of testing for character classes, we give all the rearranging 
characters a Special class. At the very beginning, we turn Thai processing ON.</p>
<p align="left">If Thai processing is ON, and we hit a Thai vowel, we backup by 
one source character, and copy the source buffer (if it is not our own private 
buffer) to a writable buffer. We then pass through all the remaining characters, 
and rearrange any Thai ones. We turn Thai processing OFF for the rest of the 
string, and return a zero CE (ignorable).</p>
<p align="left">When Thai processing is OFF, we use the data as an offset into 
the Expansion table. We fetch exactly 1 element, and process it (looking for 
specials, so it can be an expansion or contraction).</p>
<h3 align="left">Surrogates</h3>
<p align="left">Surrogates can be handled already using contractions, but this 
allows us the freedom to add an extra table for Unicode 3.1, when someone might 
want to add tens of thousands of surrogates. For such a case, we will have an 
optimized table. Essentially, what we do is add the following tables.</p>
<table border="0" cellspacing="0" cellpadding="4">
  <tr>
    <td width="25%" align="center" valign="top">
      <table border="1" width="1%">
        <tr>
          <th width="100%">
            <p align="left">Surrogate Trie·Index</p>
          </th>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">index</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">index</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">...</p>
          </td>
        </tr>
      </table>
    </td>
    <td width="25%" align="center" valign="top">
      <table border="1" width="1%">
        <tr>
          <th width="100%">
            <p align="left">Surrogate Trie·Data</p>
          </th>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">CE</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">CE</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">CE</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">CE</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">CE</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">CE</p>
          </td>
        </tr>
        <tr>
          <td width="100%">
            <p align="left">...</p>
          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<p align="left">Fetch the next source character. If it is not a surrogate, 
backup, return a 0 CE (completely ignorable).</p>
<p align="left">Otherwise get the bottom 10 bits of that next source character. 
Perform the normal trie operations: take the top few bits and add them to data. 
Use that to lookup in the SurrogateTrieIndex, and find an offset. Add the bottom 
few bits to that, and use that to index into the SurrogateTrieData to get the 
CE.</p>
<p align="left">If that CE is an expansion or contraction, handle those cases, 
otherwise just return.</p>
<h3><a name="Implicit_CEs">Implicit CEs</a></h3>
<p>If a character is not explicitly in the UCA table, then it is assigned an <i>implicit</i> 
CE which is generated from the code point.</p>
<blockquote>
  <p><b>Note: </b>As per <a
  href="http://www.unicode.org/unicode/reports/tr10/#IllegalCodePoints">UCA 
  7.1.1 lllegal code points</a>, all values xxFFFE and xxFFFF are ignored, as 
  are all <b><i>unpaired</i></b> surrogates. The code to do this (after fetching 
  the complete code point) is:</p>
  <blockquote>
    <pre>if ((codePoint &amp; 0xFFFE) == 0xFFFE || (0xD800 &lt;= codePoint &amp;&amp; codePoint &lt;= 0xDC00)) {
    return 0;  // illegal code value, use completely ignoreable!
}
</pre>
  </blockquote>
</blockquote>
<p>Implicit CEs are used for all Yi, Hangul and CJK ideographs, as well as all 
unassigned code points. In these generated CEs there is always a gap at least 
one (for possible later insertion), and with no zero bytes in the primaries. The 
implicit CEs use an optimized form that uses primary weights from Dxxx to EFFF. 
Basic code points (0000..FFFF) get a 24-bit primary weight (which turns into a 
long CE), while supplementary code points (10000..10FFFF) get a 32 bit primary 
weight (which turns into 2 standard CEs). Since the latter will be rare, this 
does not represent a performance issue.</p>
<blockquote>
  <p><b>Note: </b>These values are generated on the fly, not stored in the 
  tables; and <i>only</i> if there is no explicit table entry for the code 
  points.</p>
</blockquote>
<h4>Basic CP:</h4>
<p>Distribute the bits as follows, using a Long CE. The resulting primary uses 3 
bytes in sort keys, and has a tertiary of 03 (UNMARKED).</p>
<pre>CP =                   xxxxyyyy yyyzzzzz</pre>
<pre>CE = 1101xxxx 1yyyyyyy zzzzz100 11000011</pre>
<pre>CE = 0xD08004C3 | (CP &amp; 0xF000) &lt;&lt; 12 | (CP &amp; 0x0FFF) &lt;&lt; 11;</pre>
<p>There is no provision for secondary elements in Long CEs. This is not an 
issue for implicit CEs, but does affect tailoring. Inserting a character with 
secondary difference after an undefined element will use 2 CEs in that case: an 
Unflagged CE and a Continuation CE.</p>
<p>The primary gap is larger than one, which allows more elements to be inserted 
(in tailoring) without using extension CEs. Suppose that we have a Basic CP with 
qqqqq is zzzzz + 1; then here are the possible insertion values, marked with *. 
(The values at ** can be used iff qqqqq != 0.)</p>
<blockquote>
  <pre>zzzzz100
zzzzz101 *
zzzzz110 *
zzzzz111 *
qqqqq000 **
qqqqq001 **
qqqqq010 *
qqqqq011 *
qqqqq100</pre>
</blockquote>
<h4>Supplementary CP:</h4>
<p>First subtract 10000 from CP, then distribute the 20 remaining bits as 
follows.&nbsp; The tertiary is UNMARKED. The resulting primary uses 3 bytes in 
sort keys.</p>
<pre>CP  =              wwww xxxxxxxy yyyyyyzz</pre>
<pre>CE1 = 1110wwww xxxxxxx1 00000011 00000011 // normal</pre>
<pre>CE2 = 1yyyyyyy zz100000 00000000 10000000 // continuation</pre>
<pre>CE1 = 0xE0010303 | (CP &amp; 0xFFE00) &lt;&lt; 8;</pre>
<pre>CE2 = 0x80200080 | (CP &amp; 0x001FF) &lt;&lt; 22;</pre>
<p>There's a large gap for customizing.</p>
<h4>Comparison to UCA</h4>
<p>Except for CJK and Hangul, this results in sort keys that are 1 byte shorter 
per basic code point than what is described in UCA. The basic CJK and Hangul 
code points do take 1 byte longer per code point in sort keys than in UCA, but 
(a) UCA does not allow for tailoring relative to implicit code points without 
moving the code points, and (b) all of the CJK countries typically have explicit 
mappings for the characters they care about, which will reset them down to 2 
bytes in those cases.</p>
<h4><a name="Positioning_Implicit_CEs">Positioning Implicit CEs</a> (post 1.8)</h4>
<p>If there is a specific position set for <b>[undefined]</b> (see <a
href="#Undefined_Positioning">rule syntax</a>), one that is not at the end of 
the file, then the weights are computed differently. The length of bytes 
required depends on the size of the gap where the Undefined items are 
positioned. For example, suppose there is a gap of only 1 where <b>[undefined]</b> 
is inserted, so that elements all start with a 16 bit primary pppppppp pppppppp. 
Here is how they would be generated:</p>
<h4>Basic CP</h4>
<p>With a gap of one, the resulting primary occupies 5 bytes in sort keys:</p>
<blockquote>
  <pre>codepoint = wwyyyyyy yzzzzzzz</pre>
  <pre>CE1 = pppppppp pppppppp UNMARKED UNMARKED</pre>
  <pre>CE2 = 111100ww 1yyyyyyy 1zzzzzzz 11110000</pre>
</blockquote>
<h4>Supplementary CP</h4>
<p>&nbsp;With a gap of one, the resulting primary occupies 6 bytes in sort keys. 
(again, subtracting 10000)</p>
<blockquote>
  <pre>codepoint = vvvw wwwwwwyy yyyyyzzz</pre>
  <pre>CE1 = pppppppp pppppppp UNMARKED UNMARKED</pre>
  <pre>CE2 = 11111vvv 1wwwwwww 1yyyyyyy 11110000</pre>
  <pre>CE3 = 1111zzz0 00000000 00000000 00000000</pre>
</blockquote>
<p>However, if the gap is at least 8 at the Undefined position, then effectively 
3 bits from the first primary can be stolen, and all values would have only 1 
Long Extension CE, and take only 5 bytes in the sort key.</p>
<h3 align="left">Charset Ordering (post 1.8)</h3>
<p align="left">To save space, we can use Charset Ordering. This is to account 
for the case where CJK characters are essentially just sorted in character set 
order, e.g. by JIS order. To do this, we would add functions to character set 
converters, as described in the API section.</p>
<h3 align="left">Script Order (post 1.8)</h3>
<p align="left">ScriptOrder uses an optional array to reorder the top bytes of 
primary keys. A valid ScriptOrder array must map 00 to 00, and Fx to Fx, and 
variable primaries to variable primaries. Other bytes it is free to rearrange, 
but the result must be a permutation. This works by making sure that scripts do 
not share a first primary byte (see <a href="#UCA_Processing">#UCA Processing</a>). 
Note that if we have an Expansion, then Continuation weights (see FAQ) have the 
top nybble set to F. This is <b>not</b> interpreted as Special: instead , this 
allows ScriptOrder to ignore those bytes.</p>
<h2 align="left"><a name="Flat_File">Flat File</a></h2>
<p align="left">The flat file structure is very similar to what is describe in 
UCA, with extensions based upon the discussion here. Using a flat file allows us 
to dramatically decrease initialization time, and reduce memory consumption. 
When we process tailoring rules, we have an internal format that is very much 
like the UCA data. We will have a function that writes out that format into a 
flat file.</p>
<p align="left">When we build a tailoring, we make the following modifications 
to the current code. Note that this is not an area where we will spend time 
improving performance, since 99% of the time this is done at ICU build time. The 
current code builds an ordered list of items in the tailoring, where each item 
is an object containing the character(s), an indication of the strength 
difference, plus a special field for contracting characters. Once it is done, it 
assigns CEs to those characters based on the ordering and strength, putting the 
CE's into a trie table plus data structures for expanding, contracting, etc. 
Instead of this, we will build <i>multiple</i> lists, where each list is 
anchored to a position in the UCA.</p>
<p>We will allow &quot;&amp; X &lt; Y&quot;, where X is <i>not</i> explicitly 
defined. (In ICU 1.6 and previous, this is disallowed). In that case, Y will 
give a value that is based off of the <i>implicit</i> value that X would have. 
In processing the rules in the implementation, we may give X the implicit value 
in the intermediate data structure, then remove it when we finally store into 
the flat file to save space.</p>
<p align="left">Since we are tailoring the UCA, we could have call to insert 
elements <i>before</i> a given UCA element. Currently, that would have to be 
done by finding the previous element in the table, and inserting after. That is, 
to insert x with a primary difference before 'a', we have to know that '9'' is 
before it in the UCA, and say &amp;'9' &lt; x. To insert with a secondary 
difference, there is no good mechanism. To address this, we will add '&lt;&lt;' 
as equivalent to ';', and '&lt;&lt;&lt;' as equivalent to ','; we then add the 
reverse syntax defined for each of these operators, and thus be able to say 
&amp;a &gt;&gt; x.</p>
<p align="left">Once the tailoring table is completely built, we will add any 
UCA characters in the range 0..FF that are not there already. At a slight 
increase in table size, that guarantees the minimal code path for many cases. We 
will also close the file under canonical decomposition, so that turning off 
decomposition can be done in certain circumstances for performance. We will 
close the file under compatibility decomposition, so that when you tailor a 
letter, the compatibility characters containing it are also moved. E.g. if we 
put &amp; z &lt; i, then the &quot;fi&quot; ligature will then sort after &quot;fz&quot;.</p>
<h3><a name="Details_on_Generation">Details on Generation</a></h3>
<p>Here's how generation works, logically. (For now, ignore the distinctions 
between levels of difference). The actual implementation will tokenize the rules 
first, and work on that data structure. For all of the following discussion:</p>
<ul>
  <li>the relations , and ; are converted into &lt;&lt;&lt; and &lt;&lt;.</li>
  <li>* stands for any of the relations =, &lt;, &lt;&lt;, &lt;&lt;&lt;, &gt;, 
    &gt;&gt;, &gt;&gt;&gt;.</li>
  <li>The <i>polarity</i> for &lt;, &lt;&lt;, &lt;&lt;&lt; and = is POSITIVE, 
    for &gt;, &gt;&gt;, &gt;&gt;&gt; is NEGATIVE.</li>
  <li>The operations of &lt;, &gt; are stronger than &lt;&lt;, &gt;&gt;, which 
    are strong than &lt;&lt;&lt;, &gt;&gt;&gt;, which are stronger than =.</li>
</ul>
<h4>Data Structures</h4>
<div align="center">
  <center>
  <table border="0" cellspacing="0" cellpadding="4">
    <tr>
      <td width="25%" align="center" valign="top">
        <table border="1">
          <caption><b>ListList</b></caption>
          <tr>
            <td width="100%">ListHeader0</td>
          </tr>
          <tr>
            <td width="100%">ListHeader1</td>
          </tr>
          <tr>
            <td width="100%">ListHeader2</td>
          </tr>
          <tr>
            <td width="100%">...</td>
          </tr>
          <tr>
            <td width="100%">...</td>
          </tr>
          <tr>
            <td width="100%">&nbsp;...</td>
          </tr>
        </table>
      </td>
      <td width="25%" align="center" valign="top">
        <table border="1">
          <caption><b>ListHeader</b></caption>
          <tr>
            <td width="100%">Token* firstPositive</td>
          </tr>
          <tr>
            <td width="100%">Token* lastPositive</td>
          </tr>
          <tr>
            <td width="100%">Token* firstNegative</td>
          </tr>
          <tr>
            <td width="100%">Token* lastNegative</td>
          </tr>
          <tr>
            <td width="100%">Token* reset</td>
          </tr>
          <tr>
            <td width="100%">CE baseCE</td>
          </tr>
          <tr>
            <td width="100%">CE nextCE</td>
          </tr>
          <tr>
            <td width="100%">CE previousCE</td>
          </tr>
          <tr>
            <td width="100%">Strength strongestP</td>
          </tr>
          <tr>
            <td width="100%">Strength strongestN</td>
          </tr>
        </table>
      </td>
      <td width="25%" align="center" valign="top">
        <table border="1">
          <caption><b>Token</b></caption>
          <tr>
            <td width="100%">Token* previous</td>
          </tr>
          <tr>
            <td width="100%">Token* next</td>
          </tr>
          <tr>
            <td width="100%">StrRep source</td>
          </tr>
          <tr>
            <td width="100%">StrRep expansion</td>
          </tr>
          <tr>
            <td width="100%">Strength strength</td>
          </tr>
          <tr>
            <td width="100%">Polarity polarity</td>
          </tr>
        </table>
        &nbsp;
        <table border="1">
          <caption><b>CharsToken</b></caption>
          <tr>
            <td width="100%">Hashtable for mapping<br>
              from chars to tokens</td>
          </tr>
        </table>
      </td>
      <td width="25%" align="center" valign="top">
        <table border="1">
          <caption><b>CEtoStr</b></caption>
          <tr>
            <td width="50%" colspan="2">fast binary header</td>
          </tr>
          <tr>
            <td width="25%">CE0a</td>
            <td width="25%">CE0b</td>
            <td width="25%">StrCRep</td>
          </tr>
          <tr>
            <td width="25%">CE1a</td>
            <td width="25%">CE1b</td>
            <td width="25%">StrCRep</td>
          </tr>
          <tr>
            <td width="25%">...</td>
            <td width="25%">...</td>
            <td width="25%">...</td>
          </tr>
          <tr>
            <td width="25%">CEna</td>
            <td width="25%">CEnb</td>
            <td width="25%">StrCRep</td>
          </tr>
        </table>
        &nbsp;
        <table border="1">
          <caption><b>StringContinue</b></caption>
          <tr>
            <td width="50%">uChar[x]</td>
          </tr>
        </table>
    </tr>
    <tr>
      <td width="25%" align="left" valign="top"><i>list of list of tokens</i></td>
      <td width="25%" align="left" valign="top"><i>header for token list</i></td>
      <td width="25%" align="left" valign="top"><i>tokens,<br>
        mapping to chars</i></td>
      <td width="25%" align="left" valign="top"><i>mapping to:<br>
        next, previous CEs, characters between CEs</i>
    </tr>
  </table>
  </center>
</div>
<p><b>Notes:</b></p>
<ul>
  <li>StrRep is an int. Top 8 bits are length, bottom 24 bits are an offset into 
    the <b>Rules</b> string. This saves string allocations.</li>
  <li><b>CEtoStr</b>
    <ul>
      <li>This is a table used only for generating Tailoring tables, and is so 
        kept separate from the UCA. It consists of all the FCEs in the UCA in 
        sorted order, in the following format:</li>
      <li>
        <p align="left">Each FCE is stored as two Unflagged CEs, a and b. If 
        there is no need for a continuation, CEb is zero. We add two terminating 
        elements, the lowest possible CE and greatest possible CE at the start 
        and end of the table to ensure we have bracketing values. To find next 
        and previous, we take baseCE, and binary search for it in this table. 
        There is a fast binary header, supporting completely unrolled binary 
        search.</li>
      <li>
        <p align="left">StrCRep is either a codepoint, or if the top byte is 
        non-zero, is a StrRep pointing into StringContinue. If one CE 
        corresponds to two character strings, both are listed in StringContinue, 
        separated by FFFF. If a string has an expansion, that uses FFFE as a 
        delimiter. Example:
        <ul>
          <li>
            <p align="left">CE_Reverse</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<p><b>Processing Description</b></p>
<ol>
  <li>Build a ListList. Each list has a header, which contains two lists 
    (positive and negative), a reset token, a baseCE, nextCE, and previousCE. 
    The lists and reset may be null.</li>
  <li>As you process, you keep a LAST pointer that points to the last token you 
    handled.</li>
  <li>Consider each item: relation, source, and expansion: e.g. ...<u>&lt; x / y</u> 
    ...
    <ul>
      <li>First convert all expansions into normal form. Examples:
        <ul>
          <li>If &quot;xy&quot; doesn't occur earlier in the list or in the UCA, 
            convert &amp;xy * c * d * ... into &amp;x * c/y * d * ...</li>
          <li>Note: reset values can <i>never have</i> expansions, although they 
            can cause the very next item to have one. They may be contractions, 
            if they are found earlier in the list.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Lookup each [source,&nbsp; expansion] in the CharsToToken map, and find a 
    sourceToken</li>
  <li>If the relation is a reset:
    <ul>
      <li>If sourceToken is null
        <ul>
          <li>Create new list, create new sourceToken, make the baseCE from 
            source, put the sourceToken in ListHeader of the new list</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Otherwise (when relation != reset)
    <ul>
      <li>If sourceToken is null, create new one, otherwise remove sourceToken 
        from where it was.</li>
      <li>If LAST is a reset
        <ul>
          <li>insert sourceToken at the head of either the positive list or the 
            negative list, depending on the polarity of relation.</li>
          <li>set the polarity of sourceToken to be the same as the list you put 
            it in.</li>
        </ul>
      </li>
      <li>Otherwise (when LAST is not a reset)
        <ul>
          <li>if polarity (LAST) == polarity(relation), insert sourceToken <b>after</b> 
            LAST, otherwise insert <b>before</b>.</li>
          <li>when inserting after or before, search to the next position with 
            the same strength in that direction. (This is called <a
            href="#Postpone_Insertion">postpone insertion</a>).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>After all this, set LAST to point to sourceToken, and goto step 3.</li>
</ol>
<p>At the end of this process, you will end up with a list of lists of tokens. 
To do the next phase, we need the following relations:</p>
<ul>
  <li>
    <p align="left">previousCE(ce, strength) and nextCE(ce, strength), using <b>CEtoStr</b>. 
    Examples:
    <ul>
      <li>
        <p align="left">[11 . 8 . C]&nbsp; &lt;= previousCE(X,1)</li>
      <li>
        <p align="left">[13 . 4 . 4]</li>
      <li>
        <p align="left">[13 . 4 . A]&nbsp; &lt;= previousCE(X,2)</li>
      <li>
        <p align="left">[13 . 6 . 1]</li>
      <li>
        <p align="left">[13 . 6 . 4]&nbsp; &lt;= previousCE(X,3)</li>
      <li>
        <p align="left"><b>[13 . 6 . 9]&nbsp; &lt;= X</b></li>
      <li>
        <p align="left">[13 . 6 . C] &lt;= nextCE(X,3)</li>
      <li>
        <p align="left">[13 . 6 . E]</li>
      <li>
        <p align="left">[13 . 7 . 3] &lt;= nextCE(X,2)</li>
      <li>
        <p align="left">[13 . 7 . A]</li>
      <li>
        <p align="left">[15 . 3 . 3] &lt;= nextCE(X,1)</li>
    </ul>
  </li>
</ul>
<h4>Assigning CEs</h4>
<ol>
  <li>Find the strongest strength in each list, and set strongestP and 
    strongestN accordingly in the headers.</li>
  <li>Eliminate the negative lists by doing the following for each non-null 
    negative list:
    <ul>
      <li>if previousCE(baseCE, strongestN) != some ListHeader X's baseCE, 
        create new ListHeader X</li>
      <li>reverse the list, add to the end of X's positive list. Reset the 
        strength of the first item you add, based on the stronger strength 
        levels of the two lists.</li>
    </ul>
  </li>
  <li>For each ListHeader with a non-null positive list:
    <ul>
      <li>Find all character strings with CEs between the baseCE and the 
        next/previous CE, at the strength of the first token. Add these to the 
        tailoring.
        <ul>
          <li>That is, if UCA has ...&nbsp; x &lt;&lt;&lt; X &lt;&lt; x' 
            &lt;&lt;&lt; X' &lt; y ..., and the tailoring has &amp; x &lt; z...</li>
          <li>Then we change the tailoring to &amp; x&nbsp; &lt;&lt;&lt; X 
            &lt;&lt; x' &lt;&lt;&lt; X' &lt; z ...</li>
        </ul>
      </li>
      <li>Allocate CEs for each token in the list, based on the total number N 
        of the largest level difference, and the gap G between baseCE and nextCE 
        at that level. The relation * between the last item and nextCE is the 
        same as the strongest strength.</li>
      <li>Example: baseCE &lt; a &lt;&lt; b &lt;&lt;&lt; q &lt;&lt; c &lt; d 
        &lt; e * nextCE(X,1)
        <ul>
          <li>There are 3 primary items: a, d, e. Fit them into the primary gap. 
            Then fit b and c into the secondary gap between a and d, then fit q 
            into the tertiary gap between b and c.</li>
        </ul>
      </li>
      <li>Example: baseCE &lt;&lt; b &lt;&lt;&lt; q &lt;&lt; c * nextCE(X,2)
        <ul>
          <li>There are 2 secondary items: b, c. Fit them into the secondary 
            gap. Then fit q into the tertiary gap between b and c.</li>
        </ul>
      </li>
      <li>When incrementing primary values, we will not cross high byte 
        boundaries except where there is only a single-byte primary. That is to 
        ensure that the script reordering will continue to work.</li>
    </ul>
  </li>
</ol>
<h4>Produce Canonical Closure</h4>
<ul>
  <li>For each Unicode character with a canonical decomposition (e.g. å), check 
    to see if any of the decomposed characters (a, °) are tailored. If so, then 
    the appropriate tailoring expansion is added (å = a °).</li>
  <li>For each Unicode character with a compatibility decomposition (e.g. 
    circled-a), check to see if any of the decomposed characters are tailored. 
    If so, then the appropriate tailoring expansion is added (circled-a = a), 
    but with the tertiary value set according to the table in UCA.</li>
  <li>Note: the UCA already contains closures for the non-tailored items.</li>
</ul>
<h4>Add all Latin-1</h4>
<ul>
  <li>Copy all the UCA mappings for Latin-1 characters that are not tailored 
    into the tailoring. This also does not require any gap processing.</li>
  <li>The goal is performance, as described above.</li>
</ul>
<h3 align="left">Get Rules</h3>
<p align="left">The API for get rules will return just the tailoring rules (we 
store this with the flat file). The API for get full rules will get the UCA 
rules (we generate and store this with the UCA flat file), then appends the 
tailoring rules.</p>
<h3 align="left"><b><a name="Postpone_Insertion">Postpone Insertion</a></b></h3>
<p align="left">ICU 1.6 and below used <i>direct insertion</i> for tailoring, as 
shown below. The plan is to use <i>postpone insertion</i> for 1.8.</p>
<div align="center">
  <center>
  <table border="1" cellspacing="1" cellpadding="4">
    <tr>
      <th>&nbsp;</th>
      <th>Source</th>
      <th>Result</th>
    </tr>
    <tr>
      <th>UCA</th>
      <td><b>...&nbsp; x &lt;&lt;&lt; X &lt;&lt; x' &lt;&lt;&lt; X' &lt; y ...</b></td>
      <td>&nbsp;</td>
    </tr>
    <tr>
      <th>Direct Insertion</th>
      <td><font color="#FF0000"><b>&amp; x &lt; z</b></font></td>
      <td><b>...&nbsp; x <font color="#FF0000">&lt; z</font> &lt;&lt;&lt; X 
        &lt;&lt; x' &lt;&lt;&lt; X'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt; y</b></td>
    </tr>
    <tr>
      <th>Postpone Insertion</th>
      <td><font color="#FF0000"><b>&amp; x &lt;: z</b></font></td>
      <td><b>...&nbsp; x&nbsp;&nbsp;&nbsp;&nbsp; &lt;&lt;&lt; X &lt;&lt; x' 
        &lt;&lt;&lt; X' <font color="#FF0000">&lt; z</font> &lt; y</b></td>
    </tr>
  </table>
  </center>
</div>
<p align="left">The reason we didn't originally use postpone is that it is 
relatively easy to emulate. For example, in the above case, <b><font
color="#FF0000">&amp; X' &lt; z</font></b> is the equivalent of <b><font
color="#FF0000">&amp; x &lt;: z</font></b>. However, it is not easy to emulate 
direct insertion with postpone insertion: in the above case you would have to 
use <font color="#FF0000"><b>&amp; x &lt;: z &lt;&lt;&lt;: X &lt;&lt;: x' 
&lt;&lt;&lt;: X'</b></font> to emulate <b><font color="#FF0000">&amp;x &lt; z</font></b>. 
However, postpone insertion is probably more intuitive, is more stable under new 
versions of UCA, and works better with the large number of variant characters in 
UCA. In practice, given the tailoring rules from the old ICU, this will actually 
produce results that more compatible than if we retained direct insertion.</p>
<h2 align="left"><a name="UCA_Processing">UCA Processing</a></h2>
<p align="left">The UCA data table only specifies relative ordering among 
weights. We are free to redistribute the weight values as long as the relative 
ordering is the same. To make our processing more efficient, decrease the 
sort-key length for A-Z, allow script-ordering, provide for tailoring of the 
read-only table, we will preprocess the data so that we:</p>
<ol>
  <li>
    <p align="left">Add gap of at least 1 between all weights at each level 
    (allows tailoring).</li>
  <li>
    <p align="left">Allow no bytes of 00 or 01 (for C-strings)</li>
  <li>
    <p align="left">Set the following primaries to have odd single-byte 
    primaries (e.g. 3100, 3300, 3500...) for compression (they are odd to allow 
    gaps for tailoring).
    <ol>
      <li>
        <p align="left">Space</li>
      <li>
        <p align="left">Latin a-z</li>
      <li>
        <p align="left">Kana</li>
      <li>
        <p align="left">Hangul Jamo?</li>
    </ol>
  </li>
  <li>
    <p align="left">Start at 03 for all weights (so we have a gap between the 
    weight and 01). So MIN_VALUE is 02, and UNMARKED is 03.</li>
  <li>
    <p align="left">Add a large gap between UNMARKED and other values, to allow 
    for UCA-style run-length compression.</li>
  <li>
    <p align="left">Drop all &quot;artificial secondaries&quot; introduced for 
    canonical decomposables, then pack secondaries, starting at UNMARKED. (so we 
    can use fewer bits for secondaries)</li>
  <li>
    <p align="left">Start different scripts on 256 bounds (to let us shuffle 
    scripts). Scripts are determined by the scripts of letters in 
    ScriptNames.txt, except that&nbsp; variables are treated as a separate 
    script.</li>
  <li>
    <p align="left">We generate the case bit. It is OFF if <b><i>no</i></b> 
    character in the string is uppercase, titlecase, or large hiragana/katakana. 
    Otherwise it is ON.</li>
</ol>
<div align="center">
  <center>
  <table border="1" width="90%">
    <tr>
      <td width="100%">
        <p align="left"><b>Note: </b>We <i>already</i> allow for both normalized 
        and non-normalized collation in ICU 1.6 (and earlier). In building data 
        tables: (a) all rules are normalized to NFD before the characters are 
        added to the table, (b) after all rules have been added, then all 
        decomposables (except Hangul) are added as expansions. Step (b) is 
        equivalent to adding all the following rules (with normalization off):</p>
        <blockquote>
          <p align="left">&amp; a ` = à<br>
          &amp; a <font size="3">´ = á<br>
          ...</font></p>
        </blockquote>
        <p align="left"><font size="3">This will get the correct answer whether 
        or not the source text for any sort key is normalized or not, <i>unless</i> 
        the text contains characters that are not in canonical order. So for the 
        locales that would really be affected by this (Greece, Vietnam), we turn 
        on normalization by default.</font></td>
    </tr>
  </table>
  </center>
</div>
<p align="left"><i><b>A draft processed UCA table is found in <a
href="#Appendix_3">Appendix 3: Data Files</a>. For information on the 
fractional_ce, see <a href="#Fractional_Collation_Elements">Fractional Collation 
Elements</a>.</b></i></p>
<p align="left">Once we process the UCA data, we will write it out in a compact, 
efficient form using the function described in <a href="#Flat_File">Flat File</a>.</p>
<h4 align="left">Japanese Collation</h4>
<p align="left">Supporting compatibility with Office collation for Japanese 
involves using the caseLevel, plus changing the data (see <a href="#Appendix_1">Appendix 
1</a> for comparison). The caseLevel is described elsewhere. The current ICU 
data is of the form:</p>
<p align="left"><font face="Helv" size="2" color="#000000">&lt; </font><font
size="2" color="#000000">ゆ </font><font face="Helv" size="2" color="#000000">, 
</font><font size="2" color="#000000">ゅ </font><font face="Helv" size="2"
color="#000000">, </font><font size="2" color="#000000">ユ </font><font
face="Helv" size="2" color="#000000">, </font><font size="2" color="#000000">ユー</font><font
face="Helv" size="2" color="#000000">/</font><font size="2" color="#000000">ウ </font><font
face="Helv" size="2" color="#000000">, </font><font size="2" color="#000000">ュ 
</font><font face="Helv" size="2" color="#000000">, </font><font size="2"
color="#000000">ュー</font><font face="Helv" size="2" color="#000000">/</font><font
size="2" color="#000000">ウ</font></p>
<p align="left">To change the data part for compatibility means putting small 
before large, and katakana before hiragana. This can be done independent of the 
caseLevel feature, to get closer to the Office collation.</p>
<p align="left">&lt;&nbsp; ュ ,&nbsp; ュー/ウ ,&nbsp; ゅ ,&nbsp; ユ , 
ユー/ウ ,&nbsp; ゆ</p>
<h2 align="left"><a name="Rule_Syntax">Rule Syntax</a></h2>
<p align="left">The rule syntax will be augmented slightly to allow control of 
UCA features, and some of the additional features discussed here. Additional 
commands are expressed in square brackets. Extra whitespace is not significant, 
except where it would break identifiers. Case is not significant. For forward 
compatibility, unknown command keywords are ignored.</p>
<h3 align="left">UCA</h3>
<div align="left">
  <pre>[rearrange 0E40,0E41,0E42,0E43,0E44,0EC0,0EC1,0EC2,0EC3,0EC4]
[alternate shifted]
[backwards 2]
[variable top]</pre>
</div>
<ul>
  <li>
    <p align="left">For alternate we only support 'non-ignorable' | 'shifted'.</li>
  <li>
    <p align="left">For backwards we only support 'backwards 2', 'forwards 2'</li>
  <li>
    <p align="left">For backwards compability, a &quot;@&quot; is interpreted as 
    &quot;[backwards 2]&quot;.</li>
  <li>
    <p align="left">You can have [variable top] in place of a letter, e.g. '9' 
    &lt; [variable top]. This causes all non-zero primary weights at or below 
    that value to be variable.</li>
</ul>
<h3 align="left">Extensions</h3>
<h4 align="left">Normalization</h4>
<p align="left">Since normalization can slow down processing, we provide a rule 
that lets you turn it on or off. E.g.</p>
<pre>[normalization off]</pre>
<h4 align="left">Case</h4>
<p align="left">We add some syntax for controlling case behavior: setting the 
level on or off; and determining whether the case ordering is &quot;upper&quot; 
first, &quot;lower&quot; first, or &quot;default&quot;. If 'default', then the 
tertiary mask is 0x7F, otherwise it is 0xFF. If upper, then the case bit is 
inverted. If lower, then the case bit is left alone.</p>
<div align="left">
  <pre>[caseLevel on]</pre>
</div>
<div align="left">
  <pre>[caseFirst lower]</pre>
</div>
<div align="left">
  <pre>The Japanese tailoring, for example, would set caseLevel ON.</pre>
</div>
<h4 align="left">Script Order</h4>
<p align="left">You can create a ScriptOrder array based on the script of 
letter1, then script of letter 2, etc. This <a href="#Overriding script orders">overrides</a> 
the UCA order. E.g.</p>
<div align="left">
  <pre>[scriptOrder α, я, f]</pre>
</div>
<p align="left">&nbsp;In case of any conflict, the later ones are ignored. E.g. 
in the following, the &quot;β&quot; is ignored:</p>
<div align="left">
  <pre>[scriptOrder α, я, f, β]</pre>
</div>
<p align="left">The special symbol &quot;¤&quot; stands for all non-variable 
CEs that are below &quot;a&quot; in the UCA.</p>
<h4 align="left">Charset</h4>
<p align="left">Two pieces of syntax must be added. Charset is only valid if 
there is a preceding charsetname.</p>
<pre>[charsetname SJIS]

[charset 3400-9FAF]</pre>
<h4><a name="Undefined_Positioning">Undefined Positioning</a> (Post v1.8)</h4>
<pre>[undefined]</pre>
<p>This is a syntax element that puts all undefined codepoints at that location. 
This behaves like the UNDEFINED option described in UCA, in that it puts all 
implicit CEs at that point instead of at the end. There is always a primary 
difference with [undefined]; that is,</p>
<p align="center">&quot;&amp; X , [undefined] , Y&quot; is treated as if it were 
&quot;&amp; X &lt; [undefined] &lt; Y&quot;</p>
<p>A specified position for [undefined] will, however, generate longer sort keys 
than if all undefined values are left at the end. Basic values would use one 
extra Long Continuation CE to encompass the extra bits, while supplementary code 
points would use 2 extension CEs. See <a href="#Positioning_Implicit_CEs">Positioning 
Implicit CEs</a>.</p>
<h2 align="left"><a name="Versioning">Versioning</a></h2>
<p align="left">There are three important versions.&nbsp; Each of these three 
must be available for clients. In addition, a hash of the Tailoring table is 
available for security checks.</p>
<ul>
  <li>
    <p align="left">the Code (determines the structure of the sort key),</li>
  <li>
    <p align="left">the UCA table/Unicode version (which will change over time, 
    as characters are added), and</li>
  <li>
    <p align="left">the Tailoring table (which may change for a particular 
    language, e.g. as more becomes known about the language or as if the laws in 
    the country change).</li>
</ul>
<p align="left">We will return this as a single 32-bit int. The Code and/or 
UCA/Unicode values are bumped with any version of ICU that changes them. The 
tailoring version comes from the resource. The Charset version is zero if no 
charset is used, otherwise it is a charset version.</p>
<div align="center">
  <table border="1" cellspacing="1">
    <tr>
      <td width="25%" bgcolor="#00FF00" align="center">
        <p align="left"><font size="2">Code</font></p>
      </td>
      <td width="25%" bgcolor="#00FF00" align="center">
        <p align="left"><font size="2">UCA/Unicode</font></p>
      </td>
      <td width="25%" bgcolor="#00FF00" align="center">
        <p align="left"><font size="2">Charset</font></p>
      </td>
      <td width="25%" bgcolor="#00FF00" align="center">
        <p align="left"><font size="2">Tailoring</font></p>
      </td>
    </tr>
  </table>
</div>
<p align="left">In future versions of ICU, if you ask for a collator with this 
version (and the same locale), you will get the same binary sort key. <i>However, 
it is your own responsibility to save any parameter settings that could change 
the binary sort key (normalization, strength, etc)! If you use customized rules, 
management is also left up to you.</i></p>
<h3 align="left">Registration</h3>
<p align="left">Registration lets you register a collator, whether from the 
system or a custom-built one from rules, for a Locale. If any function in that 
address space then creates a collator afterwards using that locale, they get a 
copy of the registered collator. This is not persistent over reboots. See the 
ICU User Guide for more information.</p>
<h2 align="left"><a name="API">API</a></h2>
<p>We add some API to C and C++ to allow control over additional features, unify 
feature control system, manage memory more efficiently and improve performance 
in some special cases. None of these are breaking changes, although we do have 
two semantic changes.</p>
<ol>
  <li>
    <p align="left">The RuleBasedCollator class constructor and corresponding C 
    ucol_open take only the tailoring rules as input, not the whole set.</li>
  <li>
    <p align="left">The default decomposition mode is NFD for compatibility with 
    UCA, instead of NFKD.</li>
</ol>
<h3>General attribute handling API:</h3>
<h4>C API</h4>
<pre>void ucol_setAttribute(
  UCollator *coll,
  UColAttribute attr,
  UColAttributeValue value,
  UErrorCode *status);

UColAttributeValue ucol_getAttribute(
  UCollator *coll,
  UColAttribute attr,
  UErrorCode *status);</pre>
<h4>C++ API</h4>
<pre>void setAttribute(
  UColAttribute attr,
  UColAttributeValue value,
  UErrorCode &amp;status);

UColAttributeValue getAttribute(
  UColAttribute attr,
  UErrorCode &amp;status);</pre>
<p>These API are used for setting and getting certain attributes of the 
collation framework. Current attribute types are:</p>
<pre>UCOL_FRENCH_COLLATION,   /* attribute for direction of secondary weights*/
UCOL_ALTERNATE_HANDLING, /* attribute for handling variable elements*/
UCOL_CASE_FIRST,         /* which goes first, lower case or uppercase */
UCOL_CASE_LEVEL,         /* do we have an extra case level */
UCOL_DECOMPOSITION_MODE, /* attribute for normalization */
UCOL_STRENGTH            /* attribute for strength */</pre>
<p>Allowable values for the attributes vary from the attribute to attribute. 
They are summarized in the following list:</p>
<pre>/* accepted by most attributes */
 UCOL_DEFAULT,

/* for UCOL_FRENCH_COLLATION &amp; UCOL_CASE_LEVEL &amp; UCOL_DECOMPOSITION_MODE */
 UCOL_ON,
 UCOL_OFF,

/* for UCOL_ALTERNATE_HANDLING */
 UCOL_SHIFTED,
 UCOL_NON_IGNORABLE,

/* for UCOL_CASE_FIRST */
 UCOL_LOWER_FIRST,
 UCOL_UPPER_FIRST,

/* for UCOL_DECOMPOSITION_MODE */
 UCOL_ON_WITHOUT_HANGUL,

/* for UCOL_STRENGTH */
 UCOL_PRIMARY,
 UCOL_SECONDARY,
 UCOL_TERTIARY,
 UCOL_DEFAULT_STRENGTH = UCOL_TERTIARY,
 UCOL_QUATERNARY,
 UCOL_MAXIMUM_STRENGTH</pre>
<p>The &quot;Universal&quot; attribute value is UCOL_DEFAULT, which sets the 
value of the attribute to the default set by the tailoring rules. Attribute 
values that are inappropriate for the particular attribute types result in 
U_ILLEGAL_ARGUMENT_ERROR.</p>
<h3>Memory</h3>
<p>We add a safeClone, so that people can more easily manage collators among 
threads. We will allow stack allocation. If created on the stack, the close 
function does not free the main storage (but may free internal storage). We can 
consider making the close operation a macro, so that there is zero overhead if 
nothing needs doing.</p>
<h4>C API</h4>
<pre><font face="Courier New" color="#000000" size="2">UCollator *ucol_safeClone(const UCollator *coll,
  void *stackBuffer,
  uint32_t bufferSize,
  UErrorCode *status);</font></pre>
<h4>C++ API</h4>
<pre><font face="Courier New" color="#000000" size="2">Collator* safeClone(void);</font></pre>
<p align="left">In the future, we could add an open function that allows stack 
allocation.</p>
<h3>Rule retrieval</h3>
<p>The new API can return either rule set or only the tailoring, depending on an 
argument</p>
<h4>C API</h4>
<pre>int32_t ucol_getRulesEx(const UCollator *coll,
  UColRuleOption delta,
  UChar *buffer,
  int32_t bufferLen);</pre>
<h4>C++ API</h4>
<pre>UnicodeString getRules(UColRuleOption delta);</pre>
<p>The delta parameter is from the following range:</p>
<pre>UCOL_TAILORING_ONLY,
UCOL_FULL_RULES</pre>
<h3>Custom data handling for string comparison</h3>
<p>We allow user to supply their own function for fetching characters.
<h4>C API</h4>
<pre>U_CAPI UCollationResult ucol_strcollinc(const UCollator *coll, 
  UCharForwardIterator *source,
  void *sourceContext,
  UCharForwardIterator *target,
  void *targetContext);</pre>
<p>Where the iterating function returns either a regular UChar value, or FFFF if 
there are no more characters to be processed. It is defined as:</p>
<pre>typedef UChar UCharForwardIterator(void *context);</pre>
<h4>C++ API</h4>
<p>The C++ equivalent relies on the implementation of the abstract 
ForwardCharacterIterator class:</p>
<pre>virtual EComparisonResult compare(
  ForwardCharacterIterator &amp;source,
  ForwardCharacterIterator &amp;target);</pre>
<h3>Sort key array retrieval (C++ only)</h3>
<p>In order to have the same functionality as in C, the C++ API gets the 
following functions:
<pre>virtual int32_t getSortKey(
  const UnicodeString&amp; source,
  uint8_t *result,
  int32_t resultLength) const;

virtual int32_t getSortKey(
  const UChar *source,
  int32_t sourceLength,
  uint8_t *result,
  int32_t resultLength) const;</pre>
<p>These API store the sort key in an uint8_t (e.g. byte) array. The functions 
do the standard preflighting.</p>
<h3 align="left">Script Order (future option)</h3>
<div align="left">
  <pre>char* temp = &quot;\u03B1, \u044F, f&quot;;
// use unescape to put into uchar* tempu;
ucol_setScriptOrder(aCollator, tempu);</pre>
</div>
<p align="left">Puts the characters in temp into a scriptOrder array. Whitespace 
and commas are ignored. This <a href="#Overriding script orders">overrides</a> 
the tailored order, which in turn overrides the UCA order.</p>
<h4 align="left"><a name="Overriding script orders">Overriding script orders</a></h4>
<p align="left">When a script order overrides another you merge them together in 
the following way, with the overriding script order as the master, and the 
overridden one as slave:</p>
<blockquote>
  <p align="left">Start with the master. Find the first script in the slave that 
  is also in the master. If there is none, add all slave values at end of 
  master, and terminate. If there is one, insert all preceding slave values 
  before the matching value in the master. Set the current_position to be <i>after</i> 
  the matching value in the master. Successively add the remaining elements from 
  the slave, as follows:</p>
  <ul>
    <li>
      <p align="left">If the slave value is in the master, set the 
      current_position to <i>after</i> that master value</li>
    <li>
      <p align="left">If the slave value is not in the master, insert <i>before</i> 
      the current_position and increment current_position.</li>
  </ul>
</blockquote>
<p align="left"><i>Example (using characters to stand for scripts):</i></p>
<blockquote>
  <p align="left">Master: α, я, f</p>
  <p align="left">Slave:亰, f, ¤, α</p>
  <p align="left">Results: α, я, 亰, f, ¤</p>
</blockquote>
<p align="left">Before execution, these characters are used to form a permuting 
scriptOrder array, as described in the implementation section.</p>
<h3 align="left">Charset Ordering</h3>
<p align="left">The following methods need to be added to charset converters, 
before we can support the charset feature.</p>
<div align="left">
  <pre>/** Returns CE values for given character. The first is the return, the rest
 *  are filled in.
 *  Resets ceBufferEnd to indicate length in queue. Can never return more than CEBUFFER_MAX.
 *  Must be well-formed CEs!!
 *  the data represents the primary weight bytes to append to the first CE.
 */

ce = cvt_getOrdering(Converter cvt, int data, uchar32 ch, int[] ceBuffer, int* ceBufferEnd);</pre>
</div>
<p align="left">The top 8 bits of the data is used as the first primary weight: 
the others are extensions.</p>
<div align="left">
  <pre>/** Returns a version ID. This is a byte, which we bump in ICU 
  * whenever the collation result in getOrdering would differ because of data changes.
 */

uint8_t  cvt_getColVersion(Converter cvt);</pre>
</div>
<h1><a name="Issues">Issues</a></h1>
<p>The following section lists issues and possible future additions.</p>
<h3><a name="Parameterized_SHIFTED">Parameterized SHIFTED</a> (post 1.8 
possibility, but current implication)</h3>
<p>We could offer a further variation on Variable. Instead of having SHIFTED 
always shift the primary down to the 4th level, we could allow it to shift to 
the 3rd level or second level. (Note: ICU 1.6 used 3rd level), before all other 
elements at that level. Here is an example of the difference it would make.</p>
<table border="1">
  <tr>
    <th width="33%">Not Ignored</th>
    <th width="33%">Shifted to 3rd</th>
    <th width="34%">Shifted to 4th</th>
  </tr>
  <tr>
    <td align="center">di silva<br>
      di Silva<br>
      Di silva<br>
      Di Silva<br>
      disilva<br>
      diSilva<br>
      Disilva<br>
      DiSilva</td>
    <td align="center">di silva<br>
      di Silva<br>
      disilva<br>
      diSilva<br>
      Di silva<br>
      Di Silva<br>
      Disilva<br>
      DiSilva</td>
    <td align="center">di silva<br>
      disilva<br>
      di Silva<br>
      diSilva<br>
      Di silva<br>
      Disilva<br>
      Di Silva<br>
      DiSilva</td>
  </tr>
</table>
<p align="left">Although this is an algorithymic change, to allow for the 
possibility of adding this in the future we need to reserve one additional value 
in the Fractional UCA table on the 2nd and 3rd levels, a value that is before 
UNMARKED. This means that UNMARKED goes to 04. Any variable primary that is 
shifted down will be appended to that value.</p>
<p align="left"><i>Example:</i></p>
<table border="1">
  <tr>
    <th width="50%" align="right">&nbsp;</th>
    <td width="50%">P</td>
    <td width="50%">S</td>
    <td width="50%">T</td>
    <td width="50%">Q</td>
  </tr>
  <tr>
    <th align="right">Original CE</th>
    <td>05</td>
    <td>92</td>
    <td>31</td>
    <td>N/A*</td>
  </tr>
  <tr>
    <th align="right">Shifted to level 2</th>
    <td>00</td>
    <td>02 05</td>
    <td>02 92</td>
    <td>N/A*</td>
  </tr>
  <tr>
    <th align="right">Shifted to level 3</th>
    <td>00</td>
    <td>00</td>
    <td>00</td>
    <td>N/A*</td>
  </tr>
  <tr>
    <th align="right">Shifted to level 4</th>
    <td>00</td>
    <td>00</td>
    <td>00</td>
    <td>05</td>
  </tr>
</table>
<p align="left"><font size="-1">* Note that unless variable handling is on, 
there is no 4th level generated. This is separate from whether there is an 
IDENTICAL level added, which is always simply (normalized) code points.</font></p>
<p align="left">To allow for the future possibility of putting variables after 
all other values at that level, we should also reserve the highest value. Here 
is the resulting table of values for secondaries and tertiaries.</p>
<p align="left">IGNORABLE = 00<br>
SEPARATOR FOR LEVELS = 01<br>
RESERVED FOR SHIFTING = 02<br>
GAP FOR TAILORING = 03<br>
UNMARKED = 04<br>
GAP FOR TAILORING = 05<br>
GREATEST UCA = FC<br>
GAP FOR TAILORING = FD, FE<br>
RESERVED FOR SHIFTING = FF</p>
<h3 align="left">Fixed Positions (post 1.8 possibility)</h3>
<p align="left">The following are special items that can be used as reset 
values, so that Tailoring tables do not have to change when UCA adds more 
characters. For example, in tailoring all of CJK one can start with &amp; [last] 
&lt; .... to have all CJK at the end. If we had &amp;{yi syllable xxx} &lt; ..., 
then their position changes once characters are added after Yi. Here is the list 
of possibilities.</p>
<ul>
  <li>
    <p align="left">[last] last CE in the UCA table</li>
  <li>
    <p align="left">[first] first CE in the UCA table</li>
  <li>
    <p align="left">[last variable] last variable value</li>
  <li>
    <p align="left">[last primary ignorable] largest CE for primary ignorable</li>
  <li>
    <p align="left">[last secondary ignorable] largest CE for secondary 
    ignorable</li>
  <li>
    <p align="left">[last tertiary ignorable] largest CE for tertiary ignorable<br>
  </li>
</ul>
<h3 align="left">Compressed Primary Weights</h3>
<p align="left">We need to decide whether we are compressing primary weights or 
not. See <a href="#Compression">Compression</a> and <a href="#Appendix_2">Appendix_2</a>.</p>
<hr>
<h2 align="left"><a name="FAQ">FAQ</a></h2>
<p class="q" align="left">Q: The small/large kana differences: should that be 
set in the rules or by API?</p>
<p class="a" align="left">A: The case bit is set programmatically, on the basis 
of case and small/large kana differences. Whether and how to use it is 
controlled by both the API and the tailoring.</p>
<p class="q" align="left">Q. The reverse searching still has support for 
contracting sequences, which is used for fast Internationalized Boyer-Moore 
searching?</p>
<p class="a" align="left">A: Yes, we are not removing that capability. The 
backwards offset is used to get the separate table for contractions when 
processing backwards.</p>
<center>
<hr>
</center>
<h3 align="left"><a name="Fractional_Collation_Elements"><b>Long Collation 
Elements</b></a></h3>
<p class="q" align="left">Q: A collation weight in the UCA is defined to be a 16 
bit value (aka wyde). This will surely fail when Unicode 3.1 rolls around, with 
over 90,000 characters!</p>
<p class="a" align="left">A: The UCA makes provision for more than 64K weight 
values: see <a
href="http://www.unicode.org/unicode/reports/tr10/#Large Weight Values">Section 
6.2 Large Weight Values</a> and also <a
href="http://www.unicode.org/unicode/reports/tr10/#Escape hatch">6.3.2 Escape 
Hatch</a>. This mechanism is also used in Weight Derivation, as in <a
href="http://www.unicode.org/unicode/reports/tr10/#LegalCodePoints">7.1.2 Legal 
code points</a>. It discusses using a sequence of two collation elements, of the 
form:</p>
<blockquote>
  <div align="left">
    <pre>[(X1+1).0000.0000], [yyyy.zzzz.wwww]</pre>
  </div>
</blockquote>
<p class="q" align="left">Q: I find this hard to follow. Is there any other way 
to explain the issue?</p>
<p class="a" align="left">Ok. We can look at the weights in a different way, 
which may help to clarify what is going on.</p>
<p class="a" align="left">We'll define <i>fractional collation elements</i> to 
be the same as standard collation elements except that each weight is a fraction 
between zero and one (instead of being an integer from 1 to FFFF). For ease in 
working with computers, these are binary fractions, represented as hexadecimal.</p>
<p class="a" align="left"><i>Examples:</i></p>
<ul>
  <li>
    <p class="a" align="left"><code>[0.000000000, 0.920000000, 0.02057A900]</code></li>
  <li>
    <p class="a" align="left"><code>[0.100000000, 0.A30000000, 0.02057A900]</code></li>
  <li>
    <p class="a" align="left"><code>[0.1202C456B, 0.78AF00000, 0.023A90000]</code></li>
</ul>
<p class="a" align="left">With fractional collation elements, it is easy to see 
that all Unicode code points (including the supplementary code points) could 
have distinct primary mappings: there are innumerably many more than 10FFFF 
possible fractions! <a
href="http://www.unicode.org/unicode/faq/attribution.html#MD">[MD]</a></p>
<p class="q" align="left">Q: Is that all there is to it?</p>
<p class="a" align="left">Not quite. We still will have to turn these fractional 
collation elements into well-formed standard collation elements that we can use 
to build a sort key. To do that, we put some restrictions on the allowable 
values for the fractional weights. By adopting these restrictions, we make the 
conversion very simple, without limiting the indefinitely large range offered by 
fractional weights.</p>
<p class="a" align="left">Consider a fractional weight as broken into a sequence 
of bytes of 2 hex digits each, excluding any trailing bytes that would be 
entirely zero, and omitting the leading &quot;0.&quot;. (We could give a precise 
numeric definition, but it is easier to think of it as simply taking bytes at a 
time.)</p>
<p class="a" align="left"><i>Example:</i></p>
<blockquote>
  <p class="a" align="left"><b>0.12C456A000000...</b> breaks into four bytes: <b>12 
  C4 56 A0<br>
  0.12C456A320000....</b> breaks into five bytes: <b>12 C4</b> <b>56 A3</b>&nbsp; 
  <b>20</b></p>
</blockquote>
<p class="a" align="left">So the first example of fractional collation elements 
becomes:</p>
<p class="a" align="left"><i>Examples:</i></p>
<ul>
  <li>
    <p class="a" align="left"><code>[,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    92,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02 05 7A 90]</code></li>
  <li>
    <p class="a" align="left"><code>[10,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    A3,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 02 05 7A 90]</code></li>
  <li>
    <p class="a" align="left"><code>[12 02 C4 56 B0,&nbsp;&nbsp; 78 AF,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
    02 3A 90]</code></li>
</ul>
<p class="a" align="left">Since we eventually will be converting these 
fractional collation weights into standard ones, we will put some restrictions 
on the values taken by these fractions, based (not surprisingly) on their bytes. 
Since we have wide latitude in choosing the precise values for the fractional 
weights in setting up a collation table, these restrictions are not at all 
onerous.</p>
<p class="a" align="left"><b>R1. </b>No byte can be <b>00</b> or <b>01</b>.</p>
<blockquote>
  <p class="a" align="left">The reason for this rule is to avoid collision with 
  the <i>level separator</i> and with<i> null bytes </i>when the fractional 
  weight is eventually used in a sort key.</p>
</blockquote>
<p class="a" align="left"><i>Example:</i></p>
<blockquote>
  <p class="a" align="left"><b>12 C4 00 50</b> violates R1, since the third byte 
  is zero.</p>
</blockquote>
<p class="a" align="left"><b>R2. </b>A fractional weight cannot exactly match 
the initial bytes of another fractional weight at the same level.</p>
<blockquote>
  <p class="a" align="left">The reason for this rule is to avoid having sort 
  keys where the starting bytes from one string are compared against the 
  trailing bytes from another.</p>
</blockquote>
<p class="a" align="left"><i>Example:</i></p>
<blockquote>
  <p class="a" align="left">The two primary weights <b>A3 92 12 C4 50</b> and <b>A3 
  92 12 C4</b> violate R2. If the second weight were <b>A3 92 12 C5</b> or <b>A3 
  92 12 C4 52</b>, it would not violate R2.</p>
  <p class="a" align="left">Allowing fractions to break this rule would cause a 
  problem when these bytes are pushed into a sort key (see next question). Let's 
  take an example where we just concentrate on the primary weights. Suppose x[1] 
  = <b>A3</b>,&nbsp; y[1] = <b>A3 23</b>, and a[1] = <b>49</b>. Then we would 
  get the following ordering:</p>
  <table border="1">
    <tr>
      <td width="50%">a</td>
      <td width="50%">[<b>49 01...</b>]</td>
    </tr>
    <tr>
      <td width="50%">x</td>
      <td width="50%">[<b>A3 01...</b>]</td>
    </tr>
    <tr>
      <td width="50%">y</td>
      <td width="50%">[<b>A3 23 01 ...</b>]</td>
    </tr>
    <tr>
      <td width="50%">xa</td>
      <td width="50%">[<b>A3 49 01...</b>]</td>
    </tr>
  </table>
  <p class="a" align="left">Because the primary weights turn into different 
  lengths, and they don't follow <b>R2</b>, we get incorrect behavior. If <b>R2</b> 
  is followed, this can never happen, since &quot;x&quot; and &quot;y&quot; 
  would have to differ at some point <i>before</i> we ran out of bytes on one 
  side.</p>
</blockquote>
<p class="a" align="left"><b>R3. </b>No fractional collation element can have a 
zero weight at Level N and a non-zero weight at Level N-1. Any collation 
elements that violate this rule are called <i>ill-formed</i>.</p>
<blockquote>
  <p class="a" align="left">The reason for this rule is to avoid allowing 
  character to transpose, and still have the same sort key (cf.&nbsp; <a
  href="#Step 4">UCA §4.4, Step 4: Compare</a>).</p>
</blockquote>
<p class="a" align="left">Any fractional collation element that does not meet 
these restrictions is called <i>ill-formed</i>. <a
href="http://www.unicode.org/unicode/faq/attribution.html#MD">[MD]</a></p>
<p class="q" align="left">Q: Once I have a well-formed fractional collation 
element table, how do I generate a sort key?</p>
<p class="a" align="left">A fractional collation element table can easily be 
transformed into a standard one. Each fractional collation element is 
transformed into a sequence of one <i>or more</i> standard collation elements:</p>
<ul>
  <li>
    <p class="a" align="left">Break each fractional weight into a sequence of 
    bytes.</li>
  <li>
    <p class="a" align="left">Take two bytes from each level to form a collation 
    element.
    <ul>
      <li>
        <p class="a" align="left">If there is an odd number of bytes, use <b>02</b> 
        for the second byte.</li>
    </ul>
  </li>
  <li>
    <p class="a" align="left">If there are no more bytes for a particular level, 
    use zero for the that level.</li>
  <li>
    <p class="a" align="left">If there are no more bytes for all levels, stop.</li>
</ul>
<p class="a" align="left"><i>Example:</i></p>
<table border="1">
  <tr>
    <th>Fraction Collation Element</th>
    <th>UCA Collation Element</th>
    <th>In Sort Key</th>
  </tr>
  <tr>
    <td>[12 02 C4, 78, 03]</td>
    <td>[1202.7802.0302], [.C402.0000.0000]</td>
    <td>[12 02 C4 02 <b>00 00</b> 78 02 <b>00 00</b> 03 02]</td>
  </tr>
</table>
<p class="a" align="left">Using this transformation, two fractional collation 
elements will have the same relative ordering as their derived UCA collation 
element sequences. Because the fractional collation elements can handle all 
Unicode code points (even supplementary code points, above U+FFFF), so can the 
derived UCA collation elements sequences.</p>
<p class="a" align="left">All but the first collation element in the derived 
sequence are called <i>continuation collation elements.</i> If you now look back 
at the discussions in <a
href="http://www.unicode.org/unicode/reports/tr10/#Large Weight Values">Section 
6.2 Large Weight Values</a>, <a
href="http://www.unicode.org/unicode/reports/tr10/#Escape hatch">6.3.2 Escape 
Hatch</a>, and <a
href="http://www.unicode.org/unicode/reports/tr10/#LegalCodePoints">7.1.2 Legal 
code points</a>, you will see continuation collation elements that implicitly 
represent fractional collation elements. <a
href="http://www.unicode.org/unicode/faq/attribution.html#MD">[MD]</a></p>
<p class="q" align="left">Q: Aren't the continuation collation elements in the 
above example ill-formed?</p>
<p class="a" align="left">The text of the UCA is not as clear as it should be on 
that point. It says:</p>
<blockquote>
  <p class="a" align="left">Except in special cases, no collation element can 
  have a zero weight at Level N and a non-zero weight at Level N-1. Any 
  collation elements that violate this rule are called <i>ill-formed</i>. The 
  reason for this will be explained under Step 4 of the main algorithm.</p>
</blockquote>
<p class="a" align="left">The &quot;special cases&quot; referred to in the text 
are <i>precisely</i> the continuation collation elements that would result from 
generating the collation element table from a fractional collation element 
table. A reformulation in terms of fractional collation elements clears this up. 
<a href="http://www.unicode.org/unicode/faq/attribution.html#MD">[MD]</a></p>
<p class="q" align="left">Q: In tailoring, I need to put a collation element 
between two others. How can I do this without changing the original two values?</p>
<p class="a" align="left">The easiest way to do this is to view the collation 
element table as fractional collation elements, as described in the previous 
questions. If you construct your original table so that you leave a bit of room 
between adjacent collation elements, then you can always find intermediate 
values for the weights at any level. <a
href="http://www.unicode.org/unicode/faq/attribution.html#MD">[MD]</a></p>
<p class="q" align="left">Q: What do you mean by &quot;a bit of room&quot;?</p>
<p class="a" align="left">For two adjacent collation elements in the table, just 
make sure that for each level there is at least one <i>valid</i> fractional 
weight between the weights from those elements.</p>
<p class="a" align="left"><i>Example:</i></p>
<ul>
  <li>
    <p class="a" align="left"><b>AB C3</b> and <b>AB D0</b> have room:
    <ul>
      <li>
        <p class="a" align="left">One could insert 13 different 2-byte 
        fractions: <b>AB C4, AB C5, ..., AB CC;</b> or many more 3 or more byte 
        fractions.</li>
    </ul>
  </li>
  <li>
    <p class="a" align="left"><b>AB CD</b> and <b>AB CF</b> have room:
    <ul>
      <li>
        <p class="a" align="left">One could insert <b>AB CE</b>, or one could 
        insert many more 3-byte fractions: <b>AB CE 02, AB CE 03, ...</b></li>
    </ul>
  </li>
  <li>
    <p class="a" align="left"><b>AB CD</b> and <b>AB CE</b> don't have room.
    <ul>
      <li>
        <p class="a" align="left">While fractions of the form <b>AB CD xx</b> 
        are between these values, they would violate <b>R2</b> above.</li>
    </ul>
  </li>
  <li>
    <p class="a" align="left"><b>AA FF</b> and <b>AB 02</b> don't have room.
    <ul>
      <li>
        <p class="a" align="left">Inserting <b>AA FF xx</b> or <b>AB</b> would 
        violate <b>R1.</b></li>
      <li>
        <p class="a" align="left">inserting <b>AB 00</b> or <b>AB 01</b> would 
        violate <b>R2</b>.</li>
    </ul>
  </li>
</ul>
<p class="q" align="left">Q: So how do I determine the intermediate values?</p>
<p class="a" align="left">First, determine how many weights you need, and then 
how many valid weights are between the two given weights. Unless the fractional 
weights have the same number of bytes <i>and</i> only differ in the last byte, 
there will usually be far more weights than you need. The problem cases are 
where the weights <i>do</i> have the same number of bytes, and only differ in 
the last byte, such as <b>AB CC</b> and <b>AB CF</b>.</p>
<p class="a" align="left">A simple way to assign the weights is the following:</p>
<ul>
  <li>
    <p class="a" align="left">If there is enough room to add all the weights you 
    need, then just add them.</li>
  <li>
    <p class="a" align="left">If not, then fill up the gaps except for the <i>last</i> 
    one.
    <ul>
      <li>
        <p class="a" align="left">For example, with <b>AB CA</b> and <b>AB CF</b> 
        you will insert 3 weights: <b>AB CB, AB CC, AB CD</b>.</li>
    </ul>
  </li>
  <li>
    <p class="a" align="left">If you have no more than 254 elements at this 
    point:
    <ul>
      <li>
        <p class="a" align="left">Make the last fraction one byte longer, 
        starting with <b>02</b>. You now have room for 254 more weights:</li>
      <li>
        <p class="a" align="left">For example, you will use <b>AB CE 02, AB CE 
        03</b>, etc.</li>
    </ul>
  </li>
  <li>
    <p class="a" align="left">Otherwise, you have more than 254 elements at this 
    point, so:
    <ul>
      <li>
        <p class="a" align="left">Make the last fraction two bytes longer, 
        starting with <b>02 02</b>. You now have room for 64,516 more weights:</li>
      <li>
        <p class="a" align="left">For example, you will use <b>AB CE 02 02, AB 
        CE 02 03,..., AB CE 03 02,...</b>, etc.</li>
    </ul>
  </li>
</ul>
<p class="q" align="left">Q: Is this an optimal way to calculate the weights?</p>
<p class="a" align="left">If you know more about the relative frequency of the 
characters in text, you can choose shorter weights for the more frequent 
weights.</p>
<p class="q" align="left">Q: I use the mechanisms in <a href="#L2/L3 in 8 bits">UCA 
§6.1.2, L2/L3 in 8 bits</a> to reduce my sort-key to less than half the size. 
How can I use this continuation/tailoring method with bytes instead of wydes?</p>
<p class="a" align="left">In the above, instead of adding <b>02</b> to 
odd-byte-length weights, leave the bytes zero. When composing the sort key, just 
omit any zero bytes when composing the sort key. Use <b>01</b> for the 
LEVEL_SEPARATOR. Thus the above example would become the considerably shorter 
key below:</p>
<table border="1">
  <tr>
    <th>&nbsp;</th>
    <th>Fraction Collation Element</th>
    <th>UCA Collation Element</th>
    <th>In Sort Key</th>
  </tr>
  <tr>
    <th>Old</th>
    <td>[12 02 C4, 78, 03]</td>
    <td>[1202.7802.0302], [.C402.0000.0000]</td>
    <td>[12 02 C4 02 <b>00 00</b> 78 02 <b>00 00</b> 03 02]</td>
  </tr>
  <tr>
    <th>New</th>
    <td>[12 02 C4, 78, 03]</td>
    <td>[1202.7800.0300], [.C400.0000.0000]</td>
    <td>[12 02 C4&nbsp; <b>01</b> 78 <b>01</b> 03]</td>
  </tr>
</table>
<p class="a" align="left">&nbsp;<a
href="http://www.unicode.org/unicode/faq/attribution.html#MD">[MD]</a></p>
<h2 align="left"><a name="Appendix_1">Appendix 1</a>: Japanese Sort Order</h2>
<p align="left">The following is the result of a test of sorting in Microsoft 
Office, for comparison.</p>
<p align="left">1:LEVEL base chars, length<br>
1:カ<br>
1:カキ<br>
1:キ<br>
1:キキ<br>
<br>
2:LEVEL plain, daku-ten, (handaku-ten)<br>
2:ハカ<br>
2:バカ<br>
2:ハキ<br>
2:バキ<br>
* This is a different level. Notice that the difference between バ and ハ is 
ignored if there is a level 1 difference.<br>
<br>
3:LEVEL small before large<br>
3:ッハ<br>
3:ツハ<br>
3:ッバ<br>
3:ツバ<br>
* This is a different level. Notice that the difference between ッ and ツ is 
ignored if there is a level 2 difference<br>
<br>
4:LEVEL katakana before hiragana<br>
4:アッ<br>
4:あッ<br>
4:アツ<br>
4:あツ<br>
* This is a different level. Notice that the difference between ア and あ is 
ignored if there is a level 3 difference.<br>
<br>
5:LEVEL choo-on kigoo as vowel<br>
5:カーア<br>
5:カーあ<br>
5:カイア<br>
5:カイあ<br>
5:キイア<br>
5:キイあ<br>
5:キーア<br>
5:キーあ<br>
* Office handles the expansion of ー into different characters depending on the 
previous letter, so it sorts before イ when following a カ, but after when 
following a キ. However, it is not a different level from #4, since the order 
does not reverse with a suffix.<br>
<br>
Thus Office has 4 levels:<br>
Level 1 = base letters<br>
Level 2 = plain, daku-ten, handaku-ten<br>
Level 3 = small, large<br>
Level 4 = katakana, hiragana, choo-on kigoo</p>
<h2 align="left"><a name="Appendix_2">Appendix 2</a>: Compressing Primary 
Weights</h2>
<p>The following describes a possible mechanism for compressing primary weights 
in sort keys. We will investigate the performance/storage tradeoff before using. 
For compression of non-secondary weights, see <a href="#Compression">Compression</a>.</p>
<h4>Mechanism</h4>
<p>Generally we will have longish sequences of letters from the same script. 
They will usually share the same first few bytes of primary, and differ in the 
last byte. Let's suppose that we reserve the 02 and FF bytes in final positions 
in primary weights. Then take the longest sequence of two-byte primary weights 
with the same initial weight XX:</p>
<pre>...XX YY XX ZZ XX WW XX MM AA....</pre>
<p>where AA is the first byte of the primary weight that does not start with XX. 
This is transformed into the following, where ** is FF if AA &gt; XX, and 02 if 
AA &lt; XX (or there is no AA).</p>
<pre>...XX YY ZZ WW MM ** AA...</pre>
<p>That is, we delete all XX's but the first one, then add ** at the end.</p>
<h4>Proof</h4>
<p>We are guaranteed that this transformation, if performed uniformly, will sort 
with the same order. Look at the following example, where (a) and (b) are the 
originals, and (c) and (d) are the compressed versions:</p>
<pre>a) ...XX YY XX ZZ XX WW XX MM, AA....</pre>
<pre>b) ...XX QQ XX RR XX SS BB....</pre>
<pre>c) ...XX YY ZZ WW MM ** AA...</pre>
<pre>d) ...XX QQ RR SS ** BB...</pre>
<p>If the first difference in either case is at, say, ZZ and RR, then the 
orderings will be the same, since the XX's would be the same in either case, and 
that is the only difference.</p>
<p>If the sequences were the same length and identical, the compressions will be 
as well.</p>
<p>If the sequences are different length, but identical up through the shorter 
one, then we would be comparing, say, ** in (d) to MM in (c). The corresponding 
comparison in the originals will be BB in (b) to XX in (a). If BB &lt; XX, then 
** is 02, which is guaranteed to be less than MM. If BB &gt; XX, then ** is FF, 
which is guaranteed to be greater. BB will never be the same as XX, since then 
we would have included it in the compression (since the compression takes the 
longest sequence of XX's).</p>
<h4>Implementation</h4>
<p>The implemenation is reasonably simple. We don't have to backtrack or count 
since we break even with compression of a sequence of two, e.g.</p>
<pre>... XX YY XX ZZ AA...</pre>
<pre>... XX YY ZZ FF AA</pre>
<p>Every time we add a primary weight, check the last first byte. If we ever get 
a primary key that starts with the same byte, we don't add that byte: we set a 
flag. I think the code would look something like:</p>
<pre>if (lastFirstByte != currentFirstByte) {
  if (compressionCount &gt; 1) {
    *p++ = (currentFirstByte &gt; lastFirstByte) ? 0xFF : 0x02;
    compressionCount = 0;
  }
  *p++ = lastFirstByte = currentFirstByte;
} else {
  ++compressionCount;
}
// add other primary weight bytes to *p, if there are any</pre>
<p>This will actually work even if the primary weights have more or fewer bytes, 
although sequences of identical single-byte primaries will probably be rare, and 
the compression is not especially good for triple-bytes.</p>
<p><i>Examples:</i></p>
<h5>Single-byte primaries</h5>
<pre>... XX XX XX AA ...</pre>
<pre>... XX ** AA ...</pre>
<h5>Triple-byte primaries</h5>
<pre>... XX QQ RR XX QQ PP XX SS TT AA ...</pre>
<pre>... XX QQ RR QQ PP SS TT ** AA ...</pre>
<p>We could get better compression for the triple-byte case if we compared more 
than just the first byte. However, this makes the bookkeeping more significant. 
Not sure if it is worth it.</p>
<h4>Data Impact</h4>
<p>For first bytes, we already exclude 00, 01, Dx, Ex, Fx, leaving 206 values. 
For second bytes, we would need to disallow 02 and FF (and we already remove 00 
and 01). That would give us 252 values. For tailoring, we have to leave a gap of 
1, leaving 126 values. That gives us 25,956 possible two-byte primaries instead 
of 26,162 possible two-byte primaries, which is not a huge reduction.</p>
<h4>Performance</h4>
<p>If the above code is about right, then in the worst case (no common first 
bytes of primaries), we would have an extra byte comparison,&nbsp; boolean test, 
and byte set per character. On the other hand, the memory requirements for sort 
keys would probably be reduced sufficiently that it would be an overall win. 
(This would be especially true for disk-based sort indexes!)</p>
<h2><a name="Appendix_3">Appendix 3: Data Files</a></h2>
<p>The following data files are included for reference:</p>
<p><a href="FractionalUCA.zip">FractionalUCA.txt (zipped)</a></p>
<blockquote>
  <p>Table of Fractional CEs generated from UCA. The format is described in the 
  header:</p>
  <div align="left">
    <blockquote>
      <pre align="left">code; fractional_ce  # uca_ce # name</pre>
    </blockquote>
  </div>
  <p align="left">&nbsp;There are extra tabs between the levels, just to make it 
  easier to see transitions in weight length.</p>
</blockquote>
<p><a href="CollationTest_NON_IGNORABLE.zip">CollationTest_NON_IGNORABLE.txt (zipped)</a></p>
<blockquote>
  <p>Contains list of lines in UCA sorted order, for testing collation (with the 
  variables set to NON_IGNORABLE)</p>
</blockquote>
<p><a href="CheckCollationValidity.html">CheckCollationValidity.html</a></p>
<blockquote>
  <p>List of possible problems in UCA</p>
</blockquote>
<h2><a name="Modifications">Modifications</a></h2>
<p>These summarize modifications from the previous version.</p>
<ul>
  <li>Tailoring syntax for changing the variable range was missing, so that was 
    added.</li>
  <li>When going backwards, expansion CEs must be reversed, with continuation 
    CEs handled specially.</li>
  <li>Added subtable counts to header. Made clear that tables are not in 
    predetermined order. Changed Trie to Main, since there may be multiple Trie 
    tables.</li>
  <li>Made more clear that offset in contraction UChar table is a delta</li>
  <li>Added [last] syntax for Tailoring.</li>
  <li>Modified the bit distribution in <a href="#CollationElements">CollationElements</a></li>
  <li>Modified the generation of <a href="#Implicit_CEs">Implicit_CEs</a></li>
  <li>Added <a href="#Details_on_Generation">Details_on_Generation</a></li>
  <li>Added details on <a href="#Compression">Compression</a></li>
  <li>Added <a href="#Issues">Issues</a> section. This needs to be reviewed and 
    discussed!</li>
</ul>
<hr>
<p align="center"><i>Copyright © 2000, IBM Corp. All Rights Reserved.</i></p>

</body>

</html>
