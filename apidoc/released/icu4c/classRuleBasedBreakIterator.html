<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ICU 73.1: icu::RuleBasedBreakIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ICU 73.1<span id="projectnumber">&#160;73.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicu.html">icu</a></li><li class="navelem"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle"><div class="title">icu::RuleBasedBreakIterator Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A subclass of <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> whose behavior is specified using a list of rules.  
 <a href="classicu_1_1RuleBasedBreakIterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rbbi_8h_source.html">rbbi.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for icu::RuleBasedBreakIterator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classicu_1_1RuleBasedBreakIterator.png" usemap="#icu::RuleBasedBreakIterator_map" alt=""/>
  <map id="icu::RuleBasedBreakIterator_map" name="icu::RuleBasedBreakIterator_map">
<area href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text." alt="icu::BreakIterator" shape="rect" coords="0,112,168,136"/>
<area href="classicu_1_1UObject.html" title="UObject is the common ICU &quot;boilerplate&quot; class." alt="icu::UObject" shape="rect" coords="0,56,168,80"/>
<area href="classicu_1_1UMemory.html" title="UMemory is the common ICU base class." alt="icu::UMemory" shape="rect" coords="0,0,168,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a976126b3070d56d23a67184b41e88141"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a976126b3070d56d23a67184b41e88141">RuleBasedBreakIterator</a> ()</td></tr>
<tr class="memdesc:a976126b3070d56d23a67184b41e88141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classicu_1_1RuleBasedBreakIterator.html#a976126b3070d56d23a67184b41e88141">More...</a><br /></td></tr>
<tr class="separator:a976126b3070d56d23a67184b41e88141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaaa98a62891cc8b6ef72c913a67a7b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#acaaa98a62891cc8b6ef72c913a67a7b6">RuleBasedBreakIterator</a> (const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;that)</td></tr>
<tr class="memdesc:acaaa98a62891cc8b6ef72c913a67a7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classicu_1_1RuleBasedBreakIterator.html#acaaa98a62891cc8b6ef72c913a67a7b6">More...</a><br /></td></tr>
<tr class="separator:acaaa98a62891cc8b6ef72c913a67a7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34393c8272153f00eab8b3ba5dd8263"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#af34393c8272153f00eab8b3ba5dd8263">RuleBasedBreakIterator</a> (const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;rules, <a class="el" href="structUParseError.html">UParseError</a> &amp;parseError, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:af34393c8272153f00eab8b3ba5dd8263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of rules supplied as a string.  <a href="classicu_1_1RuleBasedBreakIterator.html#af34393c8272153f00eab8b3ba5dd8263">More...</a><br /></td></tr>
<tr class="separator:af34393c8272153f00eab8b3ba5dd8263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe74962355b2cf5cf699ab2c98d0852d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afe74962355b2cf5cf699ab2c98d0852d">RuleBasedBreakIterator</a> (const uint8_t *compiledRules, uint32_t ruleLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:afe74962355b2cf5cf699ab2c98d0852d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of precompiled binary rules.  <a href="classicu_1_1RuleBasedBreakIterator.html#afe74962355b2cf5cf699ab2c98d0852d">More...</a><br /></td></tr>
<tr class="separator:afe74962355b2cf5cf699ab2c98d0852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde71d5c99670342c9db9e67b7475822"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#adde71d5c99670342c9db9e67b7475822">RuleBasedBreakIterator</a> (<a class="el" href="udata_8h.html#acffec83601fda29bd4750b24f829f56b">UDataMemory</a> *image, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:adde71d5c99670342c9db9e67b7475822"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor uses the udata interface to create a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> whose internal tables live in a memory-mapped file.  <a href="classicu_1_1RuleBasedBreakIterator.html#adde71d5c99670342c9db9e67b7475822">More...</a><br /></td></tr>
<tr class="separator:adde71d5c99670342c9db9e67b7475822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af171cfdce6f264ae7f7f18078248a08b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#af171cfdce6f264ae7f7f18078248a08b">~RuleBasedBreakIterator</a> ()</td></tr>
<tr class="memdesc:af171cfdce6f264ae7f7f18078248a08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classicu_1_1RuleBasedBreakIterator.html#af171cfdce6f264ae7f7f18078248a08b">More...</a><br /></td></tr>
<tr class="separator:af171cfdce6f264ae7f7f18078248a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd180c6ad9f911ad16237c858c47c615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#abd180c6ad9f911ad16237c858c47c615">operator=</a> (const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;that)</td></tr>
<tr class="memdesc:abd180c6ad9f911ad16237c858c47c615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classicu_1_1RuleBasedBreakIterator.html#abd180c6ad9f911ad16237c858c47c615">More...</a><br /></td></tr>
<tr class="separator:abd180c6ad9f911ad16237c858c47c615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266522728258632298ee1bb97922a439"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a266522728258632298ee1bb97922a439">operator==</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;that) const override</td></tr>
<tr class="memdesc:a266522728258632298ee1bb97922a439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="classicu_1_1RuleBasedBreakIterator.html#a266522728258632298ee1bb97922a439">More...</a><br /></td></tr>
<tr class="separator:a266522728258632298ee1bb97922a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866de4f5f4b7ba0a40c75177a17fdeb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a866de4f5f4b7ba0a40c75177a17fdeb0">operator!=</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;that) const</td></tr>
<tr class="memdesc:a866de4f5f4b7ba0a40c75177a17fdeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not-equal operator.  <a href="classicu_1_1RuleBasedBreakIterator.html#a866de4f5f4b7ba0a40c75177a17fdeb0">More...</a><br /></td></tr>
<tr class="separator:a866de4f5f4b7ba0a40c75177a17fdeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cc5566ba23cded3e151374466c7026"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a38cc5566ba23cded3e151374466c7026">clone</a> () const override</td></tr>
<tr class="memdesc:a38cc5566ba23cded3e151374466c7026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly-constructed <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> with the same behavior, and iterating over the same text, as this one.  <a href="classicu_1_1RuleBasedBreakIterator.html#a38cc5566ba23cded3e151374466c7026">More...</a><br /></td></tr>
<tr class="separator:a38cc5566ba23cded3e151374466c7026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbfd1d9c7231c809fad160d0a76517d3"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afbfd1d9c7231c809fad160d0a76517d3">hashCode</a> (void) const</td></tr>
<tr class="memdesc:afbfd1d9c7231c809fad160d0a76517d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash code for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a>.  <a href="classicu_1_1RuleBasedBreakIterator.html#afbfd1d9c7231c809fad160d0a76517d3">More...</a><br /></td></tr>
<tr class="separator:afbfd1d9c7231c809fad160d0a76517d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae628032a4d1ff0610c26ce0109ecdcda"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ae628032a4d1ff0610c26ce0109ecdcda">getRules</a> (void) const</td></tr>
<tr class="memdesc:ae628032a4d1ff0610c26ce0109ecdcda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description used to create this iterator.  <a href="classicu_1_1RuleBasedBreakIterator.html#ae628032a4d1ff0610c26ce0109ecdcda">More...</a><br /></td></tr>
<tr class="separator:ae628032a4d1ff0610c26ce0109ecdcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e53aa07a6738178e1a45913679c81e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ad5e53aa07a6738178e1a45913679c81e">getText</a> (void) const override</td></tr>
<tr class="separator:ad5e53aa07a6738178e1a45913679c81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5cde052bcd274706b6fd01bf42f7f3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a7d5cde052bcd274706b6fd01bf42f7f3">getUText</a> (<a class="el" href="structUText.html">UText</a> *fillIn, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const override</td></tr>
<tr class="memdesc:a7d5cde052bcd274706b6fd01bf42f7f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="structUText.html" title="UText struct.">UText</a> for the text being analyzed.  <a href="classicu_1_1RuleBasedBreakIterator.html#a7d5cde052bcd274706b6fd01bf42f7f3">More...</a><br /></td></tr>
<tr class="separator:a7d5cde052bcd274706b6fd01bf42f7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1e08071bb1765ffa23b0e83a93a878"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ada1e08071bb1765ffa23b0e83a93a878">adoptText</a> (<a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> *newText) override</td></tr>
<tr class="memdesc:ada1e08071bb1765ffa23b0e83a93a878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator to analyze a new piece of text.  <a href="classicu_1_1RuleBasedBreakIterator.html#ada1e08071bb1765ffa23b0e83a93a878">More...</a><br /></td></tr>
<tr class="separator:ada1e08071bb1765ffa23b0e83a93a878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7c9dcc8dfc94f197006e7c50e51f78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afe7c9dcc8dfc94f197006e7c50e51f78">setText</a> (const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;newText) override</td></tr>
<tr class="memdesc:afe7c9dcc8dfc94f197006e7c50e51f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator to analyze a new piece of text.  <a href="classicu_1_1RuleBasedBreakIterator.html#afe7c9dcc8dfc94f197006e7c50e51f78">More...</a><br /></td></tr>
<tr class="separator:afe7c9dcc8dfc94f197006e7c50e51f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfde1ea8cad6f09f6cc1cf186c73572"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aecfde1ea8cad6f09f6cc1cf186c73572">setText</a> (<a class="el" href="structUText.html">UText</a> *text, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) override</td></tr>
<tr class="memdesc:aecfde1ea8cad6f09f6cc1cf186c73572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct.">UText</a>.  <a href="classicu_1_1RuleBasedBreakIterator.html#aecfde1ea8cad6f09f6cc1cf186c73572">More...</a><br /></td></tr>
<tr class="separator:aecfde1ea8cad6f09f6cc1cf186c73572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab793d1e3dc1d0236868785bd463f2e08"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ab793d1e3dc1d0236868785bd463f2e08">first</a> (void) override</td></tr>
<tr class="memdesc:ab793d1e3dc1d0236868785bd463f2e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current iteration position to the beginning of the text, position zero.  <a href="classicu_1_1RuleBasedBreakIterator.html#ab793d1e3dc1d0236868785bd463f2e08">More...</a><br /></td></tr>
<tr class="separator:ab793d1e3dc1d0236868785bd463f2e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640e068427c32b38cca78898a4d44750"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a640e068427c32b38cca78898a4d44750">last</a> (void) override</td></tr>
<tr class="memdesc:a640e068427c32b38cca78898a4d44750"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current iteration position to the end of the text.  <a href="classicu_1_1RuleBasedBreakIterator.html#a640e068427c32b38cca78898a4d44750">More...</a><br /></td></tr>
<tr class="separator:a640e068427c32b38cca78898a4d44750"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f0ee8fad7ea12a613b6bdb3cad52b9"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ae7f0ee8fad7ea12a613b6bdb3cad52b9">next</a> (int32_t n) override</td></tr>
<tr class="memdesc:ae7f0ee8fad7ea12a613b6bdb3cad52b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the iterator either forward or backward the specified number of steps.  <a href="classicu_1_1RuleBasedBreakIterator.html#ae7f0ee8fad7ea12a613b6bdb3cad52b9">More...</a><br /></td></tr>
<tr class="separator:ae7f0ee8fad7ea12a613b6bdb3cad52b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd699474653a478d119a3e57a0c36358"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afd699474653a478d119a3e57a0c36358">next</a> (void) override</td></tr>
<tr class="memdesc:afd699474653a478d119a3e57a0c36358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the iterator to the next boundary position.  <a href="classicu_1_1RuleBasedBreakIterator.html#afd699474653a478d119a3e57a0c36358">More...</a><br /></td></tr>
<tr class="separator:afd699474653a478d119a3e57a0c36358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0b7afee76d2adf5fcbfae3a2b4adbe"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ada0b7afee76d2adf5fcbfae3a2b4adbe">previous</a> (void) override</td></tr>
<tr class="memdesc:ada0b7afee76d2adf5fcbfae3a2b4adbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the iterator backwards, to the last boundary preceding this one.  <a href="classicu_1_1RuleBasedBreakIterator.html#ada0b7afee76d2adf5fcbfae3a2b4adbe">More...</a><br /></td></tr>
<tr class="separator:ada0b7afee76d2adf5fcbfae3a2b4adbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cfad4f533e1b9cb58b81c13af08ab7"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a23cfad4f533e1b9cb58b81c13af08ab7">following</a> (int32_t offset) override</td></tr>
<tr class="memdesc:a23cfad4f533e1b9cb58b81c13af08ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the iterator to refer to the first boundary position following the specified position.  <a href="classicu_1_1RuleBasedBreakIterator.html#a23cfad4f533e1b9cb58b81c13af08ab7">More...</a><br /></td></tr>
<tr class="separator:a23cfad4f533e1b9cb58b81c13af08ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8f68a88bc3d3d9f9d34606874671b5"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aca8f68a88bc3d3d9f9d34606874671b5">preceding</a> (int32_t offset) override</td></tr>
<tr class="memdesc:aca8f68a88bc3d3d9f9d34606874671b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the iterator to refer to the last boundary position before the specified position.  <a href="classicu_1_1RuleBasedBreakIterator.html#aca8f68a88bc3d3d9f9d34606874671b5">More...</a><br /></td></tr>
<tr class="separator:aca8f68a88bc3d3d9f9d34606874671b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d306ff87478dcdeae98593fe042f9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a85d306ff87478dcdeae98593fe042f9e">isBoundary</a> (int32_t offset) override</td></tr>
<tr class="memdesc:a85d306ff87478dcdeae98593fe042f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified position is a boundary position.  <a href="classicu_1_1RuleBasedBreakIterator.html#a85d306ff87478dcdeae98593fe042f9e">More...</a><br /></td></tr>
<tr class="separator:a85d306ff87478dcdeae98593fe042f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb1b801eef3c22f3a9e64fd4ea2bf8e"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a0cb1b801eef3c22f3a9e64fd4ea2bf8e">current</a> (void) const override</td></tr>
<tr class="memdesc:a0cb1b801eef3c22f3a9e64fd4ea2bf8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current iteration position.  <a href="classicu_1_1RuleBasedBreakIterator.html#a0cb1b801eef3c22f3a9e64fd4ea2bf8e">More...</a><br /></td></tr>
<tr class="separator:a0cb1b801eef3c22f3a9e64fd4ea2bf8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c4b778add5db7cbeb25000e218e236"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a76c4b778add5db7cbeb25000e218e236">getRuleStatus</a> () const override</td></tr>
<tr class="memdesc:a76c4b778add5db7cbeb25000e218e236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status tag from the break rule that determined the boundary at the current iteration position.  <a href="classicu_1_1RuleBasedBreakIterator.html#a76c4b778add5db7cbeb25000e218e236">More...</a><br /></td></tr>
<tr class="separator:a76c4b778add5db7cbeb25000e218e236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8e36f3ff39a261f0ca69de84c8ee07"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a9c8e36f3ff39a261f0ca69de84c8ee07">getRuleStatusVec</a> (int32_t *fillInVec, int32_t capacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) override</td></tr>
<tr class="memdesc:a9c8e36f3ff39a261f0ca69de84c8ee07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status (tag) values from the break rule(s) that determined the boundary at the current iteration position.  <a href="classicu_1_1RuleBasedBreakIterator.html#a9c8e36f3ff39a261f0ca69de84c8ee07">More...</a><br /></td></tr>
<tr class="separator:a9c8e36f3ff39a261f0ca69de84c8ee07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591e53fac1209ba1b26912568408a3b2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a591e53fac1209ba1b26912568408a3b2">getDynamicClassID</a> (void) const override</td></tr>
<tr class="memdesc:a591e53fac1209ba1b26912568408a3b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unique class ID POLYMORPHICALLY.  <a href="classicu_1_1RuleBasedBreakIterator.html#a591e53fac1209ba1b26912568408a3b2">More...</a><br /></td></tr>
<tr class="separator:a591e53fac1209ba1b26912568408a3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b0b38fb69b62bea0ff67f94efb50f0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a46b0b38fb69b62bea0ff67f94efb50f0">createBufferClone</a> (void *stackBuffer, int32_t &amp;BufferSize, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) override</td></tr>
<tr class="memdesc:a46b0b38fb69b62bea0ff67f94efb50f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated functionality.  <a href="classicu_1_1RuleBasedBreakIterator.html#a46b0b38fb69b62bea0ff67f94efb50f0">More...</a><br /></td></tr>
<tr class="separator:a46b0b38fb69b62bea0ff67f94efb50f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af363614f68831859c51db82231b53ef4"><td class="memItemLeft" align="right" valign="top">virtual const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#af363614f68831859c51db82231b53ef4">getBinaryRules</a> (uint32_t &amp;length)</td></tr>
<tr class="memdesc:af363614f68831859c51db82231b53ef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the binary form of compiled break rules, which can then be used to create a new break iterator at some time in the future.  <a href="classicu_1_1RuleBasedBreakIterator.html#af363614f68831859c51db82231b53ef4">More...</a><br /></td></tr>
<tr class="separator:af363614f68831859c51db82231b53ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e936d521b000d3543e7de997801dc8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a95e936d521b000d3543e7de997801dc8">refreshInputText</a> (<a class="el" href="structUText.html">UText</a> *input, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) override</td></tr>
<tr class="memdesc:a95e936d521b000d3543e7de997801dc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the subject text string upon which the break iterator is operating without changing any other aspect of the matching state.  <a href="classicu_1_1RuleBasedBreakIterator.html#a95e936d521b000d3543e7de997801dc8">More...</a><br /></td></tr>
<tr class="separator:a95e936d521b000d3543e7de997801dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88705f0fdbdaa71ec29a6204e09d4668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a88705f0fdbdaa71ec29a6204e09d4668">dumpCache</a> ()</td></tr>
<tr class="memdesc:a88705f0fdbdaa71ec29a6204e09d4668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging function only.  <a href="classicu_1_1RuleBasedBreakIterator.html#a88705f0fdbdaa71ec29a6204e09d4668">More...</a><br /></td></tr>
<tr class="separator:a88705f0fdbdaa71ec29a6204e09d4668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581a3d53f5699e16a408cc6b85d30a58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a581a3d53f5699e16a408cc6b85d30a58">dumpTables</a> ()</td></tr>
<tr class="memdesc:a581a3d53f5699e16a408cc6b85d30a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging function only.  <a href="classicu_1_1RuleBasedBreakIterator.html#a581a3d53f5699e16a408cc6b85d30a58">More...</a><br /></td></tr>
<tr class="separator:a581a3d53f5699e16a408cc6b85d30a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a026e38276ffa6c40d8953b4e3bc4bc01 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a026e38276ffa6c40d8953b4e3bc4bc01">~BreakIterator</a> ()</td></tr>
<tr class="memdesc:a026e38276ffa6c40d8953b4e3bc4bc01 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="classicu_1_1BreakIterator.html#a026e38276ffa6c40d8953b4e3bc4bc01">More...</a><br /></td></tr>
<tr class="separator:a026e38276ffa6c40d8953b4e3bc4bc01 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0045fc272df09804974fc767bc5340fc inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a0045fc272df09804974fc767bc5340fc">operator==</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;) const =0</td></tr>
<tr class="memdesc:a0045fc272df09804974fc767bc5340fc inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if another object is semantically equal to this one.  <a href="classicu_1_1BreakIterator.html#a0045fc272df09804974fc767bc5340fc">More...</a><br /></td></tr>
<tr class="separator:a0045fc272df09804974fc767bc5340fc inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a51e36f8952adf078b9b73865b5319e inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a7a51e36f8952adf078b9b73865b5319e">operator!=</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a7a51e36f8952adf078b9b73865b5319e inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complement of the result of operator==.  <a href="classicu_1_1BreakIterator.html#a7a51e36f8952adf078b9b73865b5319e">More...</a><br /></td></tr>
<tr class="separator:a7a51e36f8952adf078b9b73865b5319e inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3217be81995a3be45093453d64268233 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a3217be81995a3be45093453d64268233">clone</a> () const =0</td></tr>
<tr class="memdesc:a3217be81995a3be45093453d64268233 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a polymorphic copy of this object.  <a href="classicu_1_1BreakIterator.html#a3217be81995a3be45093453d64268233">More...</a><br /></td></tr>
<tr class="separator:a3217be81995a3be45093453d64268233 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b8904de97de51ffbc99c38689d9527 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a37b8904de97de51ffbc99c38689d9527">getDynamicClassID</a> (void) const override=0</td></tr>
<tr class="memdesc:a37b8904de97de51ffbc99c38689d9527 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a polymorphic class ID for this object.  <a href="classicu_1_1BreakIterator.html#a37b8904de97de51ffbc99c38689d9527">More...</a><br /></td></tr>
<tr class="separator:a37b8904de97de51ffbc99c38689d9527 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa727532413a065188276576e1c11e6 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a0fa727532413a065188276576e1c11e6">getText</a> (void) const =0</td></tr>
<tr class="memdesc:a0fa727532413a065188276576e1c11e6 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classicu_1_1CharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> over the text being analyzed.  <a href="classicu_1_1BreakIterator.html#a0fa727532413a065188276576e1c11e6">More...</a><br /></td></tr>
<tr class="separator:a0fa727532413a065188276576e1c11e6 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe2380f7611225fb3483b0ed2fbbb8a inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#acbe2380f7611225fb3483b0ed2fbbb8a">getUText</a> (<a class="el" href="structUText.html">UText</a> *fillIn, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const =0</td></tr>
<tr class="memdesc:acbe2380f7611225fb3483b0ed2fbbb8a inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="structUText.html" title="UText struct.">UText</a> for the text being analyzed.  <a href="classicu_1_1BreakIterator.html#acbe2380f7611225fb3483b0ed2fbbb8a">More...</a><br /></td></tr>
<tr class="separator:acbe2380f7611225fb3483b0ed2fbbb8a inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b894129fb567fded3ed85a7e8ead942 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a8b894129fb567fded3ed85a7e8ead942">setText</a> (const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;text)=0</td></tr>
<tr class="memdesc:a8b894129fb567fded3ed85a7e8ead942 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the text over which this operates.  <a href="classicu_1_1BreakIterator.html#a8b894129fb567fded3ed85a7e8ead942">More...</a><br /></td></tr>
<tr class="separator:a8b894129fb567fded3ed85a7e8ead942 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3110dd5111286cd514ea6896ddd8c5bd inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a3110dd5111286cd514ea6896ddd8c5bd">setText</a> (<a class="el" href="structUText.html">UText</a> *text, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)=0</td></tr>
<tr class="memdesc:a3110dd5111286cd514ea6896ddd8c5bd inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct.">UText</a>.  <a href="classicu_1_1BreakIterator.html#a3110dd5111286cd514ea6896ddd8c5bd">More...</a><br /></td></tr>
<tr class="separator:a3110dd5111286cd514ea6896ddd8c5bd inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd72184b59936bb62b07af071e2b0c1 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a1fd72184b59936bb62b07af071e2b0c1">adoptText</a> (<a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> *it)=0</td></tr>
<tr class="memdesc:a1fd72184b59936bb62b07af071e2b0c1 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the text over which this operates.  <a href="classicu_1_1BreakIterator.html#a1fd72184b59936bb62b07af071e2b0c1">More...</a><br /></td></tr>
<tr class="separator:a1fd72184b59936bb62b07af071e2b0c1 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6bb155a2ec664f63df79a80f8b43e5 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#abc6bb155a2ec664f63df79a80f8b43e5">first</a> (void)=0</td></tr>
<tr class="memdesc:abc6bb155a2ec664f63df79a80f8b43e5 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current iteration position to the beginning of the text, position zero.  <a href="classicu_1_1BreakIterator.html#abc6bb155a2ec664f63df79a80f8b43e5">More...</a><br /></td></tr>
<tr class="separator:abc6bb155a2ec664f63df79a80f8b43e5 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecbdcabef74105eb7f0747011d05e01 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a2ecbdcabef74105eb7f0747011d05e01">last</a> (void)=0</td></tr>
<tr class="memdesc:a2ecbdcabef74105eb7f0747011d05e01 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator position to the index immediately BEYOND the last character in the text being scanned.  <a href="classicu_1_1BreakIterator.html#a2ecbdcabef74105eb7f0747011d05e01">More...</a><br /></td></tr>
<tr class="separator:a2ecbdcabef74105eb7f0747011d05e01 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeede95a59db8408760b106724dfb7a4d inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#aeede95a59db8408760b106724dfb7a4d">previous</a> (void)=0</td></tr>
<tr class="memdesc:aeede95a59db8408760b106724dfb7a4d inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator position to the boundary preceding the current boundary.  <a href="classicu_1_1BreakIterator.html#aeede95a59db8408760b106724dfb7a4d">More...</a><br /></td></tr>
<tr class="separator:aeede95a59db8408760b106724dfb7a4d inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13468dd341e9f0eb92c61f25e88a5154 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a13468dd341e9f0eb92c61f25e88a5154">next</a> (void)=0</td></tr>
<tr class="memdesc:a13468dd341e9f0eb92c61f25e88a5154 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator to the boundary following the current boundary.  <a href="classicu_1_1BreakIterator.html#a13468dd341e9f0eb92c61f25e88a5154">More...</a><br /></td></tr>
<tr class="separator:a13468dd341e9f0eb92c61f25e88a5154 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6ad53a2e16b52b8d746f81d2ffdf231 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#af6ad53a2e16b52b8d746f81d2ffdf231">current</a> (void) const =0</td></tr>
<tr class="memdesc:af6ad53a2e16b52b8d746f81d2ffdf231 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return character index of the current iterator position within the text.  <a href="classicu_1_1BreakIterator.html#af6ad53a2e16b52b8d746f81d2ffdf231">More...</a><br /></td></tr>
<tr class="separator:af6ad53a2e16b52b8d746f81d2ffdf231 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4178f880af4875ae5e30a716331fbaf inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#ae4178f880af4875ae5e30a716331fbaf">following</a> (int32_t offset)=0</td></tr>
<tr class="memdesc:ae4178f880af4875ae5e30a716331fbaf inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator to the first boundary following the specified offset.  <a href="classicu_1_1BreakIterator.html#ae4178f880af4875ae5e30a716331fbaf">More...</a><br /></td></tr>
<tr class="separator:ae4178f880af4875ae5e30a716331fbaf inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980f8e8fbe1d37827cacc24f9606399f inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a980f8e8fbe1d37827cacc24f9606399f">preceding</a> (int32_t offset)=0</td></tr>
<tr class="memdesc:a980f8e8fbe1d37827cacc24f9606399f inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator position to the first boundary preceding the specified offset.  <a href="classicu_1_1BreakIterator.html#a980f8e8fbe1d37827cacc24f9606399f">More...</a><br /></td></tr>
<tr class="separator:a980f8e8fbe1d37827cacc24f9606399f inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf997425386eae9c50cd5c208dbef214 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#aaf997425386eae9c50cd5c208dbef214">isBoundary</a> (int32_t offset)=0</td></tr>
<tr class="memdesc:aaf997425386eae9c50cd5c208dbef214 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified position is a boundary position.  <a href="classicu_1_1BreakIterator.html#aaf997425386eae9c50cd5c208dbef214">More...</a><br /></td></tr>
<tr class="separator:aaf997425386eae9c50cd5c208dbef214 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971257b3ed9676ec02890187025caf1b inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a971257b3ed9676ec02890187025caf1b">next</a> (int32_t n)=0</td></tr>
<tr class="memdesc:a971257b3ed9676ec02890187025caf1b inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator position to the nth boundary from the current boundary.  <a href="classicu_1_1BreakIterator.html#a971257b3ed9676ec02890187025caf1b">More...</a><br /></td></tr>
<tr class="separator:a971257b3ed9676ec02890187025caf1b inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1920d04ad1b7d0966b2ff7863df77a74 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a1920d04ad1b7d0966b2ff7863df77a74">getRuleStatus</a> () const</td></tr>
<tr class="memdesc:a1920d04ad1b7d0966b2ff7863df77a74 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">For RuleBasedBreakIterators, return the status tag from the break rule that determined the boundary at the current iteration position.  <a href="classicu_1_1BreakIterator.html#a1920d04ad1b7d0966b2ff7863df77a74">More...</a><br /></td></tr>
<tr class="separator:a1920d04ad1b7d0966b2ff7863df77a74 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3bf12df7434e65041447bef51264e13 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#af3bf12df7434e65041447bef51264e13">getRuleStatusVec</a> (int32_t *fillInVec, int32_t capacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:af3bf12df7434e65041447bef51264e13 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">For RuleBasedBreakIterators, get the status (tag) values from the break rule(s) that determined the boundary at the current iteration position.  <a href="classicu_1_1BreakIterator.html#af3bf12df7434e65041447bef51264e13">More...</a><br /></td></tr>
<tr class="separator:af3bf12df7434e65041447bef51264e13 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde8f6f9757c37f5499073cf9fc36e3b inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#adde8f6f9757c37f5499073cf9fc36e3b">createBufferClone</a> (void *stackBuffer, int32_t &amp;BufferSize, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)=0</td></tr>
<tr class="memdesc:adde8f6f9757c37f5499073cf9fc36e3b inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated functionality.  <a href="classicu_1_1BreakIterator.html#adde8f6f9757c37f5499073cf9fc36e3b">More...</a><br /></td></tr>
<tr class="separator:adde8f6f9757c37f5499073cf9fc36e3b inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ce3ce8c87b0f5b11527caf0e824fbf inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a20ce3ce8c87b0f5b11527caf0e824fbf">isBufferClone</a> (void)</td></tr>
<tr class="memdesc:a20ce3ce8c87b0f5b11527caf0e824fbf inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> was created in user memory by <a class="el" href="classicu_1_1BreakIterator.html#adde8f6f9757c37f5499073cf9fc36e3b" title="Deprecated functionality.">createBufferClone()</a>, and thus should not be deleted.  <a href="classicu_1_1BreakIterator.html#a20ce3ce8c87b0f5b11527caf0e824fbf">More...</a><br /></td></tr>
<tr class="separator:a20ce3ce8c87b0f5b11527caf0e824fbf inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771866e07e8c3396d98218a2073c0dc2 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicu_1_1Locale.html">Locale</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a771866e07e8c3396d98218a2073c0dc2">getLocale</a> (<a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a> type, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const</td></tr>
<tr class="memdesc:a771866e07e8c3396d98218a2073c0dc2 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the locale for this break iterator.  <a href="classicu_1_1BreakIterator.html#a771866e07e8c3396d98218a2073c0dc2">More...</a><br /></td></tr>
<tr class="separator:a771866e07e8c3396d98218a2073c0dc2 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65259ad130c0b3e9a7ce3117de23846b inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a65259ad130c0b3e9a7ce3117de23846b">getLocaleID</a> (<a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a> type, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const</td></tr>
<tr class="memdesc:a65259ad130c0b3e9a7ce3117de23846b inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locale for this break iterator object.  <a href="classicu_1_1BreakIterator.html#a65259ad130c0b3e9a7ce3117de23846b">More...</a><br /></td></tr>
<tr class="separator:a65259ad130c0b3e9a7ce3117de23846b inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31f305a92919fdafea1fd54861a3343 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#ab31f305a92919fdafea1fd54861a3343">refreshInputText</a> (<a class="el" href="structUText.html">UText</a> *input, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)=0</td></tr>
<tr class="memdesc:ab31f305a92919fdafea1fd54861a3343 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the subject text string upon which the break iterator is operating without changing any other aspect of the matching state.  <a href="classicu_1_1BreakIterator.html#ab31f305a92919fdafea1fd54861a3343">More...</a><br /></td></tr>
<tr class="separator:ab31f305a92919fdafea1fd54861a3343 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classicu_1_1UObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classicu_1_1UObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classicu_1_1UObject.html">icu::UObject</a></td></tr>
<tr class="memitem:af10026497704f510d3d1f2eff50acb18 inherit pub_methods_classicu_1_1UObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1UObject.html#af10026497704f510d3d1f2eff50acb18">~UObject</a> ()</td></tr>
<tr class="memdesc:af10026497704f510d3d1f2eff50acb18 inherit pub_methods_classicu_1_1UObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classicu_1_1UObject.html#af10026497704f510d3d1f2eff50acb18">More...</a><br /></td></tr>
<tr class="separator:af10026497704f510d3d1f2eff50acb18 inherit pub_methods_classicu_1_1UObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca1169c4978c52ce2b76eda104e9a214 inherit pub_methods_classicu_1_1UObject"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1UObject.html#aca1169c4978c52ce2b76eda104e9a214">getDynamicClassID</a> () const</td></tr>
<tr class="memdesc:aca1169c4978c52ce2b76eda104e9a214 inherit pub_methods_classicu_1_1UObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">ICU4C "poor man's RTTI", returns a UClassID for the actual ICU class.  <a href="classicu_1_1UObject.html#aca1169c4978c52ce2b76eda104e9a214">More...</a><br /></td></tr>
<tr class="separator:aca1169c4978c52ce2b76eda104e9a214 inherit pub_methods_classicu_1_1UObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:abda7c218cb044e5a9454751c7295eb42"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#abda7c218cb044e5a9454751c7295eb42">getStaticClassID</a> (void)</td></tr>
<tr class="memdesc:abda7c218cb044e5a9454751c7295eb42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class ID for this class.  <a href="classicu_1_1RuleBasedBreakIterator.html#abda7c218cb044e5a9454751c7295eb42">More...</a><br /></td></tr>
<tr class="separator:abda7c218cb044e5a9454751c7295eb42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a50cefbc6dfc4eae78e926f4604c3d63c inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a50cefbc6dfc4eae78e926f4604c3d63c">createWordInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a50cefbc6dfc4eae78e926f4604c3d63c inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> for word-breaks using the given locale.  <a href="classicu_1_1BreakIterator.html#a50cefbc6dfc4eae78e926f4604c3d63c">More...</a><br /></td></tr>
<tr class="separator:a50cefbc6dfc4eae78e926f4604c3d63c inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add74ea30507cf6fab9618b2279b9c51e inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#add74ea30507cf6fab9618b2279b9c51e">createLineInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:add74ea30507cf6fab9618b2279b9c51e inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> for line-breaks using specified locale.  <a href="classicu_1_1BreakIterator.html#add74ea30507cf6fab9618b2279b9c51e">More...</a><br /></td></tr>
<tr class="separator:add74ea30507cf6fab9618b2279b9c51e inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286f339ef456afa8567c84129bffe077 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a286f339ef456afa8567c84129bffe077">createCharacterInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a286f339ef456afa8567c84129bffe077 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> for character-breaks using specified locale Returns an instance of a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> implementing character breaks.  <a href="classicu_1_1BreakIterator.html#a286f339ef456afa8567c84129bffe077">More...</a><br /></td></tr>
<tr class="separator:a286f339ef456afa8567c84129bffe077 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0db5a30f15b4f9041cb3548a9450347 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#ab0db5a30f15b4f9041cb3548a9450347">createSentenceInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:ab0db5a30f15b4f9041cb3548a9450347 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> for sentence-breaks using specified locale Returns an instance of a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> implementing sentence breaks.  <a href="classicu_1_1BreakIterator.html#ab0db5a30f15b4f9041cb3548a9450347">More...</a><br /></td></tr>
<tr class="separator:ab0db5a30f15b4f9041cb3548a9450347 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92aa4f13f60121dd175be935f2b4cf9a inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a92aa4f13f60121dd175be935f2b4cf9a">createTitleInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a92aa4f13f60121dd175be935f2b4cf9a inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> for title-casing breaks using the specified locale Returns an instance of a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> implementing title breaks.  <a href="classicu_1_1BreakIterator.html#a92aa4f13f60121dd175be935f2b4cf9a">More...</a><br /></td></tr>
<tr class="separator:a92aa4f13f60121dd175be935f2b4cf9a inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1acbff3777272a0a348533c9ed18848 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classicu_1_1Locale.html">Locale</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#af1acbff3777272a0a348533c9ed18848">getAvailableLocales</a> (int32_t &amp;count)</td></tr>
<tr class="memdesc:af1acbff3777272a0a348533c9ed18848 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of Locales for which TextBoundaries are installed.  <a href="classicu_1_1BreakIterator.html#af1acbff3777272a0a348533c9ed18848">More...</a><br /></td></tr>
<tr class="separator:af1acbff3777272a0a348533c9ed18848 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b204e6cc23add95ebe2b91671e57d10 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a6b204e6cc23add95ebe2b91671e57d10">getDisplayName</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;objectLocale, const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;displayLocale, <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;name)</td></tr>
<tr class="memdesc:a6b204e6cc23add95ebe2b91671e57d10 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the object for the desired <a class="el" href="classicu_1_1Locale.html" title="A Locale object represents a specific geographical, political, or cultural region.">Locale</a>, in the desired language.  <a href="classicu_1_1BreakIterator.html#a6b204e6cc23add95ebe2b91671e57d10">More...</a><br /></td></tr>
<tr class="separator:a6b204e6cc23add95ebe2b91671e57d10 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafda974af53eed14871dca13bb54c889 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#aafda974af53eed14871dca13bb54c889">getDisplayName</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;objectLocale, <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;name)</td></tr>
<tr class="memdesc:aafda974af53eed14871dca13bb54c889 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the object for the desired <a class="el" href="classicu_1_1Locale.html" title="A Locale object represents a specific geographical, political, or cultural region.">Locale</a>, in the language of the default locale.  <a href="classicu_1_1BreakIterator.html#aafda974af53eed14871dca13bb54c889">More...</a><br /></td></tr>
<tr class="separator:aafda974af53eed14871dca13bb54c889 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03207fda29e7eab8adf59fb1788b2cf inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="umisc_8h.html#ab5905d79ed3b979840cee1d5fd48b4fb">URegistryKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#af03207fda29e7eab8adf59fb1788b2cf">registerInstance</a> (<a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *toAdopt, const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;locale, <a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a> kind, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:af03207fda29e7eab8adf59fb1788b2cf inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new break iterator of the indicated kind, to use in the given locale.  <a href="classicu_1_1BreakIterator.html#af03207fda29e7eab8adf59fb1788b2cf">More...</a><br /></td></tr>
<tr class="separator:af03207fda29e7eab8adf59fb1788b2cf inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89b591636b40ec7a1037d02bfe8d832 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#ac89b591636b40ec7a1037d02bfe8d832">unregister</a> (<a class="el" href="umisc_8h.html#ab5905d79ed3b979840cee1d5fd48b4fb">URegistryKey</a> key, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:ac89b591636b40ec7a1037d02bfe8d832 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a previously-registered <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> using the key returned from the register call.  <a href="classicu_1_1BreakIterator.html#ac89b591636b40ec7a1037d02bfe8d832">More...</a><br /></td></tr>
<tr class="separator:ac89b591636b40ec7a1037d02bfe8d832 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa9bd79105790a87c7ad359a7d7f373 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classicu_1_1StringEnumeration.html">StringEnumeration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#adaa9bd79105790a87c7ad359a7d7f373">getAvailableLocales</a> (void)</td></tr>
<tr class="memdesc:adaa9bd79105790a87c7ad359a7d7f373 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classicu_1_1StringEnumeration.html" title="Base class for &#39;pure&#39; C++ implementations of uenum api.">StringEnumeration</a> over the locales available at the time of the call, including registered locales.  <a href="classicu_1_1BreakIterator.html#adaa9bd79105790a87c7ad359a7d7f373">More...</a><br /></td></tr>
<tr class="separator:adaa9bd79105790a87c7ad359a7d7f373 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a2ad6052587787523f902a4503693dbe6"><td class="memItemLeft" align="right" valign="top">RBBIDataWrapper *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a2ad6052587787523f902a4503693dbe6">fData</a> = nullptr</td></tr>
<tr class="memdesc:a2ad6052587787523f902a4503693dbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rule data for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> instance.  <a href="classicu_1_1RuleBasedBreakIterator.html#a2ad6052587787523f902a4503693dbe6">More...</a><br /></td></tr>
<tr class="separator:a2ad6052587787523f902a4503693dbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a17ce03f12f5fa8688859b25e2bf60938"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a17ce03f12f5fa8688859b25e2bf60938">RBBIRuleBuilder</a></td></tr>
<tr class="separator:a17ce03f12f5fa8688859b25e2bf60938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbb7407696454879cf016b20a0380f0"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a5fbb7407696454879cf016b20a0380f0">BreakIterator</a></td></tr>
<tr class="separator:a5fbb7407696454879cf016b20a0380f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a0174c4360d0cb8d21ecc3e4cea71d035 inherit pub_types_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classicu_1_1BreakIterator.html#a0174c4360d0cb8d21ecc3e4cea71d035af9daa8410e7f8dc1631f8fc6a8a8115c">DONE</a> = (int32_t)-1
 }</td></tr>
<tr class="separator:a0174c4360d0cb8d21ecc3e4cea71d035 inherit pub_types_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a151b3d5496d7ca586c331f8521446755 inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a151b3d5496d7ca586c331f8521446755">BreakIterator</a> ()</td></tr>
<tr class="separator:a151b3d5496d7ca586c331f8521446755 inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a44745041bbe7e3ec41bc1e2a880c80 inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a0a44745041bbe7e3ec41bc1e2a880c80">BreakIterator</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;other)</td></tr>
<tr class="separator:a0a44745041bbe7e3ec41bc1e2a880c80 inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094580dacf6cc3f251fb4844278a61ce inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a094580dacf6cc3f251fb4844278a61ce">BreakIterator</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;valid, const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;actual)</td></tr>
<tr class="separator:a094580dacf6cc3f251fb4844278a61ce inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac3e2e018ddcd12bb87c152e00a9129 inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a4ac3e2e018ddcd12bb87c152e00a9129">operator=</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;other)</td></tr>
<tr class="separator:a4ac3e2e018ddcd12bb87c152e00a9129 inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >A subclass of <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> whose behavior is specified using a list of rules. </p>
<p >Instances of this class are most commonly created by the factory methods of <a class="el" href="classicu_1_1BreakIterator.html#a50cefbc6dfc4eae78e926f4604c3d63c" title="Create BreakIterator for word-breaks using the given locale.">BreakIterator::createWordInstance()</a>, <a class="el" href="classicu_1_1BreakIterator.html#add74ea30507cf6fab9618b2279b9c51e" title="Create BreakIterator for line-breaks using specified locale.">BreakIterator::createLineInstance()</a>, etc., and then used via the abstract API in class <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a></p>
<p >See the ICU User Guide for information on Break Iterator Rules.</p>
<p >This class is not intended to be subclassed.</p>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00057">57</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a976126b3070d56d23a67184b41e88141" name="a976126b3070d56d23a67184b41e88141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976126b3070d56d23a67184b41e88141">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p >Creates an empty shell of an iterator, with no rules or text to iterate over. Object can subsequently be assigned to, but is otherwise unusable. </p><dl class="stable"><dt><b><a class="el" href="stable.html#_stable000653">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a id="acaaa98a62891cc8b6ef72c913a67a7b6" name="acaaa98a62891cc8b6ef72c913a67a7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaaa98a62891cc8b6ef72c913a67a7b6">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p >Will produce a break iterator with the same behavior, and which iterates over the same text, as the one passed in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> passed to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000654">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="af34393c8272153f00eab8b3ba5dd8263" name="af34393c8272153f00eab8b3ba5dd8263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34393c8272153f00eab8b3ba5dd8263">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUParseError.html">UParseError</a> &amp;&#160;</td>
          <td class="paramname"><em>parseError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of rules supplied as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rules</td><td>The break rules to be used. </td></tr>
    <tr><td class="paramname">parseError</td><td>In the event of a syntax error in the rules, provides the location within the rules of the problem. </td></tr>
    <tr><td class="paramname">status</td><td>Information on any errors encountered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000655">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a id="afe74962355b2cf5cf699ab2c98d0852d" name="afe74962355b2cf5cf699ab2c98d0852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe74962355b2cf5cf699ab2c98d0852d">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>compiledRules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ruleLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of precompiled binary rules. </p>
<p >Binary rules are obtained from RulesBasedBreakIterator::getBinaryRules(). Construction of a break iterator in this way is substantially faster than construction from source rules.</p>
<p >Ownership of the storage containing the compiled rules remains with the caller of this function. The compiled rules must not be modified or deleted during the life of the break iterator.</p>
<p >The compiled rules are not compatible across different major versions of ICU. The compiled rules are compatible only between machines with the same byte ordering (little or big endian) and the same base character set family (ASCII or EBCDIC).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#af363614f68831859c51db82231b53ef4" title="Return the binary form of compiled break rules, which can then be used to create a new break iterator...">getBinaryRules</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compiledRules</td><td>A pointer to the compiled break rules to be used. </td></tr>
    <tr><td class="paramname">ruleLength</td><td>The length of the compiled break rules, in bytes. This corresponds to the length value produced by <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#af363614f68831859c51db82231b53ef4" title="Return the binary form of compiled break rules, which can then be used to create a new break iterator...">getBinaryRules()</a>. </td></tr>
    <tr><td class="paramname">status</td><td>Information on any errors encountered, including invalid binary rules. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000656">Stable:</a></b></dt><dd>ICU 4.8 </dd></dl>

</div>
</div>
<a id="adde71d5c99670342c9db9e67b7475822" name="adde71d5c99670342c9db9e67b7475822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde71d5c99670342c9db9e67b7475822">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="udata_8h.html#acffec83601fda29bd4750b24f829f56b">UDataMemory</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This constructor uses the udata interface to create a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> whose internal tables live in a memory-mapped file. </p>
<p >"image" is an ICU UDataMemory handle for the pre-compiled break iterator tables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>handle to the memory image for the break iterator data. Ownership of the UDataMemory handle passes to the Break Iterator, which will be responsible for closing it when it is no longer needed. </td></tr>
    <tr><td class="paramname">status</td><td>Information on any errors encountered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="udata_8h.html#a1b9d6512d3024e06795e121804853c55" title="Convenience function.">udata_open</a> </dd>
<dd>
<a class="el" href="classicu_1_1RuleBasedBreakIterator.html#af363614f68831859c51db82231b53ef4" title="Return the binary form of compiled break rules, which can then be used to create a new break iterator...">getBinaryRules</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000657">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a id="af171cfdce6f264ae7f7f18078248a08b" name="af171cfdce6f264ae7f7f18078248a08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af171cfdce6f264ae7f7f18078248a08b">&#9670;&nbsp;</a></span>~RuleBasedBreakIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual icu::RuleBasedBreakIterator::~RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000658">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ada1e08071bb1765ffa23b0e83a93a878" name="ada1e08071bb1765ffa23b0e83a93a878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1e08071bb1765ffa23b0e83a93a878">&#9670;&nbsp;</a></span>adoptText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void icu::RuleBasedBreakIterator::adoptText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> *&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the iterator to analyze a new piece of text. </p>
<p >This function resets the current iteration position to the beginning of the text. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>An iterator over the text to analyze. The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> takes ownership of the character iterator. The caller MUST NOT delete it! </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000667">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a1fd72184b59936bb62b07af071e2b0c1">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a38cc5566ba23cded3e151374466c7026" name="a38cc5566ba23cded3e151374466c7026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cc5566ba23cded3e151374466c7026">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> * icu::RuleBasedBreakIterator::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a newly-constructed <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> with the same behavior, and iterating over the same text, as this one. </p>
<p >Differs from the copy constructor in that it is polymorphic, and will correctly clone (copy) a derived class. <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a38cc5566ba23cded3e151374466c7026" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> is thread safe. Multiple threads may simultaneously clone the same source break iterator. </p><dl class="section return"><dt>Returns</dt><dd>a newly-constructed <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000662">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a3217be81995a3be45093453d64268233">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a46b0b38fb69b62bea0ff67f94efb50f0" name="a46b0b38fb69b62bea0ff67f94efb50f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b0b38fb69b62bea0ff67f94efb50f0">&#9670;&nbsp;</a></span>createBufferClone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> * icu::RuleBasedBreakIterator::createBufferClone </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>BufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated functionality. </p>
<p >Use <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a38cc5566ba23cded3e151374466c7026" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> instead.</p>
<p >Create a clone (copy) of this break iterator in memory provided by the caller. The idea is to increase performance by avoiding a storage allocation. Use of this function is NOT RECOMMENDED. Performance gains are minimal, and correct buffer management is tricky. Use <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a38cc5566ba23cded3e151374466c7026" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stackBuffer</td><td>The pointer to the memory into which the cloned object should be placed. If nullptr, allocate heap memory for the cloned object. </td></tr>
    <tr><td class="paramname">BufferSize</td><td>The size of the buffer. If zero, return the required buffer size, but do not clone the object. If the size was too small (but not zero), allocate heap storage for the cloned object.</td></tr>
    <tr><td class="paramname">status</td><td>Error status. U_SAFECLONE_ALLOCATED_WARNING will be returned if the provided buffer was too small, and the clone was therefore put on the heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the clone object. This may differ from the stackBuffer address if the byte alignment of the stack buffer was not suitable or if the stackBuffer was too small to hold the clone. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>ICU 52. Use <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a38cc5566ba23cded3e151374466c7026" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> instead. </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#adde8f6f9757c37f5499073cf9fc36e3b">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a0cb1b801eef3c22f3a9e64fd4ea2bf8e" name="a0cb1b801eef3c22f3a9e64fd4ea2bf8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb1b801eef3c22f3a9e64fd4ea2bf8e">&#9670;&nbsp;</a></span>current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::current </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current iteration position. </p>
<p >Note that UBRK_DONE is never returned from this function; if iteration has run to the end of a string, <a class="el" href="classicu_1_1BreakIterator.html#af6ad53a2e16b52b8d746f81d2ffdf231" title="Return character index of the current iterator position within the text.">current()</a> will return the length of the string while <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afd699474653a478d119a3e57a0c36358" title="Advances the iterator to the next boundary position.">next()</a> will return UBRK_DONE). </p><dl class="section return"><dt>Returns</dt><dd>The current iteration position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000678">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#af6ad53a2e16b52b8d746f81d2ffdf231">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a88705f0fdbdaa71ec29a6204e09d4668" name="a88705f0fdbdaa71ec29a6204e09d4668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88705f0fdbdaa71ec29a6204e09d4668">&#9670;&nbsp;</a></span>dumpCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icu::RuleBasedBreakIterator::dumpCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging function only. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000105">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a id="a581a3d53f5699e16a408cc6b85d30a58" name="a581a3d53f5699e16a408cc6b85d30a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581a3d53f5699e16a408cc6b85d30a58">&#9670;&nbsp;</a></span>dumpTables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icu::RuleBasedBreakIterator::dumpTables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging function only. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000106">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a id="ab793d1e3dc1d0236868785bd463f2e08" name="ab793d1e3dc1d0236868785bd463f2e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab793d1e3dc1d0236868785bd463f2e08">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::first </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current iteration position to the beginning of the text, position zero. </p>
<dl class="section return"><dt>Returns</dt><dd>The offset of the beginning of the text, zero. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000670">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#abc6bb155a2ec664f63df79a80f8b43e5">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a23cfad4f533e1b9cb58b81c13af08ab7" name="a23cfad4f533e1b9cb58b81c13af08ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cfad4f533e1b9cb58b81c13af08ab7">&#9670;&nbsp;</a></span>following()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::following </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the iterator to refer to the first boundary position following the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The position from which to begin searching for a break position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the first break after the current position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000675">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#ae4178f880af4875ae5e30a716331fbaf">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="af363614f68831859c51db82231b53ef4" name="af363614f68831859c51db82231b53ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af363614f68831859c51db82231b53ef4">&#9670;&nbsp;</a></span>getBinaryRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const uint8_t * icu::RuleBasedBreakIterator::getBinaryRules </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the binary form of compiled break rules, which can then be used to create a new break iterator at some time in the future. </p>
<p >Creating a break iterator from pre-compiled rules is much faster than building one from the source form of the break rules.</p>
<p >The binary data can only be used with the same version of ICU and on the same platform type (processor endian-ness)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Returns the length of the binary data. (Out parameter.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the binary (compiled) rule data. The storage belongs to the RulesBasedBreakIterator object, not the caller, and must not be modified or deleted. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000683">Stable:</a></b></dt><dd>ICU 4.8 </dd></dl>

</div>
</div>
<a id="a591e53fac1209ba1b26912568408a3b2" name="a591e53fac1209ba1b26912568408a3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591e53fac1209ba1b26912568408a3b2">&#9670;&nbsp;</a></span>getDynamicClassID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a> icu::RuleBasedBreakIterator::getDynamicClassID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a unique class ID POLYMORPHICALLY. </p>
<p >Pure virtual override. This method is to implement a simple version of RTTI, since not all C++ compilers support genuine RTTI. Polymorphic <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a266522728258632298ee1bb97922a439" title="Equality operator.">operator==()</a> and <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a38cc5566ba23cded3e151374466c7026" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> methods call this method.</p>
<dl class="section return"><dt>Returns</dt><dd>The class ID for this object. All objects of a given class have the same class ID. Objects of other classes have different class IDs. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000681">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a37b8904de97de51ffbc99c38689d9527">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="ae628032a4d1ff0610c26ce0109ecdcda" name="ae628032a4d1ff0610c26ce0109ecdcda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae628032a4d1ff0610c26ce0109ecdcda">&#9670;&nbsp;</a></span>getRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp; icu::RuleBasedBreakIterator::getRules </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the description used to create this iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>the description used to create this iterator </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000664">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a76c4b778add5db7cbeb25000e218e236" name="a76c4b778add5db7cbeb25000e218e236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c4b778add5db7cbeb25000e218e236">&#9670;&nbsp;</a></span>getRuleStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::getRuleStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the status tag from the break rule that determined the boundary at the current iteration position. </p>
<p >For break rules that do not specify a status, a default value of 0 is returned. If more than one break rule would cause a boundary to be located at some position in the text, the numerically largest of the applicable status values is returned. </p>
<p >Of the standard types of ICU break iterators, only word break and line break provide status values. The values are defined in the header file <a class="el" href="ubrk_8h.html" title="C API: BreakIterator.">ubrk.h</a>. For Word breaks, the status allows distinguishing between words that contain alphabetic letters, "words" that appear to be numbers, punctuation and spaces, words containing ideographic characters, and more. For Line Break, the status distinguishes between hard (mandatory) breaks and soft (potential) break positions. </p>
<p ><code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a76c4b778add5db7cbeb25000e218e236" title="Return the status tag from the break rule that determined the boundary at the current iteration posit...">getRuleStatus()</a></code> can be called after obtaining a boundary position from <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afd699474653a478d119a3e57a0c36358" title="Advances the iterator to the next boundary position.">next()</a></code>, <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ada0b7afee76d2adf5fcbfae3a2b4adbe" title="Moves the iterator backwards, to the last boundary preceding this one.">previous()</a></code>, or any other break iterator functions that returns a boundary position. </p>
<p >Note that <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a76c4b778add5db7cbeb25000e218e236" title="Return the status tag from the break rule that determined the boundary at the current iteration posit...">getRuleStatus()</a></code> returns the value corresponding to <code><a class="el" href="classicu_1_1BreakIterator.html#af6ad53a2e16b52b8d746f81d2ffdf231" title="Return character index of the current iterator position within the text.">current()</a></code> index even after <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afd699474653a478d119a3e57a0c36358" title="Advances the iterator to the next boundary position.">next()</a></code> has returned DONE. </p>
<p >When creating custom break rules, one is free to define whatever status values may be convenient for the application. </p>
<dl class="section return"><dt>Returns</dt><dd>the status from the break rule that determined the boundary at the current iteration position.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#ad998235a2dd88fbcf5770d5126155fac" title="Enum constants for the word break tags returned by getRuleStatus().">UWordBreak</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000679">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

<p>Reimplemented from <a class="el" href="classicu_1_1BreakIterator.html#a1920d04ad1b7d0966b2ff7863df77a74">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a9c8e36f3ff39a261f0ca69de84c8ee07" name="a9c8e36f3ff39a261f0ca69de84c8ee07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8e36f3ff39a261f0ca69de84c8ee07">&#9670;&nbsp;</a></span>getRuleStatusVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::getRuleStatusVec </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>fillInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the status (tag) values from the break rule(s) that determined the boundary at the current iteration position. </p>
<p >The returned status value(s) are stored into an array provided by the caller. The values are stored in sorted (ascending) order. If the capacity of the output array is insufficient to hold the data, the output will be truncated to the available length, and a U_BUFFER_OVERFLOW_ERROR will be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillInVec</td><td>an array to be filled in with the status values. </td></tr>
    <tr><td class="paramname">capacity</td><td>the length of the supplied vector. A length of zero causes the function to return the number of status values, in the normal way, without attempting to store any values. </td></tr>
    <tr><td class="paramname">status</td><td>receives error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of rule status values from the rules that determined the boundary at the current iteration position. In the event of a U_BUFFER_OVERFLOW_ERROR, the return value is the total number of status values that were available, not the reduced number that were actually returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a76c4b778add5db7cbeb25000e218e236" title="Return the status tag from the break rule that determined the boundary at the current iteration posit...">getRuleStatus</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000680">Stable:</a></b></dt><dd>ICU 3.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classicu_1_1BreakIterator.html#af3bf12df7434e65041447bef51264e13">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="abda7c218cb044e5a9454751c7295eb42" name="abda7c218cb044e5a9454751c7295eb42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abda7c218cb044e5a9454751c7295eb42">&#9670;&nbsp;</a></span>getStaticClassID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a> icu::RuleBasedBreakIterator::getStaticClassID </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the class ID for this class. </p>
<p >This is useful only for comparing to a return value from <a class="el" href="classicu_1_1BreakIterator.html#a37b8904de97de51ffbc99c38689d9527" title="Return a polymorphic class ID for this object.">getDynamicClassID()</a>. For example: </p><pre class="fragment"> Base* polymorphic_pointer = createPolymorphicObject();
 if (polymorphic_pointer-&gt;getDynamicClassID() ==
     Derived::getStaticClassID()) ...
</pre> <dl class="section return"><dt>Returns</dt><dd>The class ID for all objects of this class. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000682">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="ad5e53aa07a6738178e1a45913679c81e" name="ad5e53aa07a6738178e1a45913679c81e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e53aa07a6738178e1a45913679c81e">&#9670;&nbsp;</a></span>getText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> &amp; icu::RuleBasedBreakIterator::getText </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Return a <a class="el" href="classicu_1_1CharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> over the text being analyzed. The returned character iterator is owned by the break iterator, and must not be deleted by the caller. Repeated calls to this function may return the same <a class="el" href="classicu_1_1CharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a>. </p>
<p >The returned character iterator must not be used concurrently with the break iterator. If concurrent operation is needed, clone the returned character iterator first and operate on the clone. </p>
<p >When the break iterator is operating on text supplied via a <a class="el" href="structUText.html" title="UText struct.">UText</a>, this function will fail, returning a <a class="el" href="classicu_1_1CharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> containing no text. The function <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a7d5cde052bcd274706b6fd01bf42f7f3" title="Get a UText for the text being analyzed.">getUText()</a> provides similar functionality, is reliable, and is more efficient. </p>
<p >TODO: deprecate this function?</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator over the text being analyzed. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000665">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a0fa727532413a065188276576e1c11e6">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a7d5cde052bcd274706b6fd01bf42f7f3" name="a7d5cde052bcd274706b6fd01bf42f7f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5cde052bcd274706b6fd01bf42f7f3">&#9670;&nbsp;</a></span>getUText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a> * icu::RuleBasedBreakIterator::getUText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>fillIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="structUText.html" title="UText struct.">UText</a> for the text being analyzed. </p>
<p >The returned <a class="el" href="structUText.html" title="UText struct.">UText</a> is a shallow clone of the <a class="el" href="structUText.html" title="UText struct.">UText</a> used internally by the break iterator implementation. It can safely be used to access the text without impacting any break iterator operations, but the underlying text itself must not be altered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillIn</td><td>A <a class="el" href="structUText.html" title="UText struct.">UText</a> to be filled in. If nullptr, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be allocated to hold the result. </td></tr>
    <tr><td class="paramname">status</td><td>receives any error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="structUText.html" title="UText struct.">UText</a> for this break iterator. If an input <a class="el" href="structUText.html" title="UText struct.">UText</a> was provided, it will always be returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000666">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#acbe2380f7611225fb3483b0ed2fbbb8a">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="afbfd1d9c7231c809fad160d0a76517d3" name="afbfd1d9c7231c809fad160d0a76517d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbfd1d9c7231c809fad160d0a76517d3">&#9670;&nbsp;</a></span>hashCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::hashCode </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a hash code for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000663">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a85d306ff87478dcdeae98593fe042f9e" name="a85d306ff87478dcdeae98593fe042f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d306ff87478dcdeae98593fe042f9e">&#9670;&nbsp;</a></span>isBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> icu::RuleBasedBreakIterator::isBoundary </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified position is a boundary position. </p>
<p >As a side effect, leaves the iterator pointing to the first boundary position at or after "offset". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if "offset" is a boundary position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000677">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#aaf997425386eae9c50cd5c208dbef214">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a640e068427c32b38cca78898a4d44750" name="a640e068427c32b38cca78898a4d44750"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640e068427c32b38cca78898a4d44750">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::last </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current iteration position to the end of the text. </p>
<dl class="section return"><dt>Returns</dt><dd>The text's past-the-end offset. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000671">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a2ecbdcabef74105eb7f0747011d05e01">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="ae7f0ee8fad7ea12a613b6bdb3cad52b9" name="ae7f0ee8fad7ea12a613b6bdb3cad52b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f0ee8fad7ea12a613b6bdb3cad52b9">&#9670;&nbsp;</a></span>next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::next </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the iterator either forward or backward the specified number of steps. </p>
<p >Negative values move backward, and positive values move forward. This is equivalent to repeatedly calling <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afd699474653a478d119a3e57a0c36358" title="Advances the iterator to the next boundary position.">next()</a> or <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ada0b7afee76d2adf5fcbfae3a2b4adbe" title="Moves the iterator backwards, to the last boundary preceding this one.">previous()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of steps to move. The sign indicates the direction (negative is backwards, and positive is forwards). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character offset of the boundary position n boundaries away from the current one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000672">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a971257b3ed9676ec02890187025caf1b">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="afd699474653a478d119a3e57a0c36358" name="afd699474653a478d119a3e57a0c36358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd699474653a478d119a3e57a0c36358">&#9670;&nbsp;</a></span>next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::next </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the iterator to the next boundary position. </p>
<dl class="section return"><dt>Returns</dt><dd>The position of the first boundary after this one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000673">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a13468dd341e9f0eb92c61f25e88a5154">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a866de4f5f4b7ba0a40c75177a17fdeb0" name="a866de4f5f4b7ba0a40c75177a17fdeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866de4f5f4b7ba0a40c75177a17fdeb0">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icu::RuleBasedBreakIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not-equal operator. </p>
<p >If operator== returns true, this returns false, and vice versa. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> to be compared for inequality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both BreakIterators are not same. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000661">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00307">307</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

<p class="reference">References <a class="el" href="classicu_1_1BreakIterator.html#a0045fc272df09804974fc767bc5340fc">icu::BreakIterator::operator==()</a>.</p>

</div>
</div>
<a id="abd180c6ad9f911ad16237c858c47c615" name="abd180c6ad9f911ad16237c858c47c615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd180c6ad9f911ad16237c858c47c615">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp; icu::RuleBasedBreakIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p >Sets this iterator to have the same behavior, and iterate over the same text, as the one passed in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The RuleBasedBreakItertor passed in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000659">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a266522728258632298ee1bb97922a439" name="a266522728258632298ee1bb97922a439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266522728258632298ee1bb97922a439">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool icu::RuleBasedBreakIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p >Returns true if both BreakIterators are of the same class, have the same behavior, and iterate over the same text. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> to be compared for equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both BreakIterators are of the same class, have the same behavior, and iterate over the same text. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000660">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a0045fc272df09804974fc767bc5340fc">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="aca8f68a88bc3d3d9f9d34606874671b5" name="aca8f68a88bc3d3d9f9d34606874671b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8f68a88bc3d3d9f9d34606874671b5">&#9670;&nbsp;</a></span>preceding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::preceding </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the iterator to refer to the last boundary position before the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The position to begin searching for a break from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the last boundary before the starting position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000676">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a980f8e8fbe1d37827cacc24f9606399f">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="ada0b7afee76d2adf5fcbfae3a2b4adbe" name="ada0b7afee76d2adf5fcbfae3a2b4adbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0b7afee76d2adf5fcbfae3a2b4adbe">&#9670;&nbsp;</a></span>previous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::previous </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the iterator backwards, to the last boundary preceding this one. </p>
<dl class="section return"><dt>Returns</dt><dd>The position of the last boundary position preceding this one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000674">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#aeede95a59db8408760b106724dfb7a4d">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a95e936d521b000d3543e7de997801dc8" name="a95e936d521b000d3543e7de997801dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e936d521b000d3543e7de997801dc8">&#9670;&nbsp;</a></span>refreshInputText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp; icu::RuleBasedBreakIterator::refreshInputText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the subject text string upon which the break iterator is operating without changing any other aspect of the matching state. </p>
<p >The new and previous text strings must have the same content.</p>
<p >This function is intended for use in environments where ICU is operating on strings that may move around in memory. It provides a mechanism for notifying ICU that the string has been relocated, and providing a new <a class="el" href="structUText.html" title="UText struct.">UText</a> to access the string in its new position.</p>
<p >Note that the break iterator implementation never copies the underlying text of a string being processed, but always operates directly on the original text provided by the user. Refreshing simply drops the references to the old text and replaces them with references to the new.</p>
<p >Caution: this function is normally used only by very specialized, system-level code. One example use case is with garbage collection that moves the text in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The new (moved) text string. </td></tr>
    <tr><td class="paramname">status</td><td>Receives errors detected by this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000684">Stable:</a></b></dt><dd>ICU 49 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#ab31f305a92919fdafea1fd54861a3343">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="afe7c9dcc8dfc94f197006e7c50e51f78" name="afe7c9dcc8dfc94f197006e7c50e51f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7c9dcc8dfc94f197006e7c50e51f78">&#9670;&nbsp;</a></span>setText() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void icu::RuleBasedBreakIterator::setText </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the iterator to analyze a new piece of text. </p>
<p >This function resets the current iteration position to the beginning of the text.</p>
<p >The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> will retain a reference to the supplied string. The caller must not modify or delete the text while the <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> retains the reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>The text to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000668">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a8b894129fb567fded3ed85a7e8ead942">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="aecfde1ea8cad6f09f6cc1cf186c73572" name="aecfde1ea8cad6f09f6cc1cf186c73572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfde1ea8cad6f09f6cc1cf186c73572">&#9670;&nbsp;</a></span>setText() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void icu::RuleBasedBreakIterator::setText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>
<p >The iterator position is reset to the start.</p>
<p >This function makes a shallow clone of the supplied <a class="el" href="structUText.html" title="UText struct.">UText</a>. This means that the caller is free to immediately close or otherwise reuse the Utext that was passed as a parameter, but that the underlying text itself must not be altered while being referenced by the break iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> used to change the text. </td></tr>
    <tr><td class="paramname">status</td><td>Receives any error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000669">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a3110dd5111286cd514ea6896ddd8c5bd">icu::BreakIterator</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a5fbb7407696454879cf016b20a0380f0" name="a5fbb7407696454879cf016b20a0380f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fbb7407696454879cf016b20a0380f0">&#9670;&nbsp;</a></span>BreakIterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000100">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00195">195</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<a id="a17ce03f12f5fa8688859b25e2bf60938" name="a17ce03f12f5fa8688859b25e2bf60938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ce03f12f5fa8688859b25e2bf60938">&#9670;&nbsp;</a></span>RBBIRuleBuilder</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class RBBIRuleBuilder</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000099">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00193">193</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a2ad6052587787523f902a4503693dbe6" name="a2ad6052587787523f902a4503693dbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad6052587787523f902a4503693dbe6">&#9670;&nbsp;</a></span>fData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RBBIDataWrapper* icu::RuleBasedBreakIterator::fData = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The rule data for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> instance. </p>
<p >Not for general use; Public only for testing purposes. </p><dl class="internal"><dt><b><a class="el" href="internal.html#_internal000093">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00074">74</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="rbbi_8h_source.html">rbbi.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
