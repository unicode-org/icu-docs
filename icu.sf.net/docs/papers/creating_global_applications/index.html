<html>
<head>
<title>Java Cookbook: Creating Global Applications</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /></meta> </meta> 
<meta content="The Java content zone on IBM's Developer Web site is your stop for information on Java-based products, programming, and happenings in the fast-paced world of Java development." name="DESCRIPTION"></meta> </meta> </meta> 
</head>
<body bgcolor="#ffffff" marginheight="2" marginwidth="2" topmargin="2" leftmargin="2">
<h1><span class="atitle">Java Cookbook: Creating Global Applications</span></h1>
<span class="atitle2"></span> 
<p> <a href="#author1">Mark Davis</a><br />
  Senior Technical Staff Member, IBM<br />
  January 1998</p>
<p>Originally published on <a href="http://www-106.ibm.com/developerworks/unicode/library/sun-ibm-java.html?dwzone=unicode">http://www-106.ibm.com/developerworks/unicode/library/sun-ibm-java.html?dwzone=unicode</a></p>
<table width="160" border="0" align="right" bgcolor="#999999">
  <tr bgcolor="#0000CC"> 
    <td> 
      <div align="center"><b><font color="#FFFFFF">Contents:</font></b></div>
    </td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h0">Background</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h1">Introduction</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h2">Converting your Application</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h3">Translate Strings</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h4">Concatenation</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h5">Handle Numbers, Currencies, Dates, and Times</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h6">Fix String Comparison</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h7">Use Character Properties</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h8">Word-Break Detection</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h9">Convert Non-Unicode Text</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h10">Handle Multilingual Text</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h11">Limitations of JDK 1.1</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h12">Far East</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h13">Middle East</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h14">Southeast Asia</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h15">JDK 1.2 and Beyond</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h16">Closing</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#h17">Acknowledgements</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#resources">Resources</a></td>
  </tr>
  <tr bgcolor="#CCCCCC"> 
    <td><a href="#author1">About the author</a></td>
  </tr>
  <!--Standard links for every article--> 
</table>
<p>The emergence of the Internet and other distributed networks puts increasing 
  importance on the ability to create global software -- that is, software that 
  can be developed independently of the countries or languages of intended users 
  -- and then translated for multiple countries or regions. Java 1.1 takes a major 
  step forward in creating global applications and applets. It provides frameworks 
  based on the Unicode<sup>TM</sup> 2.0 character set -- the standard for international 
  text -- and it provides an architecture for developing global applications, 
  which can present messages, numbers, dates, and currency in any country's conventional 
  formats. </p>
<p> However, when all is said and done, it may not be clear just how to go about 
  making your program ready for localization with Java 1.1. This article outlines 
  how to do that, what the strengths and limitations are of the current 1.1 support, 
  and what to expect in the future. The discussion also applies to new programs; 
  it is generally much easier to build a global program from the ground, than 
  to go back later and retrofit it! </p>
<p> In the first section, we discuss how to convert your application into a global 
  application. We then move on to look at what the current limitations in the 
  JDK 1.1 are, and what the future may hold in store for us. </p>
<a name="h0"><span class="atitle2"><b>Background</b></span></a><br />
The bulk of the international support in Java 1.1 was licensed from Taligent, 
with data supplied by IBM's Native Language Technical Center (NLTC) in Toronto. 
Taligent had developed an integrated set of object-oriented frameworks to support 
the creation of international software, providing a standard API to make handling 
the requirements of different countries and languages transparent to developers. 
Using experience gained in building C++ frameworks, Taligent redesigned its frameworks 
in Java, which allows for a much simpler API and implementation. This was a cooperative 
effort with JavaSoft, which participated in reviewing and adapting the APIs we 
supplied. 
<p> Before diving into the text, we will clarify some notation that we will be 
  using. In the examples, changed text will be in <i>italic</i>, and comments 
  will be in blue. We will also use the following terms: </p>
<p> <a name="h1"><span class="atitle2"><b>Introduction</b></span></a><br />
  <i>display string</i> <br />
  A string that may be shown to the user. These strings will need to be translated 
  for different countries. Non-display strings, such as URLs, are used programmatically, 
  and are not translated. </p>
<p> <i>locale</i> <br />
  A name for conventions shared among a large set of users for language, dates, 
  times, numbers, etc. Typically, a single country is represented by a single 
  locale (and loosely speaking, you may use "country" and "locale" interchangeably). 
  However, some countries, such as Switzerland, have more than one official language 
  and therefore multiple locales. </p>
<p> <i>global application</i> <br />
  An application that can be completely translated for use in different locales. 
  All text shown to the user is in the native language, and user expectations 
  are met for dates, times, and other locale conventions. Also known as <i>localizable 
  application</i>. To <i>globalize</i> is to convert your program into a localizable 
  one. (Of course, with Java, you can also have global applets. </p>
<p> The JDK 1.1 implements the Unicode 2.0 character set with the Unicode character 
  database version 2.0.14; for brevity, we will refer to this as Unicode 2.0.14. 
  (Also, our use of the term <i>application</i> should be understood to include 
  applets, unless otherwise noted.) </p>
<p> <b>Note:</b> On some browsers, the default font sizes are a bit small for 
  the examples. You can reset the size to make them more readable. For example, 
  in Netscape, use Options:General Preferences:Fonts. </p>
<p> <a name="h2"><span class="atitle2"><b>Converting your Application</b></span></a><br />
  We will first take you through a step-by-step process of converting your application 
  into a global one. This will also guide you in making an application global 
  from the beginning. For more detailed information about each of the topics, 
  you should definitely consult the Java 1.1 International API documentation. 
  Thoroughly covering all the issues involved in developing global applications 
  is beyond the scope of this paper, but there are a number of resources available 
  on the Web or in print. See the references at the end of this document. </p>
<p> In the course of this section our examples are additive, with each successive 
  one adding to code that may already have been converted to some extent. In those 
  cases, the <b>Old</b> heading refers to the partially converted code, not to 
  your original. </p>
<p> When the user starts up a global application, the default locale will be used 
  for the display text and other user inter FACE elements. If the user changes 
  the default locale (generally with some mechanism on the host system), then 
  you can get a different user inter FACE language. (If you wish, you can go further, 
  and support a <i>multilingual</i> application (or applet), which allows use 
  of simultaneous multiple locales. We'll discuss this later.) </p>
<p> <a name="h3"><span class="atitle2"><b>Translate Strings</b></span></a><br />
  The first step to take in preparing your program is to enable translation of 
  display strings by separating them from the rest of your code. With Java, this 
  is done via ResourceBundles . These provide a general mechanism that allows 
  you to access strings and other objects according to locale conventions. In 
  principle, they are fairly simple: They simply provide a mapping from <code>&lt;key,locale&gt;</code> 
  to <code>&lt;value&gt;</code>. However, they also supply inheritance among locale 
  resources that allows you to minimize duplication across countries, and gives 
  you a graceful degradation in case the exact locale does not have localized 
  resources. </p>
<p> Unfortunately, at this point in time, you will have to change your code by 
  hand to make your strings translatable. You can do the bulk of the work with 
  a PERL script if you want, but you will still have to check the results. The 
  general problem with converting strings automatically is the difficulty in distinguishing 
  display strings from non-display strings. Once the commercial Java development 
  environments fully support resource bundles, this task should become easier, 
  since they will make it easy to avoid mixing display strings in the code in 
  the first place. </p>
<p> Resource bundles are very flexible -- so flexible that getting started may 
  be mystifying. You can use list resource bundles, property resource bundles, 
  or you can make your own. You can have fine-grained bundles or coarse-grained, 
  and so on. To give you some direction, we'll start by showing one particular 
  way to use resource bundles, and then we'll discuss some of the other options. 
<ul>
  <li>Create a class called <code>MyResources</code> </li>
</ul>
<p></p>
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td colspan=2  align="top"><font face="Helvetica, Helv, Arial" size="-1"><b>Making 
      an Empty ResourceBundle</b></font></td>
  </tr>
  <tr> 
    <td valign="top" width="34"><font face="Helvetica, Helv, Arial" size="-1"><b>New</b></font></td>
  </tr>
  <tr> 
    <td valign="top" width="454" bgcolor="#99ccff"> <font face="Courier"> 
      <pre>
<font face="Courier"><i>public class MyResources extends ListResourceBundle {</i>
<font color="#003399">// boilerplate
</font><i>public static ResourceBundle rb =</i>
<i>ResourceBundle.getBundle(&quot;MyResources&quot;);</i>
<i>public Object[][] getContents() { return contents; }</i>
<i>static final Object[][] contents = {</i>
<font color="#003399">// insert localized {key, value}, pairs below</font>
<i>};</i>
<i>}</i>
</font></pre>
      </font> </td>
  </tr>
</table>
<p> 
<ul>
  <li>Treat each display string as in the following example, inserting:</li>
</ul>
<p></p>
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td   align="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>Moving 
      Strings to Resource Bundles</b></font></strong></td>
  </tr>
  <tr> 
    <td  valign="top" width="34"> <font face="Helvetica, Helv, Arial" size="-1"><b>Old</b></font> 
    </td>
  </tr>
  <tr> 
    <td valign="top" width="497" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier">myCheckbox = new Checkbox(&quot;Clean cartridge before printing document&quot;);
</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td valign="top" width="497" bgcolor="#99ccff"> <font face="Courier" color="#003399">
      <pre><font face="Courier" color="#003399">// insert localized {key, value}, pairs below
</font><font face="Helvetica, Helv, Arial" size="-1">...
</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td valign="top"width="34"><font face="Helvetica, Helv, Arial" size="-1"><b>New</b></font></td>
  </tr>
  <tr> 
    <td valign="top" width="497" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier">myCheckbox = new Checkbox(<i>MyResources.rb.getString(&quot;CleanCartridge&quot;)</i>);
</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td valign="top" width="497" bgcolor="#99ccff"> <font face="Courier" >
      <pre><font face="Courier" >// insert localized {key, value} pairs here
<i>{&quot;CleanCartridge&quot;, &quot;Clean cartridge before printing document&quot;},</i>
...
</font></pre>
      </font> </td>
  </tr>
</table>
<p> 
<ul>
  <li>You have now set up a series of resource pairs of the form {key, value}. 
    The resource keys (such as "CleanCartridge" ) can be any unique string you 
    want, even the original string. However, you are better off using short, clear 
    names: remember that your translators will be seeing these too.</li>
  <li>To then create a new French translation for your program:</li>
  <ul>
    <li>Copy MyResources and rename it to MyResources_fr by appending the proper 
      Java language ID. (You can see a list of the language IDs on the <a href="http://unicode.org/">Unicode 
      Web site</a>. By convention, language codes are lowercased.)</li>
    <li>Make it extend its parent, MyResources.</li>
    <li>Remove the static rb (you only want this on the root class).</li>
    <li>Translate the resource values into French (but not the keys!). </li>
    <li>If any of the values are unchanged -- the same as the parent -- remove 
      the whole {key, value} pair. (You can do this because the {key, value} pairs 
      are inherited from the parent.) </li>
    <li>Do the same again for any other other language you want to support.</li>
  </ul>
</ul>
<p></p>
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td  valign="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>Translating 
      Resource Bundles</b></font></strong></td>
  </tr>
  <tr> 
    <td  valign="top" width="33"> <font face="Helvetica, Helv, Arial" size="-1"><b>Old</b></font> 
    </td>
  </tr>
  <tr> 
    <td valign="top" width="455" bgcolor="#99ccff"> 
      <pre><font face="Courier" color="#003399">// insert localized {key, value} pairs here
</font><font face="Courier"><i>  {&quot;CleanCartridge&quot;, &quot;Clean cartridge before printing document&quot;},</i>
</font></pre>
    </td>
  </tr>
  <tr> 
    <td valign="top" width="33"> <font face="Helvetica, Helv, Arial" size="-1"><b>New</b></font> 
    </td>
  </tr>
  <tr> 
    <td valign="top" width="455" bgcolor="#99ccff"> <font face="Courier" bgcolor="#99ccff"> 
      <pre><font face="Courier" bgcolor="#99ccff">// insert localized {key, value}, pairs below
</font><font face="Courier">{&quot;CleanCartridge&quot;, <i>&quot;Cleanez le cartridge de inque après que... &quot;</i>},
</font></pre>
      </font> </td>
  </tr>
</table>
<p> 
<ul>
  <li>If you have special strings for a particular country -- and not just language 
    -- then you do much the same as above.</li>
  <ul>
    <li>Create a bundle in the same way for that country, such as MyResources_fr_BE 
      for Belgium, by appending the proper Java country ID (You can see a list 
      of the country IDs on the <a href="http://unicode.org/">Unicode Web site</a>. 
      By convention, country codes are uppercased.)</li>
    <li>Make it extend its parent; in this case, MyResources_fr.</li>
    <li>If any of the values are unchanged -- the same as the parent -- remove 
      the whole {key, value} pair. </li>
  </ul>
</ul>
<p></p>
<p> The way this is set up, the static rb will be initialized with the proper 
  resource bundle according to the default Locale. This convenience allows us 
  to refer to that bundle. You can use locale variables instead to reference the 
  resource bundle, if you want. </p>
<p> If your resource bundle gets too large then you can subdivide it into other 
  resource bundles, such as <code>MyPrintingResources</code>, following the same 
  pattern. You can make this as fine-grained as you want, so that you only load 
  the resources for a part of your program when that part gets used. You can return 
  arbitrary objects, not only strings, since it is often easier (and sometimes 
  necessary, such as for graphics that need to be localized). For example: </p>
<table border="1" width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td valign="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>Moving 
      Objects to Resource Bundles</b></font></strong></td>
  </tr>
  <tr> 
    <td valign="top"  width="38"> <font face="Helvetica, Helv, Arial" size="-1"><b>Old</b></font> 
    </td>
  </tr>
  <tr> 
    <td valign="top" width="523" bgcolor="#99ccff"> <font face="Courier"> 
      <pre><font face="Courier">myCheckbox = new Checkbox(&quot;Clean cartridge before printing document&quot;);
</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td valign="top" width="523" bgcolor="#99ccff"> <font face="Courier" color="#003399">
      <pre><font face="Courier" color="#003399">// insert localized {key, value}, pairs below</font><font face="Courier">
...
</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td  valign="top" width="38"><font face="Helvetica, Helv, Arial" size="-1"><b>New</b></font></td>
  </tr>
  <tr> 
    <td valign="top" width="523" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier">myCheckbox = (Checkbox) MyResources.rb.getObject(&quot;CleanCartridge&quot;);
</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td valign="top" width="523" bgcolor="#99ccff"> <font face="Courier" color="#003399">
      <pre><font face="Courier" color="#003399">// insert localized {key, value} pairs here
</font><font face="Courier"><i>{&quot;CleanCartridge&quot;, new Checkbox(&quot;Clean cartridge before printing document&quot;)},</i>
...
</font></pre>
      </font> </td>
  </tr>
</table>
<p> You can also use a <code>PropertyResourceBundle</code> instead of a ListResourceBundle. 
  In that case, what you do is follow the same pattern, but instead of creating 
  a class, you put the {key, value} pairs into a <code>PropertyFile</code>. The 
  name of the property file is the same as the name of the <code>ListResourceBundle</code> 
  that you would have had. Since you don't have classes any more, put your static 
  rb in some convenient place, such as in your applet, and use that name for references 
  (for example <code>MyApplet.rb.getString("CleanCartridge"</code>) ). However, 
  if you use a <code>PropertyResourceBundle</code>, be aware that you can only 
  extract strings -- and not other classes. </p>
<p> Resource bundles have a very simple interFACE. If you wanted to use other 
  sources for your strings, you can always subclass to make your own resource 
  bundle. For example, you could write one that accessed strings or serialized 
  objects out of a database, or even over the Web. The basic requirements are 
  to map keys to values, and provide for the inheritance of keys discussed above. 
</p>
<p> For more information, see the <a href="http://www.taligent.com/Products/javaintl/Demos/About.html">Taligent 
  Java Demos</a> and the <a href="http://www.javasoft.com:80/products/jdk/1.1/docs/guide/intl/index.html">JavaSoft 
  International Specification</a>. </p>
<a name="h4"><span class="atitle2"><b>Concatenation</b></span></a><br />
If you haven't done much internationalization, then you may not have heard the 
mantra: <i>Never concatenate display strings!</i> Why is this a problem? Well, 
the order of parts of a sentence is different in different languages; this difference 
can easily lead you into trouble. For example, if you write <code>MyResources.rb.getString("DeleteBefore") 
+ someDate</code>, the localizer is limited to modifying only the string, and 
not the position of the date. If the language requires verbs to be at the end 
of the sentence, the localizer is stuck. 
<p> You can replace concatenation by use of MessageFormats, which allow the localizer 
  to position the variable information appropriately: </p>
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td colspan=2  align="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>MessageFormat 
      Instead of Concatenation</b></font></strong></td>
  </tr>
  <tr> 
    <td valign="top"  width="32"> <font face="Helvetica, Helv, Arial" size="-1"><b>Old</b></font> 
    </td>
  </tr>
  <tr> 
    <td valign="top" width="615" bgcolor="#99ccff"> <font face="Courier"> 
      <pre><font face="Courier">myCheckbox=new Checkbox(MyResources.rb.getString(&quot;DeleteBefore&quot;)+ someDate);</font></pre>
      </font></td>
  </tr>
  <tr> 
    <td width="615" bgcolor="#99ccff"> <font face="Courier" color="#003399">
      <pre><font face="Courier" color="#003399">
   // insert localized {key, value}, pairs below
</font><font face="Courier">{&quot;DeleteBefore&quot;, &quot;Delete all files before &quot;},</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td  valign="top" width="32"> <font face="Helvetica, Helv, Arial" size="-1"><b>New</b></font> 
    </td>
  </tr>
  <tr> 
    <td valign="top" width="615" bgcolor="#99ccff"> <font face="Courier">
      <pre>
<font face="Courier"><i>MessageFormat mf=new MessageFormat(MyResources.rb.getString(&quot;DeleteBefore&quot;));</i>
myCheckbox=new Checkbox(<i>mf.format(new Object[] {someDate})</i>);</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td width="615" height="50" bgcolor="#99ccff"> <font face="Courier" color="#003399"> 
      <pre><font face="Courier" color="#003399">// insert localized {key, value}, pairs below
</font><font face="Courier">{&quot;DeleteBefore&quot;, &quot;Delete files before {0}&quot;},
</font></pre>
      </font> </td>
  </tr>
</table>
<p> <b>Note:</b> The reason for using the array of objects for the parameter is 
  to allow multiple arguments. There will probably be convenience methods in the 
  future to make this a bit smoother. </p>
<p> This new pattern string can then be localized, allowing rearrangement of the 
  position of the argument {0} . If you want to, you could combine this into a 
  single statement, using the static MessageFormat.format() : </p>
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td colspan=2  align="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>One-Line 
      MessageFormat</b></font></strong></td>
  </tr>
  <tr> 
    <th align="right" valign="top" width="35" height="26"> 
      <div align="left"><font face="Helvetica, Helv, Arial" size="-1"><b>New</b></font></div>
    </th>
    <td valign="top" width="450" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier">myCheckbox = new Checkbox(MessageFormat.format(
MyResources.rb.getString(&quot;DeleteBefore&quot;), new Object[] {someDate}));</font></pre>
      </font> </td>
  </tr>
</table>
<p> Message formats can also be used to customize the precise format of dates, 
  times, numbers, or currencies. If you only specify the position of the argument, 
  then a default for the current locale will be chosen. However, you (for English) 
  or the localizer (for other languages) can also more precisely control the format 
  if you desire. This is done by adding additional keywords or patterns after 
  the argument number, as in the following examples: </p>
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <th width="100%"><font face="Helvetica, Helv, Arial" size="-1"><b>Argument</b></font></th>
  </tr>
  <tr> 
    <td width="100%" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier">new Date(97,22,5);</font></pre>
      </font> </td>
  </tr>
</table>
<p></p>
<p>
<font face="Helvetica, Helv, Arial" size="-1"> 
<table border="1"  width="525" cellpadding="2" cellspacing="2">
  <tr> 
    <th width="50%" nowrap><font face="Helvetica, Helv, Arial" size="-1"><b>Pattern</b></font></th>
    <th width="50%" nowrap><font face="Helvetica, Helv, Arial" size="-1"><b>Result</b></font></th>
  </tr>
  <tr> 
    <td bgcolor="#99ccff"> <font face="Courier"> 
      <pre><font face="Courier">&quot;Delete files before {0}&quot;</font></pre>
      </font> </td>
    <td><font face="Helvetica, Helv, Arial" size="-1">Delete files before 6/13/97 
      1:00 AM</font></td>
  </tr>
  <tr> 
    <td bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier">&quot;Delete files before {0,date,long}&quot;</font></pre>
      </font> </td>
    <td><font face="Helvetica, Helv, Arial" size="-1">Delete files before June 
      13, 1997</font></td>
  </tr>
  <tr> 
    <td width="50%" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier">&quot;Delete files before {0,date,yyyy.MMM.dd}&quot;</font></pre>
      </font> </td>
    <td width="50%"><font face="Helvetica, Helv, Arial" size="-1">Delete files 
      before 1997.Jun.13</font></td>
  </tr>
</table>
<p> For more information, see the <a href="http://www.taligent.com/Products/javaintl/Demos/About.html">Taligent 
  Java Demos</a> and the <a href="http://www.javasoft.com:80/products/jdk/1.1/docs/guide/intl/index.html">JavaSoft 
  International Specification</a>. </p>
<a name="h5"><span class="atitle2"><b>Handle Numbers, Currencies, Dates, and Times</b></span></a><br />
Number and date formats can also be used separately, with similar control over 
their formatting. (Number formats handle general numbers and currencies; date 
formats cover both dates and times.) To globalize your program, replace the implicit 
conversion of a number to a string with an explicit formatting call, and put the 
pattern for the format into a resource bundle, as in the following example: 
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td align="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>Number 
      Output</b></font></strong></td>
  </tr>
  <tr> 
    <td  valign="top" width="32"> <font face="Helvetica, Helv, Arial" size="-1"><b>Old</b></font> 
    </td>
  </tr>
  <tr> 
    <td valign="top" width="570" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier">myTextField.setText(myNumber);</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td width="570" bgcolor="#99ccff"> <font face="Courier"> 
      <pre><font face="Courier" color="#003399">// insert localized {key, value}, pairs below
</font><font face="Helvetica, Helv, Arial" size="-1">...</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td  valign="top"  width="32"> <font face="Helvetica, Helv, Arial" size="-1"><b>New</b></font> 
    </td>
  </tr>
  <tr> 
    <td valign="top" width="570" bgcolor="#99ccff"> <font face="Courier"> 
      <pre><font face="Courier">NumberFormat nf=(NumberFormat)(MyResources.rb.getObject(&quot;PageNumberFormat&quot;));
myTextField.setText(nf.format(myNumber));</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td width="570" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier" color="#003399">// insert localized {key, value}, pairs below
</font><font face="Courier">{&quot;PageNumberFormat&quot;, new DecimalFormat(&quot;#,##0&quot;)},
...
</font></pre>
      </font> </td>
  </tr>
</table>
<p> If you want to get only a string from the resources and create your own number 
  format, you can do it. However, you must do it in a a special way. You should 
  always get a number format using getInstance() , since a particular locale may 
  have a specialized subclass of NumberFormat . However, this subclass may not 
  allow use of a pattern string. So you need to check the type of the NumberFormat 
  you get before setting the pattern. (This should be simplified in a future release 
  of Java.) </p>
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td   align="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>Number 
      Output from String Resource</b></font></strong></td>
  </tr>
  <tr> 
    <td  valign="top"  width="133"> <font face="Helvetica, Helv, Arial" size="-1"><b>Old</b></font> 
    </td>
  </tr>
  <tr> 
    <td valign="top" width="545" height="35" bgcolor="#99ccff"> <font face="Courier">	
      <pre><font face="Courier">myTextField.setText(myNumber);</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td width="545" height="23" bgcolor="#99ccff"> <font face="Courier"> 
      <pre><font face="Courier" color="#003399">// insert localized {key, value}, pairs below
</font><font face="Courier">
...</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td  valign="top"  width="133"> <font face="Helvetica, Helv, Arial" size="-1"><b>New</b></font> 
    </td>
  </tr>
  <tr> 
    <td valign="top" width="545" height="143" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier">NumberFormat nf = NumberFormat.getInstance();

if (nf instanceof DecimalFormat) 

((DecimalFormat)nf).applyPattern(MyResources.rb.getString(&quot;PageNumberFormat&quot;));

myTextField.setText(nf.format(myNumber));</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <td width="545" bgcolor="#99ccff"> 
      <div align="left"> <font face="Courier">
        <pre><font face="Courier" color="#003399">// insert localized {key, value}, pairs below
</font><font face="Courier">
{&quot;PageNumberFormat&quot;, &quot;#,##0&quot;},

...</font></pre>
        </font> </div>
    </td>
  </tr>
</table>
<p> You can also programmatically alter number formats, such as by setting the 
  maximum or minimum number of decimals, or by deciding whether a thousands separator 
  is used. However, it is better practice to use a pattern string instead, since, 
  otherwise, you don't allow your localizers to customize the format. </p>
<p>Of course, if you are formatting in a tight loop, you should move the creation 
  of the format out of the loop! You can also make your formats static to avoid 
  repeated creations.</p>
<p>Instead of using methods on Integer, Float, etc. to do conversion from Strings 
  to numbers, dates, times, etc., use the appropriate formats again for parsing. 
  A Format will parse what it can produce (and more), so you can use the same 
  one for output <i>and</i> input. </p>
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td colspan=2  align="top"> 
      <div align="left"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>Number 
        Input</b></font></strong></div>
    </td>
  </tr>
  <tr> 
    <th align="right" valign="top" width="33"> 
      <div align="left"><font face="Helvetica, Helv, Arial" size="-1"><b>Old</b></font></div>
    </th>
    <td valign="top" width="447" bgcolor="#99ccff"> 
      <div align="left"> <font face="Courier"> 
        <pre><font face="Courier">try {

myNumber = Integer.parseInt(myTextField.getText());

} catch (NumberFormatException e) {

alertBadNumber(e);

}</font></pre>
        </font> </div>
    </td>
  </tr>
  <tr> 
    <th align="right" valign="top" width="33"> 
      <div align="left"><font face="Helvetica, Helv, Arial" size="-1"><b>New</b></font></div>
    </th>
    <td valign="top" width="447" bgcolor="#99ccff"> 
      <div align="left"> <font face="Courier"> 
        <pre><font face="Courier">try {

myNumber = nf.parse(myTextField2.getText());

} catch (ParseException e) {

alertBadNumber(e);

}</font></pre>
        </font> </div>
    </td>
  </tr>
</table>
<p> If you are creating your own display of date fields, such as for an alarm 
  clock widget, then you may want to display the different component fields (year, 
  month, date...) each in a separate TextField . Then you will want to use a Calendar 
  , which will convert the standard Date into its components according to local 
  conventions. </p>
<p> <b>Note:</b> The order <i>and choice</i> of these fields may vary according 
  to local conventions. For example, the year may come at the start of the date 
  instead of the end, or the date format may even consist of very different information, 
  such as year + day-in-year . Currently, there is no simple way to get the order 
  of the fields in the format; that should be addressed in a future release. In 
  the meantime, if you intend to use FieldPosition to determine the position of 
  the fields with the text, be warned that there is a bug that makes that difficult: 
  consult Taligent's Web site for a workaround. </p>
<p> Calendar has special support for clock widgets. For any given field, it can 
  tell you the result of incrementing or decrementing that field. It also supports 
  a variant form of incrementing/decrementing, called <i>rolling</i>, which gives 
  you the same effect as setting a field on your digital watch, in which changing 
  the minute field doesn't affect the hour: ...11:58, 11:59, 11:00, 11:01... </p>
<p> For more information, see the <a href="http://www.taligent.com/Products/javaintl/Demos/About.html">Taligent 
  Java Demos</a> and the <a href="http://www.javasoft.com:80/products/jdk/1.1/docs/guide/intl/index.html">JavaSoft 
  International Specification</a>. </p>
<p> <a name="h6"><span class="atitle2"><b>Fix String Comparison</b></span></a><br />
  The standard comparison in String will only do a binary comparison. For display 
  strings, this is <b><i>almost always incorrect!</i> </b> Wherever the ordering 
  <i>or equality</i> of strings is important to the user, such as when presenting 
  an alphabetized list, then use a Collator instead. Otherwise a German, for example, 
  will find that you don't equate two strings that he thinks are equal!</p>
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td colspan=2  align="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>String 
      Comparison</b></font></strong></td>
  </tr>
  <tr> 
    <th align="right" valign="top" width="35"> 
      <div align="left"><font face="Helvetica, Helv, Arial" size="-1"><b>Old</b></font></div>
    </th>
    <td valign="top" width="445" bgcolor="#99ccff"> <font face="Courier"> 
      <pre><font face="Courier">if (string1.equals(string2)) {...
...
if (string1.compare(string2) &lt; 0) {...
</font></pre>
      </font> </td>
  </tr>
  <tr> 
    <th align="right" valign="top" width="35"> 
      <div align="left"><font face="Helvetica, Helv, Arial" size="-1"><b>New</b></font></div>
    </th>
    <td valign="top" width="445" bgcolor="#99ccff"> <font face="Courier"> 
      <pre><font face="Courier">Collator col = Collator.getInstance();
if (col.equals(string1, string2)) {...
...
if (col.compare(string1, string2) &lt; 0) {...
</font></pre>
      </font> </td>
  </tr>
</table>
<p> Of course, if you are comparing strings in a tight loop, you should move the 
  creation of the collator out of the loop! You can also make your collator static 
  to avoid repeated creations. </p>
<p> If a string is going to be compared multiple times, then use a CollationKey 
  instead. This preprocesses the string to handle all of the international issues, 
  and converts it into an internal form that can be compared with a simple binary 
  comparison. This makes multiple comparisons much faster. </p>
<table border="1"  width="503" cellpadding="2" cellspacing="2">
  <tr> 
    <td colspan=2  align="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>Using 
      CollationKey</b></font></strong></td>
  </tr>
  <tr> 
    <th align="right" valign="top" width="29"> 
      <div align="left"><b><font face="Helvetica, Helv, Arial" size="-1">New</font></b></div>
    </th>
    <td valign="top" width="454" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier" color="#003399">// make up a list of sort keys
</font><font face="Courier">CollationKey[] keys = new CollationKey[sourceStrings.length];
for (int i = 0; i &lt; sourceStrings.length; ++i) {
keys[i] = col.getCollationKey(sourceStrings[i]);
}
<font color="#003399">// now sort and stuff them into an AWT List
</font>sort(keys);
List list = new List();
for (int i = 0; i &lt; sourceStrings.length; ++i) {
list.addItem(keys[i].getSourceString());
}
</font></pre>
      </font> </td>
  </tr>
</table>
<p> There are also a number of advanced features in Collators, such as the ability 
  to merge in additional rules at runtime or modify the rules. For example, you 
  can make "b" sort after "c", if you really wanted, or you can have "?" sort 
  exactly as if it were spelt out as "question-mark". You can also use collators 
  to do correct native-language searching as well as sorting, using a CollationElementIterator 
  . However, this code is not straightforward, and I would recommend waiting until 
  there are methods in Java to do it for you. </p>
<p> For more information, see the <a href="http://www.taligent.com/Products/javaintl/Demos/About.html">Taligent 
  Java Demos</a> and the <a href="http://www.javasoft.com:80/products/jdk/1.1/docs/guide/intl/index.html">JavaSoft 
  International Specification</a>. </p>
<p> <a name="h7"><span class="atitle2"><b>Use Character Properties</b></span></a><br />
  If your code assumes that all characters of a given type (such as letters or 
  digits) are the ones in the ASCII range, then it will break with foreign languages. 
  Rather than test for particular ranges of characters, you should use the Unicode 
  character properties wherever possible.</p>
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td colspan=2  align="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>Replacing 
      Range Tests</b></font></strong></td>
  </tr>
  <tr> 
    <th align="right" valign="top" width="37"> 
      <div align="left"><font face="Helvetica, Helv, Arial" size="-1"><b>Old</b></font></div>
    </th>
    <td valign="top" width="443" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier">for (i = 0; i &lt; string.length(); ++i) {
char ch = string.charAt(i);
if ((ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')) {
<font color="#003399">// we have a letter, do something with it.</font></font></pre>
      </font> </td>
  </tr>
  <tr> 
    <th align="right" valign="top" width="37"> 
      <div align="left"><font face="Helvetica, Helv, Arial" size="-1"><b>New</b></font></div>
    </th>
    <td valign="top" width="443" bgcolor="#99ccff"> <font face="Courier">
      <pre><font face="Courier" color="#003399">for (i = 0; i &lt; string.length(); ++i) {
char ch = string.charAt(i);
if (Character.isLetter(ch)) {
<font color="#003399">// we have a letter (including non ASCII), do something with it.</font></font></pre>
      </font> </td>
  </tr>
</table>
<p> A number of methods are defined for the more common Unicode character properties. 
  In addition, you have full access to all the Unicode 2.0.14 character categories 
  by using Character.getType() . For more information, see the <a href="http://www.javasoft.com:80/products/jdk/1.1/docs/guide/intl/index.html">JavaSoft 
  International Specification</a>. </p>
<table border="1"  width="500" cellpadding="2" cellspacing="2">
  <tr> 
    <td colspan=2  align="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>Replacing 
      Type Tests</b></font></strong></td>
  </tr>
  <tr> 
    <th align="right" valign="top" width="20"> 
      <div align="left"><font face="Helvetica, Helv, Arial" size="-1"><b>Old</b></font></div>
    </th>
    <td valign="top" bgcolor="#99ccff"> <font face="Courier"> 
      <pre><font face="Courier" color="#003399">for (i = 0; i &lt; string.length(); ++i) {
char ch = string.charAt(i);
if (ch == '(' || ch == '{' || ch == '[') {
<font color="#003399">// we have an open brace, do something with it.</font></font></pre>
      </font> </td>
  </tr>
  <tr> 
    <th align="right" valign="top" width="20"> 
      <div align="left"><font face="Helvetica, Helv, Arial" size="-1"><b align="right">New</b></font></div>
    </th>
    <td valign="top" bgcolor="#99ccff"> <font face="Courier"> 
      <pre><font face="Courier" color="#003399">for (i = 0; i &lt; string.length(); ++i) {
char ch = string.charAt(i);
if (Character.getType(ch) == Character.START_PUNCTUATION) {
<font color="#003399">// we have an open brace (including non ASCII), do something with it.</font></font></pre>
      </font> </td>
  </tr>
</table>
<p> </p>
<a name="h8"><span class="atitle2"><b>Word-Break Detection</b></span></a><br />
Word breaks in natural language are not only defined by spaces. For example, when 
I search in this word processor for the word "checked" with the option "Whole 
Words" checked, I find the last instance of "checked" even though it is not bounded 
by spaces (there is a comma at the end). Even if you are using more sophisticated 
tests for ASCII text, such as checking for various kinds of punctuation, you must 
now deal with the wealth of possible characters in Unicode, and how they may behave 
differently in different countries. By using a BreakIterator , you can avoid dealing 
with these complexities. 
<p> <b><b>Going Word-by-Word</b></b>
<table border="1" cellspacing="0" cellpadding="5" width="100%" bgcolor="#CCCCCC">
  <tr>
    <td>
      <pre><code>
BreakIterator boundary = BreakIterator.getWordInstance();
boundary.setText(stringToExamine);
int start = boundary.first();
for (int end = boundary.next(); 
end != BreakIterator.DONE; 
start = end, end = boundary.next()) {
System.out.println(source.substring(start,end));
}
</code></pre>
    </td>
  </tr>
</table>
<p></p>
<p> To find out whether a current index is at a word break, you can use the following 
  code (this should be in a convenience routine in a future release): </p>
<p> <b><b>Testing Word Breaks</b></b><a name=""><b></b></a>
<table border="1" cellspacing="0" cellpadding="5" width="100%" bgcolor="#CCCCCC">
  <tr>
    <td>
      <pre><code>
if (currentIndex &lt; 0 || currentIndex &gt; stringToExamine.length())
return false;
if (currentIndex == 0 || currentIndex == stringToExamine.length())
return true;
int discard = boundary.following(currentIndex);
if (boundary.previous() == currentIndex) 
return true;
return false;
</code></pre>
    </td>
  </tr>
</table>
<p></p>
<p> You can use different break iterators to find word boundaries, line-wrap boundaries, 
  sentence boundaries and character boundaries. The latter may seem mysterious: 
  character simply means Unicode character, right? However, what native users 
  consider a single character may not be only a single Unicode character, and 
  user expectations may differ from country to country. </p>
<p> <b>Note:</b> In the Java code base is a DecompositionIterator (it is currently 
  private). This actually walks through Unicode text and returns normalized characters. 
  For example, it maps the compatibility characters (such as the FULLWIDTH EXCLAMATION 
  MARK) at the end of the Unicode range onto their respective standard characters. 
  Once this is made public, then it can also be used in processing text. </p>
<p> For more information, see the <a href="http://www.taligent.com/Products/javaintl/Demos/About.html">Taligent 
  Java Demos</a> and the <a href="http://www.javasoft.com:80/products/jdk/1.1/docs/guide/intl/index.html">JavaSoft 
  International Specification</a>. </p>
<a name="h9"><span class="atitle2"><b>Convert Non-Unicode Text</b></span></a><br />
As long as you are writing a pure Java application using only Unicode characters, 
you don't have to worry about the thousands of possible character sets out in 
the world. However, if you are dealing with other data, then you will need to 
convert in and out of Unicode. 
<p> Unfortunately, the API for doing character code conversions is fairly limited 
  at this time, although the hidden implementation is quite extensive. There are 
  two places where this API surFACEs. In each of them, you use a string to identify 
  the non-Unicode character set that you are converting to or from. You can attach 
  an encoding to a stream ( OutputStreamWriter or InputStreamReader ) or you specify 
  on String the encoding when constructing from an array of bytes or when using 
  the getBytes method to convert to bytes. </p>
<p> <b><b>Using Foreign Character Sets</b></b><a name=""><b></b></a>
<table border="1" cellspacing="0" cellpadding="5" width="100%" bgcolor="#CCCCCC">
  <tr>
    <td>
      <pre><code>
// convert from ISO 8859-2 into Macintosh Central European
String string = new String(foreignBytes[],"8859_2");
otherBytes = string.getBytes("MacCentralEurope");
</code></pre>
    </td>
  </tr>
</table>
<p></p>
<p> <b>Note:</b> Remember that the length of any conversion is not necessarily 
  the same as the length of the source. For example, when converting the SJIS 
  encoding to Unicode, sometimes one byte will convert into a single Unicode character, 
  and sometimes two bytes will. </p>
<p> There is no programmatic way to get a list of the supported character sets, 
  other than to delve into the Sun directory in the Java source. Following is 
  a list of the current supported sets on NT, gotten in just that fashion. Unfortunately, 
  there is no guarantee that these will be present on every platform, nor is there 
  yet documentation of what some of the more obscure names in this list actually 
  refer to! </p>
<table border="1"  width="541" cellpadding="2" cellspacing="2">
  <tr> 
    <td colspan=2  align="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>Foreign 
      Character Set Labels</b></font></strong></td>
  </tr>
  <tr> 
    <td valign="top"> <font face="Helvetica, Helv, Arial" size="-1">&quot;Default&quot; 
      </font> 
      <p><font face="Helvetica, Helv, Arial" size="-1"> <font face="Helvetica, Helv, Arial" size="-1">&quot;8859_1&quot; 
        &quot;8859_2&quot; &quot;8859_3&quot; &quot;8859_4&quot; &quot;8859_5&quot; 
        &quot;8859_6&quot; &quot;8859_7&quot; &quot;8859_8&quot; &quot;8859_9&quot; 
        </font> </font></p>
      <p><font face="Helvetica, Helv, Arial" size="-1"> <font face="Helvetica, Helv, Arial" size="-1">&quot;Cp037&quot; 
        &quot;Cp273&quot; &quot;Cp277&quot; &quot;Cp278&quot; &quot;Cp280&quot; 
        &quot;Cp284&quot; &quot;Cp285&quot; &quot;Cp297&quot; &quot;Cp420&quot; 
        &quot;Cp424&quot; &quot;Cp437&quot; &quot;Cp500&quot; &quot;Cp737&quot; 
        &quot;Cp775&quot; &quot;Cp838&quot; &quot;Cp850&quot; &quot;Cp852&quot; 
        &quot;Cp855&quot; &quot;Cp856&quot; &quot;Cp857&quot; &quot;Cp860&quot; 
        &quot;Cp861&quot; &quot;Cp862&quot; &quot;Cp863&quot; &quot;Cp864&quot; 
        &quot;Cp865&quot; &quot;Cp866&quot; &quot;Cp868&quot; &quot;Cp869&quot; 
        &quot;Cp870&quot; &quot;Cp871&quot; &quot;Cp874&quot; &quot;Cp875&quot; 
        &quot;Cp918&quot; &quot;Cp921&quot; &quot;Cp922&quot; &quot;Cp930&quot; 
        &quot;Cp933&quot; &quot;Cp935&quot; &quot;Cp937&quot; &quot;Cp939&quot; 
        &quot;Cp942&quot; &quot;Cp948&quot; &quot;Cp949&quot; &quot;Cp950&quot; 
        &quot;Cp964&quot; &quot;Cp970&quot; &quot;Cp1006&quot; &quot;Cp1025&quot; 
        &quot;Cp1026&quot; &quot;Cp1046&quot; &quot;Cp1097&quot; &quot;Cp1098&quot; 
        &quot;Cp1112&quot; &quot;Cp1122&quot; &quot;Cp1123&quot; &quot;Cp1124&quot; 
        &quot;Cp1250&quot; &quot;Cp1251&quot; &quot;Cp1252&quot; &quot;Cp1253&quot; 
        &quot;Cp1254&quot; &quot;Cp1255&quot; &quot;Cp1256&quot; &quot;Cp1257&quot; 
        &quot;Cp1258&quot; &quot;Cp1381&quot; &quot;Cp1383&quot; &quot;Cp33722&quot; 
        &quot;MS874&quot; </font> </font></p>
      <p><font face="Helvetica, Helv, Arial" size="-1"> <font face="Helvetica, Helv, Arial" size="-1">&quot;DBCS_ASCII&quot; 
        &quot;DBCS_EBCDIC&quot; &quot;EUC&quot; &quot;EUCJIS&quot; &quot;GB2312&quot; 
        &quot;JIS&quot; &quot;JIS0208&quot; &quot;KOI8_R&quot; &quot;KSC5601&quot; 
        &quot;SJIS&quot; &quot;SingleByte&quot; &quot;Big5&quot; &quot;CNS11643&quot; 
        </font> </font></p>
      <p><font face="Helvetica, Helv, Arial" size="-1"> <font face="Helvetica, Helv, Arial" size="-1"> 
        &quot;MacArabic&quot; &quot;MacCentralEurope&quot; &quot;MacCroatian&quot; 
        &quot;MacCyrillic&quot; &quot;MacDingbat&quot; &quot;MacGreek&quot; &quot;MacHebrew&quot; 
        &quot;MacIceland&quot; &quot;MacRoman&quot; &quot;MacRomania&quot; &quot;MacSymbol&quot; 
        &quot;MacThai&quot; &quot;MacTurkish&quot; &quot;MacUkraine&quot; </font> 
        </font></p>
      <p><font face="Helvetica, Helv, Arial" size="-1"> <font face="Helvetica, Helv, Arial" size="-1"> 
        &quot;Unicode&quot; &quot;UnicodeBig&quot; &quot;UnicodeLittle&quot; &quot;UTF8&quot; 
        </font> </font></p>
      <p><font face="Helvetica, Helv, Arial" size="-1"> <font face="Helvetica, Helv, Arial" size="-1"><i>Only 
        to Unicode: </i>&quot;JISAutoDetect&quot;<i><br>
        Only from Unicode: </i>&quot;UnicodeBigUnmarked&quot; &quot;UnicodeLittleUnmarked&quot; 
        </font> </font></p>
    </td>
  </tr>
</table>
<p> </p>
<a name="h10"><span class="atitle2"><b>Handle Multilingual Text</b></span></a><br />
If you wish, you can go further and support a <i>multilingual</i> application 
(or applet), which allows use of simultaneous multiple locales. First you should 
understand an important distinction between <i>multilingual data</i> and <i>multilingual 
user interFACE</i>: 
<ul>
  <li> <i>multilingual data:</i> Users can enter data or set data formats according 
    to multiple locales (e.g. formats of cells in a spreadsheet).</li>
  <li> <i>multilingual user interFACE:</i> Users can switch the locale of the 
    display of your application (Menus, Buttons, etc.) at <i>runtime</i>.</li>
</ul>
<p> You can support both in JDK 1.1, but most people don't find it worth the effort 
  to support a runtime multilingual user interFACE. </p>
<p> Since Unicode is the character set for Java, the user can enter in multilingual 
  data (with some restrictions; see <a href="#h11">Limitations of JDK 1.1</a>). 
  All of the formats, collators, and other international classes allow you to 
  pass an explicit Locale as a parameter. You can thus give the user the choice 
  of which locales to use for your display locale or for data. This allows you, 
  for example, to easily have French dates in one column of a table and German 
  dates in another. </p>
<p> <b><b>Multilingual Text Handling</b></b>
<table border="1" cellspacing="0" cellpadding="5" width="100%" bgcolor="#CCCCCC">
  <tr>
    <td>
      <pre><code>
NumberFormat nf = NumberFormat.getInstance(Locale.FRANCE);
// or
NumberFormat nf = NumberFormat.getInstance(new Locale("fr","",""));
</code></pre>
    </td>
  </tr>
</table>
<p></p>
<p> To find out the list of locales available for a particular type of object, 
  such as a NumberFormat , look for a static on that object (or its base class) 
  called getAvailableLocales() . To then display the localized names of those 
  locales, such as in a Menu or List , use getDisplayName() . </p>
<p> <b><b>Listing Locales</b></b>
<table border="1" cellspacing="0" cellpadding="5" width="100%" bgcolor="#CCCCCC">
  <tr>
    <td>
      <pre><code>
numberLocaleMenu = new Menu("&amp;Locale");
Locale[] locales = NumberFormat.getAvailableLocales();
for (int i = 0; i &lt; locales.length; ++i) {
numberLocaleMenu.addItem(locales[i].getDisplayName());
}
</code></pre>
    </td>
  </tr>
</table>
<p></p>
<p> The following table lists the locales that currently have localized international 
  objects (numbers, dates, etc.) in Java 1.1. If you create locales from the arguments 
  listed, you get the corresponding display names in the adjacent column. This 
  list is supplied <i>only</i> for comparison; you should always use code to find 
  the actual localized objects on your current system. Notice that if you don't 
  supply a specific country (or variant), a default will be chosen. </p>
</font>
<table border="1" width="500" cellpadding="2" cellspacing="2">
  <font face="Helvetica, Helv, Arial" size="-1"> 
  <tr> 
    <td colspan=4 align="top"><strong><font face="Helvetica, Helv, Arial" size="-1"><b>JDK 
      1.1 Locales</b></font></strong></td>
  </tr>
  <tr> 
    <th align="left"><font face="Helvetica, Helv, Arial" size="-1">Arguments</font></th>
    <th align="left"><font face="Helvetica, Helv, Arial" size="-1">Display Name</font></th>
    <th align="left"><font face="Helvetica, Helv, Arial" size="-1">Arguments</font></th>
    <th align="left"><font face="Helvetica, Helv, Arial" size="-1">Display Name</font></th>
  </tr>
  <tr> 
    <td valign="top" width="15%"> <font face="helvetica, helv, arial" size=-1>
      <pre>
<font face="helvetica, helv, arial">&quot;ar&quot;,&quot;&quot;,&quot;&quot;
&quot;be&quot;,&quot;&quot;,&quot;&quot;
&quot;bg&quot;,&quot;&quot;,&quot;&quot;
&quot;ca&quot;,&quot;&quot;,&quot;&quot;
&quot;cs&quot;,&quot;&quot;,&quot;&quot;
&quot;da&quot;,&quot;&quot;,&quot;&quot;
&quot;de&quot;,&quot;&quot;,&quot;&quot;
&quot;de&quot;,&quot;AT&quot;,&quot;&quot;
&quot;de&quot;,&quot;CH&quot;,&quot;&quot;
&quot;el&quot;,&quot;&quot;,&quot;&quot;
&quot;en&quot;,&quot;&quot;,&quot;&quot;
&quot;en&quot;,&quot;CA&quot;,&quot;&quot;
&quot;en&quot;,&quot;GB&quot;,&quot;&quot;
&quot;en&quot;,&quot;IE&quot;,&quot;&quot;
&quot;es&quot;,&quot;&quot;,&quot;&quot;
&quot;et&quot;,&quot;&quot;,&quot;&quot;
&quot;fi&quot;,&quot;&quot;,&quot;&quot;
&quot;fr&quot;,&quot;&quot;,&quot;&quot;
&quot;fr&quot;,&quot;BE&quot;,&quot;&quot;
&quot;fr&quot;,&quot;CA&quot;,&quot;&quot;
&quot;fr&quot;,&quot;CH&quot;,&quot;&quot;
&quot;hr&quot;,&quot;&quot;,&quot;&quot;
&quot;hu&quot;,&quot;&quot;,&quot;&quot;
&quot;is&quot;,&quot;&quot;,&quot;&quot;
&quot;it&quot;,&quot;&quot;,&quot;&quot;
&quot;it&quot;,&quot;CH&quot;,&quot;&quot;
</font></pre>
      </font> </td>
    <td valign="top" width="35%"> <font face="helvetica, helv, arial" size=-1>
      <pre><font face="helvetica, helv, arial" size=-1>
Arabic (Egypt)
Belorussian (Belarus)
Bulgarian (Bulgaria)
Catalan (Spain)
Czech (Czech Republic)
Danish (Denmark)
German (Germany)
German (Austria)
German (Switzerland)
Greek (Greece)
English (United States)
English (Canada)
English (United Kingdom)
English (Ireland)
Spanish (Spain)
Estonian (Estonia)
Finnish (Finland)
French (France)
French (Belgium)
French (Canada)
French (Switzerland)
Croatian (Croatia)
Hungarian (Hungary)
Icelandic (Iceland)
Italian (Italy)
Italian (Switzerland)
</font></pre>
      </font> </td>
    <td valign="top" width="15%"> <font face="helvetica, helv, arial"> 
      <pre>
<font face="helvetica, helv, arial">
&quot;iw&quot; ,&quot; &quot;,&quot;&quot;
&quot;ja&quot; ,&quot; &quot;,&quot;&quot;
&quot;ko&quot; ,&quot; &quot;,&quot;&quot;
&quot;lt&quot; ,&quot; &quot;,&quot;&quot;
&quot;lv&quot; ,&quot; &quot;,&quot;&quot;
&quot;mk&quot; ,&quot; &quot;,&quot;&quot;
&quot;nl&quot; ,&quot; &quot;,&quot;&quot;
&quot;nl&quot; ,&quot; BE&quot;,&quot;&quot;
&quot;no&quot; ,&quot; &quot;,&quot;&quot;
&quot;no&quot; ,&quot; NO&quot;,&quot;NY&quot;
&quot;pl&quot; ,&quot; &quot;,&quot;&quot;
&quot;pt&quot; ,&quot; &quot;,&quot;&quot;
&quot;ro&quot; ,&quot; &quot;,&quot;&quot;
&quot;ru&quot; ,&quot; &quot;,&quot;&quot;
&quot;sh&quot; ,&quot; &quot;,&quot;&quot;
&quot;sk&quot; ,&quot; &quot;,&quot;&quot;
&quot;sl&quot; ,&quot; &quot;,&quot;&quot;
&quot;sq&quot; ,&quot; &quot;,&quot;&quot;
&quot;sr&quot; ,&quot; &quot;,&quot;&quot;
&quot;sv&quot; ,&quot; &quot;,&quot;&quot;
&quot;tr&quot; ,&quot; &quot;,&quot;&quot;
&quot;uk&quot; ,&quot; &quot;,&quot;&quot;
&quot;zh&quot; ,&quot; &quot;,&quot;&quot;
&quot;zh&quot; ,&quot; TW&quot;,&quot;&quot;
</font></pre>
      </font> </td>
    <td valign="top" width="35%"> 
      <pre><font face="helvetica, helv, arial" size=-1>
Hebrew     (Israel)
Japanese   (Japan)
Korean     (Korea)
Lithuanian (Lituania)
Latvian    (Latvia)
Macedonian (Macedonia)
Dutch      (Netherlands)
Dutch      (Belgium)
Norwegian  (Bokmål)   (Norway)
Norwegian  (Nynorsk)  (Norway,NY)
Polish     (Poland)
Portuguese (Portugal)
Romanian   (Romania)
Russian    (Russia)
Serbian    (Latin)    (Serbia)
Slovak     (Slovakia)
Slovene    (Slovenia)
Albanian   (Albania)
Serbian    (Cyrillic) (Serbia)
Swedish    (Sweden)
Turkish    (Turkey)
Ukrainian  (Ukraine)
Chinese    (China)
Chinese    (ROC)
</font></pre>
    </td>
  </tr>
  </font> 
</table>
<p> Although for most applications a runtime multilingual user interFACE is not 
  worth the effort, if you do want to support it, you will restructure your application 
  somewhat. Essentially, you must do one of the following: </p>
<p> 
<ul>
  <li>Separate out the code that builds your UI. When the user picks a different 
    UI locale from a menu, you reset the default locale and then simply call your 
    code to rebuild the whole UI. </li>
  <li>Provide code that walks through your UI. When the user picks a different 
    UI locale from a menu, you reset the default locale and call this code to 
    go through each menu and container to replace each individual element with 
    the appropriate new resources. </li>
</ul>
<p></p>
<p> <a name="h11"><span class="atitle2"><b>Limitations of JDK 1.1</b></span></a><br />
  The JDK 1.1 release provides a great deal of support for European languages 
  and the countries that use them (we will refer to these locales as <i>Western</i>), 
  but due to time constraints there is only minimal support for the Far East, 
  and there is no adequate support for the Middle East and Southeast Asia (in 
  which we also include the Indian subcontinent). In addition, the font support 
  is very weak, even for English!</p>
<p> On the plus side, JDK 1.1 fonts have the capability to draw any Unicode characters, 
  assuming that the host platform/browser supports drawing those characters. This 
  requires that the appropriate fonts be installed on the host system. JDK 1.1 
  does have a mechanism for letting you combine many different native fonts together 
  into a single logical font in order to cover a larger range of Unicode characters. 
  It is currently done by means of editing one or more text font.properties files 
  in a special format. JavaSoft has very good documentation about this process 
  and its current limitations on the JavaSoft Web site at <a href="http://www.javasoft.com:80/products/jdk/1.1/docs/guide/intl/index.html"> 
  http://www.javasoft.com:80/products/jdk/1.1/docs/guide/intl/index.html </a>. 
</p>
<p> On the minus side, Java support for fonts is still very weak. For one thing, 
  there is no way to access the full set of fonts on a system; you are limited 
  to a small set of logical fonts: Serif, SansSerif, Monospaced, etc. (By the 
  way, to get the list of fonts, it is futile to search for that method in Font 
  ; you must use Toolkit.getFontList ). For most applets this is not so bad; the 
  few available logical fonts supported on each implementation are usually sufficient. 
  However, for Java applications this is a real problem; you can't build a Java 
  application that can list and use the available fonts on a system, something 
  that the simplest of native applications can do. </p>
<p> <b>Note:</b> The logical font names will map to different fonts on different 
  platforms; never make assumptions about metrics or coverage of these fonts. 
</p>
<p> The following are general deficiencies in the current international support. 
  <i>For background information on all the following topics, see the Unicode Standard.</i> 
</p>
<p> 
<ul>
  <li> <b>Default Locales in Applets.</b> There is unfortunately no per-thread 
    data in JDK 1.1. That deficiency, in addition to security concerns, prevents 
    applets from being able to call Locale.setDefault. If you want to do this, 
    the only current work-around is to store your own default in a well-known 
    place, and pass it around explicitly. This will not work for inaccessable 
    code that only uses the standard default locale, such as exception formatting.</li>
  <li> <b>Full Locale Coverage.</b> Though a large number of locales are in JDK 
    1.1, more need to be added. This would be especially true for for South America, 
    where the locale data tends to only differ in the name of the country and 
    the currency and number formats. These countries are otherwise in pretty good 
    shape. </li>
  <li> <b>Editing.</b> The current TextArea and TextField use host peers to do 
    the editing. That means that if the host does not support Unicode natively, 
    there is a conversion to some character set that the host does handle, typically 
    a character set that only handles the hosts default locale. In such circumstances, 
    the rich set of symbols and punctuation in Unicode (let alone letters in other 
    languages) is simply discarded. In addition, some current implementations 
    do signed conversion back to Unicode, so when you put 00E5<sub>16</sub> (&aringl;) 
    into the TextArea, you get back FFE5<sub>16</sub> (fullwidth &yen;)!</li>
  <li> <b>Character Code Conversions. </b>As we mentioned above, you really need 
    to be able to iterate through all of the installed character code converters 
    and to have a richer API -- for, among other things, better performance.</li>
  <li> <b>Keyboards.</b> Most non-Western locales use mixtures of different scripts; 
    for example, you will find English product names mixed in with Japanese or 
    with Arabic. To handle this, the user needs to be able to change between different 
    keyboard mappings. Usually, the operating system will provide support for 
    this, but for word processing, you need to be able to find out what the current 
    keyboard is, iterate through the installed keyboards, and reset the current 
    keyboard. You can thereby provide a convenience for the user, in which, if 
    he clicks down into Japanese text, you automatically switch the keyboard to 
    Japanese. </li>
  <li> <b>Calendars.</b> Most non-Western locales have alternative calendars and 
    need to allow a choice between the standard (Gregorian) calendar and at least 
    one alternative. Japanese, for example, needs an additional calendar, which 
    is based on the year of the various Emperors' reigns. If you need to do this 
    in JDK 1.1, you will need to subclass Calendar , which is fairly straightforward. 
    Although you can do this, it may be of limited use until some of the other 
    features are supported in Java. </li>
  <li> <b>Styled Text.</b> Using the current Java API, you can perform your own 
    text layout to support drawing, hit-testing, highlighting, and line-break. 
    For example, you would make a series of draw calls with font changes between 
    each one. Even with Western scripts, this does not support higher-level features 
    such as justification efficiently. With non-Western scripts, such as Hebrew, 
    that have a mixture of right-to-left and left-to-right characters, this method 
    breaks down very quickly. </li>
</ul>
<p></p>
<a name="h12"><span class="atitle2"><b>Far East</b></span></a><br />
Chinese, Japanese, and Korean (CJK) have very large alphabets, which require fonts 
that can handle large character sets, and require special support for inputting 
characters. For high-end systems, vertical text and ruby (textual annotations) 
are also required. 
<p> <b>Input Methods</b><br />
  The main issue for correct localization for CJK is input. Due to the complexity 
  of the character sets, there is a conversion facility that transforms input 
  from a small set of phonetic or component characters that the user types into 
  the actual CJK characters stored in the document. This facility is often called 
  an <i>input method engine</i> (IME) or sometimes a <i>front-end processor</i> 
  (FEP). An IME is generally quite complex. It often does sophisticated grammatical 
  analysis of the text, and it commonly </p>
<p> 
<ul>
  <li>uses the input context to disambiguate characters</li>
  <li>marks special states of text with distinctive highlighting</li>
  <li>allows the user to choose and control alternative transformations</li>
  <li>allows the user to add new expressions to user dictionaries.</li>
</ul>
<p></p>
<p> There are three main types of input support that each offer different levels 
  of capability and require different degrees of application changes: </p>
<p> 
<ol>
  <li>Name: <b>Off</b>-the-spot (a.k.a. bottom-line) <br />
    User Value: minimal <br />
    Application Changes: none <br />
    When the user types a character, a window appears (usually at the bottom of 
    the screen). Within that window, the user interacts with the IME. When the 
    user is finished, a series of keyboard events are fed to the unsuspecting 
    application one at a time. (This would speed up if there were a Java keyboard 
    event that contained an entire string.)</li>
  <br>
  <li>Name: <b>Over</b>-the-spot <br />
    User Value: partial <br />
    Application Changes: minimal <br />
    When the user types a character, a window appears right over the place the 
    user was typing. The text is often in the same font and size and feels more 
    like the user is typing directly into the document. Otherwise, this is the 
    same as off-the-spot. </li>
  <br>
  <li>Name: <b>On</b>-the-spot (a.k.a. inline) <br />
    User Value: full <br />
    Application Changes: major (for word processors) <br />
    When the user types a character, it goes directly into the document. The special 
    highlighting happens within the text, and changes are immediately reflected, 
    including word-wrap. These require fairly complex interactions for word processors; 
    programs that use the built-in Java editing (TextField, TextArea) are not 
    affected.</li>
</ol>
<p></p>
<p> Currently, you are completely dependent on the quality of the Java implementation 
  on the host platform or browser. </p>
<ul>
  <li>You will get on-the-spot in TextField and TextArea -- <i>but only if the 
    implementation supports it</i>.</li>
  <li>Otherwise you will get off-the-spot support -- <i>but only if the implementation 
    supports it. </i> </li>
</ul>
<p> It is fairly easy for a host platform or browser to support both these features, 
  at least on the major platforms that have CJK support, but, unfortunately there 
  are no guarantees that this is done. </p>
<p> Moreover, there is <i>no</i> way for a Java program to support on-the-spot 
  outside of TextArea/TextField, such as for word processors doing real rich-text 
  editing with mixed styles and fonts. You can do over-the-spot support yourself 
  by opening up your own small window that contains a TextArea, putting the window 
  in the right position and setting the font yourself. However, you can't get 
  a list of the available IMEs or choose which gets invoked. </p>
<p> <b>Fonts</b><br />
  Large character fonts are handled in JDK 1.1. As discussed above, there is a 
  limited selection. </p>
<p> Neither Ruby nor Vertical text is in JDK 1.1. Both require special handling 
  in text layout, but are fairly high-end features and so are not a problem for 
  most programs. </p>
<ul>
  <li> <b>Ruby:</b> Because people often don't know the pronunciation of a particular 
    ideograph (Kanji), small phonetic symbols are often placed over one or more 
    ideographs. Figure 1 shows an example of how this works, using English characters 
    to show the pronunciation of Greek letters. 
    <p> <img height="68" src="images/image2.gif" width="107"></p>
    <b>Figure 1 Ruby</b></li>
  <li> <b>Vertical Text:</b> CJK characters can also be written vertically, with 
    lines that go from right to left (usually). There are two complications: Some 
    characters will rotate or change shape in a vertical context, and intermixed 
    Latin text may rotate 90 degrees clockwise (and Arabic characters 90 degrees 
    counter-clockwise!). </li>
</ul>
<a name="h13"><span class="atitle2"><b>Middle East</b></span></a><br />
Arabic and Hebrew are written from right-to-left but also allow mixing in left-to-right 
text, such as numbers or English text. An example is shown in Figure 2. This feature 
is called BIDI (short for <i>bidirectional</i>). Moreover, Arabic characters may 
change shape radically, depending on their context. Both these features require 
very special handling in text layout to support drawing, hit-testing, highlighting, 
and line-break<i> and are not optional</i> for these locales. 
<p> <img height="88" src="images/image4.gif" width="323"></p>
<b>Figure 2 Bidirectional Reordering</b>
<p> Moreover, the general flow of objects will generally also be from right to 
  left. This includes the flow of components with a FlowLayout , and tab stops 
  in text, and on which side the box appears in a Checkbox . Text is also generally 
  right-flush instead of left-flush. The localizer and developer need to have 
  control of this flow direction on a component-by-component basis. </p>
<p> In addition, legacy data in other character sets may be stored in either visual 
  or logical order, while Unicode uses logical order. So special character converters 
  must be be written that can convert back and forth. </p>
<a name="h14"><span class="atitle2"><b>Southeast Asia</b></span></a><br />
Indic languages require special handling, since they require special ligatures 
(called <i>conjuncts</i>) and also rearrange certain vowels. Thai does not have 
these issues, but does require precise placement of multiple accents, which stack 
upon one another. This requires very special handling in text layout to support 
drawing, hit-testing, highlighting, and line-break<i>, and is not optional</i>. 
<p> <img height="451" src="images/image5.gif" width="323"></p>
<p> <b>Figure 3</b></p>
<p> Moreover, Thai requires special word-break handling, since spaces are not 
  used to separate words -- think of this as hyphenating within English words. 
  It also needs special collation to sort some vowel-consonant combinations as 
  if they were reversed. These languages may also employ simple input methods 
  to alert the user to illegitimate combinations of letters. </p>
<b><a name="h15"><span class="atitle2">JDK 1.2 and Beyond</span></a></b><a name="h15"></a><br />
JavaSoft is working with several companies to provide input method support in 
JDK 1.2. This should address the major shortcoming of Java in the Far East. The 
new work on the JFC will also include 100% Java text editing, which will handle 
the concerns mentioned above. 
<p> In addition,Taligent is under contract to JavaSoft to assist in further improving 
  the international system in general. In the JDK 1.2 release, this will involve 
  supporting BIDI, providing a much more general text layout and font mechanism, 
  as well as bug-fixing and incorporating our further performance improvements 
  from our C/C++ libraries. After JDK 1.2, this will include support for Southeast 
  Asian countries as well. </p>
<p> Much of this support, such as new calendars, will be transparent to the developer 
  who is already using JDK 1.1 features. However, some, such as the input method 
  support, may require changes to applications, especially applications that are 
  doing their own text processing. </p>
<p> Some of the other possible future enhancements include the following: </p>
<p> <b>Miscellaneous Possible Future Enhancements</b>
<ul>
  <li> Thread-locale data, so applets can call Locale.setDefault().</li>
  <li> getWebLocale(), so applets to find out their Web page's locale.</li>
  <li> Full synchronization of host and Java default locales and time zones.</li>
  <li> Searching API on Collators</li>
  <li> Programmatic switching of the priority of uppercase and lowercase letters 
    in Collators.</li>
  <li> Host-matching formats, collators, etc.</li>
  <li> Formatted TextFields (e.g. TextFields that format numbers and ensure that 
    input text matches the format).</li>
  <li> Historical time zones for better compatibility with UNIX.</li>
  <li> Sublinear searching for fast international searching.</li>
  <li> Transliteration for rule-based text conversions for smartquotes &amp; kana.</li>
  <li> Int'l Regular Expressions for language-sensitive matching.</li>
  <li> Spell-check framework for connecting spell-check engines.</li>
  <li> Hyphenation framework for connecting hyphenation engines.</li>
</ul>
<p></p>
<p> <a name="h16"><span class="atitle2"><b>Closing</b></span></a><br />
  With the Unicode support already in Java 1.1, the amount of work that you have 
  to do to globalize your application is much smaller than on other platforms. 
  You can get started right now to localize your programs, which will get your 
  application a long way towards world coverage: covering Europe, the Americas, 
  and (minimally) the Far East. As Java continues to evolve, you soon will be 
  able to localize to all world markets, building on the same base of code you 
  have now.</p>
<p> <a name="h17"><span class="atitle2"><b>Acknowledgements</b></span></a><br />
  My thanks to Brian Beck, Ken Whistler, Laura Werner, Kathleen Wilson, Baldev 
  Soor, Debbie Coutant, Tom McFarland, Lee Collins, Andy Clark, David Goldsmith 
  and Dave Fritz for their review or assistance with this paper.</p>
<p> Pulling the JDK 1.1 international classes together on a very short schedule 
  demanded a lot of hard work by people at Taligent, including Kathleen Wilson, 
  Helena Shih Chapman, Chen-Lieh Huang, and John Fitzpatrick. People at the IBM NLTC also 
  assisted, most especially Baldev Soor, but also Siraj Berhan and Stan Winitsky. 
  And without the support and excellent feedback from people at JavaSoft, this 
  work would not have been possible, especially from Brian Beck, but also from 
  Asmus Freytag, David Bowen, Bill Shannon, Mark Reinhold, Guy Steele, Larry Cable, 
  Graham Hamilton, and Naoyuki Ishimura. </p>
<p><a name="resources"><span class="atitle2"><b>Resources</b></span></a> 
<ul>
  <li>For more detailed information about each of the topics, you should definitely 
    consult the <a href="http://www.javasoft.com:80/products/jdk/1.1/docs/guide/intl/index.html">Java 
    1.1 International documentation</a>.</li>
  <li>More information on <a href="http://www.ibm.com/java/tools/international-classes/">Java 
    international classes</a> is available from this Web site.</li>
  <li>To see how to write robust Java classes, consult <a href="http://www-105.ibm.com/developerworks/education.nsf/dw/java-onlinecourse-bytitle">Java 
    Cookbook:Well-Mannered Objects</a>.</li>
  <li>If you are a beginner at Java but are acquainted with C++ or C, look at 
    <a href="http://www.ibm.com/java/education/portingc/index.html">Java Cookbook: 
    Porting C++ to Java</a>.</li>
  <li>We also supply C/C++ versions of these classes in case you are interested 
    in licensing them for other applications besides Java. We also provide online 
    updates to this paper and a <a href="news://productnews.taligent.com/taligent.products.unicode">discussion 
    forum</a> with information on bugs and workarounds.</li>
  <li>I also strongly recommend buying a copy of The Unicode Standard, Version 
    2.0 (and I don't even personally get any of the royalties!). For purchasing 
    information and general information about the Unicode Consortium look at the 
    <a href="http://unicode.org">Unicode Web site</a>.</li>
</ul>
<hr>
<p><a name="author1" /></a> <span class="atitle2"><b>About the author</b></span><br />
  Dr. Mark Davis is a Senior Technical Staff Member responsible for international 
  software architecture. Mark co-founded the Unicode effort, and is the president 
  of the Unicode Consortium. He is a principal co-author and editor of the Unicode 
  Standard, Versions 1.0 and 2.0. At various times, his department has included 
  software groups covering text, international, operating system services, Windows 
  porting, and technical communications. Technically, he specializes in object-oriented 
  programming and in the architecture and implementation of international and 
  text software.</p>
<p></p>
<p></p>
<p></p>
<p></p>
<p>&nbsp;</p>
</body>
</html>
