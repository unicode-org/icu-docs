<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ICU 78.1: icu::RuleBasedBreakIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ICU 78.1
   &#160;<span id="projectnumber">78.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceicu.html">icu</a></li><li class="navelem"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Data Fields</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">icu::RuleBasedBreakIterator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A subclass of <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> whose behavior is specified using a list of rules.  
 <a href="classicu_1_1RuleBasedBreakIterator.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="rbbi_8h_source.html">rbbi.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for icu::RuleBasedBreakIterator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classicu_1_1RuleBasedBreakIterator.png" usemap="#icu::RuleBasedBreakIterator_map" alt=""/>
  <map id="icu::RuleBasedBreakIterator_map" name="icu::RuleBasedBreakIterator_map">
<area href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text." alt="icu::BreakIterator" shape="rect" coords="0,112,168,136"/>
<area href="classicu_1_1UObject.html" title="UObject is the common ICU &quot;boilerplate&quot; class." alt="icu::UObject" shape="rect" coords="0,56,168,80"/>
<area href="classicu_1_1UMemory.html" title="UMemory is the common ICU base class." alt="icu::UMemory" shape="rect" coords="0,0,168,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a976126b3070d56d23a67184b41e88141"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a976126b3070d56d23a67184b41e88141">RuleBasedBreakIterator</a> ()</td></tr>
<tr class="memdesc:a976126b3070d56d23a67184b41e88141"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classicu_1_1RuleBasedBreakIterator.html#a976126b3070d56d23a67184b41e88141">More...</a><br /></td></tr>
<tr class="separator:a976126b3070d56d23a67184b41e88141"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaaa98a62891cc8b6ef72c913a67a7b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#acaaa98a62891cc8b6ef72c913a67a7b6">RuleBasedBreakIterator</a> (const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;that)</td></tr>
<tr class="memdesc:acaaa98a62891cc8b6ef72c913a67a7b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classicu_1_1RuleBasedBreakIterator.html#acaaa98a62891cc8b6ef72c913a67a7b6">More...</a><br /></td></tr>
<tr class="separator:acaaa98a62891cc8b6ef72c913a67a7b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34393c8272153f00eab8b3ba5dd8263"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#af34393c8272153f00eab8b3ba5dd8263">RuleBasedBreakIterator</a> (const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;rules, <a class="el" href="structUParseError.html">UParseError</a> &amp;parseError, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:af34393c8272153f00eab8b3ba5dd8263"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of rules supplied as a string.  <a href="classicu_1_1RuleBasedBreakIterator.html#af34393c8272153f00eab8b3ba5dd8263">More...</a><br /></td></tr>
<tr class="separator:af34393c8272153f00eab8b3ba5dd8263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe74962355b2cf5cf699ab2c98d0852d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afe74962355b2cf5cf699ab2c98d0852d">RuleBasedBreakIterator</a> (const uint8_t *compiledRules, uint32_t ruleLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:afe74962355b2cf5cf699ab2c98d0852d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of precompiled binary rules.  <a href="classicu_1_1RuleBasedBreakIterator.html#afe74962355b2cf5cf699ab2c98d0852d">More...</a><br /></td></tr>
<tr class="separator:afe74962355b2cf5cf699ab2c98d0852d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde71d5c99670342c9db9e67b7475822"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#adde71d5c99670342c9db9e67b7475822">RuleBasedBreakIterator</a> (<a class="el" href="udata_8h.html#acffec83601fda29bd4750b24f829f56b">UDataMemory</a> *image, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:adde71d5c99670342c9db9e67b7475822"><td class="mdescLeft">&#160;</td><td class="mdescRight">This constructor uses the udata interface to create a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> whose internal tables live in a memory-mapped file.  <a href="classicu_1_1RuleBasedBreakIterator.html#adde71d5c99670342c9db9e67b7475822">More...</a><br /></td></tr>
<tr class="separator:adde71d5c99670342c9db9e67b7475822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af171cfdce6f264ae7f7f18078248a08b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#af171cfdce6f264ae7f7f18078248a08b">~RuleBasedBreakIterator</a> ()</td></tr>
<tr class="memdesc:af171cfdce6f264ae7f7f18078248a08b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classicu_1_1RuleBasedBreakIterator.html#af171cfdce6f264ae7f7f18078248a08b">More...</a><br /></td></tr>
<tr class="separator:af171cfdce6f264ae7f7f18078248a08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5e205b2cc4e2f0b1ea66f0c3b52293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a3e5e205b2cc4e2f0b1ea66f0c3b52293">operator=</a> (const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;that)</td></tr>
<tr class="memdesc:a3e5e205b2cc4e2f0b1ea66f0c3b52293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classicu_1_1RuleBasedBreakIterator.html#a3e5e205b2cc4e2f0b1ea66f0c3b52293">More...</a><br /></td></tr>
<tr class="separator:a3e5e205b2cc4e2f0b1ea66f0c3b52293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266522728258632298ee1bb97922a439"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a266522728258632298ee1bb97922a439">operator==</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;that) const override</td></tr>
<tr class="memdesc:a266522728258632298ee1bb97922a439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="classicu_1_1RuleBasedBreakIterator.html#a266522728258632298ee1bb97922a439">More...</a><br /></td></tr>
<tr class="separator:a266522728258632298ee1bb97922a439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866de4f5f4b7ba0a40c75177a17fdeb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a866de4f5f4b7ba0a40c75177a17fdeb0">operator!=</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;that) const</td></tr>
<tr class="memdesc:a866de4f5f4b7ba0a40c75177a17fdeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not-equal operator.  <a href="classicu_1_1RuleBasedBreakIterator.html#a866de4f5f4b7ba0a40c75177a17fdeb0">More...</a><br /></td></tr>
<tr class="separator:a866de4f5f4b7ba0a40c75177a17fdeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a87322521a900cbe20d7eb726f73d6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a86a87322521a900cbe20d7eb726f73d6">clone</a> () const override</td></tr>
<tr class="memdesc:a86a87322521a900cbe20d7eb726f73d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a newly-constructed <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> with the same behavior, and iterating over the same text, as this one.  <a href="classicu_1_1RuleBasedBreakIterator.html#a86a87322521a900cbe20d7eb726f73d6">More...</a><br /></td></tr>
<tr class="separator:a86a87322521a900cbe20d7eb726f73d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2180f9e814fae42b116b3506484629e3"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a2180f9e814fae42b116b3506484629e3">hashCode</a> () const</td></tr>
<tr class="memdesc:a2180f9e814fae42b116b3506484629e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a hash code for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a>.  <a href="classicu_1_1RuleBasedBreakIterator.html#a2180f9e814fae42b116b3506484629e3">More...</a><br /></td></tr>
<tr class="separator:a2180f9e814fae42b116b3506484629e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec794d3a57ef4147c314cf76dae4e0a0"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aec794d3a57ef4147c314cf76dae4e0a0">getRules</a> () const</td></tr>
<tr class="memdesc:aec794d3a57ef4147c314cf76dae4e0a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the description used to create this iterator.  <a href="classicu_1_1RuleBasedBreakIterator.html#aec794d3a57ef4147c314cf76dae4e0a0">More...</a><br /></td></tr>
<tr class="separator:aec794d3a57ef4147c314cf76dae4e0a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb714b61ea0aeebd5d3d82ce8bbb9f6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aebb714b61ea0aeebd5d3d82ce8bbb9f6">getText</a> () const override</td></tr>
<tr class="separator:aebb714b61ea0aeebd5d3d82ce8bbb9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada835f178dd68b53aef4278b168fa374"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ada835f178dd68b53aef4278b168fa374">getUText</a> (<a class="el" href="structUText.html">UText</a> *fillIn, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const override</td></tr>
<tr class="memdesc:ada835f178dd68b53aef4278b168fa374"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a <a class="el" href="structUText.html" title="UText struct.">UText</a> for the text being analyzed.  <a href="classicu_1_1RuleBasedBreakIterator.html#ada835f178dd68b53aef4278b168fa374">More...</a><br /></td></tr>
<tr class="separator:ada835f178dd68b53aef4278b168fa374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1e08071bb1765ffa23b0e83a93a878"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ada1e08071bb1765ffa23b0e83a93a878">adoptText</a> (<a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> *newText) override</td></tr>
<tr class="memdesc:ada1e08071bb1765ffa23b0e83a93a878"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator to analyze a new piece of text.  <a href="classicu_1_1RuleBasedBreakIterator.html#ada1e08071bb1765ffa23b0e83a93a878">More...</a><br /></td></tr>
<tr class="separator:ada1e08071bb1765ffa23b0e83a93a878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7c9dcc8dfc94f197006e7c50e51f78"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#afe7c9dcc8dfc94f197006e7c50e51f78">setText</a> (const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;newText) override</td></tr>
<tr class="memdesc:afe7c9dcc8dfc94f197006e7c50e51f78"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator to analyze a new piece of text.  <a href="classicu_1_1RuleBasedBreakIterator.html#afe7c9dcc8dfc94f197006e7c50e51f78">More...</a><br /></td></tr>
<tr class="separator:afe7c9dcc8dfc94f197006e7c50e51f78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfde1ea8cad6f09f6cc1cf186c73572"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aecfde1ea8cad6f09f6cc1cf186c73572">setText</a> (<a class="el" href="structUText.html">UText</a> *text, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) override</td></tr>
<tr class="memdesc:aecfde1ea8cad6f09f6cc1cf186c73572"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct.">UText</a>.  <a href="classicu_1_1RuleBasedBreakIterator.html#aecfde1ea8cad6f09f6cc1cf186c73572">More...</a><br /></td></tr>
<tr class="separator:aecfde1ea8cad6f09f6cc1cf186c73572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cd000b9363232d516589e55c28ced01"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a0cd000b9363232d516589e55c28ced01">first</a> () override</td></tr>
<tr class="memdesc:a0cd000b9363232d516589e55c28ced01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current iteration position to the beginning of the text, position zero.  <a href="classicu_1_1RuleBasedBreakIterator.html#a0cd000b9363232d516589e55c28ced01">More...</a><br /></td></tr>
<tr class="separator:a0cd000b9363232d516589e55c28ced01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08265d0a04d40733a6277c826e0c7e4"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ac08265d0a04d40733a6277c826e0c7e4">last</a> () override</td></tr>
<tr class="memdesc:ac08265d0a04d40733a6277c826e0c7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the current iteration position to the end of the text.  <a href="classicu_1_1RuleBasedBreakIterator.html#ac08265d0a04d40733a6277c826e0c7e4">More...</a><br /></td></tr>
<tr class="separator:ac08265d0a04d40733a6277c826e0c7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f0ee8fad7ea12a613b6bdb3cad52b9"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ae7f0ee8fad7ea12a613b6bdb3cad52b9">next</a> (int32_t n) override</td></tr>
<tr class="memdesc:ae7f0ee8fad7ea12a613b6bdb3cad52b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the iterator either forward or backward the specified number of steps.  <a href="classicu_1_1RuleBasedBreakIterator.html#ae7f0ee8fad7ea12a613b6bdb3cad52b9">More...</a><br /></td></tr>
<tr class="separator:ae7f0ee8fad7ea12a613b6bdb3cad52b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab200e2a04f6db29817afcf947d1ab1"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a5ab200e2a04f6db29817afcf947d1ab1">next</a> () override</td></tr>
<tr class="memdesc:a5ab200e2a04f6db29817afcf947d1ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advances the iterator to the next boundary position.  <a href="classicu_1_1RuleBasedBreakIterator.html#a5ab200e2a04f6db29817afcf947d1ab1">More...</a><br /></td></tr>
<tr class="separator:a5ab200e2a04f6db29817afcf947d1ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc3013c5ed9e4d2e9b44b25402464a7b"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#adc3013c5ed9e4d2e9b44b25402464a7b">previous</a> () override</td></tr>
<tr class="memdesc:adc3013c5ed9e4d2e9b44b25402464a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves the iterator backwards, to the last boundary preceding this one.  <a href="classicu_1_1RuleBasedBreakIterator.html#adc3013c5ed9e4d2e9b44b25402464a7b">More...</a><br /></td></tr>
<tr class="separator:adc3013c5ed9e4d2e9b44b25402464a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cfad4f533e1b9cb58b81c13af08ab7"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a23cfad4f533e1b9cb58b81c13af08ab7">following</a> (int32_t offset) override</td></tr>
<tr class="memdesc:a23cfad4f533e1b9cb58b81c13af08ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the iterator to refer to the first boundary position following the specified position.  <a href="classicu_1_1RuleBasedBreakIterator.html#a23cfad4f533e1b9cb58b81c13af08ab7">More...</a><br /></td></tr>
<tr class="separator:a23cfad4f533e1b9cb58b81c13af08ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca8f68a88bc3d3d9f9d34606874671b5"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aca8f68a88bc3d3d9f9d34606874671b5">preceding</a> (int32_t offset) override</td></tr>
<tr class="memdesc:aca8f68a88bc3d3d9f9d34606874671b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the iterator to refer to the last boundary position before the specified position.  <a href="classicu_1_1RuleBasedBreakIterator.html#aca8f68a88bc3d3d9f9d34606874671b5">More...</a><br /></td></tr>
<tr class="separator:aca8f68a88bc3d3d9f9d34606874671b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d306ff87478dcdeae98593fe042f9e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a85d306ff87478dcdeae98593fe042f9e">isBoundary</a> (int32_t offset) override</td></tr>
<tr class="memdesc:a85d306ff87478dcdeae98593fe042f9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified position is a boundary position.  <a href="classicu_1_1RuleBasedBreakIterator.html#a85d306ff87478dcdeae98593fe042f9e">More...</a><br /></td></tr>
<tr class="separator:a85d306ff87478dcdeae98593fe042f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e26e26140e8666bdb409a19c0ccae2f"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a2e26e26140e8666bdb409a19c0ccae2f">current</a> () const override</td></tr>
<tr class="memdesc:a2e26e26140e8666bdb409a19c0ccae2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the current iteration position.  <a href="classicu_1_1RuleBasedBreakIterator.html#a2e26e26140e8666bdb409a19c0ccae2f">More...</a><br /></td></tr>
<tr class="separator:a2e26e26140e8666bdb409a19c0ccae2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76c4b778add5db7cbeb25000e218e236"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a76c4b778add5db7cbeb25000e218e236">getRuleStatus</a> () const override</td></tr>
<tr class="memdesc:a76c4b778add5db7cbeb25000e218e236"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status tag from the break rule that determined the boundary at the current iteration position.  <a href="classicu_1_1RuleBasedBreakIterator.html#a76c4b778add5db7cbeb25000e218e236">More...</a><br /></td></tr>
<tr class="separator:a76c4b778add5db7cbeb25000e218e236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8e36f3ff39a261f0ca69de84c8ee07"><td class="memItemLeft" align="right" valign="top">virtual int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a9c8e36f3ff39a261f0ca69de84c8ee07">getRuleStatusVec</a> (int32_t *fillInVec, int32_t capacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) override</td></tr>
<tr class="memdesc:a9c8e36f3ff39a261f0ca69de84c8ee07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the status (tag) values from the break rule(s) that determined the boundary at the current iteration position.  <a href="classicu_1_1RuleBasedBreakIterator.html#a9c8e36f3ff39a261f0ca69de84c8ee07">More...</a><br /></td></tr>
<tr class="separator:a9c8e36f3ff39a261f0ca69de84c8ee07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9f97b3d259e4017f6996a19492ce15"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a4a9f97b3d259e4017f6996a19492ce15">getDynamicClassID</a> () const override</td></tr>
<tr class="memdesc:a4a9f97b3d259e4017f6996a19492ce15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a unique class ID POLYMORPHICALLY.  <a href="classicu_1_1RuleBasedBreakIterator.html#a4a9f97b3d259e4017f6996a19492ce15">More...</a><br /></td></tr>
<tr class="separator:a4a9f97b3d259e4017f6996a19492ce15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecf44a6eb5b5a712113d47de1511c62"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a7ecf44a6eb5b5a712113d47de1511c62">createBufferClone</a> (void *stackBuffer, int32_t &amp;BufferSize, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) override</td></tr>
<tr class="memdesc:a7ecf44a6eb5b5a712113d47de1511c62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deprecated functionality.  <a href="classicu_1_1RuleBasedBreakIterator.html#a7ecf44a6eb5b5a712113d47de1511c62">More...</a><br /></td></tr>
<tr class="separator:a7ecf44a6eb5b5a712113d47de1511c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb4fa90807c2e89ca7514db3a0e4f31"><td class="memItemLeft" align="right" valign="top">virtual const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aaeb4fa90807c2e89ca7514db3a0e4f31">getBinaryRules</a> (uint32_t &amp;length)</td></tr>
<tr class="memdesc:aaeb4fa90807c2e89ca7514db3a0e4f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the binary form of compiled break rules, which can then be used to create a new break iterator at some time in the future.  <a href="classicu_1_1RuleBasedBreakIterator.html#aaeb4fa90807c2e89ca7514db3a0e4f31">More...</a><br /></td></tr>
<tr class="separator:aaeb4fa90807c2e89ca7514db3a0e4f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2b3c4cd181c4dad7791282c905e981"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a3b2b3c4cd181c4dad7791282c905e981">refreshInputText</a> (<a class="el" href="structUText.html">UText</a> *input, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) override</td></tr>
<tr class="memdesc:a3b2b3c4cd181c4dad7791282c905e981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the subject text string upon which the break iterator is operating without changing any other aspect of the matching state.  <a href="classicu_1_1RuleBasedBreakIterator.html#a3b2b3c4cd181c4dad7791282c905e981">More...</a><br /></td></tr>
<tr class="separator:a3b2b3c4cd181c4dad7791282c905e981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88705f0fdbdaa71ec29a6204e09d4668"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a88705f0fdbdaa71ec29a6204e09d4668">dumpCache</a> ()</td></tr>
<tr class="memdesc:a88705f0fdbdaa71ec29a6204e09d4668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging function only.  <a href="classicu_1_1RuleBasedBreakIterator.html#a88705f0fdbdaa71ec29a6204e09d4668">More...</a><br /></td></tr>
<tr class="separator:a88705f0fdbdaa71ec29a6204e09d4668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581a3d53f5699e16a408cc6b85d30a58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a581a3d53f5699e16a408cc6b85d30a58">dumpTables</a> ()</td></tr>
<tr class="memdesc:a581a3d53f5699e16a408cc6b85d30a58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Debugging function only.  <a href="classicu_1_1RuleBasedBreakIterator.html#a581a3d53f5699e16a408cc6b85d30a58">More...</a><br /></td></tr>
<tr class="separator:a581a3d53f5699e16a408cc6b85d30a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a974704cc225b0128d3a61734b2354d9e inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a974704cc225b0128d3a61734b2354d9e">~BreakIterator</a> ()</td></tr>
<tr class="memdesc:a974704cc225b0128d3a61734b2354d9e inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">destructor  <a href="classicu_1_1BreakIterator.html#a974704cc225b0128d3a61734b2354d9e">More...</a><br /></td></tr>
<tr class="separator:a974704cc225b0128d3a61734b2354d9e inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f24d8977c298a8259ae54402a286c61 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a4f24d8977c298a8259ae54402a286c61">operator!=</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;rhs) const</td></tr>
<tr class="memdesc:a4f24d8977c298a8259ae54402a286c61 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the complement of the result of operator==.  <a href="classicu_1_1BreakIterator.html#a4f24d8977c298a8259ae54402a286c61">More...</a><br /></td></tr>
<tr class="separator:a4f24d8977c298a8259ae54402a286c61 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab3efbfd6b3ae9190914aca4cac3897 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#abab3efbfd6b3ae9190914aca4cac3897">isBufferClone</a> ()</td></tr>
<tr class="memdesc:abab3efbfd6b3ae9190914aca4cac3897 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> was created in user memory by <a class="el" href="classicu_1_1BreakIterator.html#a8bb5838936c784c3e004f94e3938a2cc" title="Deprecated functionality.">createBufferClone()</a>, and thus should not be deleted.  <a href="classicu_1_1BreakIterator.html#abab3efbfd6b3ae9190914aca4cac3897">More...</a><br /></td></tr>
<tr class="separator:abab3efbfd6b3ae9190914aca4cac3897 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153e9740dc3b742ca40ec1a8c5b8ea9e inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="classicu_1_1Locale.html">Locale</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a153e9740dc3b742ca40ec1a8c5b8ea9e">getLocale</a> (<a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a> type, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const</td></tr>
<tr class="memdesc:a153e9740dc3b742ca40ec1a8c5b8ea9e inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the locale for this break iterator.  <a href="classicu_1_1BreakIterator.html#a153e9740dc3b742ca40ec1a8c5b8ea9e">More...</a><br /></td></tr>
<tr class="separator:a153e9740dc3b742ca40ec1a8c5b8ea9e inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a23d1cf037e21213ff62755e0350346 inherit pub_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a1a23d1cf037e21213ff62755e0350346">getLocaleID</a> (<a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a> type, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status) const</td></tr>
<tr class="memdesc:a1a23d1cf037e21213ff62755e0350346 inherit pub_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locale for this break iterator object.  <a href="classicu_1_1BreakIterator.html#a1a23d1cf037e21213ff62755e0350346">More...</a><br /></td></tr>
<tr class="separator:a1a23d1cf037e21213ff62755e0350346 inherit pub_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classicu_1_1UObject"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classicu_1_1UObject')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classicu_1_1UObject.html">icu::UObject</a></td></tr>
<tr class="memitem:af10026497704f510d3d1f2eff50acb18 inherit pub_methods_classicu_1_1UObject"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1UObject.html#af10026497704f510d3d1f2eff50acb18">~UObject</a> ()</td></tr>
<tr class="memdesc:af10026497704f510d3d1f2eff50acb18 inherit pub_methods_classicu_1_1UObject"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classicu_1_1UObject.html#af10026497704f510d3d1f2eff50acb18">More...</a><br /></td></tr>
<tr class="separator:af10026497704f510d3d1f2eff50acb18 inherit pub_methods_classicu_1_1UObject"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a2eb0f654542370e06be16667ddf57f83"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a2eb0f654542370e06be16667ddf57f83">getStaticClassID</a> ()</td></tr>
<tr class="memdesc:a2eb0f654542370e06be16667ddf57f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the class ID for this class.  <a href="classicu_1_1RuleBasedBreakIterator.html#a2eb0f654542370e06be16667ddf57f83">More...</a><br /></td></tr>
<tr class="separator:a2eb0f654542370e06be16667ddf57f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8651c91dea3032e7e0c8ccaab5c888"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a8d8651c91dea3032e7e0c8ccaab5c888">registerExternalBreakEngine</a> (<a class="el" href="classicu_1_1ExternalBreakEngine.html">ExternalBreakEngine</a> *toAdopt, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a8d8651c91dea3032e7e0c8ccaab5c888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new external break engine.  <a href="classicu_1_1RuleBasedBreakIterator.html#a8d8651c91dea3032e7e0c8ccaab5c888">More...</a><br /></td></tr>
<tr class="separator:a8d8651c91dea3032e7e0c8ccaab5c888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a6aa1459cc086397bdb85ccd1bb3c5500 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a6aa1459cc086397bdb85ccd1bb3c5500">createWordInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a6aa1459cc086397bdb85ccd1bb3c5500 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> for word-breaks using the given locale.  <a href="classicu_1_1BreakIterator.html#a6aa1459cc086397bdb85ccd1bb3c5500">More...</a><br /></td></tr>
<tr class="separator:a6aa1459cc086397bdb85ccd1bb3c5500 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae588706df064825f1bccb2a9165169e inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#aae588706df064825f1bccb2a9165169e">createLineInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:aae588706df064825f1bccb2a9165169e inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> for line-breaks using specified locale.  <a href="classicu_1_1BreakIterator.html#aae588706df064825f1bccb2a9165169e">More...</a><br /></td></tr>
<tr class="separator:aae588706df064825f1bccb2a9165169e inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afffc1125b180a61857f698e147b1a668 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#afffc1125b180a61857f698e147b1a668">createCharacterInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:afffc1125b180a61857f698e147b1a668 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> for character-breaks using specified locale Returns an instance of a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> implementing character breaks.  <a href="classicu_1_1BreakIterator.html#afffc1125b180a61857f698e147b1a668">More...</a><br /></td></tr>
<tr class="separator:afffc1125b180a61857f698e147b1a668 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae161880c561882dad879112e15fde42b inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#ae161880c561882dad879112e15fde42b">createSentenceInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:ae161880c561882dad879112e15fde42b inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> for sentence-breaks using specified locale Returns an instance of a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> implementing sentence breaks.  <a href="classicu_1_1BreakIterator.html#ae161880c561882dad879112e15fde42b">More...</a><br /></td></tr>
<tr class="separator:ae161880c561882dad879112e15fde42b inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749bd540aefa78212db180f8dcaaea9c inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a749bd540aefa78212db180f8dcaaea9c">createTitleInstance</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;where, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a749bd540aefa78212db180f8dcaaea9c inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> for title-casing breaks using the specified locale Returns an instance of a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> implementing title breaks.  <a href="classicu_1_1BreakIterator.html#a749bd540aefa78212db180f8dcaaea9c">More...</a><br /></td></tr>
<tr class="separator:a749bd540aefa78212db180f8dcaaea9c inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33a3d6f2f817b83288c4a945ea3fefc inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> const <a class="el" href="classicu_1_1Locale.html">Locale</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#aa33a3d6f2f817b83288c4a945ea3fefc">getAvailableLocales</a> (int32_t &amp;count)</td></tr>
<tr class="memdesc:aa33a3d6f2f817b83288c4a945ea3fefc inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the set of Locales for which TextBoundaries are installed.  <a href="classicu_1_1BreakIterator.html#aa33a3d6f2f817b83288c4a945ea3fefc">More...</a><br /></td></tr>
<tr class="separator:aa33a3d6f2f817b83288c4a945ea3fefc inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb35a87e148b3837374f1216572eb967 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#afb35a87e148b3837374f1216572eb967">getDisplayName</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;objectLocale, const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;displayLocale, <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;name)</td></tr>
<tr class="memdesc:afb35a87e148b3837374f1216572eb967 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the object for the desired <a class="el" href="classicu_1_1Locale.html" title="A Locale object represents a specific geographical, political, or cultural region.">Locale</a>, in the desired language.  <a href="classicu_1_1BreakIterator.html#afb35a87e148b3837374f1216572eb967">More...</a><br /></td></tr>
<tr class="separator:afb35a87e148b3837374f1216572eb967 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd29143732d484c997913c0f66c42c1f inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#acd29143732d484c997913c0f66c42c1f">getDisplayName</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;objectLocale, <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;name)</td></tr>
<tr class="memdesc:acd29143732d484c997913c0f66c42c1f inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get name of the object for the desired <a class="el" href="classicu_1_1Locale.html" title="A Locale object represents a specific geographical, political, or cultural region.">Locale</a>, in the language of the default locale.  <a href="classicu_1_1BreakIterator.html#acd29143732d484c997913c0f66c42c1f">More...</a><br /></td></tr>
<tr class="separator:acd29143732d484c997913c0f66c42c1f inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9e0c5fad7551d191615be5184087624 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="umisc_8h.html#ab5905d79ed3b979840cee1d5fd48b4fb">URegistryKey</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#ab9e0c5fad7551d191615be5184087624">registerInstance</a> (<a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> *toAdopt, const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;locale, <a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a> kind, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:ab9e0c5fad7551d191615be5184087624 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a new break iterator of the indicated kind, to use in the given locale.  <a href="classicu_1_1BreakIterator.html#ab9e0c5fad7551d191615be5184087624">More...</a><br /></td></tr>
<tr class="separator:ab9e0c5fad7551d191615be5184087624 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15349f991d1031068ed4f3ddcad97f6a inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a15349f991d1031068ed4f3ddcad97f6a">unregister</a> (<a class="el" href="umisc_8h.html#ab5905d79ed3b979840cee1d5fd48b4fb">URegistryKey</a> key, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;status)</td></tr>
<tr class="memdesc:a15349f991d1031068ed4f3ddcad97f6a inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregister a previously-registered <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> using the key returned from the register call.  <a href="classicu_1_1BreakIterator.html#a15349f991d1031068ed4f3ddcad97f6a">More...</a><br /></td></tr>
<tr class="separator:a15349f991d1031068ed4f3ddcad97f6a inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe26c0805c1bfb2a10f81844a66da35 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="classicu_1_1StringEnumeration.html">StringEnumeration</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a1fe26c0805c1bfb2a10f81844a66da35">getAvailableLocales</a> ()</td></tr>
<tr class="memdesc:a1fe26c0805c1bfb2a10f81844a66da35 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a <a class="el" href="classicu_1_1StringEnumeration.html" title="Base class for &#39;pure&#39; C++ implementations of uenum api.">StringEnumeration</a> over the locales available at the time of the call, including registered locales.  <a href="classicu_1_1BreakIterator.html#a1fe26c0805c1bfb2a10f81844a66da35">More...</a><br /></td></tr>
<tr class="separator:a1fe26c0805c1bfb2a10f81844a66da35 inherit pub_static_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a2ad6052587787523f902a4503693dbe6"><td class="memItemLeft" align="right" valign="top">RBBIDataWrapper *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a2ad6052587787523f902a4503693dbe6">fData</a> = nullptr</td></tr>
<tr class="memdesc:a2ad6052587787523f902a4503693dbe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The rule data for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> instance.  <a href="classicu_1_1RuleBasedBreakIterator.html#a2ad6052587787523f902a4503693dbe6">More...</a><br /></td></tr>
<tr class="separator:a2ad6052587787523f902a4503693dbe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a17ce03f12f5fa8688859b25e2bf60938"><td class="memItemLeft" align="right" valign="top"><a id="a17ce03f12f5fa8688859b25e2bf60938"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>RBBIRuleBuilder</b></td></tr>
<tr class="separator:a17ce03f12f5fa8688859b25e2bf60938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fbb7407696454879cf016b20a0380f0"><td class="memItemLeft" align="right" valign="top"><a id="a5fbb7407696454879cf016b20a0380f0"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>BreakIterator</b></td></tr>
<tr class="separator:a5fbb7407696454879cf016b20a0380f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a0174c4360d0cb8d21ecc3e4cea71d035 inherit pub_types_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classicu_1_1BreakIterator.html#a0174c4360d0cb8d21ecc3e4cea71d035af9daa8410e7f8dc1631f8fc6a8a8115c">DONE</a> = static_cast&lt;int32_t&gt;(-1)
 }</td></tr>
<tr class="separator:a0174c4360d0cb8d21ecc3e4cea71d035 inherit pub_types_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classicu_1_1BreakIterator"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classicu_1_1BreakIterator')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classicu_1_1BreakIterator.html">icu::BreakIterator</a></td></tr>
<tr class="memitem:a5901b6506fa5eb097c5528f409ff6b84 inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#a5901b6506fa5eb097c5528f409ff6b84">BreakIterator</a> ()</td></tr>
<tr class="separator:a5901b6506fa5eb097c5528f409ff6b84 inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac636bfc4d77f9883251ebe4549354703 inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#ac636bfc4d77f9883251ebe4549354703">BreakIterator</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;other)</td></tr>
<tr class="separator:ac636bfc4d77f9883251ebe4549354703 inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0186a66dae7388f8c1778a56b9475b inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#aba0186a66dae7388f8c1778a56b9475b">BreakIterator</a> (const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;valid, const <a class="el" href="classicu_1_1Locale.html">Locale</a> &amp;actual)</td></tr>
<tr class="separator:aba0186a66dae7388f8c1778a56b9475b inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa89e086b273875b2d21ce72760763c1 inherit pro_methods_classicu_1_1BreakIterator"><td class="memItemLeft" align="right" valign="top"><a class="el" href="utypes_8h.html#a559955ec3bc692657c5d8b1c6de8e334">U_COMMON_API</a> <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classicu_1_1BreakIterator.html#aaa89e086b273875b2d21ce72760763c1">operator=</a> (const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;other)</td></tr>
<tr class="separator:aaa89e086b273875b2d21ce72760763c1 inherit pro_methods_classicu_1_1BreakIterator"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A subclass of <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> whose behavior is specified using a list of rules. </p>
<p>Instances of this class are most commonly created by the factory methods of <a class="el" href="classicu_1_1BreakIterator.html#a6aa1459cc086397bdb85ccd1bb3c5500" title="Create BreakIterator for word-breaks using the given locale.">BreakIterator::createWordInstance()</a>, <a class="el" href="classicu_1_1BreakIterator.html#aae588706df064825f1bccb2a9165169e" title="Create BreakIterator for line-breaks using specified locale.">BreakIterator::createLineInstance()</a>, etc., and then used via the abstract API in class <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a></p>
<p>See the ICU User Guide for information on Break Iterator Rules.</p>
<p>This class is not intended to be subclassed.</p>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00120">120</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a976126b3070d56d23a67184b41e88141"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976126b3070d56d23a67184b41e88141">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>
<p>Creates an empty shell of an iterator, with no rules or text to iterate over. Object can subsequently be assigned to, but is otherwise unusable. </p><dl class="stable"><dt><b><a class="el" href="stable.html#_stable000653">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a id="acaaa98a62891cc8b6ef72c913a67a7b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaaa98a62891cc8b6ef72c913a67a7b6">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<p>Will produce a break iterator with the same behavior, and which iterates over the same text, as the one passed in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> passed to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000654">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="af34393c8272153f00eab8b3ba5dd8263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34393c8272153f00eab8b3ba5dd8263">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUParseError.html">UParseError</a> &amp;&#160;</td>
          <td class="paramname"><em>parseError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of rules supplied as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rules</td><td>The break rules to be used. </td></tr>
    <tr><td class="paramname">parseError</td><td>In the event of a syntax error in the rules, provides the location within the rules of the problem. </td></tr>
    <tr><td class="paramname">status</td><td>Information on any errors encountered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000655">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a id="afe74962355b2cf5cf699ab2c98d0852d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe74962355b2cf5cf699ab2c98d0852d">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>compiledRules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>ruleLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> from a set of precompiled binary rules. </p>
<p>Binary rules are obtained from RulesBasedBreakIterator::getBinaryRules(). Construction of a break iterator in this way is substantially faster than construction from source rules.</p>
<p>Ownership of the storage containing the compiled rules remains with the caller of this function. The compiled rules must not be modified or deleted during the life of the break iterator.</p>
<p>The compiled rules are not compatible across different major versions of ICU. The compiled rules are compatible only between machines with the same byte ordering (little or big endian) and the same base character set family (ASCII or EBCDIC).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aaeb4fa90807c2e89ca7514db3a0e4f31" title="Return the binary form of compiled break rules, which can then be used to create a new break iterator...">getBinaryRules</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compiledRules</td><td>A pointer to the compiled break rules to be used. </td></tr>
    <tr><td class="paramname">ruleLength</td><td>The length of the compiled break rules, in bytes. This corresponds to the length value produced by <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aaeb4fa90807c2e89ca7514db3a0e4f31" title="Return the binary form of compiled break rules, which can then be used to create a new break iterator...">getBinaryRules()</a>. </td></tr>
    <tr><td class="paramname">status</td><td>Information on any errors encountered, including invalid binary rules. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000656">Stable:</a></b></dt><dd>ICU 4.8 </dd></dl>

</div>
</div>
<a id="adde71d5c99670342c9db9e67b7475822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde71d5c99670342c9db9e67b7475822">&#9670;&nbsp;</a></span>RuleBasedBreakIterator() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">icu::RuleBasedBreakIterator::RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="udata_8h.html#acffec83601fda29bd4750b24f829f56b">UDataMemory</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This constructor uses the udata interface to create a <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> whose internal tables live in a memory-mapped file. </p>
<p>"image" is an ICU UDataMemory handle for the pre-compiled break iterator tables. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td>handle to the memory image for the break iterator data. Ownership of the UDataMemory handle passes to the Break Iterator, which will be responsible for closing it when it is no longer needed. </td></tr>
    <tr><td class="paramname">status</td><td>Information on any errors encountered. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="udata_8h.html#a98e818acb2ce5e00b90143b5a626b223" title="Convenience function.">udata_open</a> </dd>
<dd>
<a class="el" href="classicu_1_1RuleBasedBreakIterator.html#aaeb4fa90807c2e89ca7514db3a0e4f31" title="Return the binary form of compiled break rules, which can then be used to create a new break iterator...">getBinaryRules</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000657">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a id="af171cfdce6f264ae7f7f18078248a08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af171cfdce6f264ae7f7f18078248a08b">&#9670;&nbsp;</a></span>~RuleBasedBreakIterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual icu::RuleBasedBreakIterator::~RuleBasedBreakIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000658">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ada1e08071bb1765ffa23b0e83a93a878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1e08071bb1765ffa23b0e83a93a878">&#9670;&nbsp;</a></span>adoptText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void icu::RuleBasedBreakIterator::adoptText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a> *&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the iterator to analyze a new piece of text. </p>
<p>This function resets the current iteration position to the beginning of the text. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>An iterator over the text to analyze. The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> takes ownership of the character iterator. The caller MUST NOT delete it! </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000667">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a0a3de4868b1420a5ec77129adccc9aab">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a86a87322521a900cbe20d7eb726f73d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a87322521a900cbe20d7eb726f73d6">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a>* icu::RuleBasedBreakIterator::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a newly-constructed <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> with the same behavior, and iterating over the same text, as this one. </p>
<p>Differs from the copy constructor in that it is polymorphic, and will correctly clone (copy) a derived class. <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a86a87322521a900cbe20d7eb726f73d6" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> is thread safe. Multiple threads may simultaneously clone the same source break iterator. </p><dl class="section return"><dt>Returns</dt><dd>a newly-constructed <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000662">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a91377b4643772dbc295aabb026250176">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a7ecf44a6eb5b5a712113d47de1511c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecf44a6eb5b5a712113d47de1511c62">&#9670;&nbsp;</a></span>createBufferClone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a>* icu::RuleBasedBreakIterator::createBufferClone </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t &amp;&#160;</td>
          <td class="paramname"><em>BufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deprecated functionality. </p>
<p>Use <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a86a87322521a900cbe20d7eb726f73d6" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> instead.</p>
<p>Create a clone (copy) of this break iterator in memory provided by the caller. The idea is to increase performance by avoiding a storage allocation. Use of this function is NOT RECOMMENDED. Performance gains are minimal, and correct buffer management is tricky. Use <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a86a87322521a900cbe20d7eb726f73d6" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stackBuffer</td><td>The pointer to the memory into which the cloned object should be placed. If nullptr, allocate heap memory for the cloned object. </td></tr>
    <tr><td class="paramname">BufferSize</td><td>The size of the buffer. If zero, return the required buffer size, but do not clone the object. If the size was too small (but not zero), allocate heap storage for the cloned object.</td></tr>
    <tr><td class="paramname">status</td><td>Error status. U_SAFECLONE_ALLOCATED_WARNING will be returned if the provided buffer was too small, and the clone was therefore put on the heap.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the clone object. This may differ from the stackBuffer address if the byte alignment of the stack buffer was not suitable or if the stackBuffer was too small to hold the clone. </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>ICU 52. Use <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a86a87322521a900cbe20d7eb726f73d6" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> instead. </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a8bb5838936c784c3e004f94e3938a2cc">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a2e26e26140e8666bdb409a19c0ccae2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e26e26140e8666bdb409a19c0ccae2f">&#9670;&nbsp;</a></span>current()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the current iteration position. </p>
<p>Note that UBRK_DONE is never returned from this function; if iteration has run to the end of a string, <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a2e26e26140e8666bdb409a19c0ccae2f" title="Returns the current iteration position.">current()</a> will return the length of the string while <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a5ab200e2a04f6db29817afcf947d1ab1" title="Advances the iterator to the next boundary position.">next()</a> will return UBRK_DONE). </p><dl class="section return"><dt>Returns</dt><dd>The current iteration position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000678">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a19958b5b92e8512491dad3185d82d96a">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a88705f0fdbdaa71ec29a6204e09d4668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88705f0fdbdaa71ec29a6204e09d4668">&#9670;&nbsp;</a></span>dumpCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icu::RuleBasedBreakIterator::dumpCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging function only. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000106">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a id="a581a3d53f5699e16a408cc6b85d30a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581a3d53f5699e16a408cc6b85d30a58">&#9670;&nbsp;</a></span>dumpTables()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void icu::RuleBasedBreakIterator::dumpTables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Debugging function only. </p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000107">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

</div>
</div>
<a id="a0cd000b9363232d516589e55c28ced01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cd000b9363232d516589e55c28ced01">&#9670;&nbsp;</a></span>first()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::first </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current iteration position to the beginning of the text, position zero. </p>
<dl class="section return"><dt>Returns</dt><dd>The offset of the beginning of the text, zero. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000670">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#aa2325d663a7f3afffc15e0937a4d1724">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a23cfad4f533e1b9cb58b81c13af08ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cfad4f533e1b9cb58b81c13af08ab7">&#9670;&nbsp;</a></span>following()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::following </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the iterator to refer to the first boundary position following the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The position from which to begin searching for a break position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the first break after the current position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000675">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a157dbbc79eb03a3e8e28576b2c2991c3">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="aaeb4fa90807c2e89ca7514db3a0e4f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb4fa90807c2e89ca7514db3a0e4f31">&#9670;&nbsp;</a></span>getBinaryRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const uint8_t* icu::RuleBasedBreakIterator::getBinaryRules </td>
          <td>(</td>
          <td class="paramtype">uint32_t &amp;&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the binary form of compiled break rules, which can then be used to create a new break iterator at some time in the future. </p>
<p>Creating a break iterator from pre-compiled rules is much faster than building one from the source form of the break rules.</p>
<p>The binary data can only be used with the same version of ICU and on the same platform type (processor endian-ness)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Returns the length of the binary data. (Out parameter.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the binary (compiled) rule data. The storage belongs to the RulesBasedBreakIterator object, not the caller, and must not be modified or deleted. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000683">Stable:</a></b></dt><dd>ICU 4.8 </dd></dl>

</div>
</div>
<a id="a4a9f97b3d259e4017f6996a19492ce15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9f97b3d259e4017f6996a19492ce15">&#9670;&nbsp;</a></span>getDynamicClassID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a> icu::RuleBasedBreakIterator::getDynamicClassID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a unique class ID POLYMORPHICALLY. </p>
<p>Pure virtual override. This method is to implement a simple version of RTTI, since not all C++ compilers support genuine RTTI. Polymorphic <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a266522728258632298ee1bb97922a439" title="Equality operator.">operator==()</a> and <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a86a87322521a900cbe20d7eb726f73d6" title="Returns a newly-constructed RuleBasedBreakIterator with the same behavior, and iterating over the sam...">clone()</a> methods call this method.</p>
<dl class="section return"><dt>Returns</dt><dd>The class ID for this object. All objects of a given class have the same class ID. Objects of other classes have different class IDs. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000681">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#ae180ee7a2d78f164321145e3a571b995">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="aec794d3a57ef4147c314cf76dae4e0a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec794d3a57ef4147c314cf76dae4e0a0">&#9670;&nbsp;</a></span>getRules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a>&amp; icu::RuleBasedBreakIterator::getRules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the description used to create this iterator. </p>
<dl class="section return"><dt>Returns</dt><dd>the description used to create this iterator </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000664">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a76c4b778add5db7cbeb25000e218e236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76c4b778add5db7cbeb25000e218e236">&#9670;&nbsp;</a></span>getRuleStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::getRuleStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the status tag from the break rule that determined the boundary at the current iteration position. </p>
<p>For break rules that do not specify a status, a default value of 0 is returned. If more than one break rule would cause a boundary to be located at some position in the text, the numerically largest of the applicable status values is returned. </p>
<p>Of the standard types of ICU break iterators, only word break and line break provide status values. The values are defined in the header file <a class="el" href="ubrk_8h.html" title="C API: BreakIterator.">ubrk.h</a>. For Word breaks, the status allows distinguishing between words that contain alphabetic letters, "words" that appear to be numbers, punctuation and spaces, words containing ideographic characters, and more. For Line Break, the status distinguishes between hard (mandatory) breaks and soft (potential) break positions. </p>
<p><code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a76c4b778add5db7cbeb25000e218e236" title="Return the status tag from the break rule that determined the boundary at the current iteration posit...">getRuleStatus()</a></code> can be called after obtaining a boundary position from <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a5ab200e2a04f6db29817afcf947d1ab1" title="Advances the iterator to the next boundary position.">next()</a></code>, <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#adc3013c5ed9e4d2e9b44b25402464a7b" title="Moves the iterator backwards, to the last boundary preceding this one.">previous()</a></code>, or any other break iterator functions that returns a boundary position. </p>
<p>Note that <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a76c4b778add5db7cbeb25000e218e236" title="Return the status tag from the break rule that determined the boundary at the current iteration posit...">getRuleStatus()</a></code> returns the value corresponding to <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a2e26e26140e8666bdb409a19c0ccae2f" title="Returns the current iteration position.">current()</a></code> index even after <code><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a5ab200e2a04f6db29817afcf947d1ab1" title="Advances the iterator to the next boundary position.">next()</a></code> has returned DONE. </p>
<p>When creating custom break rules, one is free to define whatever status values may be convenient for the application. </p>
<dl class="section return"><dt>Returns</dt><dd>the status from the break rule that determined the boundary at the current iteration position.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#ad998235a2dd88fbcf5770d5126155fac" title="Enum constants for the word break tags returned by getRuleStatus().">UWordBreak</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000679">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

<p>Reimplemented from <a class="el" href="classicu_1_1BreakIterator.html#a2f94f50a23a2e3c23c385661bf6ac38e">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a9c8e36f3ff39a261f0ca69de84c8ee07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8e36f3ff39a261f0ca69de84c8ee07">&#9670;&nbsp;</a></span>getRuleStatusVec()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::getRuleStatusVec </td>
          <td>(</td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>fillInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the status (tag) values from the break rule(s) that determined the boundary at the current iteration position. </p>
<p>The returned status value(s) are stored into an array provided by the caller. The values are stored in sorted (ascending) order. If the capacity of the output array is insufficient to hold the data, the output will be truncated to the available length, and a U_BUFFER_OVERFLOW_ERROR will be signaled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillInVec</td><td>an array to be filled in with the status values. </td></tr>
    <tr><td class="paramname">capacity</td><td>the length of the supplied vector. A length of zero causes the function to return the number of status values, in the normal way, without attempting to store any values. </td></tr>
    <tr><td class="paramname">status</td><td>receives error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of rule status values from the rules that determined the boundary at the current iteration position. In the event of a U_BUFFER_OVERFLOW_ERROR, the return value is the total number of status values that were available, not the reduced number that were actually returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a76c4b778add5db7cbeb25000e218e236" title="Return the status tag from the break rule that determined the boundary at the current iteration posit...">getRuleStatus</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000680">Stable:</a></b></dt><dd>ICU 3.0 </dd></dl>

<p>Reimplemented from <a class="el" href="classicu_1_1BreakIterator.html#aadf11abea3b50285afd9add379dbc09b">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a2eb0f654542370e06be16667ddf57f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb0f654542370e06be16667ddf57f83">&#9670;&nbsp;</a></span>getStaticClassID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="uobject_8h.html#a22af10545208a455a6e884008df48e9f">UClassID</a> icu::RuleBasedBreakIterator::getStaticClassID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the class ID for this class. </p>
<p>This is useful only for comparing to a return value from <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a4a9f97b3d259e4017f6996a19492ce15" title="Returns a unique class ID POLYMORPHICALLY.">getDynamicClassID()</a>. For example: </p><pre class="fragment"> Base* polymorphic_pointer = createPolymorphicObject();
 if (polymorphic_pointer-&gt;getDynamicClassID() ==
     Derived::getStaticClassID()) ...
</pre> <dl class="section return"><dt>Returns</dt><dd>The class ID for all objects of this class. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000682">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="aebb714b61ea0aeebd5d3d82ce8bbb9f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb714b61ea0aeebd5d3d82ce8bbb9f6">&#9670;&nbsp;</a></span>getText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1CharacterIterator.html">CharacterIterator</a>&amp; icu::RuleBasedBreakIterator::getText </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classicu_1_1CharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> over the text being analyzed. The returned character iterator is owned by the break iterator, and must not be deleted by the caller. Repeated calls to this function may return the same <a class="el" href="classicu_1_1CharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a>. </p>
<p>The returned character iterator must not be used concurrently with the break iterator. If concurrent operation is needed, clone the returned character iterator first and operate on the clone. </p>
<p>When the break iterator is operating on text supplied via a <a class="el" href="structUText.html" title="UText struct.">UText</a>, this function will fail, returning a <a class="el" href="classicu_1_1CharacterIterator.html" title="Abstract class that defines an API for iteration on text objects.">CharacterIterator</a> containing no text. The function <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#ada835f178dd68b53aef4278b168fa374" title="Get a UText for the text being analyzed.">getUText()</a> provides similar functionality, is reliable, and is more efficient. </p>
<p>TODO: deprecate this function?</p>
<dl class="section return"><dt>Returns</dt><dd>An iterator over the text being analyzed. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000665">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a093d20c39e5fee2117961f79040956f7">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="ada835f178dd68b53aef4278b168fa374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada835f178dd68b53aef4278b168fa374">&#9670;&nbsp;</a></span>getUText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structUText.html">UText</a>* icu::RuleBasedBreakIterator::getUText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>fillIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a <a class="el" href="structUText.html" title="UText struct.">UText</a> for the text being analyzed. </p>
<p>The returned <a class="el" href="structUText.html" title="UText struct.">UText</a> is a shallow clone of the <a class="el" href="structUText.html" title="UText struct.">UText</a> used internally by the break iterator implementation. It can safely be used to access the text without impacting any break iterator operations, but the underlying text itself must not be altered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fillIn</td><td>A <a class="el" href="structUText.html" title="UText struct.">UText</a> to be filled in. If nullptr, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be allocated to hold the result. </td></tr>
    <tr><td class="paramname">status</td><td>receives any error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current <a class="el" href="structUText.html" title="UText struct.">UText</a> for this break iterator. If an input <a class="el" href="structUText.html" title="UText struct.">UText</a> was provided, it will always be returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000666">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a63b2b5705a781e0cd2c0c48b2b3c2a75">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a2180f9e814fae42b116b3506484629e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2180f9e814fae42b116b3506484629e3">&#9670;&nbsp;</a></span>hashCode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::hashCode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute a hash code for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>A hash code </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000663">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a85d306ff87478dcdeae98593fe042f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d306ff87478dcdeae98593fe042f9e">&#9670;&nbsp;</a></span>isBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> icu::RuleBasedBreakIterator::isBoundary </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the specified position is a boundary position. </p>
<p>As a side effect, leaves the iterator pointing to the first boundary position at or after "offset". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>the offset to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if "offset" is a boundary position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000677">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a0c7549d21f1000695ea736593a99114c">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="ac08265d0a04d40733a6277c826e0c7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08265d0a04d40733a6277c826e0c7e4">&#9670;&nbsp;</a></span>last()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::last </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the current iteration position to the end of the text. </p>
<dl class="section return"><dt>Returns</dt><dd>The text's past-the-end offset. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000671">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#ac545f95ac173f7ae750fb67392cbf17c">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a5ab200e2a04f6db29817afcf947d1ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab200e2a04f6db29817afcf947d1ab1">&#9670;&nbsp;</a></span>next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the iterator to the next boundary position. </p>
<dl class="section return"><dt>Returns</dt><dd>The position of the first boundary after this one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000673">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#accab59fabb902b54a5bf632b567f2ad7">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="ae7f0ee8fad7ea12a613b6bdb3cad52b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f0ee8fad7ea12a613b6bdb3cad52b9">&#9670;&nbsp;</a></span>next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::next </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advances the iterator either forward or backward the specified number of steps. </p>
<p>Negative values move backward, and positive values move forward. This is equivalent to repeatedly calling <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#a5ab200e2a04f6db29817afcf947d1ab1" title="Advances the iterator to the next boundary position.">next()</a> or <a class="el" href="classicu_1_1RuleBasedBreakIterator.html#adc3013c5ed9e4d2e9b44b25402464a7b" title="Moves the iterator backwards, to the last boundary preceding this one.">previous()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>The number of steps to move. The sign indicates the direction (negative is backwards, and positive is forwards). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character offset of the boundary position n boundaries away from the current one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000672">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#acfce48e6715119fed4301e530d4f1d1a">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a866de4f5f4b7ba0a40c75177a17fdeb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866de4f5f4b7ba0a40c75177a17fdeb0">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool icu::RuleBasedBreakIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Not-equal operator. </p>
<p>If operator== returns true, this returns false, and vice versa. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> to be compared for inequality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both BreakIterators are not same. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000661">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00361">361</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

<p class="reference">References <a class="el" href="classicu_1_1BreakIterator.html#a65a07e9bd87958c328b0a5f1d057b53a">icu::BreakIterator::operator==()</a>.</p>

</div>
</div>
<a id="a3e5e205b2cc4e2f0b1ea66f0c3b52293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5e205b2cc4e2f0b1ea66f0c3b52293">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a>&amp; icu::RuleBasedBreakIterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>
<p>Sets this iterator to have the same behavior, and iterate over the same text, as the one passed in. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The RuleBasedBreakItertor passed in </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the newly created <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000659">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a266522728258632298ee1bb97922a439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266522728258632298ee1bb97922a439">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool icu::RuleBasedBreakIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1BreakIterator.html">BreakIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>that</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>
<p>Returns true if both BreakIterators are of the same class, have the same behavior, and iterate over the same text. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">that</td><td>The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> to be compared for equality </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if both BreakIterators are of the same class, have the same behavior, and iterate over the same text. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000660">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a65a07e9bd87958c328b0a5f1d057b53a">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="aca8f68a88bc3d3d9f9d34606874671b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8f68a88bc3d3d9f9d34606874671b5">&#9670;&nbsp;</a></span>preceding()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::preceding </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the iterator to refer to the last boundary position before the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The position to begin searching for a break from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The position of the last boundary before the starting position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000676">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a96615b1370f0deac65972613bd2c53fb">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="adc3013c5ed9e4d2e9b44b25402464a7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc3013c5ed9e4d2e9b44b25402464a7b">&#9670;&nbsp;</a></span>previous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int32_t icu::RuleBasedBreakIterator::previous </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Moves the iterator backwards, to the last boundary preceding this one. </p>
<dl class="section return"><dt>Returns</dt><dd>The position of the last boundary position preceding this one. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000674">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a8485ea48350a7a49524766a362c3ab79">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a3b2b3c4cd181c4dad7791282c905e981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2b3c4cd181c4dad7791282c905e981">&#9670;&nbsp;</a></span>refreshInputText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classicu_1_1RuleBasedBreakIterator.html">RuleBasedBreakIterator</a>&amp; icu::RuleBasedBreakIterator::refreshInputText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the subject text string upon which the break iterator is operating without changing any other aspect of the matching state. </p>
<p>The new and previous text strings must have the same content.</p>
<p>This function is intended for use in environments where ICU is operating on strings that may move around in memory. It provides a mechanism for notifying ICU that the string has been relocated, and providing a new <a class="el" href="structUText.html" title="UText struct.">UText</a> to access the string in its new position.</p>
<p>Note that the break iterator implementation never copies the underlying text of a string being processed, but always operates directly on the original text provided by the user. Refreshing simply drops the references to the old text and replaces them with references to the new.</p>
<p>Caution: this function is normally used only by very specialized, system-level code. One example use case is with garbage collection that moves the text in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The new (moved) text string. </td></tr>
    <tr><td class="paramname">status</td><td>Receives errors detected by this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000684">Stable:</a></b></dt><dd>ICU 49 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a463524dd38af76a689b5d3e1f87237ff">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="a8d8651c91dea3032e7e0c8ccaab5c888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8651c91dea3032e7e0c8ccaab5c888">&#9670;&nbsp;</a></span>registerExternalBreakEngine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void icu::RuleBasedBreakIterator::registerExternalBreakEngine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classicu_1_1ExternalBreakEngine.html">ExternalBreakEngine</a> *&#160;</td>
          <td class="paramname"><em>toAdopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a new external break engine. </p>
<p>The external break engine will be adopted. Because ICU may choose to cache break engine internally, this must be called at application startup, prior to any calls to object methods of <a class="el" href="classicu_1_1RuleBasedBreakIterator.html" title="A subclass of BreakIterator whose behavior is specified using a list of rules.">RuleBasedBreakIterator</a> to avoid undefined behavior. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toAdopt</td><td>the <a class="el" href="classicu_1_1ExternalBreakEngine.html" title="The ExternalBreakEngine class define an abstract interface for the host environment to provide a low ...">ExternalBreakEngine</a> instance to be adopted </td></tr>
    <tr><td class="paramname">status</td><td>the in/out status code, no special meanings are assigned </td></tr>
  </table>
  </dd>
</dl>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000108">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. ICU 74 technology preview </dd></dl>

</div>
</div>
<a id="afe7c9dcc8dfc94f197006e7c50e51f78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7c9dcc8dfc94f197006e7c50e51f78">&#9670;&nbsp;</a></span>setText() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void icu::RuleBasedBreakIterator::setText </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classicu_1_1UnicodeString.html">UnicodeString</a> &amp;&#160;</td>
          <td class="paramname"><em>newText</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the iterator to analyze a new piece of text. </p>
<p>This function resets the current iteration position to the beginning of the text.</p>
<p>The <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> will retain a reference to the supplied string. The caller must not modify or delete the text while the <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> retains the reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newText</td><td>The text to analyze. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000668">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#aaeda5bd245bd9d3cf093731484f5ea8c">icu::BreakIterator</a>.</p>

</div>
</div>
<a id="aecfde1ea8cad6f09f6cc1cf186c73572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfde1ea8cad6f09f6cc1cf186c73572">&#9670;&nbsp;</a></span>setText() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void icu::RuleBasedBreakIterator::setText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> &amp;&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the break iterator to operate over the text represented by the <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>
<p>The iterator position is reset to the start.</p>
<p>This function makes a shallow clone of the supplied <a class="el" href="structUText.html" title="UText struct.">UText</a>. This means that the caller is free to immediately close or otherwise reuse the Utext that was passed as a parameter, but that the underlying text itself must not be altered while being referenced by the break iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> used to change the text. </td></tr>
    <tr><td class="paramname">status</td><td>Receives any error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000669">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p>Implements <a class="el" href="classicu_1_1BreakIterator.html#a615a40ff53341af642fe1e1a9209bbb9">icu::BreakIterator</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a2ad6052587787523f902a4503693dbe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad6052587787523f902a4503693dbe6">&#9670;&nbsp;</a></span>fData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RBBIDataWrapper* icu::RuleBasedBreakIterator::fData = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The rule data for this <a class="el" href="classicu_1_1BreakIterator.html" title="The BreakIterator class implements methods for finding the location of boundaries in text.">BreakIterator</a> instance. </p>
<p>Not for general use; Public only for testing purposes. </p><dl class="internal"><dt><b><a class="el" href="internal.html#_internal000105">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. </dd></dl>

<p class="definition">Definition at line <a class="el" href="rbbi_8h_source.html#l00136">136</a> of file <a class="el" href="rbbi_8h_source.html">rbbi.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>common/unicode/<a class="el" href="rbbi_8h_source.html">rbbi.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
