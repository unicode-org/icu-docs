<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<link rel="stylesheet" href="http://www.unicode.org/reports/reports.css" type="text/css">
<title>UTS #18: Unicode Regular Expressions</title>
<style type="text/css">
<!--
.rule_head, .rule_body { font-style: italic; border-width: 0 }
.rule_head   { font-weight: bold }
-->
</style>
</head>

<body bgcolor="#ffffff">

<table class="header" width="100%">
  <tr>
    <td class="icon"><a href="http://www.unicode.org">
    <img align="middle" alt="[Unicode]" border="0" src="http://www.unicode.org/webscripts/logo60s2.gif" width="34" height="33"></a>&nbsp;&nbsp;<a class="bar" href="http://www.unicode.org/reports/">Technical 
    Reports</a></td>
  </tr>
  <tr>
    <td class="gray">&nbsp;</td>
  </tr>
</table>
<div class="body">
  <h2 align="center"><span class="changedspan">Proposed Update </span>Unicode Technical <span>
  Standard </span>#18</h2>
  <h1 align="right">Unicode Regular Expressions</h1>
  <table class="wide" border="1" width="100%">
    <tr>
      <td width="20%">Version</td>
      <td><span class="changedspan">10</span></td>
    </tr>
    <tr>
      <td>Authors</td>
      <td>Mark Davis (<a href="mailto:mark.davis@us.ibm.com">mark.davis@us.ibm.com</a>)</td>
    </tr>
    <tr>
      <td>Date</td>
      <td><span class="changedspan">2004-10-12</span></td>
    </tr>
    <tr>
      <td>This Version</td>
      <td><span class="changedspan"><a href="http://www.unicode.org/reports/tr18/tr18-10.html">
      http://www.unicode.org/reports/tr18/tr18-10.html</a></span></td>
    </tr>
    <tr>
      <td>Previous Version</td>
      <td><span class="changedspan"><a href="http://www.unicode.org/reports/tr18/tr18-9.html">
      http://www.unicode.org/reports/tr18/tr18-9.html</a></span></td>
    </tr>
    <tr>
      <td>Latest Version</td>
      <td><a href="http://www.unicode.org/reports/tr18/">http://www.unicode.org/reports/tr18/</a></td>
    </tr>
    <tr>
      <td>Tracking Number</td>
      <td><span class="changedspan"><a href="#Modifications">10</a></span></td>
    </tr>
  </table>
  <p><br>
  </p>
  <h3><i>Summary</i></h3>
  <p><i><em>This document describes guidelines for how to adapt regular expression engines to use 
  Unicode.</em></i></p>
  <h3><i>Status</i></h3>
  <p><span class="changedspan"><i>This document is a proposed update of a previously approved 
  Unicode Technical Standard. Publication does not imply endorsement by the Unicode Consortium. This 
  is a draft document which may be updated, replaced, or superseded by other documents at any time. 
  This is not a stable document; it is inappropriate to cite this document as other than a work in 
  progress.</i></span></p>
  <blockquote>
    <p><i><b>A Unicode Technical Standard (UTS)</b> is an independent specification. Conformance to 
    the Unicode Standard does not imply conformance to any UTS.</i></p>
  </blockquote>
  <p><i>Please submit corrigenda and other comments with the online reporting form [<a href="#Feedback">Feedback</a>]. 
  Related information that is useful in understanding this document is found in [<a href="#References">References</a>]. 
  For the latest version of the Unicode Standard see [<a href="#Unicode">Unicode</a>]. For a list of 
  current Unicode Technical Reports see [<a href="#Reports">Reports</a>]. For more information about 
  versions of the Unicode Standard, see [<a href="#Versions">Versions</a>].</i></p>
  <h3><i>Contents</i></h3>
  <blockquote>
    <dl>
      <dt><a href="#Introduction">0 Introduction</a></dt>
      <dd><a href="#Notation">0.1 Notation</a></dd>
      <dd><a href="#Conformance">0.2 Conformance</a></dd>
      <dt><a href="#Basic_Unicode_Support">1 Basic Unicode Support: Level 1</a></dt>
      <dd><a href="#Hex_notation">1.1 Hex notation</a></dd>
      <dd><a href="#Categories">1.2 Properties</a></dd>
      <dd><a href="#Subtraction_and_Intersection">1.3 Subtraction and Intersection</a></dd>
      <dd><a href="#Simple_Word_Boundaries">1.4 Simple Word Boundaries</a></dd>
      <dd><a href="#Simple_Loose_Matches">1.5 Simple Loose Matches</a></dd>
      <dd><a href="#Line_Boundaries">1.6 Line Boundaries</a></dd>
      <dd><a href="#Supplementary_Characters">1.7 Supplementary Characters</a></dd>
      <dt><a href="#Extended_Unicode_Support">2 Extended Unicode Support: Level 2</a></dt>
      <dd><a href="#Canonical_Equivalents">2.1 Canonical Equivalents</a></dd>
      <dd><a href="#Default_Grapheme_Clusters">2.2 Default Grapheme Clusters</a></dd>
      <dd><a href="#Default_Word_Boundaries">2.3 Default Word Boundaries</a></dd>
      <dd><a href="#Default_Loose_Matches">2.4 Default Loose Matches</a></dd>
      <dd><a href="#Name_Properties">2.5 Name Properties</a></dd>
      <dd><a href="#Wildcard_Properties">2.6 Wildcard Properties</a></dd>
      <dt><a href="#Tailored_Support">3 Tailored Support: Level 3</a></dt>
      <dd><a href="#Tailored_Properties">3.1 Tailored Punctuation</a></dd>
      <dd><a href="#Tailored_Graphemes_Clusters">3.2 Tailored Grapheme Clusters</a></dd>
      <dd><a href="#Tailored_Word_Boundaries">3.3 Tailored Word Boundaries</a></dd>
      <dd><a href="#Tailored_Loose_Matches">3.4 Tailored Loose Matches</a></dd>
      <dd><a href="#Tailored_Ranges">3.5 Tailored Ranges</a></dd>
      <dd><a href="#Context_Matching">3.6 Context Matching</a></dd>
      <dd><a href="#Partial_Matches">3.7 Incremental Matches</a></dd>
      <dd><a href="#Unicode_Set_Sharing">3.8 Unicode Set Sharing</a></dd>
      <dd><a href="#Possible_Match_Sets">3.9 Possible Match Sets</a></dd>
      <dd><a href="#Folded_Matching">3.10 Folded Matching</a></dd>
      <dd><a href="#Submatchers">3.11 Submatchers</a></dd>
      <dt><a href="#Character_Blocks">Annex A. Character Blocks</a></dt>
      <dt><a href="#Sample_Collation_Character_Code">Annex B. Sample Collation Character Code</a></dt>
      <dt><a href="#Compatibility_Properties">Annex C. Compatibility Properties</a></dt>
      <dt><a href="#References">References</a></dt>
      <dt><a href="#Acknowledgments">Acknowledgments</a></dt>
      <dt><a href="#Modifications">Modifications</a></dt>
    </dl>
  </blockquote>
  <h2>0 <a name="Introduction">Introduction</a></h2>
  <p>The following describes general guidelines for extending regular expression engines (Regex) to 
  handle Unicode. The following issues are involved in such extensions.</p>
  <ul>
    <li>Unicode is a large character set—regular expression engines that are only adapted to handle 
    small character sets will not scale well. </li>
    <li>Unicode encompasses a wide variety of languages which can have very different 
    characteristics than English or other western European text. </li>
  </ul>
  <p>There are three fundamental levels of Unicode support that can be offered by regular expression 
  engines:</p>
  <ul>
    <li><b>Level 1: Basic Unicode Support. </b>At this level, the regular expression engine provides 
    support for Unicode characters as basic logical units. (This is independent of the actual 
    serialization of Unicode as UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, or UTF-32LE.) This is a minimal 
    level for useful Unicode support. It does not account for end-user expectations for character 
    support, but does satisfy most low-level programmer requirements. The results of regular 
    expression matching at this level are independent of country or language. At this level, the 
    user of the regular expression engine would need to write more complicated regular expressions 
    to do full Unicode processing.</li>
    <li><b>Level 2: Extended Unicode Support. </b>At this level, the regular expression engine also 
    accounts for default grapheme clusters (what the end-user generally thinks of as a character), 
    better detection of word boundaries, and canonical equivalence. This is still a default 
    level—independent of country or language—but provides much better support for end-user 
    expectations than the raw level 1, without the regular-expression writer needing to know about 
    some of the complications of Unicode encoding structure.</li>
    <li><b>Level 3: Tailored Support. </b>At this level, the regular expression engine also provides 
    for tailored treatment of characters (including country- or language-specific behavior), for 
    example, whereby the characters <i>ch</i> can behave as a single character (in Slovak or 
    traditional Spanish). The results of a particular regular expression reflect the end-users 
    expectations of what constitutes a character in their language, and what order the characters 
    are in. However, there is a performance impact to support at this level.</li>
  </ul>
  <p>One of the most important requirements for a regular expression engine is to document clearly 
  what Unicode features are and are not supported. Even if higher-level support is not currently 
  offered, provision should be made for the syntax to be extended in the future to encompass those 
  features.</p>
  <blockquote>
    <p><b><i>Note: </i></b><i>Unicode is a constantly evolving standard: new characters will be 
    added in the future. This means that a regular expression that tests for, say, currency symbols 
    will have different results in Unicode 2.0 than in Unicode 2.1 (where the Euro currency symbol 
    was added.)</i></p>
  </blockquote>
  <p>At any level, efficiently handling properties or conditions based on a large character set can 
  take a lot of memory. A common mechanism for reducing the memory requirements — while still 
  maintaining performance — is the two-stage table, discussed in Chapter 5 of <i>The Unicode 
  Standard </i>[<a href="#Unicode">Unicode</a>]. For example, the Unicode character properties 
  required in <a href="#Categories">RL1.2 Properties</a> can be stored in memory in a two-stage 
  table with only 7 or 8Kbytes. Accessing those properties only takes a small amount of 
  bit-twiddling and two array accesses.</p>
  <blockquote>
    <p><i><b>Note: </b>For ease of reference, the section ordering for this document is intended to 
    be as stable as possible over successive versions. That may lead, in some cases, to the ordering 
    of the sections being less than optimal.</i></p>
  </blockquote>
  <h3>0.1 <a name="Notation">Notation</a></h3>
  <p>In order to describe regular expression syntax, we will use an extended BNF form:</p>
  <table class="syntax">
    <tr>
      <td><code>x y</code></td>
      <td>the sequence consisting of x then y</td>
    </tr>
    <tr>
      <td><code>x*</code></td>
      <td>zero or more occurrences of x</td>
    </tr>
    <tr>
      <td><code>x?</code></td>
      <td>zero or one occurrence of x</td>
    </tr>
    <tr>
      <td><code>x | y</code></td>
      <td>either x or y</td>
    </tr>
    <tr>
      <td><code>( x )</code></td>
      <td>for grouping</td>
    </tr>
    <tr>
      <td><code>&quot;XYZ&quot;</code></td>
      <td>terminal character(s)</td>
    </tr>
  </table>
  <p>The following syntax for character ranges will be used in successive examples.</p>
  <blockquote>
    <p>Note: <i>This is only a <b>sample</b> syntax for the purposes of examples in this document.</i> 
    (Regular expression syntax varies widely: the issues discussed here would need to be adapted to 
    the syntax of the particular implementation. However, it is important to have a concrete syntax 
    to correctly illustrate the different issues.</p>
    <p>In general, the syntax here is similar to that of
    <a href="http://www.perl.com/pub/q/documentation">Perl Regular Expressions</a> [<a href="#Perl">Perl</a>].) 
    In some cases, this gives multiple syntactic constructs that provide for the same functionality.</p>
  </blockquote>
  <table class="syntax">
    <tr>
      <td width="100%">
      <pre>LIST := &quot;[&quot; NEGATION? ITEM (SEP? ITEM)* &quot;]&quot;
ITEM := CODE_POINT2
     := CODE_POINT2 &quot;-&quot; CODE_POINT2 // range

CODE_POINT2 := ESCAPE CODE_POINT
            := CODE_POINT

NEGATION := &quot;^&quot;
SEP := &quot;&quot;  // no separator = union 
    := &quot;|&quot; // union
ESCAPE := &quot;\&quot;</pre>
      </td>
    </tr>
  </table>
  <p>Code_point refers to any Unicode code point from U+0000 to U+10FFFF, although typically the 
  only ones of interest will be those representing characters. Whitespace is allowed between any 
  elements, but to simplify the presentation the many occurrences of &quot; &quot;* are omitted.</p>
  <p>Code points that are syntax characters or whitespace are typically escaped. For more 
  information see [<a href="#Syntax">Syntax</a>]. In examples, we will sometimes use the syntax \s 
  to mean whitespace. See also <a href="#Compatibility_Properties">Annex C. Compatibility Properties</a>.</p>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <td><code>[a-z | A-Z | 0-9]</code></td>
      <td rowspan="3">Match ASCII alphanumerics</td>
    </tr>
    <tr>
      <td><code>[a-z A-Z 0-9]</code></td>
    </tr>
    <tr>
      <td><code>[a-zA-Z0-9]</code></td>
    </tr>
    <tr>
      <td><code>[^a-z A-Z 0-9]</code></td>
      <td>Match anything but ASCII alphanumerics</td>
    </tr>
    <tr>
      <td><code>[\] \- \ ]</code></td>
      <td>Match the literal characters ], -, &lt;space&gt;</td>
    </tr>
  </table>
  <p>Where string offsets are used in examples, they are from zero to n (the length of the string), 
  and indicate positions <i>between</i> characters. Thus in &quot;abcde&quot;, the substring from 2 to 4 
  includes the two characters &quot;cd&quot;.</p>
  <p><span class="changedspan">We also define the following notation for use here and in other 
  Unicode documents:</span></p>
  <table class="syntax">
    <tr>
      <td><span class="changedspan"><code>\n</code></span></td>
      <td><span class="changedspan">As used within regular expressions, expands to the text matching 
      the <b>n</b>th parenthesized group in regular expression. (<font SIZE="3">à</font> la Perl)</span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><code>$n</code></span></td>
      <td><span class="changedspan">As used within replacement strings for regular expressions, 
      expands to the text matching the <b>n</b>th parenthesized group in a corresponding regular 
      expression. The value of $0 is the entire expression.(<font SIZE="3"> à</font> la Perl)</span></td>
    </tr>
    <tr>
      <td><span class="changedspan"><code>$xyz</code></span></td>
      <td><span class="changedspan">As used within regular expressions or replacement strings, 
      expands to an assigned variable value. The &#39;xyz&#39; is of the form of an identifier. For example, 
      given<br>
      $greek_lower = [[:greek:]&amp;[:lowercase:]], the regular expression pattern &quot;ab$greek_lower&quot; is 
      equivalent to &quot;ab[[:greek:]&amp;[:lowercase:]]&quot;.</span></td>
    </tr>
  </table>
  <blockquote>
    <p><span class="changedspan"><b>Note: </b>Since any character could occur as a literal in a 
    regular expression, when regular expression syntax is embedded within other syntax it can be 
    difficult to determine where the end of the regex expression is. Common practice is to allow the 
    user to choose a delimiter like &#39;/&#39; in /ab(c)*/. The user can then simply choose a delimiter 
    that is not in the particular regular expression.</span></p>
  </blockquote>
  <h3>0.2 <a name="Conformance">Conformance</a></h3>
  <p>The following describes the possible ways that an implementation can claim conformance to this 
  technical standard.</p>
  <p>All syntax and API presented in this document is <i>only</i> for the purpose of illustration; 
  there is absolutely no requirement to follow such syntax or API. Regular expression syntax varies 
  widely: the features discussed here would need to be adapted to the syntax of the particular 
  implementation. In general, the syntax in examples is similar to that of
  <a href="http://www.perl.com/pub/q/documentation">Perl Regular Expressions</a> [<a href="#Perl">Perl</a>], 
  but it may not be exactly the same. While the API examples generally follow
  <a href="http://java.sun.com/j2se/1.4.1/docs/api/java/util/regex/package-summary.html">Java style</a>, 
  it is again <i>only</i> for illustration.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head"><a name="C0">C0</a>.</td>
      <td class="rule_body">An implementation claiming conformance to this specification at any 
      Level shall identify the version of this specification and the version of the Unicode 
      Standard.<br>
&nbsp;</td>
    </tr>
  </table>
  <table class="noborder">
    <tr>
      <td class="rule_head"><a name="C1">C1</a>.</td>
      <td class="rule_body">An implementation claiming conformance to Level 1 of this specification 
      shall meet the requirements described in the following sections:</td>
    </tr>
  </table>
  <blockquote>
    <dl>
      <dd><a href="#Hex_notation">RL1.1 Hex Notation</a></dd>
      <dd><a href="#Categories">RL1.2 Properties</a><br>
      <span class="changedspan"><a href="#Categories">RL1.2a Compatibility Properties</a></span></dd>
      <dd><a href="#Subtraction_and_Intersection">RL1.3 Subtraction and Intersection</a></dd>
      <dd><a href="#Simple_Word_Boundaries">RL1.4 Simple Word Boundaries</a></dd>
      <dd><a href="#Simple_Loose_Matches">RL1.5 Simple Loose Matches</a></dd>
      <dd><a href="#Line_Boundaries">RL1.6 Line Boundaries</a></dd>
      <dd><a href="#Supplementary_Characters">RL1.7 Supplementary Characters</a></dd>
    </dl>
  </blockquote>
  <table class="noborder">
    <tr>
      <td class="rule_head"><a name="C2">C2</a>.</td>
      <td class="rule_body">An implementation claiming conformance to Level 2 of this specification 
      shall satisfy C1, and meet the requirements described in the following sections:</td>
    </tr>
  </table>
  <blockquote>
    <dl>
      <dd><a href="#Canonical_Equivalents">RL2.1 Canonical Equivalents</a></dd>
      <dd><a href="#Default_Grapheme_Clusters">RL2.2 Default Grapheme Clusters</a></dd>
      <dd><a href="#Default_Word_Boundaries">RL2.3 Default Word Boundaries</a></dd>
      <dd><a href="#Default_Loose_Matches">RL2.4 Default Loose Matches</a></dd>
      <dd><a href="#Name_Properties">RL2.5 Name Properties</a></dd>
      <dd><a href="#Wildcard_Properties">RL2.6 Wildcard Properties</a></dd>
    </dl>
  </blockquote>
  <table class="noborder">
    <tr>
      <td class="rule_head"><a name="C3">C3</a>.</td>
      <td class="rule_body">An implementation claiming conformance to Level 3 of this specification 
      shall satisfy C1 and C2, and meet the requirements described in the following sections:</td>
    </tr>
  </table>
  <blockquote>
    <dl>
      <dd><a href="#Tailored_Properties">RL3.1 Tailored Punctuation</a></dd>
      <dd><a href="#Tailored_Graphemes_Clusters">RL3.2 Tailored Grapheme Clusters</a></dd>
      <dd><a href="#Tailored_Word_Boundaries">RL3.3 Tailored Word Boundaries</a></dd>
      <dd><a href="#Tailored_Loose_Matches">RL3.4 Tailored Loose Matches</a></dd>
      <dd><a href="#Tailored_Ranges">RL3.5 Tailored Ranges</a></dd>
      <dd><a href="#Context_Matching">RL3.6 Context Matching</a></dd>
      <dd><a href="#Partial_Matches">RL3.7 Incremental Matches</a></dd>
      <dd><a href="#Unicode_Set_Sharing">RL3.8 Unicode Set Sharing</a></dd>
      <dd><a href="#Possible_Match_Sets">RL3.9 Possible Match Sets</a></dd>
      <dd><a href="#Folded_Matching">RL3.10 Folded Matching</a></dd>
      <dd><a href="#Submatchers">RL3.11 Submatchers</a></dd>
    </dl>
  </blockquote>
  <table class="noborder">
    <tr>
      <td class="rule_head"><a name="C4">C4</a>.</td>
      <td class="rule_body">An implementation claiming <i>partial</i> conformance to this 
      specification shall clearly indicate which levels are completely supported (C1-C3), plus any 
      additional supported features from higher levels.</td>
    </tr>
  </table>
  <blockquote>
    <p>For example, an implementation may claim conformance to Level 1, plus
    <a href="#Context_Matching">Context Matching</a>, and <a href="#Partial_Matches">Incremental 
    Matches</a>. Another implementation may claim conformance to Level 1, except for
    <a href="#Subtraction_and_Intersection">Subtraction and Intersection</a>.</p>
  </blockquote>
  <p><b>Notes:</b></p>
  <ul>
    <li>A regular expression engine may be operating in the context of a larger system. In that case 
    some of the requirements may be met by the overall system. For example, the requirements of 
    section 2.1 might be best met by making normalization available as a part of the larger system, 
    and requiring users of the system to normalize strings where desired before supplying them to 
    the regular-expression engine. Such usage is conformant, as long as the situation is clearly 
    documented.</li>
    <li>A conformance claim may also include capabilities added by an optional add-on, such as an 
    optional library module, as long as this is clearly documented.</li>
    <li>For backwards compatibility, some of the functionality may only be available if some special 
    setting is turned on. None of the conformance requirements require the functionality to be 
    available by default.</li>
  </ul>
  <h2><a name="Basic_Unicode_Support">1 Basic Unicode Support</a>: <a name="Level_1">Level 1</a></h2>
  <p>Regular expression syntax usually allows for an expression to denote a set of single 
  characters, such as <code>[a-z A-Z 0-9]</code>. Since there are a very large number of characters 
  in the Unicode standard, simple list expressions do not suffice.</p>
  <h3><a name="Hex_notation">1.1 Hex notation</a></h3>
  <p>The character set used by the regular expression writer may not be Unicode, or may not have the 
  ability to input all Unicode code points from a keyboard.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.1</td>
      <td class="rule_head">Hex Notation</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall supply a mechanism for 
      specifying any Unicode code point (from U+0000 to U+10FFFF).</td>
    </tr>
  </table>
  <p>A sample notation for listing hex Unicode characters within strings is by prefixing four hex 
  digits with &quot;\u&quot; and prefixing eight hex digits with &quot;\U&quot;. This would provide for the following 
  addition:</p>
  <table class="syntax">
    <tr>
      <td width="100%">
      <pre>&lt;codepoint&gt; := &lt;character&gt;
&lt;codepoint&gt; := ESCAPE U_SHORT_MARK
               HEX_CHAR HEX_CHAR HEX_CHAR HEX_CHAR

&lt;codepoint&gt; := ESCAPE U_LONG_MARK
               HEX_CHAR HEX_CHAR HEX_CHAR HEX_CHAR
               HEX_CHAR HEX_CHAR HEX_CHAR HEX_CHAR

U_SHORT_MARK := &quot;u&quot;
U_LONG_MARK := &quot;U&quot;</pre>
      </td>
    </tr>
  </table>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <td><code>[\u3040-\u309F \u30FC]</code></td>
      <td>Match Hiragana characters, plus prolonged sound sign</td>
    </tr>
    <tr>
      <td><code>[\u00B2 \u2082]</code></td>
      <td>Match superscript and subscript 2</td>
    </tr>
    <tr>
      <td><code>[a \U00010450]</code></td>
      <td>Match &quot;a&quot; or U+10450 SHAVIAN LETTER PEEP</td>
    </tr>
  </table>
  <ul>
    <li><b>Note:</b> instead of <code>[...\u3040...]</code>, an alternate syntax is <code>
    [...\x{3040}...]</code>, as in Perl 5.6 and later.</li>
    <li><b>Note: </b>more advanced regular expression engines can also offer the ability to use the 
    Unicode character name for readability. See <a href="#Name_Properties">2.5 Name Properties</a>.</li>
  </ul>
  <h3><a name="Categories">1.2 Properties</a></h3>
  <p>Since Unicode is a large character set, a regular expression engine needs to provide for the 
  recognition of whole categories of characters as well as simply ranges of characters; otherwise 
  the listing of characters becomes impractical and error-prone. This is done by providing syntax 
  for sets of characters based on the Unicode character properties, and allowing them to be mixed 
  with lists and ranges of individual code points.</p>
  <p>There are a large number of <a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Properties">
  Unicode Character Database properties</a>. The official data mapping Unicode characters (and code 
  points) to properties is the <a href="http://www.unicode.org/ucd/">Unicode Character Database</a> 
  [<a href="http://www.unicode.org/ucd/">UCD</a>]. See also Chapter 4 in <i>The Unicode Standard</i> 
  [<a href="#Unicode">Unicode</a>].</p>
  <p align="left">The recommended names for UCD properties and property values are in
  <a href="http://www.unicode.org/Public/UNIDATA/PropertyAliases.txt">PropertyAliases.txt</a> [<a href="#Prop">Prop</a>] 
  and <a href="http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt">
  PropertyValueAliases.txt</a> [<a href="#PropValue">PropValue</a>]. There are both abbreviated 
  names and longer, more descriptive names. It is strongly recommended that both names be 
  recognized, and that loose matching of property names be used, whereby the case distinctions, 
  whitespace, hyphens, and underbar are ignored.</p>
  <blockquote>
    <p><b>Note:</b> it may be a useful implementation technique to load the Unicode tables that 
    support properties and other features on demand, to avoid unnecessary memory overhead for simple 
    regular expressions that don&#39;t use those properties. </p>
  </blockquote>
  <p>Where a regular expression is expressed as much as possible in terms of higher-level semantic 
  constructs such as <i>Letter</i>, it makes it practical to work with the different alphabets and 
  languages in Unicode. Here is an example of a syntax addition that permits properties.</p>
  <blockquote>
    <p>Notice that following Perl Syntax, the <i>p</i> is lowercase to indicate a positive match, 
    and uppercase to indicate a negative match.</p>
  </blockquote>
  <table class="syntax">
    <tr>
      <td width="100%"><code>ITEM := POSITIVE_SPEC | NEGATIVE_SPEC<br>
      POSITIVE_SPEC := (&quot;\p{&quot; PROP_SPEC &quot;}&quot;) | (&quot;[:&quot; PROP_SPEC &quot;:]&quot;)<br>
      NEGATIVE_SPEC := (&quot;\P{&quot; PROP_SPEC &quot;}&quot;) | (&quot;[:^&quot; PROP_SPEC &quot;:]&quot;)<br>
      PROP_SPEC := &lt;binary_unicode_property&gt;<br>
      PROP_SPEC := &lt;unicode_property&gt; (&quot;:&quot; | &quot;=&quot;) &lt;unicode_property_value&gt;<br>
      PROP_SPEC := &lt;script_or_category_property_value&gt;</code></td>
    </tr>
  </table>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <td><code>[\p{L} \p{Nd}]</code></td>
      <td rowspan="2">Match all letters and decimal digits</td>
    </tr>
    <tr>
      <td><code>[\p{letter} \p{decimal number}]</code></td>
    </tr>
    <tr>
      <td><code>\P{L}</code></td>
      <td rowspan="2">Match anything that is not a letter</td>
    </tr>
    <tr>
      <td><code>\P{letter}</code></td>
    </tr>
    <tr>
      <td><code>\p{East Asian Width:Narrow}</code></td>
      <td>Match anything that has the <code>East Asian Width</code> property value of Narrow</td>
    </tr>
    <tr>
      <td><code>\p{Whitespace}</code></td>
      <td>Match anything that has the binary property Whitespace</td>
    </tr>
  </table>
  <p>Some properties are binary: they are either true or false for a given code point. In that case, 
  only the property name is required. Others have multiple values, so for uniqueness both the 
  property name and the property value need to be included. For example, <i>Alphabetic</i> is both a 
  binary property and a value of the Line_Break enumeration, so \p{Alphabetic} would mean the binary 
  property, and \p{Line Break:Alphabetic} or \p{Line_Break=Alphabetic} would mean the enumerated 
  property. There are two exceptions to this: the properties <i>Script</i> and <i>General Category</i> 
  commonly have the property name omitted. Thus \p{Not_Assigned} is equivalent to \p{General_Category 
  = Not_Assigned}, and \p{Greek} is equivalent to \p{Script:Greek}.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.2</td>
      <td class="rule_head">Properties</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall provide a least a 
      minimal list of properties, consisting of the following:
      <ul>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#General_Category">
        General_Category</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Script">Script</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Alphabetic">Alphabetic</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Uppercase">Uppercase</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Lowercase">Lowercase</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#White_Space">White_Space</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Noncharacter_Code_Point">
        Noncharacter_Code_Point</a></li>
        <li><a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Default_Ignorable_Code_Point">
        Default_Ignorable_Code_Point</a></li>
        <li>ANY, ASCII, ASSIGNED</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td class="rule_body"><span class="changedspan"><b>RL1.2a&nbsp;</b></span></td>
      <td class="rule_body"><span class="changedspan"><span style="background-color: #FFFF00"><b>
      Compatibility</b></span><b> Properties</b></span></td>
    </tr>
    <tr>
      <td class="rule_body">&nbsp;</td>
      <td class="rule_body"><span class="changedspan">To meet this requirement, an implementation 
      shall provide the properties listed in <a href="#Compatibility_Properties">Annex C. 
      Compatibility Properties</a>, with the property values as listed there. Such an implementation 
      shall document whether it is using the Standard Recommendation or POSIX-compatible properties.</span></td>
    </tr>
  </table>
  <p>Of <span class="changedspan">the properties in RL1.2</span>, only General Category and Script 
  have multiple values; the rest are binary. An implementation that does not support non-binary 
  enumerated properties can essentially &quot;flatten&quot; the enumerated type. Thus, for example, instead of 
  \p{script=latin} the syntax could be \p{script_latin}.</p>
  <h4>General Category Property</h4>
  <p>The most basic overall character property is the General Category, which is a basic 
  categorization of Unicode characters into: <i>Letters, Punctuation, Symbols, Marks, Numbers, 
  Separators, </i>and<i> Other</i>. These property values each have a single letter abbreviation, 
  which is the uppercase first character except for separators, which use Z. The official data 
  mapping Unicode characters to the General Category value is in
  <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">UnicodeData.txt</a> [<a href="#UData">UData</a>].</p>
  <p>Each of these categories has different subcategories. For example, the subcategories for <i>
  Letter</i> are <i>uppercase</i>, <i>lowercase</i>, <i>titlecase</i>, <i>modifier</i>, and <i>other</i> 
  (in this case, <i>other</i> includes uncased letters such as Chinese). By convention, the 
  subcategory is abbreviated by the category letter (in uppercase), followed by the first character 
  of the subcategory in lowercase. For example, <i>Lu</i> stands for <i>Uppercase Letter</i>.</p>
  <blockquote>
    <p><b>Note: </b>Since it is recommended that the property syntax be lenient as to spaces, 
    casing, hyphens and underbars, any of the following should be equivalent: \p{Lu}, \p{lu}, \p{uppercase 
    letter}, \p{uppercase letter}, \p{Uppercase_Letter}, and \p{uppercaseletter}</p>
  </blockquote>
  <p>The General Category property values are listed below. For more information on the meaning of 
  these values, see <a href="http://www.unicode.org/Public/UNIDATA/UCD.html">UCD.html</a> [<a href="#UDataDoc">UDataDoc</a>].</p>
  <div align="center">
    <center>
    <table border="0" cellspacing="0" cellpadding="4" class="noborder">
      <tr>
        <td width="33%" class="noborder">
        <table class="values">
          <tr>
            <th>Abb.</th>
            <th align="left">Long form</th>
          </tr>
          <tr>
            <td>L</td>
            <td>Letter</td>
          </tr>
          <tr>
            <td>Lu</td>
            <td>Uppercase Letter</td>
          </tr>
          <tr>
            <td>Ll</td>
            <td>Lowercase Letter</td>
          </tr>
          <tr>
            <td>Lt</td>
            <td>Titlecase Letter</td>
          </tr>
          <tr>
            <td>Lm</td>
            <td>Modifier Letter</td>
          </tr>
          <tr>
            <td>Lo</td>
            <td>Other Letter</td>
          </tr>
          <tr>
            <td>M</td>
            <td>Mark</td>
          </tr>
          <tr>
            <td>Mn</td>
            <td>Non-Spacing Mark</td>
          </tr>
          <tr>
            <td>Mc</td>
            <td>Spacing Combining Mark</td>
          </tr>
          <tr>
            <td>Me</td>
            <td>Enclosing Mark</td>
          </tr>
          <tr>
            <td>N</td>
            <td>Number</td>
          </tr>
          <tr>
            <td>Nd</td>
            <td>Decimal Digit Number</td>
          </tr>
          <tr>
            <td>Nl</td>
            <td>Letter Number</td>
          </tr>
          <tr>
            <td>No</td>
            <td>Other Number</td>
          </tr>
        </table>
        </td>
        <td width="33%" class="noborder">
        <table class="values">
          <tr>
            <th>Abb.</th>
            <th align="left">Long form</th>
          </tr>
          <tr>
            <td>S</td>
            <td>Symbol</td>
          </tr>
          <tr>
            <td>Sm</td>
            <td>Math Symbol</td>
          </tr>
          <tr>
            <td>Sc</td>
            <td>Currency Symbol</td>
          </tr>
          <tr>
            <td>Sk</td>
            <td>Modifier Symbol</td>
          </tr>
          <tr>
            <td>So</td>
            <td>Other Symbol</td>
          </tr>
          <tr>
            <td>P</td>
            <td>Punctuation</td>
          </tr>
          <tr>
            <td>Pc</td>
            <td>Connector Punctuation</td>
          </tr>
          <tr>
            <td>Pd</td>
            <td>Dash Punctuation</td>
          </tr>
          <tr>
            <td>Ps</td>
            <td>Open Punctuation</td>
          </tr>
          <tr>
            <td>Pe</td>
            <td>Close Punctuation</td>
          </tr>
          <tr>
            <td>Pi</td>
            <td>Initial Punctuation</td>
          </tr>
          <tr>
            <td>Pf</td>
            <td>Final Punctuation</td>
          </tr>
          <tr>
            <td>Po</td>
            <td>Other Punctuation</td>
          </tr>
        </table>
        </td>
        <td width="33%" class="noborder">
        <table class="values">
          <tr>
            <th>Abb.</th>
            <th align="left">Long form</th>
          </tr>
          <tr>
            <td>Z</td>
            <td>Separator</td>
          </tr>
          <tr>
            <td>Zs</td>
            <td>Space Separator</td>
          </tr>
          <tr>
            <td>Zl</td>
            <td>Line Separator</td>
          </tr>
          <tr>
            <td>Zp</td>
            <td>Paragraph Separator</td>
          </tr>
          <tr>
            <td>C</td>
            <td>Other</td>
          </tr>
          <tr>
            <td>Cc</td>
            <td>Control</td>
          </tr>
          <tr>
            <td>Cf</td>
            <td>Format</td>
          </tr>
          <tr>
            <td>Cs</td>
            <td>Surrogate</td>
          </tr>
          <tr>
            <td>Co</td>
            <td>Private Use</td>
          </tr>
          <tr>
            <td>Cn</td>
            <td>Not Assigned</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Any*</td>
          </tr>
          <tr>
            <td>-</td>
            <td>Assigned*</td>
          </tr>
          <tr>
            <td>-</td>
            <td>ASCII</td>
          </tr>
        </table>
        </td>
      </tr>
    </table>
    </center>
  </div>
  <table border="0" width="100%" cellspacing="0" cellpadding="4" class="noborder">
    <tr>
      <td valign="top" class="noborder">*</td>
      <td valign="top" class="noborder">The last few properties are not part of the General 
      Category.
      <ul>
        <li><i>Any</i> matches all code points. This could also be captured with <code>
        [\u0000-\u10FFFF]</code>, but with <a href="#Tailored_Ranges">Tailored Ranges</a> off. In 
        some regular expression languages, <code>\p{Any}</code> may be expressed by a period, but 
        that may exclude newline characters.</li>
        <li><i>Assigned</i> is equivalent to <code>\P{Cn}</code>, and matches all assigned 
        characters (for the target version of Unicode). It also includes all private use characters. 
        It is useful for avoiding confusing double negatives. Note that <i>Cn</i> includes 
        noncharacters, so <i>Assigned</i> excludes them.</li>
        <li>ASCII is equivalent to <code>[\u0000-\u007F]</code>, but with <a href="#Tailored_Ranges">
        Tailored Ranges</a> off.</li>
      </ul>
      </td>
    </tr>
  </table>
  <h4>Script Property</h4>
  <p>A regular-expression mechanism may choose to offer the ability to identify characters on the 
  basis of other Unicode properties besides the General Category. In particular, Unicode characters 
  are also divided into scripts as described in <a href="http://www.unicode.org/reports/tr24/">UTR 
  #24: Script Names</a> [<a href="#ScriptDoc">ScriptDoc</a>] (for the data file, see
  <a href="http://www.unicode.org/Public/UNIDATA/Scripts.txt">Scripts.txt</a> [<a href="#ScriptData">ScriptData</a>]). 
  Using a property such as \p{Greek} allows people test letters for whether they are Greek or not.</p>
  <p>Note, however, that the usage model for the script property normally requires that people 
  construct somewhat more complex regular expressions, because a great many characters are shared 
  between scripts. Documentation should point users to the description in UTR #24.</p>
  <h4 align="left">Other Properties</h4>
  <p align="left">Other useful properties are described in Section 2 of Unicode Normalization Forms 
  [<a href="#Norm">Norm</a>], in Section 3.13 of The Unicode Standard, Version 4.0 [<a href="#Case">Case</a>], 
  and in the documentation for the Unicode Character Database [<a href="#UCD">UCD</a>].</p>
  <p align="left">The binary properties include:</p>
  <ul>
    <li>
    <p align="left"><i>Bidi_Control, Join_Control</i></li>
    <li>
    <p align="left"><i>ASCII_Hex_Digit, Hex_Digit</i></li>
    <li>
    <p align="left"><i>ID_Start, ID_Continue, XID_Start, XID_Continue</i></li>
    <li>
    <p align="left"><i>isLowercase, isUppercase, isTitlecase, isCasefolded, isCased</i></li>
    <li>
    <p align="left"><i>isNFC, isNFD, isNFKC, isNFKD</i></li>
  </ul>
  <p align="left">The enumerated non-binary properties include:</p>
  <ul>
    <li>
    <p align="left"><i>Decomposition_Type</i></li>
    <li>
    <p align="left"><i>Numeric_Type</i></li>
    <li>
    <p align="left"><i>East_Asian_Width</i></li>
    <li>
    <p align="left"><i>Line_Break</i></li>
  </ul>
  <p align="left">The numeric properties include:</p>
  <ul>
    <li>
    <p align="left"><i>Numeric_Value</i></li>
  </ul>
  <p align="left">The string properties include:</p>
  <ul>
    <li>
    <p align="left"><i>Name</i>
    <ul>
      <li>
      <p align="left">See also <a href="#Name_Properties">2.5 Name Properties</a> and
      <a href="#Wildcard_Properties">2.6 Wildcard Properties</a>.</li>
    </ul>
    </li>
    <li>
    <p align="left"><i>toLowercase, toUppercase, toTitlecase, toCasefolded</i></li>
    <li>
    <p align="left"><i>toNFC, toNFD, toNFKC, toNFKD</i></li>
    <li>
    <p align="left"><i>Age</i>
    <ul>
      <li>
      <p align="left"><b>Caution:</b> the
      <a href="http://www.unicode.org/Public/UNIDATA/DerivedAge.txt">DerivedAge</a> data file in the 
      UCD provides the deltas between versions, for compactness. However, when using the property 
      all characters included in that version are include. Thus \p{age=3.0} includes the letter <i>a</i>, 
      which was included in Unicode 1.0. To get characters that are new in a particular version, 
      subtract off the previous version as described in <a href="#Subtraction_and_Intersection">1.3 
      Subtraction and Intersection</a>. E.g. [\p{age=3.1} - \p{age=3.0]</li>
    </ul>
    </li>
  </ul>
  <p align="left">A full list of the available UCD properties is on
  <a href="http://www.unicode.org/Public/UNIDATA/UCD.html#Properties">UCD Properties</a>. Of those, 
  the following are only useful in very restricted cases, such as in the internal implementation of 
  normalization or case conversions:</p>
  <ul>
    <li>
    <p align="left">Composition_Exclusion, Decomposition_Mapping, Expands_On_Nx, FC_NFKC_Closure, 
    Nx_Quick_Check, Special_Case_Condition, ISO_Comment, Other_x</li>
  </ul>
  <h4 align="left">Blocks</h4>
  <p align="left">Unicode blocks can sometimes also be a useful enumerated property. However, there 
  are some <i>very</i> significant caveats to the use of Unicode blocks for the identification of 
  characters: see <a href="#Character_Blocks">Annex A. Character Blocks</a>. If blocks are used, 
  some of the names can collide with Script names, so they should be distinguished, such as with 
  syntax like \p{Greek Block} or \p{Block=Greek}.</p>
  <h3><a name="Subtraction_and_Intersection">1.3 Subtraction</a> and Intersection</h3>
  <p>As discussed above, character properties are essential with a large character set. In addition, 
  there needs to be a way to &quot;subtract&quot; characters from what is already in the list. For example, 
  one may want to include all non-ASCII letters without having to list every character in <code>\p{letter}</code> 
  that is not one of those 52.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.3</td>
      <td class="rule_head">Subtraction and Intersection</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall supply mechanisms for 
      both intersection and set-difference of Unicode sets.</td>
    </tr>
  </table>
  <p><br>
  </p>
  <table class="syntax">
    <tr>
      <td>
      <pre>ITEM := &quot;[&quot; ITEM &quot;]&quot; // for grouping
SEP := &quot;&quot;            // no separator = union 
    := &quot;|&quot;           // union
    := &quot;&amp;&quot;           // intersection
    := &quot;-&quot;           // removal = set difference</pre>
      </td>
    </tr>
  </table>
  <p>Implementations may also choose to offer other set operations, such as
  <a href="http://mathworld.wolfram.com/SymmetricDifference.html">symmetric difference</a>: [\p{letter} 
  ⊖ \p{ascii}]</p>
  <p><b>Note:</b> In the sample syntax used here:</p>
  <ol>
    <li>The symbol &quot;-&quot; between two characters still means a range, not a set-difference. That is:
    <ul>
      <li>[\p{ascii} - aeiouy] is equivalent to [\p{ascii} - [aeiouy]]</li>
      <li>[aeiouy &amp; \p{ascii}] is equivalent to [[aeiouy] &amp; \p{ascii}]</li>
    </ul>
    </li>
    <li>Union binds more closely than intersection, which binds more closely than removal. Otherwise 
    items bind from the left. (However, such binding or precedence may vary by regular expression 
    engine.)
    <p>For example, we get the following, where A..E stand for expressions, not characters:
    <ul>
      <li>[A|B|C-D|E] is the same as [[A|B|C] - [D|E]]
      <ul>
        <li>That is, it means form the union of A, B, and C, and then subtract the union of D and E.</li>
      </ul>
      </li>
      <li>[A - B - C - D &amp; E] is the same as [[[A - B] - C] - [D &amp; E]]
      <ul>
        <li>That is, take A, then remove all Bs, then all Cs, then remove the intersection of D and 
        E.</li>
      </ul>
      </li>
    </ul>
    </li>
  </ol>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <td><code>[\p{L} - QW]</code></td>
      <td>Match all letters but Q and W</td>
    </tr>
    <tr>
      <td><code>[\p{N} - [\p{Nd} - 0-9]]</code></td>
      <td>Match all non-decimal numbers, plus 0-9.</td>
    </tr>
    <tr>
      <td><code>[\u0000-\u007F - \P{letter}]</code></td>
      <td>Match all letters in the ASCII range, by subtracting non-letters.</td>
    </tr>
    <tr>
      <td><code>[\p{Greek } - </code><code>\N{GREEK SMALL LETTER ALPHA}</code><code>]</code></td>
      <td>Match Greek letters except alpha</td>
    </tr>
    <tr>
      <td><code>[\p{Assigned} - \p{Decimal Digit Number} - a-f A-F ａ-ｆ Ａ-Ｆ]</code></td>
      <td>Match all assigned characters except for hex digits (using a broad definition).</td>
    </tr>
  </table>
  <h3><br>
  <a name="Simple_Word_Boundaries">1.4 Simple Word Boundaries</a></h3>
  <p>Most regular expression engines allow a test for word boundaries (such as by &quot;\b&quot; in Perl). 
  They generally use a very simple mechanism for determining word boundaries: one example of that 
  would be having word boundaries between any pair of characters where one is a <code>&lt;word_character&gt;</code> 
  and the other is not, or at the start and end of a string. This is not adequate for Unicode 
  regular expressions.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.4</td>
      <td class="rule_head">Simple Word Boundaries</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall extend the word 
      boundary mechanism so that:
      <ol>
        <li>The class of <code>&lt;word_character&gt;</code> includes all the Alphabetic values from the 
        Unicode character database, from
        <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">UnicodeData.txt</a> [<a href="#UData">UData</a>]<span class="changedspan">, 
        plus the U+200C ZERO WIDTH NON-JOINER and U+200D ZERO WIDTH JOINER</span>. See also
        <a href="#Compatibility_Properties">Annex C: Compatibility Properties</a>.</li>
        <li>Non-spacing marks are never divided from their base characters, and otherwise ignored in 
        locating boundaries.</li>
      </ol>
      </td>
    </tr>
  </table>
  <p>Level 2 provides more general support for word boundaries between arbitrary Unicode characters 
  which may override this behavior.</p>
  <h3><a name="Simple_Loose_Matches">1.5 Simple Loose Matches</a></h3>
  <p>The only loose matches that most regular expression engines offer is caseless matching. If the 
  engine does offers this, then it needs to account for the large range of cased Unicode characters 
  outside of ASCII.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.5</td>
      <td class="rule_head">Simple Loose Matches</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, if an implementation provides for 
      case-insensitive matching, then it shall provide at least the simple, default Unicode 
      case-insensitive matching.
      <p>To meet this requirement, if an implementation provides for case conversions, then it shall 
      provide at least the simple, default Unicode case conversion.</td>
    </tr>
  </table>
  <p>In addition, because of the vagaries of natural language, there are situations where two 
  different Unicode characters have the same uppercase or lowercase. To meet this requirement, 
  implementations must implement these in accordance with the Unicode Standard. For example, the 
  Greek U+03C3 &quot;σ&quot; <i>small sigma,</i> U+03C2 &quot;ς&quot; <i>small final sigma,</i> and U+03A3 &quot;Σ&quot; <i>
  capital sigma</i> all match.</p>
  <p>Some caseless matches may match one character against two: for example, U+00DF &quot;ß&quot; matches the 
  two characters &quot;SS&quot;. And case matching may vary by locale. However, because many implementations 
  are not set up to handle this, at Level 1 only simple case matches are necessary. To correctly 
  implement a caseless match, <span>see Chapter 3 of the Unicode Standard [<a href="#Unicode">Unicode</a>]</span>. 
  The data file supporting caseless matching is
  <a href="http://www.unicode.org/Public/UNIDATA/CaseFolding.txt">CaseFolding.txt</a> [<a href="#CaseData">CaseData</a>].</p>
  <p>To meet this requirement, where an implementation also offers case conversions, then these must 
  also <span>follow Chapter 3 of the Unicode Standard [<a href="#Unicode">Unicode</a>]</span>. The 
  relevant data files are <a href="http://www.unicode.org/Public/UNIDATA/SpecialCasing.txt">
  SpecialCasing.txt</a> [<a href="#SpecialCasing">SpecialCasing</a>] and
  <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.html">UnicodeData.txt</a> [<a href="#UData">UData</a>].</p>
  <h3><a name="Line_Boundaries">1.6 Line Boundaries</a></h3>
  <p>Most regular expression engines also allow a test for line boundaries: end-of-line or 
  start-of-line. This presumes that lines of text are separated by line (or paragraph) separators.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.6</td>
      <td class="rule_head">Line Boundaries</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, if an implementation provides for 
      line-boundary testing, it shall recognize not only CRLF, LF, CR, but also NEL (U+0085), PS 
      (U+2029) and LS (U+2028).</td>
    </tr>
  </table>
  <p>Formfeed (U+000C) also normally indicates an end-of-line. For more information, see Chapter 3 
  of [<a href="#Unicode">Unicode</a>].</p>
  <p>These characters should be uniformly handled in determining logical line numbers, 
  start-of-line, end-of-line, and arbitrary-character implementations. Logical line number is useful 
  for compiler error messages and the like. Regular expressions often allow for SOL and EOL 
  patterns, which match certain boundaries. Often there is also a &quot;non-line-separator&quot; arbitrary 
  character pattern that excludes line separator characters.</p>
  <p>The behavior of these may also differ depending one whether one is in a &quot;multiline&quot; mode or 
  not. For more information, see <i>Anchors and Other &quot;Zero-Width Assertions&quot;</i> in Chapter 3 of [<a href="#Friedl">Friedl</a>].</p>
  <p class="changed">A newline sequence is defined to be any of the following:</p>
  <p align="center"><code>\u000A | <span class="changedspan">\u000B | </span>\u000C | \u000D | 
  \u0085 | \u2028 | \u2029 | \u000D\u000A</code></p>
  <ol>
    <li><b>Logical line number</b>
    <ul>
      <li>The line number is increased by one for each occurrence of <span class="changedspan">a 
      newline sequence</span>. </li>
      <li>Note that different implementations may call the first line either line zero or line one.</li>
    </ul>
    </li>
    <li><b>Logical beginning of line (often &quot;^&quot;)</b>
    <ul>
      <li>SOL is at the start of a file or string, and also immediately following any occurrence of<span class="changedspan"> 
      a newline sequence.</span></li>
    </ul>
    <ul>
      <li>There is no empty line within the sequence <code>\u000D\u000A</code>.</li>
      <li>Note that there may be a separate pattern for &quot;beginning of text&quot; for a multiline mode, 
      one which matches only at the beginning of the first line, e.g., in Perl \A.</li>
    </ul>
    </li>
    <li><b>Logical end of line (often &quot;$&quot;)</b>
    <ul>
      <li>EOL at the end of a file or string, and also immediately preceding a final occurrence of<span class="changedspan"> 
      a newline sequence.</span></li>
      <li>There is no empty line within the sequence <code>\u000D\u000A</code>.</li>
      <li>SOL and EOL are not symmetric because of multiline mode: EOL can be interpreted in at 
      least three different ways:
      <ol type="a">
        <li>EOL matches at the end of the string</li>
        <li>EOL matches before final newline</li>
        <li>EOL matches before any newline</li>
      </ol>
      </li>
    </ul>
    </li>
    <li><b>Arbitrary character pattern (often &quot;.&quot;)</b>
    <ul>
      <li>Should <i>not</i> match any of <span class="changedspan">&nbsp;the newline sequences.</span></li>
      <li>In &quot;multiline mode&quot;, these <i>would</i> match, and <code>\u000D\u000A</code> matches as if 
      it were a single character.</li>
      <li>Note that ^.*$ (an empty line pattern) should not match the empty string within the 
      sequence <code>\u000D\u000A</code>, but should match the empty string within the reversed 
      sequence <code>\u000A\u000D</code>.</li>
    </ul>
    </li>
  </ol>
  <p>It is strongly recommended that there be a regular expression meta-character, such as &quot;\R&quot;, for 
  matching all line ending characters and sequences listed above (e.g. in #1). It would thus be 
  shorthand for <code>([\u000A<span class="changedspan">\u000B</span>\u000C\u000D\u0085\u2028\u2029] 
  | \u000D\u000A)</code>.</p>
  <p>For more information on line breaking, see [<a href="#LineBreak">LineBreak</a>].</p>
  <h3><a name="Supplementary_Characters">1.7 Code Points</a></h3>
  <p>A fundamental requirement is that Unicode text be interpreted semantically by code point, not 
  code units.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL1.7</td>
      <td class="rule_head">Supplementary Characters</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall handle the full range 
      of Unicode code points, including values from U+FFFF to U+10FFFF. In particular, where UTF-16 
      is used, a sequence consisting of a leading surrogate followed by a trailing surrogate shall 
      be handled as a single code point in matching.</td>
    </tr>
  </table>
  <p>UTF-16 uses pairs of Unicode code units to express code points above FFFF<sub>16</sub>. 
  Surrogate pairs (or their equivalents in other encoding forms) are be handled internally as single 
  code point values. In particular, <code>[\u0000-\U0010000]</code> will match all the following 
  sequence of code units:</p>
  <table>
    <tr>
      <th width="198" align="left">Code Point</th>
      <th width="199" align="left">UTF-8 Code Units</th>
      <th width="199" align="left">UTF-16 Code Units</th>
      <th width="199" align="left">UTF-32 Code Units</th>
    </tr>
    <tr>
      <td><code>7F</code></td>
      <td><code>7F</code></td>
      <td><code>007F</code></td>
      <td><code>0000007F</code></td>
    </tr>
    <tr>
      <td><code>80</code></td>
      <td><code>C2 80</code></td>
      <td><code>0080</code></td>
      <td><code>00000080</code></td>
    </tr>
    <tr>
      <td><code>7FF</code></td>
      <td><code>DF BF</code></td>
      <td><code>07FF</code></td>
      <td><code>000007FF</code></td>
    </tr>
    <tr>
      <td><code>800</code></td>
      <td><code>E0 A0 80</code></td>
      <td><code>0800</code></td>
      <td><code>00000800</code></td>
    </tr>
    <tr>
      <td><code>FFFF</code></td>
      <td><code>EF BF BF</code></td>
      <td><code>FFFF</code></td>
      <td><code>0000FFFF</code></td>
    </tr>
    <tr>
      <td><code>10000</code></td>
      <td><code>F0 90 80 80</code></td>
      <td><code>D800 DC00</code></td>
      <td><code>00010000</code></td>
    </tr>
  </table>
  <p><br>
  </p>
  <hr align="LEFT">
  <h2><a name="Extended_Unicode_Support">2 Extended Unicode Support</a>: <a name="Level_2">Level 2</a></h2>
  <p>Level 1 support works well in many circumstances. However, it does not handle more complex 
  languages or extensions to the Unicode Standard very well. Particularly important cases are 
  canonical equivalence, word boundaries, default grapheme cluster boundaries, and loose matches. 
  (For more information about boundary conditions, see<i> The Unicode Standard, Section 5-15</i>.)</p>
  <p>Level 2 support matches much more what user expectations are for sequences of Unicode 
  characters. It is still locale-independent and easily implementable. However, the implementation 
  may be slower when supporting Level 2, and some expressions may require Level 1 matches. Thus it 
  is often useful to have some sort of syntax that will turn Level 2 support on and off.</p>
  <h3><a name="Canonical_Equivalents">2.1 Canonical Equivalents</a></h3>
  <p>There are many instances where a character can be equivalently expressed by two different 
  sequences of Unicode characters. For example, <code>[ä]</code> should match both &quot;ä&quot; and 
  &quot;a\u0308&quot;. (See <a href="http://www.unicode.org/reports/tr15/">UAX #15: Unicode Normalization</a> 
  [<a href="#Norm">Norm</a>] and <i>Sections 2.5 and 3.9</i> of <i>The Unicode Standard</i> for more 
  information.)</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL2.1</td>
      <td class="rule_head">Canonical Equivalents</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement, an implementation shall provide a mechanism 
      for ensuring that all canonically equivalent literal characters match.</td>
    </tr>
  </table>
  <p>There are two main options for implementing this:</p>
  <ol>
    <li>Before (or during) processing, translate text (and pattern) into a normalized form. This is 
    the simplest to implement, since there are available code libraries for doing normalization </li>
  </ol>
  <ol>
    <li value="2">Expand the regular expression internally into a more generalized regular 
    expression that takes canonical equivalence into account. For example, the expression <code>[a-z 
    ä]</code> can be internally turned into <code>[a-z ä]&nbsp;|&nbsp;(a&nbsp;\u0308)</code>. While this can be 
    faster, it may also be substantially more difficult to generate expressions capturing all of the 
    possible equivalent sequences. </li>
  </ol>
  <p>It may be useful to distinguish a regular-expression engine from the larger software package 
  which uses it. For example, the requirements of this section can be met by requiring the package 
  to normalize text before supplying it to the regular expression engine. However, where the regular 
  expression engine returns offsets into the text, the package may need to map those back to what 
  the offsets would be in the original, unnormalized text.</p>
  <blockquote>
    <p><b>Note:</b> Combining characters are required for many languages. Even when text is in 
    Normalization Form C, there may be combining characters in the text.</p>
  </blockquote>
  <h3><a name="Default_Grapheme_Clusters">2.2 Default Grapheme Clusters</a></h3>
  <p>One or more Unicode characters may make up what the user thinks of as a character. To avoid 
  ambiguity with the computer use of the term <i>character,</i> this is called a <i>grapheme cluster</i>. 
  For example, &quot;G&quot; + <i>acute-accent</i> is a grapheme cluster: it is thought of as a single 
  character by users, yet is actually represented by two Unicode characters.</p>
  <blockquote>
    <p><b>Note: </b>default grapheme clusters were previously referred to as &quot;locale-independent 
    graphemes&quot;. The term <i>cluster</i> has been added to emphasize that the term <i>grapheme</i> as 
    used differently in linguistics. For simplicity and to align with
    <a href="http://www.unicode.org/reports/tr10/">UTS #10: Unicode Collation Algorithm</a> [<a href="#Collation">Collation</a>], 
    the terms &quot;locale-independent&quot; and &quot;locale-dependent&quot; been also changed to &quot;default&quot; and 
    &quot;tailored&quot; respectively.</p>
  </blockquote>
  <p>Essentially, the default grapheme clusters do only two things: they keep Hangul syllables 
  together, and they don&#39;t break before non-spacing marks.</p>
  <p>These <i>default</i> grapheme clusters are not the same as <i>tailored</i> grapheme clusters, 
  which are covered in Level 3, <a href="#Boundaries">Tailored Grapheme Clusters</a>. The default 
  grapheme clusters are determined according to the rules in
  <a href="http://www.unicode.org/reports/tr29/">UTR #29: Text Boundaries</a> [<a href="#Boundaries">Boundaries</a>].</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL2.2</td>
      <td class="rule_head">Default Grapheme Clusters</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide a mechanism 
      for matching against an arbitrary default grapheme cluster, a literal cluster, and matching 
      default grapheme cluster boundaries.</i></td>
    </tr>
  </table>
  <p>For example, an implementation could interpret &quot;\X&quot; as matching any default grapheme cluster, 
  while interpreting &quot;.&quot; as matching any single code point. It could interpret &quot;\h&quot; as a zero-width 
  match against any grapheme cluster boundary, and &quot;\H&quot; as the negation of that.</p>
  <p>Regular expression engines should also provide some mechanism for easily matching against 
  literal clusters, since they are more likely to match user expectations for many languages. One 
  mechanism for doing that is to have explicit syntax for literal clusters, as in the following. 
  This syntax can also be used for tailored grapheme clusters (<a href="#Tailored_Graphemes_Clusters">Tailored 
  Grapheme Clusters</a>).</p>
  <table class="syntax">
    <tr>
      <td width="100%"><code>ITEM := &quot;\q{&quot; CODE_POINT + &quot;}&quot;</code></td>
    </tr>
  </table>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <td><code>[a-z\q{x\u0323}]</code></td>
      <td>Match a-z, and x with an under-dot (used in American Indian languages)</td>
    </tr>
    <tr>
      <td><code>[a-z\q{aa}]</code></td>
      <td>Match a-z, and aa (treated as a single character in Danish).</td>
    </tr>
    <tr>
      <td><code>[a-z ñ \q{ch} \q{ll} \q{rr}]</code></td>
      <td>Match lowercase characters in traditional Spanish.</td>
    </tr>
  </table>
  <p>These can be expressed syntactically by breaking them into combinations of code point sets and 
  other constructs:</p>
  <table class="example">
    <tr>
      <th class="example">Original</th>
      <th class="example">Equivalence</th>
    </tr>
    <tr>
      <td class="example"><code>[a-z ñ \q{ch} \q{ll} \q{rr}]</code></td>
      <td class="example"><code>([[a-z ñ]-[clr]] | c(?!h) | ch | l(?!l) | ll | r(?!r) | rr)</code></td>
    </tr>
  </table>
  <p>This is a bit cumbersome for users: notice the use of the negative lookahead syntax ?! to 
  force, for example, force &quot;c&quot; followed by &quot;h&quot; to match only &quot;ch&quot;. Not only is this cumbersome, but 
  that is not as convenient when other options are added, as in Level 3.</p>
  <p>A typical implementation of the inverse of a set containing literal clusters simply removes 
  those strings, thus <code>[^a-z ñ \q{ch} \q{ll} \q{rr}]</code> is equivalent to <code>[^a-z ñ]</code>. 
  Without literal clusters, intersection and set-difference can be expressed simply as a combination 
  of the other with inverse. However, this is not the case if the implementation of inverse simply 
  removes the strings. Thus:</p>
  <ul>
    <li><code>[\p{letter} - \p{ascii}]</code> is equivalent to <code>[\p{letter} &amp; [^\p{ascii}]]</code></li>
    <li><code>[\p{letter} &amp; \p{ascii}]</code> is equivalent to <code>[\p{letter} - [^\p{ascii}]]</code></li>
    <li><code>[[a\q{rr}] - [a\q{rr}]]</code> is <i>not </i>equivalent to <code>[[a\q{rr}] &amp; [^a\q{rr}]]</code></li>
  </ul>
  <h3><a name="Default_Word_Boundaries">2.3 Default Word Boundaries</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL2.3</td>
      <td class="rule_head">Default Word Boundaries</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide a mechanism 
      for matching Unicode default word boundaries.</i></td>
    </tr>
  </table>
  <p>The simple Level 1 support using simple <code>&lt;word_character&gt;</code> classes is only a very 
  rough approximation of user word boundaries. A much better method takes into account more context 
  than just a single pair of letters. A general algorithm can take care of character and word 
  boundaries for most of the world&#39;s languages. For more information, see
  <a href="http://www.unicode.org/reports/tr29/">UTR #29: Text Boundaries</a> [<a href="#Boundaries">Boundaries</a>].</p>
  <blockquote>
    <p><b>Note: </b>Word boundaries and &quot;soft&quot; line-break boundaries (where one could break in line 
    wrapping) are not generally the same; line breaking has a much more complex set of requirements 
    to meet the typographic requirements of different languages. See
    <a href="http://www.unicode.org/reports/tr14/">UAX #14: Line Breaking Properties</a> [<a href="#LineBreak">LineBreak</a>] 
    for more information. However, soft line breaks are not generally relevant to general regular 
    expression engines.</p>
  </blockquote>
  <p>A fine-grained approach to languages such as Chinese or Thai, languages that do not have 
  spaces, requires information that is beyond the bounds of what a Level 2 algorithm can provide.</p>
  <h3><a name="Default_Loose_Matches">2.4 Default Loose Matches</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL2.4</td>
      <td class="rule_head">Default Loose Matches</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body">To meet this requirement:
      <ul>
        <li>if an implementation provides for case-insensitive matching, then it shall provide at 
        least the full, default Unicode case-insensitive matching.</li>
        <li>if an implementation provides for case conversions, then it shall provide at least the 
        full, default Unicode case conversion.</li>
      </ul>
      </td>
    </tr>
  </table>
  <p>At Level 1, caseless matches do not need to handle cases where one character matches against 
  two. Level 2 includes caseless matches where one character may match against two (or more) 
  characters. For example, 00DF &quot;ß&quot; will match against the two characters &quot;SS&quot;.</p>
  <p>To correctly implement a caseless match and case conversions, see
  <a href="http://www.unicode.org/reports/tr21/">UAX #21: Case Mappings</a> [<a href="#Case">Case</a>]. 
  For ease of implementation, a complete case folding file is supplied at
  <a href="http://www.unicode.org/Public/UNIDATA/CaseFolding.txt">CaseFolding.txt</a> [<a href="#CaseData">CaseData</a>].</p>
  <p>If the implementation containing the regular expression engine also offers case conversions, 
  then these should also be done in accordance with UAX #21, with the full mappings. The relevant 
  data files are <a href="http://www.unicode.org/Public/UNIDATA/SpecialCasing.txt">SpecialCasing.txt</a> 
  [<a href="#SpecialCasing">SpecialCasing</a>] and
  <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.html">UnicodeData.txt</a> [<a href="#UData">UData</a>].</p>
  <h3>2.5 <a name="Name_Properties">Name Properties</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL2.5</td>
      <td class="rule_head">Name Properties</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall support 
      individually named characters.</i></td>
    </tr>
  </table>
  <p>When using names in regular expressions, the main data is supplied in the Name property in the 
  UCD, as described in [<a href="#UDataDoc">UDataDoc</a>], or computed as in the case of CJK 
  Ideographs or Hangul Syllables. Certain code points are not assigned names in the standard. These 
  should be given names based on the General_Category:</p>
  <table class="example">
    <tr>
      <td><b>Control:</b></td>
      <td>The Unicode 1.0 name field (ISO control names).</td>
    </tr>
    <tr>
      <td><b>Private Use:</b></td>
      <td rowspan="2">&lt;no name&gt;</td>
    </tr>
    <tr>
      <td><b>Unassigned:</b></td>
    </tr>
  </table>
  <p>The ISO names for the control characters may be unfamiliar, especially since many people are 
  not familiar with changes in the formal ISO names to make them more language neutral, so it is 
  recommended that they be supplemented with other aliases. For example, for U+0009 the 
  implementation could accept the official name CHARACTER TABULATION, and also the aliases 
  HORIZONTAL TABULATION, HT, and TAB.</p>
  <h4>Individually Named Characters</h4>
  <p>This facility provides syntax for specifying a code point by supplying the precise name, such 
  as the following. This syntax specifies a single code point, which can thus be used in ranges.</p>
  <table class="syntax">
    <tr>
      <td width="100%"><code>&lt;codepoint&gt; := &quot;\N{&quot; &lt;character_name&gt; &quot;}&quot;</code></td>
    </tr>
  </table>
  <p>This is equivalent to using the property <i>name,</i> as in \<code>p{name=WHITE SMILING FACE}</code>. 
  The only distinction between them is that \N should cause a syntax error if it fails to match a 
  character.</p>
  <p>As with other property values, names should use a loose match, disregarding case, spaces and 
  hyphen (&quot;-&quot;) (the underbar character &quot;_&quot; cannot occur in Unicode character names). An 
  implementation may also choose to allow namespaces, where some prefix like &quot;LATIN LETTER&quot; is set 
  globally and used if there is no match otherwise.</p>
  <p>There are, however, three instances that require special-casing with loose matching, where an 
  extra test shall be made for the presence or absence of a hyphen.</p>
  <ul>
    <li>U+0F68 TIBETAN LETTER A and<br>
    <i>U+0F60 TIBETAN LETTER -A</i> </li>
    <li>U+0FB8 TIBETAN SUBJOINED LETTER A and<br>
    <i>U+0FB0 TIBETAN SUBJOINED LETTER -A</i> </li>
    <li>U+116C HANGUL JUNGSEONG OE and<br>
    <i>U+1180 HANGUL JUNGSEONG O-E</i></li>
  </ul>
  <p>&nbsp;Examples:</p>
  <ul>
    <li><code>\N{WHITE SMILING FACE}</code> or <code>\N{whitesmilingface}</code> is equivalent to
    <code>\u263A</code></li>
    <li><code>\N{GREEK SMALL LETTER ALPHA}</code> is equivalent to <code>\u03B1</code></li>
    <li><code>\N{FORM FEED}</code> is equivalent to <code>\u000C</code></li>
    <li><code>\N{SHAVIAN LETTER PEEP}</code> is equivalent to <code>\U00010450</code></li>
    <li><code>[\N{GREEK SMALL LETTER ALPHA}-\N{GREEK SMALL LETTER BETA}]</code> is equivalent to
    <code>[\u03B1-\u03B2]</code></li>
  </ul>
  <h3>2.6 <a name="Wildcard_Properties">Wildcard Properties</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL2.5</td>
      <td class="rule_head">Wildcard Properties</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall support Unicode 
      properties with wildcards.</i></td>
    </tr>
  </table>
  <p>Instead of a single property value, this feature allows the use of a regular expression to pick 
  out a set of characters based on whether the property values match the regular expression. The 
  regular expression must support at least wild-cards; other regular expressions features are 
  recommended but optional.</p>
  <blockquote>
    <p><b>Note: </b>Where regular expressions are using in matching, case, spaces, hyphen, and 
    underbar are significant; it is presumed that people will use regular-expression features to 
    ignore these if desired.</p>
  </blockquote>
  <p><i>Examples, where &quot;.*&quot; matches any character, | is alternation, and (...) is grouping:</i></p>
  <table class="example">
    <tr>
      <td><b><code>\p{name=/LATIN LETTER.*P/}</code> is equivalent to:</b></td>
    </tr>
    <tr>
      <td><code>01AA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # LATIN LETTER REVERSED 
      ESH LOOP<br>
      0294&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # LATIN LETTER GLOTTAL STOP<br>
      0296&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # LATIN LETTER INVERTED GLOTTAL 
      STOP<br>
      1D18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # LATIN LETTER SMALL CAPITAL P</code></td>
    </tr>
    <tr>
      <td><b><code>\p{name=/.*VARIA(TION|NT).*/}</code> is equivalent to:</b></td>
    </tr>
    <tr>
      <td><code>180B..180D&nbsp;&nbsp;&nbsp; # MONGOLIAN FREE VARIATION SELECTOR ONE..</code><code>~ 
      ~ ~ ~ </code><code>THREE<br>
      299C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # RIGHT ANGLE VARIANT WITH SQUARE<br>
      303E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # IDEOGRAPHIC VARIATION INDICATOR<br>
      FE00..FE0F&nbsp;&nbsp;&nbsp; # VARIATION SELECTOR-1..</code><code>~ ~</code><code>16<br>
      E0100..E01EF&nbsp; # VARIATION SELECTOR-17..</code><code>~ ~</code><code>256</code></td>
    </tr>
    <tr>
      <td><b><code>\p{nfd=/.*b.*/}</code> is equivalent to:</b></td>
    </tr>
    <tr>
      <td><code>0062 # Ll [1] U+0062 LATIN SMALL LETTER B<br>
      1E03 # Ll [1] U+1E03 LATIN SMALL LETTER B WITH DOT ABOVE<br>
      1E05 # Ll [1] U+1E05 LATIN SMALL LETTER B WITH DOT BELOW<br>
      1E07 # Ll [1] U+1E07 LATIN SMALL LETTER B WITH LINE BELOW</code></td>
    </tr>
  </table>
  <p>The above are all on the basis of Unicode 4.0; different versions of Unicode may produce 
  different results.</p>
  <hr align="LEFT">
  <h2><a name="Tailored_Support">3 Tailored Support</a>: <a name="Level_3">Level 3</a></h2>
  <p>All of the above deals with a default specification for a regular expression. However, a 
  regular expression engine also may want to support tailored specifications, typically tailored for 
  a particular language or locale. This may be important when the regular expression engine is being 
  used by end-users instead of programmers, such as in a word-processor allowing some level of 
  regular expressions in searching.</p>
  <p>For example, the order of Unicode characters may differ substantially from the order expected 
  by users of a particular language. The regular expression engine has to decide, for example, 
  whether the list <code>[a-ä]</code> means:</p>
  <ul>
    <li>the Unicode characters in binary order between <code>0061<sub>16</sub></code> and <code>00E5<sub>16</sub></code> 
    (including &#39;<code>z</code>&#39;, &#39;<code>Z</code>&#39;, &#39;[&#39;, and &#39;<code>¼</code>&#39;), <i>or</i> </li>
    <li>the letters in that order in the users&#39; locale (which <i>does not</i> include &#39;<code>z</code>&#39; 
    in English, but <i>does</i> include it in Swedish). </li>
  </ul>
  <p>If both tailored and default regular expressions are supported, then a number of different 
  mechanism are affected. There are a two main alternatives for control of tailored support:</p>
  <ul>
    <li><i>coarse-grained support:</i> the whole regular expression (or the whole script in which 
    the regular expression occurs) can be marked as being tailored. </li>
    <li><i>fine-grained support:</i> any part of the regular expression can be marked in some way as 
    being tailored. </li>
  </ul>
  <p>For example, fine-grained support could use some syntax like the following indicate tailoring 
  to a locale within a certain range. (Marking locales is generally specified by means of the common 
  ISO 639 and 3166 tags, such as &quot;en_US&quot;. For more information on these tags, see the online data in 
  [<a href="http://www.unicode.org/onlinedat/online.html">Online</a>].)</p>
  <table class="syntax">
    <tr>
      <td width="100%">
      <pre>\T{&lt;locale&gt;}..\E</pre>
      </td>
    </tr>
  </table>
  <p>Level 3 support may be considerably slower than Level 2, and some scripts may require either 
  Level 1 or Level 2 matches instead. Thus there must be some sort of syntax that will allow Level 3 
  support to be turned on and off. Because tailored regular expression patterns are usually quite 
  specific to the locale, and will generally not work across different locales, the syntax should 
  also specify the particular locale or other tailoring customization that the pattern was designed 
  for.</p>
  <p>Sections 3.6 and following describe some additional capabilities of regular expression engines 
  that are very useful in a Unicode environment, especially in dealing with the complexities of the 
  large number of writing systems and languages expressible in Unicode.</p>
  <h3><a name="Tailored_Properties">3.1. Tailored Punctuation</a></h3>
  <p>The Unicode character properties for punctuation may vary from language to language or from 
  country to country. In most cases, the effects of such changes will be apparent in other 
  operations, such as a determination of word breaks. But there are other circumstances where the 
  effects should be apparent in the general APIs, such as when testing whether a curly quotation 
  mark is <i>opening</i> or <i>closing</i> punctuation may vary.</p>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.1</td>
      <td class="rule_head">Tailored Punctuation</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall allow for 
      punctuation properties to be tailored according to locale.</i></td>
    </tr>
  </table>
  <p>As described in 3.0, there must be the capability of turning this support on or off.</p>
  <h3><a name="Tailored_Graphemes_Clusters">3.2 Tailored Grapheme Clusters</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.2</td>
      <td class="rule_head">Tailored Grapheme Clusters</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for 
      collation grapheme clusters matches based on a locale&#39;s collation order.</i></td>
    </tr>
  </table>
  <p>Tailored grapheme clusters may be somewhat different than the default grapheme clusters 
  discussed in Level 2. They are coordinated with the collation ordering for a given language in the 
  following way. A collation ordering determines a <i>collation grapheme cluster</i>, which is a 
  sequence of characters that is treated as a unit by the ordering. For example, <i>ch</i> is a 
  collation character for a traditional Spanish ordering. More specifically, a collation character 
  is the longest sequence of characters that maps to a sequence of one or more collation elements 
  where the first collation element has a primary weight and subsequent elements do not, and no 
  completely ignorable characters are included.</p>
  <p>The tailored grapheme clusters for a particular locale are the collation characters for the 
  collation ordering for that locale. The determination of tailored grapheme clusters requires the 
  regular expression engine to either draw upon the platform&#39;s collation data, or incorporate its 
  own tailored data for each supported locale.</p>
  <p>See <a href="http://www.unicode.org/reports/tr10/">UTS #10: Unicode Collation Algorithm</a> [<a href="#Collation">Collation</a>] 
  for more information about collation, and <a href="#Sample_Collation_Character_Code">Annex B. 
  Sample Collation Character Code</a> for sample code.</p>
  <h3><a name="Tailored_Word_Boundaries">3.3 Tailored Word Boundaries</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.3</td>
      <td class="rule_head">Tailored Word Boundaries</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall allow for the 
      ability to have word boundaries to be tailored according to locale.</i></td>
    </tr>
  </table>
  <p>Semantic analysis may be required for correct word boundary detection in languages that don&#39;t 
  require spaces, such as Thai, Japanese, Chinese or Korean. This can require fairly sophisticated 
  support if Level 3 word boundary detection is required, and usually requires drawing on platform 
  OS services.</p>
  <h3><a name="Tailored_Loose_Matches">3.4 Tailored Loose Matches</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.4</td>
      <td class="rule_head">Tailored Loose Matches</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for loose 
      matches based on a locale&#39;s collation order, with at least 3 levels.</i></td>
    </tr>
  </table>
  <p>In Level 1 and 2, caseless matches are described, but there are other interesting linguistic 
  features that users may want to match. For example, <i>V</i> and <i>W</i> are considered 
  equivalent in Swedish collations, and so [V] should match <i>W</i> in Swedish. In line with the
  <a href="http://www.unicode.org/reports/tr10/">UTS #10: Unicode Collation Algorithm</a> [<a href="#Collation">Collation</a>], 
  at the following four levels of equivalences are recommended:</p>
  <ul>
    <li>exact match: bit-for-bit identity </li>
    <li>tertiary match: disregard 4th level differences (language tailorings) </li>
    <li>secondary match: disregard 3rd level differences such as upper/lowercase and compatibility 
    variation (e.g. matching both half-width and full-width katakana). </li>
    <li>primary match: disregard accents, case and compatibility variation; also disregard 
    differences between katakana and hiragana. </li>
  </ul>
  <p>If users are to have control over these equivalence classes, here is an example of how the 
  sample syntax could be modified to account for this. The syntax for switching the strength or type 
  of matching varies widely. Note that these tags switch behavior on and off in the middle of a 
  regular expression; they do not match a character.</p>
  <table class="syntax">
    <tr>
      <td width="100%">
      <pre>ITEM := \v{PRIMARY}   // match primary only
ITEM := \v{SECONDARY} // match primary &amp; secondary only
ITEM := \v{TERTIARY}  // match primary, secondary, tertiary
ITEM := \v{EXACT}     // match all levels, normal state</pre>
      </td>
    </tr>
  </table>
  <p><i>Examples:</i></p>
  <table class="example">
    <tr>
      <td><code>[\v{SECONDARY}a-m]</code></td>
      <td>Match a-m, plus case variants A-M, plus compatibility variants</td>
    </tr>
  </table>
  <p>Basic information for these equivalence classes can be derived from the data tables referenced 
  by <a href="http://www.unicode.org/reports/tr10/">UTS #10: Unicode Collation Algorithm</a> [<a href="#Collation">Collation</a>].</p>
  <h3><a name="Tailored_Ranges">3.5. Tailored Ranges</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.5</td>
      <td class="rule_head">Tailored Ranges</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for ranges 
      based on a locale&#39;s collation order.</i></td>
    </tr>
  </table>
  <p>Tailored character ranges will include tailored grapheme clusters, as discussed above. This 
  broadens the set of grapheme clusters — in traditional Spanish, for example, <code>[b-d]</code> 
  would match against &quot;<code>ch</code>&quot;.</p>
  <blockquote>
    <p><b>Note: </b>this is another reason why a property for all characters <code>\p{Any}</code> is 
    needed—it is possible for a locale&#39;s collation to not have <code>[\u0000-\U0010FFFF]</code> 
    encompass all characters.</p>
  </blockquote>
  <p>Languages may also vary whether they consider lowercase below uppercase or the reverse. This 
  can have some surprising results: <code>[a-Z]</code> may not match anything if <i>Z &lt; a</i> in 
  that locale!</p>
  <h3>3.6 <a name="Context_Matching">Context Matching</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.6</td>
      <td class="rule_head">Context Matching</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for a 
      restrictive match against input text, allowing for context before and after the match.</i></td>
    </tr>
  </table>
  <p>For parallel, filtered transformations, such as involved in script transliteration, it is 
  important to restrict the matching of a regular expression to a substring of a given string, and 
  yet allow for context before and after the affected area. Here is a sample API that implements 
  such functionality, where m is an extension of a Regex
  <a href="http://java.sun.com/j2se/1.4.1/docs/api/java/util/regex/Matcher.html">Matcher</a>.</p>
  <pre>  if (m.matches(text, contextStart, targetStart, targetLimit, contextLimit)) {
    int end = p.getMatchEnd();
  }</pre>
  <p>The range of characters between <code>contextStart</code> and <code>targetStart</code> define a
  <i>precontext</i>; the characters between <code>targetStart</code> and <code>targetLimit</code> 
  define a <i>target</i>, and the offsets between <code>targetLimit</code> and <code>contextLimit</code> 
  define a <i>postcontext</i>. Thus <code>contextStart</code> ≤ <code>targetStart</code> ≤ <code>
  targetLimit</code> ≤ <code>contextLimit</code>. The meaning of this function is that</p>
  <ul>
    <li>a match is attempted beginning at <code>targetStart</code>.</li>
    <li>the match will only succeed with an endpoint at or less than <code>targetLimit</code>.</li>
    <li>any zero-width look-arounds (look-aheads or look-behinds) can match characters inside or 
    outside of the target, but cannot match characters outside of the context.</li>
  </ul>
  <p><i>Examples:</i></p>
  <p>In these examples, the text in the pre- and postcontext is italicized and the target is 
  underlined. In the output column, the text in <b>bold<font color="#00FF00"> </font></b>is the 
  matched portion. The pattern syntax &quot;(←x)&quot; means a backwards match for <i>x</i> (without moving 
  the cursor) This would be <code>(?&lt;=x)</code> in Perl. The pattern &quot;(→x)&quot; means a forwards match 
  for <i>x</i> (without moving the cursor). This would be <code>(?=x)</code> in Perl.</p>
  <div align="center">
    <center>
    <table border="1" cellspacing="0" cellpadding="4">
      <tr>
        <th width="30%" align="center">Pattern</th>
        <th width="10%" align="center">Input</th>
        <th width="10%" align="center">Output</th>
        <th align="center">Comment</th>
      </tr>
      <tr>
        <td align="center">/(←a) (bc)* (→d)/</td>
        <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
        <td align="center">1<i>a</i><u><b>bcbc</b></u><i>d</i>2</td>
        <td align="center">matching with context</td>
      </tr>
      <tr>
        <td align="center">/(←a) (bc)* (→bcd)/</td>
        <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
        <td align="center">1<i>a</i><u><b>bc</b>bc</u><i>d</i>2</td>
        <td align="center">stops early, since otherwise &#39;d&#39; wouldn&#39;t match.</td>
      </tr>
      <tr>
        <td align="center">/(bc)*d/</td>
        <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
        <td align="center"><i>no match</i></td>
        <td align="center">&#39;d&#39; can&#39;t be matched in the target, only in the postcontext</td>
      </tr>
      <tr>
        <td align="center">/(←a) (bc)* (→d)/</td>
        <td align="center">1a<u>bcbc</u><i>d</i>2</td>
        <td align="center"><i>no match</i></td>
        <td align="center">&#39;a&#39; can&#39;t be matched, since it is before the precontext (which is 
        zero-length, here)</td>
      </tr>
    </table>
    </center>
  </div>
  <p>While it would be possible to simulate this API call with other regular expression calls, it 
  would require subdividing the string and making multiple regular expression engine calls, 
  significantly affecting performance.</p>
  <p>There should also be pattern syntax for matches (like ^ and $) for the <code>contextStart</code> 
  and <code>contextLimit</code> positions.</p>
  <blockquote>
    <p>Internally, this can be implemented by modifying the regular expression engine so that all 
    matches are limited to characters between <code>contextStart</code> and <code>contextLimit</code>, 
    and that all matches that are not zero-width look-arounds are limited to the characters between
    <code>targetStart</code> and <code>targetLimit</code>.</p>
  </blockquote>
  <h3>3.7 <a name="Partial_Matches">Incremental Matches</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.7</td>
      <td class="rule_head">Incremental Matches</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for 
      incremental matching.</i></td>
    </tr>
  </table>
  <p>For buffered matching, one needs to be able to return whether there is a partial match; that 
  is, whether there <i>would be</i> a match if additional characters were added after the <code>
  targetLimit</code>. This can be done with a separate method having an enumerated return value: <i>
  match</i>, <i>no_match</i>, or <i>partial_match</i>.</p>
  <pre>  if (m.incrementalmatches(text, cs, ts, tl, cl) == Matcher.MATCH) {
    ...
  }</pre>
  <p>Thus performing an incremental match of <code>/bcbce(→d)/</code> against &quot;1a<u>bcbc</u><i>d</i>2&quot; 
  would return a <i>partial_match</i> because the addition of an <i>e</i> to the end of the target 
  would allow it to match. Note that <code>/(bc)*(→d)/</code> would <i>also</i> return a partial 
  match, because if <i>bc</i> were added at the end of the target, it would match.</p>
  <p>Here is the above table, when an incremental match method is called:</p>
  <table border="1" cellspacing="0" cellpadding="4">
    <tr>
      <th width="30%" align="center">Pattern</th>
      <th width="10%" align="center">Input</th>
      <th width="10%" align="center">Output</th>
      <th align="center">Comment</th>
    </tr>
    <tr>
      <td align="center">/(←a) (bc)* (→d)/</td>
      <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
      <td align="center"><i>partial match</i></td>
      <td align="center">&#39;bc&#39; could be inserted.</td>
    </tr>
    <tr>
      <td align="center">/(←a) (bc)* (→bcd)/</td>
      <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
      <td align="center"><i>partial match</i></td>
      <td align="center">&#39;bc&#39; could be inserted.</td>
    </tr>
    <tr>
      <td align="center">/(bc)*d/</td>
      <td align="center">1<i>a</i><u>bcbc</u><i>d</i>2</td>
      <td align="center"><i>partial match</i></td>
      <td align="center">&#39;d&#39; could be inserted.</td>
    </tr>
    <tr>
      <td align="center">/(←a) (bc)* (→d)/</td>
      <td align="center">1a<u>bcbc</u><i>d</i>2</td>
      <td align="center"><i>no match</i></td>
      <td align="center">as with the matches function; the backwards search for &#39;a&#39; fails.</td>
    </tr>
  </table>
  <p>The typical usage of incremental match is to make a series of incremental match calls, marching 
  through a buffer with each successful match. At the end, if there is a partial match, one loads 
  another buffer (or waits for other input). When the process terminates (no more buffers/input 
  available), then a regular match call is made.</p>
  <blockquote>
    <p>Internally, incremental matching can be implemented in the regular expression engine by 
    detecting whether the matching process ever fails when the current position is at or after <code>
    targetLimit</code>, and setting a flag if so. If the overall match fails, and this flag is set, 
    then the return value is set to <i>partial_match</i>. Otherwise, either <i>match</i> or <i>
    no_match</i> is returned, as appropriate.</p>
  </blockquote>
  <p>The return value <i>partial_match</i> indicates that there was a partial match: if further 
  characters were added there could be a match to the resulting string. It may be useful to divide 
  this return value into two, instead:</p>
  <ul>
    <li><i>extendable_match</i>: in addition to there being a partial match, there was also a match 
    somewhere in the string. For example, when matching /(ab)*/ against &quot;aba&quot;, there is a match, <i>
    and</i> if other characters were added (&quot;a&quot;, &quot;aba&quot;,...) there could also be another match.</li>
    <li><i>only_partial_match</i>: there was no other match in the string. For example, when 
    matching /abcd/ against &quot;abc&quot;, there is only a partial match; there would be no match unless 
    additional characters were added.</li>
  </ul>
  <h3>3.8 <a name="Unicode_Set_Sharing">Unicode Set Sharing</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.8</td>
      <td class="rule_head">Unicode Set Sharing</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for shared 
      storage of Unicode sets.</i></td>
    </tr>
  </table>
  <p>For script transliteration and similar applications, there may be a hundreds of regular 
  expressions, sharing a number of Unicode sets in common. These Unicode sets, such as <code>[\p{Alphabetic} 
  - \p{Latin}]</code>, could take a fair amount of memory, since they would typically be expanded 
  into an internal memory representation that allows for fast lookup. If these sets separately 
  stored, this means an excessive memory burden.</p>
  <p>To reduce the storage requirements, an API may allow regular expressions to share storage of 
  these and other constructs, by having a &#39;pool&#39; of data associated with a set of compiled regular 
  expressions.</p>
  <pre>rules.registerSet(&quot;$lglow&quot;, &quot;[\p{lowercase}&amp;[\p{latin}\p{greek}]] &quot;);
rules.registerSet(&quot;$mark&quot;, &quot;[\p{Mark}]&quot;);
...
rules.add(&quot;θ&quot;, &quot;th&quot;);
rules.add(&quot;Θ(→$mark*$lglow)&quot;, &quot;Th&quot;);
rules.add(&quot;Θ&quot;, &quot;TH&quot;);
...
rules.add(&quot;φ&quot;, &quot;th&quot;);
rules.add(&quot;Ψ(→$mark*$lglow)&quot;, &quot;Ps&quot;);
rules.add(&quot;Ψ&quot;, &quot;PS&quot;);
...</pre>
  <h3>3.9 <a name="Possible_Match_Sets">Possible Match Sets</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.9</td>
      <td class="rule_head">Possible Match Sets</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for the 
      generation of possible match sets from any regular expression pattern.</i></td>
    </tr>
  </table>
  <p>There are a number of circumstances where additional functions on regular expression patterns 
  can be useful for performance or analysis of those patterns. These are functions that return 
  information about the sets of characters that a regular expression can match.</p>
  <p>When applying a list of regular expressions (with replacements) against a given piece of text, 
  one can do that either serially or in parallel. With a serial application, each regular expression 
  is applied the text, repeatedly from start to end. With parallel application, each position in the 
  text is checked against the entire list, with the first match winning. After the replacement, the 
  next position in the text is checked, and so on.</p>
  <p>For such a parallel process to be efficient, one needs to be able to winnow out the regular 
  expressions that simply could not match text starting with a given code point. For that, it is 
  very useful to have a function on a regular expression pattern that returns a set of all the code 
  points that the pattern would partially or fully match.</p>
  <pre>   myFirstMatchingSet = pattern.getFirstMatchSet(Regex.POSSIBLE_FIRST_CODEPOINT);</pre>
  <p>For example, the pattern <code>/[[\u0000-\u00FF] &amp; [:Latin:]] * [0-9]/</code> would return the 
  set {0..9, A..Z, a..z}. Logically, this is the set of all code points that would be at least 
  partial matches (if considered in isolation).</p>
  <blockquote>
    <p>Note: an additional useful function would be one that returned the set of all code points 
    that could be matched at any point. Thus a code point outside of this set cannot be in any part 
    of a matching range.</p>
  </blockquote>
  <p>The second useful case is the set of all code points that could be matched in any particular 
  group, that is, that could be set in the standard $0, $1, $2, etc. variables.</p>
  <pre>   myAllMatchingSet = pattern.getAllMatchSet(Regex.POSSIBLE_IN$0);</pre>
  <blockquote>
    <p>Internally, this can be implemented by analysing the regular expression (or parts of it) 
    recursively to determine which characters match. For example, the first match set of an 
    alternation <i>(a | b)</i> is the union of the first match sets of the terms <i>a</i> and <i>b</i>.</p>
    <p>The set that is returned is only guaranteed to <i>include</i> all possible first characters; 
    if an expression gets too complicated it could be a proper superset of all the possible 
    characters.</p>
  </blockquote>
  <h3>3.10 <a name="Folded_Matching">Folded Matching</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.10</td>
      <td class="rule_head">Folded Matching</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for 
      registration of folding functions for providing insensitive matching for linguistic features 
      other than case.</i></td>
    </tr>
  </table>
  <p>Regular expressions typically provide for case-sensitive or case-insensitive matching. This 
  accounts for the fact that in English and many other languages, users quite often want to 
  disregard the differences between characters that are solely due to case. It would be quite 
  awkward to do this manually: for example, to do a caseless match against the last name in <code>
  /Mark\sDavis/</code>, one would have to use the pattern <code>/Mark\s<u><font color="#0000FF">[Dd][Aa][Vv][Ii][Ss]</font></u>/</code>, 
  instead of some syntax that can indicate that the target text is to be matched after folding case, 
  such as <code>/Mark\s<font color="#0000FF"><u>\C</u></font>Davis<font color="#0000FF"><u>\E</u></font>/</code>.</p>
  <p>For many languages and writing systems, there are other differences besides case where users 
  want to allow a loose match. Once such way to do this is given above in the discussion of matching 
  according to collation strength. There are others: for example, for Ethiopic one may need to match 
  characters independent of their inherent vowel, or match certain types of vowels. It is difficult 
  to tell exactly which ways people might want to match text for different languages, so the most 
  flexible way to provide such support is to provide a general mechanism for overriding the way that 
  regular expressions match literals.</p>
  <p>One way to do this is to use <i>folding</i> functions. These are functions that map strings to 
  strings, and are idempotent (applying a function more than once produces the same result: <i>f(f(x)) 
  = f(x)</i>. There are two parts to this: (a) allow folding functions to be registered, and (b) 
  extend patterns so that registered folding functions can be activated. During the span of text in 
  which a folding function is activated, both the pattern literals and the input text will be 
  processed according to the folding before comparing. For example:</p>
  <pre><span class="CComment">// Folds katakana and hiragana together</span>
class KanaFolder implements RegExFolder {
  <span class="CComment">// from RegExFolder, must be overridden in subclasses</span>
  String fold(String source) {...}

  <span class="CComment">// from RegExFolder, may be overridden for efficiency</span>
  RegExFolder clone(String parameter, Locale locale) {...}
  int fold(int source) {...}
  UnicodeSet fold(UnicodeSet source) {...}
}
  ...

  RegExFolder.registerFolding(&quot;k_h&quot;, new KanaFolder());

  ...

  p = Pattern.compile(&quot;(<span style="color: #0000FF">\F{k_h=argument}</span>マルク (\s)* ダ (ヸ | ビ) ス <span style="color: #0000FF">\E</span> : \s+)*&quot;);</pre>
  <p>In the above example, the Kana folding is in force until terminated with
  <span style="color: #0000FF">\E</span>. Within the scope of the folding, all text in the target 
  would be folded before matching (the literal text in the pattern would also be folded). This only 
  affects literals; regular expression syntax such as &#39;(&#39; or &#39;*&#39; are unaffected.</p>
  <p>While it is sufficient to provide a folding function for strings, for efficiency one can also 
  provide functions for folding single code points and Unicode sets (e.g. [a-z...]). For more 
  information, see [<a href="#Folding">Folding</a>].</p>
  <h3>3.11 <a name="Submatchers">Submatchers</a></h3>
  <table class="noborder">
    <tr>
      <td class="rule_head">RL3.11</td>
      <td class="rule_head">Submatchers</td>
    </tr>
    <tr>
      <td class="rule_body"></td>
      <td class="rule_body"><i>To meet this requirement, an implementation shall provide for general 
      registration of matching functions for providing matching for general linguistic features.</i></td>
    </tr>
  </table>
  <p>There are over 70 properties in the Unicode character database, yet there are many other 
  sequences of characters that people may want to match, many of them specific to given languages. 
  For example, characters that are used as vowels may vary by language. This goes beyond 
  single-character properties, since certain sequences of characters may need to be matched; such 
  sequences may not be easy themselves to express using regular expressions. Extending the regular 
  expression syntax to provide for registration of arbitrary properties of characters allows these 
  requirements to be handled.</p>
  <p>The following provides an example of this. The actual function is just for illustration.</p>
  <pre>class MultipleMatcher implements RegExSubmatcher {
  <span class="CComment">// from RegExFolder, must be overridden in subclasses
  /**
   * Returns -1 if there is no match; otherwise returns the endpoint;
   * an offset indicating how far the match got.
   * The endpoint is always between targetStart and targetLimit, inclusive.
   * Note that there may be zero-width matches.
   */</span>
  int match(String text, int contextStart, int targetStart, int targetLimit, int contextLimit) {
    <span class="CComment">// code for matching numbers according to numeric value.</span>
  }

  <span class="CComment">// from RegExFolder, may be overridden for efficiency
  /**
   * The parameter is a number. The match will match any numeric value that is a multiple.
   * Example: for &quot;2.3&quot;, it will match &quot;0002.3000&quot;, &quot;4.6&quot;, &quot;11.5&quot;, and any non-Western
   * script variants, like Indic numbers.
   */</span>
  RegExSubmatcher clone(String parameter, Locale locale) {...}
}
  ...

  RegExSubmatcher.registerMatcher(&quot;multiple&quot;, new MultipleMatcher());

  ...

  p = Pattern.compile(&quot;xxx<span style="color: #0000FF">\M{multiple=2.3}</span>xxx&quot;);</pre>
  <p>In this example, the match function can be written to parse numbers according to the 
  conventions of different locales, based on OS functions available for doing such parsing. If there 
  are mechanisms for setting a locale for a portion of a regular expression, then that locale would 
  be used; otherwise the default locale would be used.</p>
  <blockquote>
    <p><b>Note:</b> It might be advantageous to make the Submatcher API identical to the Matcher 
    API; that is, only have one base class &quot;Matcher&quot;, and have user extensions derive from the base 
    class. The base class itself can allow for nested matchers.</p>
  </blockquote>
  <hr>
  <h2><a name="Character_Blocks">Annex A. Character Blocks</a></h2>
  <p>The Block property from the Unicode Character Database can be a useful property for quickly 
  describing a set of Unicode characters. It assigns a name to segments of the Unicode codepoint 
  space; for example, <code>[\u0370-\u03FF]</code> is the Greek block.</p>
  <p>However, block names need to be used with discretion; they are very easy to misuse since they 
  only supply a very coarse view of the Unicode character allocation. For example:</p>
  <ul>
    <li><b>Blocks are not at all exclusive.</b> There are many mathematical operators that are not 
    in the Mathematical Operators block; there are many currency symbols not in Currency Symbols, 
    etc.</li>
    <li><b>Blocks may include characters not assigned in the current version of Unicode. </b>This 
    can be both an advantage and disadvantage. Like the General Property, this allows an 
    implementation to handle characters correctly that are not defined at the time the 
    implementation is released. However, it also means that depending on the current properties of 
    assigned characters in a block may fail. For example, all characters in a block may currently be 
    letters, but this may not be true in the future.</li>
    <li><b>Writing systems may use characters from multiple blocks: </b>English uses characters from 
    Basic Latin and General Punctuation, Syriac uses characters from both the Syriac and Arabic 
    blocks, various languages use Cyrillic plus a few letters from Latin, etc.</li>
    <li><b>Characters from a single writing system may be split across multiple blocks.</b> See the 
    table below. Moreover, presentation forms for a number of different scripts may be collected in 
    blocks like Alphabetic Presentation Forms or Halfwidth and Fullwidth Forms.</li>
  </ul>
  <p>The following table illustrates the mismatch between writing systems and blocks. These are only 
  examples; this table is not a complete analysis. It also doesn&#39;t include common punctuation used 
  with all of these writing systems.</p>
  <table>
    <caption>Writing Systems vs. Blocks</caption>
    <tr>
      <th align="left">Writing Systems</th>
      <th align="left">Blocks</th>
    </tr>
    <tr>
      <td>Latin&nbsp;&nbsp;</td>
      <td>Basic Latin, Latin-1 Supplement, Latin Extended-A, Latin Extended-B, Latin Extended 
      Additional, Diacritics</td>
    </tr>
    <tr>
      <td>Greek&nbsp;&nbsp;</td>
      <td>Greek, Greek Extended, Diacritics</td>
    </tr>
    <tr>
      <td>Arabic&nbsp;&nbsp;</td>
      <td>Arabic, Arabic Presentation Forms-A, Arabic Presentation Forms-B</td>
    </tr>
    <tr>
      <td>Korean</td>
      <td>Hangul Jamo, Hangul Compatibility Jamo, Hangul Syllables, CJK Unified Ideographs, CJK 
      Unified Ideographs Extension A, CJK Compatibility Ideographs, CJK Compatibility Forms, 
      Enclosed CJK Letters and Months, Small Form Variants</td>
    </tr>
    <tr>
      <td>Yi&nbsp;&nbsp;</td>
      <td>Yi Syllables, Yi Radicals</td>
    </tr>
    <tr>
      <td>Chinese</td>
      <td>CJK Unified Ideographs, CJK Unified Ideographs Extension A, CJK Compatibility Ideographs, 
      CJK Compatibility Forms, Enclosed CJK Letters and Months, Small Form Variants, Bopomofo, 
      Bopomofo Extended</td>
    </tr>
  </table>
  <p>For the above reasons, Script values are generally preferred to Block values. Even there, they 
  should be used in accordance with the guidelines in <a href="http://www.unicode.org/reports/tr24/">
  UTR #24: Script Names</a> [<a href="#ScriptDoc">ScriptDoc</a>].</p>
  <h2><a name="Sample_Collation_Character_Code">Annex B: Sample Collation Character Code</a></h2>
  <p>The following provides sample code for doing Level 3 collation character detection. This code 
  is meant to be illustrative, and has not been optimized. Although written in Java, it could be 
  easily expressed in any programming language that allows access to the Unicode Collation Algorithm 
  mappings.</p>
  <pre><span style="color: #0000FF">/**
 * Return the end of a collation character.
 * @param s         the source string
 * @param start     the position in the string to search
 *                  forward from
 * @param collator  the collator used to produce collation elements.
 * This can either be a custom-built one, or produced from
 * the factory method Collator.getInstance(someLocale).
 * @return          the end position of the collation character
 */</span>

static int getLocaleCharacterEnd(String s,
  int start, RuleBasedCollator collator) {
    int lastPosition = start;
    CollationElementIterator it 
      = collator.getCollationElementIterator(
          s.substring(start, s.length()));
    it.next(); <span style="color: #0000FF">// discard first collation element</span>
    int primary;
        
    <span style="color: #0000FF">// accumulate characters until we get to a non-zero primary</span>
        
    do {
        lastPosition = it.getOffset();
        int ce = it.next();
        if (ce == CollationElementIterator.NULLORDER) break;
        primary = CollationElementIterator.primaryOrder(ce);
    } while (primary == 0);
    return lastPosition;
}</pre>
  <h2>Annex C: <a name="Compatibility_Properties">Compatibility Properties</a></h2>
  <p>The following are recommended assignments for compatibility property names, for use in Regular 
  Expressions.<span class="changedspan"> There are two alternatives: the Standard Recommendation and 
  the POSIX Compatible versions. The latter is modified to meet the formal requirements of [POSIX], 
  and also to maintain (as much as possible compatibility) with the usage in practice. So, for 
  example, \p{Lowercase} and \p{Uppercase} are merged into <b>alpha</b>, since one of the POSIX 
  requirements is that <b>alpha</b> contain <b>lower</b> and <b>upper</b> <font SIZE="3">—</font> 
  and there are a few Unicode Symbols that are Lowercase bug not included in Alphabetic. Similarly, 
  since sometimes alpha is used in practice (incorrectly) for word breaks, ZWNJ and ZWJ are added so 
  that they do not break words.</span></p>
  <table border="1" cellspacing="0" cellpadding="2">
    <tr>
      <th class="heading">Property</th>
      <th class="heading"><span class="changedspan">Standard Recommendation</span></th>
      <th class="heading"><span class="changedspan">POSIX Compatible</span></th>
      <th class="heading">Comments</th>
    </tr>
    <tr>
      <td><b><a name="alpha">alpha</a></b></td>
      <td class="recommended">\p{Alphabetic}</td>
      <td class="recommended">\p{Alphabetic}<br>
      <span class="changedspan">\p{Lowercase}<br>
      \p{Uppercase}<br>
      \N{ZERO WIDTH NON-JOINER}<br>
      \N{ZERO WIDTH JOINER}</span></td>
      <td>Alphabetic includes more than gc = Letter. Note that marks (Me, Mn, Mc) are required for 
      words of many languages. While they could be applied to non-alphabetics, their principle use 
      is on alphabetics. See
      <a href="http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt">
      DerivedCoreProperties</a> [<a href="#UCD">UCD</a>] for Alphabetic, also
      <a href="http://www.unicode.org/Public/UNIDATA/extracted/DerivedGeneralCategory.txt">
      DerivedGeneralCategory</a> [<a href="#UCD">UCD</a>].<p>Alphabetic should <i>not</i> be used as 
      an approximation for word boundaries: see <a href="#word">word</a> below.</td>
    </tr>
    <tr>
      <td><b><a name="lower">lower</a></b></td>
      <td class="recommended">\p{Lowercase}</td>
      <td class="recommended">\p{Lowercase}</td>
      <td>Lowercase includes more than gc = Lowercase_Letter (Ll). See
      <a href="http://www.unicode.org/Public/UNIDATA/DerivedCoreProperties.txt">
      DerivedCoreProperties</a> [<a href="#UCD">UCD</a>]. </td>
    </tr>
    <tr>
      <td><b><a name="upper">upper</a></b></td>
      <td class="recommended">\p{Lowercase}</td>
      <td class="recommended">\p{Lowercase}</td>
      <td>Uppercase includes more than gc = Uppercase_Letter (Lu).</td>
    </tr>
    <tr>
      <td><b><a name="punct">punct</a></b></td>
      <td class="recommended">\p{gc=Punctuation}</td>
      <td class="recommended"><span class="changedspan">\p{gc=Punctuation}<br>
      \p{gc=Symbol}<br>
      - \p{alpha}</span></td>
      <td>POSIX adds symbols. Not recommended generally, due to the confusion of having <i>punct</i> 
      include non-punctuation marks.</td>
    </tr>
    <tr>
      <td><b><a name="digit">digit</a><br>
      (\d)</b></td>
      <td class="recommended">\p{gc=Decimal_Number}</td>
      <td class="recommended">\p{gc=Decimal_Number} </td>
      <td>Non-decimal numbers (like Roman numerals) are normally excluded. In U4.0+, this is the 
      same as gc = Decimal_Number (Nd). See
      <a href="http://www.unicode.org/Public/UNIDATA/extracted/DerivedNumericType.txt">
      DerivedNumericType</a> [<a href="#UCD">UCD</a>].</td>
    </tr>
    <tr>
      <td><b><a name="xdigit">xdigit</a></b><br>
      </td>
      <td class="recommended">\p{gc=Decimal_Number}<br>
      <span class="changedspan">\p{Hex_Digit}</span></td>
      <td class="recommended">\p{gc=Decimal_Number}<br>
      <span class="changedspan">\p{Hex_Digit}</span></td>
      <td>Hex_Digit contains 0-9 A-F, fullwidth and halfwidth, upper and lowercase.</td>
    </tr>
    <tr>
      <td><b><a name="alnum">alnum</a></b></td>
      <td class="recommended">\p{alpha}<br>
      \p{digit}</td>
      <td class="recommended">\p{alpha}<br>
      \p{digit}</td>
      <td>Simple combination of other properties</td>
    </tr>
    <tr>
      <td><b><a name="space">space<br>
      </a>\s</b></td>
      <td class="recommended">\p{Whitespace}</td>
      <td class="recommended">\p{Whitespace}</td>
      <td>See <a href="http://www.unicode.org/Public/UNIDATA/PropList.txt">PropList</a> [<a href="#UCD">UCD</a>] 
      for the definition of Whitespace.</td>
    </tr>
    <tr>
      <td><b><a name="blank">blank</a></b></td>
      <td class="recommended">\p{Whitespace} -<br>
      [\N{LF} \N{VT} \N{FF} \N{CR} \N{NEL} \p{gc=Line_Separator} \p{gc=Paragraph_Separator}]</td>
      <td class="recommended">\p{Whitespace} -<br>
      [\N{LF} \N{VT} \N{FF} \N{CR} \N{NEL} \p{gc=Line_Separator} \p{gc=Paragraph_Separator}]</td>
      <td>&quot;horizontal&quot; whitespace.</td>
    </tr>
    <tr>
      <td><b><a name="cntrl">cntrl</a></b></td>
      <td class="recommended">\p{gc=Control}</td>
      <td class="recommended">\p{gc=Control}</td>
      <td>The characters in \p{gc=Format} share some, but not all aspects of control characters. 
      Many format characters are required in the representation of plain text.</td>
    </tr>
    <tr>
      <td><b><a name="graph">graph</a></b></td>
      <td class="recommended">[^<br>
      \p{space}<br>
      \p{gc=Control}<br>
      \p{gc=Format}<br>
      \p{gc=Surrogate}<br>
      \p{gc=Unassigned}]</td>
      <td class="recommended">[^<br>
      \p{space}<br>
      \p{gc=Control}<br>
      \p{gc=Format}<br>
      \p{gc=Surrogate}<br>
      \p{gc=Unassigned}]<br>
      <span class="changedspan">\N{ZWNJ}<br>
      \N{ZWJ}</span></td>
      <td><i>Warning: </i>the set to the left is defined by <i>excluding </i>space, controls, etc. 
      with ^.
      <p>Perl 5.8.0 is similar except that it excludes: Z, Cc, Cf, Cs, Cn. The intent is for Perl 
      5.8.1 to align with the specification here.</td>
    </tr>
    <tr>
      <td><b>print</b></td>
      <td class="recommended">\p{graph}<br>
      <span class="changedspan">\p{blank}<br>
      - \p{cntrl}</span></td>
      <td class="recommended">\p{graph}<br>
      <span class="changedspan">\p{blank}<br>
      - \p{cntrl}</span></td>
      <td>Includes graph and space-like characters.</td>
    </tr>
    <tr>
      <td><b><a name="word">word</a><br>
      (\w)</b></td>
      <td class="recommended">\p{alpha}<br>
      \p{gc=Mark}<br>
      \p{digit}<br>
      \p{gc=Connector_Punctuation}</td>
      <td class="recommended">&nbsp;</td>
      <td>This is only an approximation to Word Boundaries (see <a href="#b">b</a> below). The 
      Connector Punctuation is added in for programming language identifiers, thus adding &quot;_&quot; and 
      similar characters.</td>
    </tr>
    <tr>
      <td><b>\<a name="X">X</a></b></td>
      <td class="recommended">Default Grapheme Clusters</td>
      <td class="recommended">Default Grapheme Clusters</td>
      <td>See [<a href="#Boundaries">Boundaries</a>], also
      <a href="http://www.unicode.org/reports/tr29/GraphemeClusterBreakTest.html">
      GraphemeClusterBreakTest</a>. Other functions are used for programming language identifier 
      boundaries.</td>
    </tr>
    <tr>
      <td><b>\<a name="b">b</a></b></td>
      <td class="recommended">Default Word Boundaries</td>
      <td class="recommended">Default Word Boundaries</td>
      <td>If there is a requirement that \b align with \w, then it would use the approximation above 
      instead. See [<a href="#Boundaries">Boundaries</a>], also
      <a href="http://www.unicode.org/reports/tr29/WordBreakTest.html">WordBreakTest</a>.<p>Note 
      that different functions are used for programming language identifier boundaries. See also [<a href="#Syntax">Syntax</a>].</td>
    </tr>
  </table>
  <p class="reviewnote"><b>Note to Reviewers: </b>Are there any other changes in the POSIX column 
  that would promote compatibility? For example, should we add some of the Format characters to 
  cntrl? Do POSIX implementations expect that the union of the properties (alpha lower upper punct 
  digit xdigit alnum space blank cntrl graph print word) covers all assigned characters (minus 
  perhaps private use)?</p>
  <h2><a name="References">References</a></h2>
  <table class="noborder" cellpadding="4">
    <tr>
      <td width="1" class="noborder" height="40">[<a name="Boundaries">Boundaries</a>]</td>
      <td class="noborder" height="40"><a href="http://www.unicode.org/reports/tr29/">UAX #29: Text 
      Boundaries</a><br>
      <a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="40">[<a name="Case">Case</a>]</td>
      <td class="noborder" height="40">Section 3.13 [<a href="#Unicode">Unicode</a>]<br>
      <a href="http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992">
      http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf#G33992</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="20">[<a name="CaseData">CaseData</a>]</td>
      <td class="noborder" height="20">
      <a href="http://www.unicode.org/Public/UNIDATA/CaseFolding.txt">
      http://www.unicode.org/Public/UNIDATA/CaseFolding.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="40">[<a name="Collation">Collation</a>]</td>
      <td class="noborder" height="40"><a href="http://www.unicode.org/reports/tr10/">UTS #10: 
      Unicode Collation Algorithm<br>
      http://www.unicode.org/reports/tr10/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="60">[<a name="FAQ">FAQ</a>]</td>
      <td class="noborder" height="60">Unicode Frequently Asked Questions<br>
      <a href="http://www.unicode.org/faq/">http://www.unicode.org/faq/<br>
      </a><i>For answers to common questions on technical issues.</i></td>
    </tr>
    <tr>
      <td valign="top" width="1" class="noborder" height="40">[<a name="Feedback">Feedback</a>]</td>
      <td valign="top" class="noborder" height="40">Reporting Errors and Requesting Information 
      Online<i><br>
      </i><a href="http://www.unicode.org/reporting.html">http://www.unicode.org/reporting.html</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="60">[<a name="Folding">Folding</a>]</td>
      <td class="noborder" height="60"><a href="http://www.unicode.org/reports/tr30/">UTR #30 
      Character Foldings</a> <i>(Current Status: Draft)<br>
      <a href="http://www.unicode.org/reports/tr30/">http://www.unicode.org/reports/tr30/</a></i></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="60">[<a name="Friedl">Friedl</a>]</td>
      <td class="noborder" height="60">Jeffrey Friedl, &quot;Mastering Regular Expressions&quot;, 2nd Edition 
      2002, O&#39;Reilly and Associates, ISBN 0-596-00289-0</td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="60">[<a name="Glossary">Glossary</a>]</td>
      <td class="noborder" height="60">Unicode Glossary<a href="http://www.unicode.org/glossary/"><br>
      http://www.unicode.org/glossary/<br>
      </a><i>For explanations of terminology used in this and other documents.</i></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="40">[<a name="LineBreak">LineBreak</a>]</td>
      <td class="noborder" height="40"><a href="http://www.unicode.org/reports/tr14/">UAX #14: Line 
      Breaking Properties<br>
      http://www.unicode.org/reports/tr14/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="40">[<a name="NewLine">NewLine</a>]</td>
      <td class="noborder" height="40"><a href="http://www.unicode.org/reports/tr13/">UAX #13, 
      Unicode Newline Guidelines<br>
      http://www.unicode.org/reports/tr13/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="40">[<a name="Norm">Norm</a>]</td>
      <td class="noborder" height="40"><a href="http://www.unicode.org/reports/tr15/">UAX #15: 
      Unicode Normalization<br>
      http://www.unicode.org/reports/tr15/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="20">[Online]</td>
      <td class="noborder" height="20"><a href="http://www.unicode.org/onlinedat/online.html">
      http://www.unicode.org/onlinedat/online.html</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="120">[<a name="Perl">Perl</a>]</td>
      <td class="noborder" height="120"><a href="http://www.perl.com/pub/q/documentation">
      http://www.perl.com/pub/q/documentation<br>
      </a>See especially:<br>
      <a href="http://www.perldoc.com/perl5.8.0/lib/charnames.html">
      http://www.perldoc.com/perl5.8.0/lib/charnames.html</a><br>
      <a href="http://www.perldoc.com/perl5.8.0/pod/perlre.html">
      http://www.perldoc.com/perl5.8.0/pod/perlre.html</a><br>
      <a href="http://www.perldoc.com/perl5.8.0/pod/perluniintro.html">
      http://www.perldoc.com/perl5.8.0/pod/perluniintro.html</a><br>
      <a href="http://www.perldoc.com/perl5.8.0/pod/perlunicode.html">
      http://www.perldoc.com/perl5.8.0/pod/perlunicode.html</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="20">[<a name="POSIX">POSIX</a>]</td>
      <td class="noborder" height="20">The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 
      2003 Edition, &quot;Locale&quot; chapter<br>
      <a href="http://www.opengroup.org/onlinepubs/007904975/basedefs/xbd_chap07.html">
      http://www.opengroup.org/onlinepubs/007904975/basedefs/xbd_chap07.html</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="20">[<a name="Prop">Prop</a>]</td>
      <td class="noborder" height="20">
      <a href="http://www.unicode.org/Public/UNIDATA/PropertyAliases.txt">
      http://www.unicode.org/Public/UNIDATA/PropertyAliases.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="20">[<a name="PropValue">PropValue</a>]</td>
      <td class="noborder" height="20">
      <a href="http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt">
      http://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="80">[<a name="Reports">Reports</a>]</td>
      <td class="noborder" height="80">Unicode Technical Reports<br>
      <a href="http://www.unicode.org/reports/">http://www.unicode.org/reports/<br>
      </a><i>For information on the status and development process for technical reports, and for a 
      list of technical reports.</i></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="20">[<a name="ScriptData">ScriptData</a>]</td>
      <td class="noborder" height="20"><a href="http://www.unicode.org/Public/UNIDATA/Scripts.txt">
      http://www.unicode.org/Public/UNIDATA/Scripts.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="40">[<a name="ScriptDoc">ScriptDoc</a>]</td>
      <td class="noborder" height="40">UTR #24: Script Names<br>
      <a href="http://www.unicode.org/reports/tr24/">http://www.unicode.org/reports/tr24/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="20">[<a name="SpecialCasing">SpecialCasing</a>]</td>
      <td class="noborder" height="20">
      <a href="http://www.unicode.org/Public/UNIDATA/SpecialCasing.txt">
      http://www.unicode.org/Public/UNIDATA/SpecialCasing.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="40">[<a name="Syntax">Syntax</a>]</td>
      <td class="noborder" height="40">UTR #31: Identifier and Pattern Syntax <i>(Current Status: 
      Draft)<br>
      <a href="http://www.unicode.org/reports/tr31/">http://www.unicode.org/reports/tr31/</a></i></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="20">[<a name="UCD">UCD</a>]</td>
      <td class="noborder" height="20"><a href="http://www.unicode.org/ucd/">
      http://www.unicode.org/ucd/</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="20">[<a name="UData">UData</a>]</td>
      <td class="noborder" height="20">
      <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.txt">
      http://www.unicode.org/Public/UNIDATA/UnicodeData.txt</a></td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="20">[<a name="UDataDoc">UDataDoc</a>]</td>
      <td class="noborder" height="20">
      <a href="http://www.unicode.org/Public/UNIDATA/UnicodeData.html">
      http://www.unicode.org/Public/UNIDATA/UnicodeData.html</a></td>
    </tr>
    <tr>
      <td valign="top" width="1" class="noborder" height="40">[<a name="Unicode">Unicode</a>]</td>
      <td valign="top" class="noborder" height="40">The Unicode Consortium.
      <a href="http://www.unicode.org/versions/Unicode4.0.0/">The Unicode Standard, Version 4.0</a>. 
      Reading, MA, Addison-Wesley, 2003. 0-321-18578-1.</td>
    </tr>
    <tr>
      <td width="1" class="noborder" height="80">[<a name="Versions">Versions</a>]</td>
      <td class="noborder" height="80">Versions of the Unicode Standard<br>
      <a href="http://www.unicode.org/versions/">http://www.unicode.org/versions/<br>
      </a><i>For details on the precise contents of each version of the Unicode Standard, and how to 
      cite them.</i></td>
    </tr>
  </table>
  <p>&nbsp; </p>
  <h2><a name="Acknowledgments">Acknowledgments</a></h2>
  <p>Thanks to Jeffrey Friedl, Andy Heninger, Alan Liu, Kent Karlsson, Jarkko Hietaniemi, Gurusamy 
  Sarathy, Henry Spencer, Tom Watson, and Kento Tamura for their feedback on the document.</p>
  <h2><a name="Modifications">Modifications</a></h2>
  <p>The following summarizes modifications from the previous version of this document.</p>
  <table class="noborder">
    <tr>
      <td width="1" class="noborder"><span class="changedspan"><a name="TrackingNumber9">10</a></span></td>
      <td class="noborder">
      <ul>
        <li><span class="changedspan">R1.4, item 2 changed for ZW(N)J</span></li>
        <li><span class="changedspan"><span style="background-color: #FFFF00">Added conformance 
        clause to allow a claim of conformance to the Compatibility properties.</span></span></li>
        <li><span class="changedspan"><span style="background-color: #FFFF00">Split the 
        Compatibility properties into two, to allow for regular vs. strict POSIX properties.</span></span></li>
        <li><span class="changedspan"><span style="background-color: #FFFF00">Added ZWJ, ZWNJ to 
        word characters and alpha</span></span></li>
        <li><span class="changedspan"><span style="background-color: #FFFF00">Added other notation 
        for use here and in other Unicode Standards</span></span></li>
        <li><span class="changedspan"><span style="background-color: #FFFF00">Added vertical tab to 
        newline sequences. Reorganized text slightly to only list codepoints once.</span></span></li>
        <li><span class="changedspan"><span style="background-color: #FFFF00">Minor Editing</span></span></li>
      </ul>
      </td>
    </tr>
    <tr>
      <td width="1" class="noborder"><a name="TrackingNumber9">9</a></td>
      <td class="noborder">
      <ul>
        <li>Split 2.5 into two sections, expanding latter.</li>
        <li>Misc. editing and clarifications.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td width="1" class="noborder"><a name="TrackingNumber8">8</a></td>
      <td class="noborder">
      <ul>
        <li>Renumbered sections to match levels</li>
        <li>Introduced &quot;RL&quot; numbering on clauses</li>
        <li>Misc. editing and clarifications.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td width="1" class="noborder"><a name="TrackingNumber7">7</a></td>
      <td class="noborder">
      <ul>
        <li>Now proposed as a UTS, adding <a href="#Conformance">Conformance</a> and specific 
        wording in each relevant section.</li>
        <li>Move hex notation for surrogates from <a href="#Supplementary_Characters">1.7 Surrogates</a> 
        into <a href="#Hex_notation">1.1 Hex notation</a>.</li>
        <li>Added <a href="#Context_Matching">3.6 Context Matching</a> and following.</li>
        <li>Updated to Unicode 4.0</li>
        <li>Minor editing</li>
        <li><b>Note:</b> paragraphs with major changes are highlighted in this document; less 
        substantive wording changes may not be.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td width="1" class="noborder"><a name="TrackingNumber6">6</a></td>
      <td class="noborder">
      <ul>
        <li>Fixed 16-bit reference, moved Supplementary characters support (surrogates) to level 1.
        </li>
        <li>Generally changed &quot;locale-dependent&quot; to &quot;default&quot;, &quot;locale-independent&quot; to &quot;tailored&quot; 
        and &quot;grapheme&quot; to &quot;grapheme cluster&quot;</li>
        <li>Changed syntax slightly to be more like Perl</li>
        <li>Added explicit table of General Category values</li>
        <li>Added clarifications about scripts and blocks</li>
        <li>Added descriptions of other properties, and a pointer to the default names</li>
        <li>Referred to TR 29 for grapheme cluster and word boundaries</li>
        <li>Removed old annex B (word boundary code)</li>
        <li>Removed spaces from anchors</li>
        <li>Added references, modification sections </li>
        <li>Rearranged property section</li>
        <li>Minor editing</li>
      </ul>
      </td>
    </tr>
  </table>
  <p class="copyright">Copyright © 2000-2004 Unicode, Inc. All Rights Reserved. The Unicode 
  Consortium makes no expressed or implied warranty of any kind, and assumes no liability for errors 
  or omissions. No liability is assumed for incidental and consequential damages in connection with 
  or arising out of the use of the information or programs contained or accompanying this technical 
  report. The Unicode <a href="http://www.unicode.org/copyright.html">Terms of Use</a> apply.</p>
  <p class="copyright">Unicode and the Unicode logo are trademarks of Unicode, Inc., and are 
  registered in some jurisdictions.</div>

</body>

</html>
