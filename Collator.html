<html><head><TITLE>Collator</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  U_I18N_API Collator  </H2><BLOCKQUOTE>

The <code>Collator</code> class performs locale-sensitive
<code>String</code> comparison
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CCollator,MCollator.html,CRuleBasedCollator,MRuleBasedCollator.html">
<param name=before value="M,M^_">
<param name=after value="M,M">
<param name=indent value="0,0">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Protected Methods</h3><DD><DT><A HREF="#DOC.7.24"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Collator</B>() </B>
 <DD><I>
Constructors</I>
<DT><A HREF="#DOC.7.25"> <IMG BORDER=0 SRC=icon1.gif></A> const  <!2><A HREF="Collator.html#DOC.7.24">Collator</A>&  <B>operator=</B>(const <!2><A HREF="Collator.html#DOC.7.24">Collator</A>& other) </B>
 <DD><I>
Assignment operator</I>
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

The <code>Collator</code> class performs locale-sensitive
<code>String</code> comparison. You use this class to build
searching and sorting routines for natural language text.

<p>
<code>Collator</code> is an abstract base class. Subclasses
implement specific collation strategies. One subclass,
<code>RuleBasedCollator</code>, is currently provided
and is applicable to a wide set of languages. Other
subclasses may be created to handle more specialized needs.

<p>
Like other locale-sensitive classes, you can use the static
factory method, <code>getInstance</code>, to obtain the appropriate
<code>Collator</code> object for a given locale. You will only need
to look at the subclasses of <code>Collator</code> if you need
to understand the details of a particular collation strategy or
if you need to modify that strategy.

<p>
The following example shows how to compare two strings using
the <code>Collator</code> for the default locale.
<blockquote>
<pre>
// Compare two strings in the default locale
UErrorCode success = U_ZERO_ERROR;
Collator* myCollator = Collator::createInstance(success);
if( myCollator->compare("abc", "ABC") &lt; 0 ) {
cout &lt;&lt; "abc is less than ABC" &lt;&lt; endl;
}else{
cout &lt;&lt; "abc is greater than or equal to ABC" &lt;&lt; endl;
}
</pre>
</blockquote>

<p>
You can set a <code>Collator</code>'s <em>strength</em> property
to determine the level of difference considered significant in
comparisons. Four strengths are provided: <code>PRIMARY</code>,
<code>SECONDARY</code>, <code>TERTIARY</code>, and <code>IDENTICAL</code>.
The exact assignment of strengths to language features is
locale dependant.  For example, in Czech, "e" and "f" are considered
primary differences, while "e" and "\u00EA" are secondary differences,
"e" and "E" are tertiary differences and "e" and "e" are identical.
The following shows how both case and accents could be ignored for
US English.
<blockquote>
<pre>
//Get the Collator for US English and set its strength to PRIMARY
UErrorCode success = U_ZERO_ERROR;
Collator* usCollator = Collator::createInstance(Locale::US, success);
usCollator->setStrength(Collator::PRIMARY);
if( usCollator->compare("abc", "ABC") == 0 ) {
cout &lt;&lt; "'abc' and 'ABC' strings are equivalent with strength PRIMARY" &lt;&lt; endl;
}
</pre>
</blockquote>
<p>
For comparing <code>String</code>s exactly once, the <code>compare</code>
method provides the best performance. When sorting a list of
<code>String</code>s however, it is generally necessary to compare each
<code>String</code> multiple times. In this case, <code>CollationKey</code>s
provide better performance. The <code>CollationKey</code> class converts
a <code>String</code> to a series of bits that can be compared bitwise
against other <code>CollationKey</code>s. A <code>CollationKey</code> is
created by a <code>Collator</code> object for a given <code>String</code>.
<p>
<strong>Note:</strong> <code>Collator</code>s with different Locale,
CollationStrength and DecompositionMode settings will return different
sort orders for the same set of strings. Locales have specific 
collation rules, and the way in which secondary and tertiary differences 
are taken into account, for example, will result in a different sorting order
for same strings.
<p>



</BLOCKQUOTE>
<DL>

<A NAME="Collator">
<A NAME ="DOC.7.24">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Collator()</B></TT>
<DD>
Constructors
<DL></DL><P>
<A NAME="operator=">
<A NAME ="DOC.7.25">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> const  <!2><A HREF="Collator.html#DOC.7.24">Collator</A>&  operator=(const <!2><A HREF="Collator.html#DOC.7.24">Collator</A>& other)</B></TT>
<DD>
Assignment operator
<DL></DL><P></DL>
<hr>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="RuleBasedCollator.html"> RuleBasedCollator </A><br>
</DL>
<DL><DT><B>Author:</B><DD>Helena Shih
<DT><B>Version:</B><DD>1.7 1/14/97

<DT><B>See Also:</B><DD><!1><A HREF="RuleBasedCollator.html">RuleBasedCollator</A>
<br><!1><A HREF="CollationKey.html">CollationKey</A>
<br><!1><A HREF="CollationElementIterator.html">CollationElementIterator</A>
<br>Locale
<br><!1><A HREF="Normalizer.html">Normalizer</A>
<br></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
