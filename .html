<html><head><TITLE></TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>    </H2>
<hr>
<DL>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=BiDi.html><B>BiDi</B></A> 
 <DD><I>
BiDi is a C++ wrapper class for UBiDi</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=BreakIterator.html><B>BreakIterator</B></A> 
 <DD><I>
The BreakIterator class implements methods for finding the location
of boundaries in text</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=Calendar.html><B>Calendar</B></A> 
 <DD><I>
<code>Calendar</code> is an abstract base class for converting between
a <code>UDate</code> object and a set of integer fields such as
<code>YEAR</code>, <code>MONTH</code>, <code>DAY</code>, <code>HOUR</code>,
and so on</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=CharacterIterator.html><B>CharacterIterator</B></A> 
 <DD><I>
Abstract class defining a protcol for accessing characters in a text-storage object</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ChoiceFormat.html><B>ChoiceFormat</B></A> 
 <DD><I>
A ChoiceFormat allows you to attach a format to a range of numbers</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=CollationElementIterator.html><B>CollationElementIterator</B></A> 
 <DD><I>
The CollationElementIterator class is used as an iterator to walk through
each character of an international string</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=Collator.html><B>Collator</B></A> 
 <DD><I>
The <code>Collator</code> class performs locale-sensitive
<code>String</code> comparison</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=DateFormat.html><B>DateFormat</B></A> 
 <DD><I>
DateFormat is an abstract class for a family of classes that convert dates and
times from their internal representations to textual form and back again in a
language-independent manner</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=DecimalFormatSymbols.html><B>DecimalFormatSymbols</B></A> 
 <DD><I>
This class represents the set of symbols needed by DecimalFormat
to format numbers</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=DecimalFormat.html><B>DecimalFormat</B></A> 
 <DD><I>
Concrete class for formatting decimal numbers, allowing a variety
of parameters, and localization to Western, Arabic, or Indic numbers</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=DateFormatSymbols.html><B>DateFormatSymbols</B></A> 
 <DD><I>
DateFormatSymbols is a public class for encapsulating localizable date-time
formatting data -- including timezone data</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=FieldPosition.html><B>FieldPosition</B></A> 
 <DD><I>
<code>FieldPosition</code> is a simple class used by <code>Format</code>
and its subclasses to identify fields in formatted output</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=Formattable.html><B>Formattable</B></A> 
 <DD><I>
Formattable objects can be passed to the Format class or
its subclasses for formatting</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=Format.html><B>Format</B></A> 
 <DD><I>
Base class for all formats</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=GregorianCalendar.html><B>GregorianCalendar</B></A> 
 <DD><I>
Concrete class which provides the standard calendar used by most of the world</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ULocale.html><B>ULocale</B></A> 
 <DD><I>

A <code>Locale</code> object represents a specific geographical, political,
or cultural region</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=MessageFormat.html><B>MessageFormat</B></A> 
 <DD><I>
Provides means to produce concatenated messages in language-neutral way</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=Normalizer.html><B>Normalizer</B></A> 
 <DD><I>
<tt>Normalizer</tt> transforms Unicode text into an equivalent composed or
decomposed form, allowing for easier sorting and searching of text</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=NumberFormat.html><B>NumberFormat</B></A> 
 <DD><I>
Abstract base class for all number formats</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ParsePosition.html><B>ParsePosition</B></A> 
 <DD><I>
<code>ParsePosition</code> is a simple class used by <code>Format</code>
and its subclasses to keep track of the current position during parsing</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=icu_isNaN.html><B>icu_isNaN</B></A> 
 <DD><I>
Platform utilities isolates the platform dependencies of the
libarary</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int16_t  U_EXPORT2  <B>icu_log10</B>(double d)
 <DD><I>
Returns the common log of the double value d</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>icu_digitsAfterDecimal</B>(double x)
 <DD><I>
Returns the number of digits after the decimal point in a double number x</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=icu_tzset.html><B>icu_tzset</B></A> 
 <DD><I>
Time zone utilities

Wrappers for C runtime library functions relating to timezones</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=icu_isBigEndian.html><B>icu_isBigEndian</B></A> 
 <DD><I>
Retrun true if this platform is big-endian, that is, if the number
0x1234 is stored 0x12, 0x34 in memory</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ResourceBundle.html><B>ResourceBundle</B></A> 
 <DD><I>
A class representing a collection of resource information pertaining to a given
locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=StringCharacterIterator.html><B>StringCharacterIterator</B></A> 
 <DD><I>
A concrete subclass of CharacterIterator that iterates over the
characters in a UnicodeString</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=SimpleTimeZone.html><B>SimpleTimeZone</B></A> 
 <DD><I>
<code>SimpleTimeZone</code> is a concrete subclass of <code>TimeZone</code>
that represents a time zone for use with a Gregorian calendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=SimpleDateFormat.html><B>SimpleDateFormat</B></A> 
 <DD><I>
SimpleDateFormat is a concrete class for formatting and parsing dates in a
language-independent manner</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=CollationKey.html><B>CollationKey</B></A> 
 <DD><I>
Collation keys are generated by the Collator class</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=RuleBasedCollator.html><B>RuleBasedCollator</B></A> 
 <DD><I>
The RuleBasedCollator class provides the simple implementation of Collator,
using data-driven tables</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=TimeZone.html><B>TimeZone</B></A> 
 <DD><I>
<code>TimeZone</code> represents a time zone offset, and also figures out daylight
savings</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=BiDialgorithmforICU.html><B>BiDi algorithm for ICU</B></A> 
 <DD><I>
</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.2.html><B></B></A> 
 <DD><I>
The BreakIterator C API defines  methods for finding the location
of boundaries in text</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>typedef  void*  <B>UBreakIterator</B>
 <DD><I>A text-break iterator </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UBreakIteratorType.html><B>UBreakIteratorType</B></A> 
 <DD><I>The possible types of text boundaries</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>#define <B>UBRK_DONE</B>((UTextOffset)
 <DD><I>Value indicating all text boundaries have been returned</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_open.html><B>ubrk_open</B></A> 
 <DD><I>
Open a new UBreakIterator for locating text boundaries for a specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_openRules.html><B>ubrk_openRules</B></A> 
 <DD><I>
Open a new UBreakIterator for locating text boundaries using specified breaking rules</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_close.html><B>ubrk_close</B></A> 
 <DD><I>
Close a UBreakIterator</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_current.html><B>ubrk_current</B></A> 
 <DD><I>
Determine the most recently-returned text boundary</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_next.html><B>ubrk_next</B></A> 
 <DD><I>
Determine the text boundary following the current text boundary</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_previous.html><B>ubrk_previous</B></A> 
 <DD><I>
Determine the text boundary preceding the current text boundary</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_first.html><B>ubrk_first</B></A> 
 <DD><I>
Determine the index of the first character in the text being scanned</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_last.html><B>ubrk_last</B></A> 
 <DD><I>
Determine the index immediately <EM>beyond</EM> the last character in the text being
scanned</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_preceding.html><B>ubrk_preceding</B></A> 
 <DD><I>
Determine the text boundary preceding the specified offset</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_following.html><B>ubrk_following</B></A> 
 <DD><I>
Determine the text boundary following the specified offset</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_getAvailable.html><B>ubrk_getAvailable</B></A> 
 <DD><I>
Get a locale for which text breaking information is available</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ubrk_countAvailable.html><B>ubrk_countAvailable</B></A> 
 <DD><I>
Determine how many locales have text breaking information available</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.3.html><B></B></A> 
 <DD><I>
UCalendar C API is used  for converting between a <code>UDate</code> object
and a set of integer fields such as <code>UCAL_YEAR</code>, <code>UCAL_MONTH</code>, 
<code>UCAL_DAY</code>, <code>UCAL_HOUR</code>, and so on</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>typedef  void*  <B>UCalendar</B>
 <DD><I>A calendar </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCalendarType.html><B>UCalendarType</B></A> 
 <DD><I>Possible types of UCalendars </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCalendarDateFields.html><B>UCalendarDateFields</B></A> 
 <DD><I>Possible fields in a UCalendar </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.4.html><B></B></A> 
 <DD><I>
Useful constant for days of week</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCalendarDaysOfWeek.html><B>UCalendarDaysOfWeek</B></A> 
 <DD><I>Possible days of the week in a UCalendar </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCalendarMonths.html><B>UCalendarMonths</B></A> 
 <DD><I>Possible months in a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCalendarAMPMs.html><B>UCalendarAMPMs</B></A> 
 <DD><I>Possible AM/PM values in a UCalendar </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_getAvailableTZIDs.html><B>ucal_getAvailableTZIDs</B></A> 
 <DD><I>
Get an available TimeZone ID</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_countAvailableTZIDs.html><B>ucal_countAvailableTZIDs</B></A> 
 <DD><I>
Determine how many TimeZones exist with a certain offset</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_getNow.html><B>ucal_getNow</B></A> 
 <DD><I>
Get the current date and time</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_open.html><B>ucal_open</B></A> 
 <DD><I>
Open a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_close.html><B>ucal_close</B></A> 
 <DD><I>
Close a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_setTimeZone.html><B>ucal_setTimeZone</B></A> 
 <DD><I>
Set the TimeZone used by a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCalendarDisplayNameType.html><B>UCalendarDisplayNameType</B></A> 
 <DD><I>Possible formats for a UCalendar's display name </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_getTimeZoneDisplayName.html><B>ucal_getTimeZoneDisplayName</B></A> 
 <DD><I>
Get the display name for a UCalendar's TimeZone</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_inDaylightTime.html><B>ucal_inDaylightTime</B></A> 
 <DD><I>
Determine if a UCalendar is currently in daylight savings time</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCalendarAttribute.html><B>UCalendarAttribute</B></A> 
 <DD><I>Types of UCalendar attributes </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_getAttribute.html><B>ucal_getAttribute</B></A> 
 <DD><I>
Get a numeric attribute associated with a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_setAttribute.html><B>ucal_setAttribute</B></A> 
 <DD><I>
Set a numeric attribute associated with a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_getAvailable.html><B>ucal_getAvailable</B></A> 
 <DD><I>
Get a locale for which calendars are available</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_countAvailable.html><B>ucal_countAvailable</B></A> 
 <DD><I>
Determine how many locales have calendars available</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_getMillis.html><B>ucal_getMillis</B></A> 
 <DD><I>
Get a UCalendar's current time in millis</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_setMillis.html><B>ucal_setMillis</B></A> 
 <DD><I>
Set a UCalendar's current time in millis</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_setDate.html><B>ucal_setDate</B></A> 
 <DD><I>
Set a UCalendar's current date</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_setDateTime.html><B>ucal_setDateTime</B></A> 
 <DD><I>
Set a UCalendar's current date</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_equivalentTo.html><B>ucal_equivalentTo</B></A> 
 <DD><I>
Determine if two UCalendars represent the same date</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_add.html><B>ucal_add</B></A> 
 <DD><I>
Add a specified signed amount to a particular field in a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_roll.html><B>ucal_roll</B></A> 
 <DD><I>
Add a specified signed amount to a particular field in a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_get.html><B>ucal_get</B></A> 
 <DD><I>
Get the current value of a field from a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_set.html><B>ucal_set</B></A> 
 <DD><I>
Set the value of a field in a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_isSet.html><B>ucal_isSet</B></A> 
 <DD><I>
Determine if a field in a UCalendar is set</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_clearField.html><B>ucal_clearField</B></A> 
 <DD><I>
Clear a field in a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_clear.html><B>ucal_clear</B></A> 
 <DD><I>
Clear all fields in a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCalendarLimitType.html><B>UCalendarLimitType</B></A> 
 <DD><I>Possible limit values for a UCalendar </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucal_getLimit.html><B>ucal_getLimit</B></A> 
 <DD><I>
Determine a limit for a field in a UCalendar</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCharDigitPair.html><B>UCharDigitPair</B></A> 
 <DD><I>
The Unicode C API allows you to query the properties associated with individual 
Unicode character values</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.5.html><B></B></A> 
 <DD><I>
The Unicode C API allows you to query the properties associated with individual 
Unicode character values</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <B></B>
 <DD><I>
Constants</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCHAR_MIN_VALUE.html><B>UCHAR_MIN_VALUE</B></A> 
 <DD><I>
The minimum value a UChar can have</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCHAR_MAX_VALUE.html><B>UCHAR_MAX_VALUE</B></A> 
 <DD><I>
The maximum value a UChar can have</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> enum  <B>UCharCategory</B>
 <DD><I>
Data for enumerated Unicode general category types</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> enum  <B>UCharDirection</B>
 <DD><I>
This specifies the language directional property of a character set</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> enum  <B>UCharScript</B>
 <DD><I>
Script range as defined in the Unicode standard</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> enum  <B>UCellWidth</B>
 <DD><I>
Values returned by the u_getCellWidth() function</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <B></B>
 <DD><I>
Functions to classify characters</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_islower.html><B>u_islower</B></A> 
 <DD><I>
Determines whether the specified UChar is a lowercase character
according to Unicode 2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isupper.html><B>u_isupper</B></A> 
 <DD><I>
Determines whether the specified character is an uppercase character
according to Unicode 2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_istitle.html><B>u_istitle</B></A> 
 <DD><I>
Determines whether the specified character is a titlecase character
according to Unicode 2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isdigit.html><B>u_isdigit</B></A> 
 <DD><I>
Determines whether the specified character is a digit according to Unicode
2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isdefined.html><B>u_isdefined</B></A> 
 <DD><I>
Determines whether the specified numeric value is actually a defined character
according to Unicode 2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isalpha.html><B>u_isalpha</B></A> 
 <DD><I>
Determines whether the specified character is a letter
according to Unicode 2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isspace.html><B>u_isspace</B></A> 
 <DD><I>
Determines if the specified character is a space character or not</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_iscntrl.html><B>u_iscntrl</B></A> 
 <DD><I>
Determines whether the specified character is a control character or not</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isprint.html><B>u_isprint</B></A> 
 <DD><I>
Determines whether the specified character is a printable character according 
to Unicode 2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isbase.html><B>u_isbase</B></A> 
 <DD><I>
Determines whether the specified character is of the base form according 
to Unicode 2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_charDirection.html><B>u_charDirection</B></A> 
 <DD><I>
Returns the linguistic direction property of a character</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_charCellWidth.html><B>u_charCellWidth</B></A> 
 <DD><I>
Returns a value indicating the display-cell width of the character
when used in Asian text, according to the Unicode standard (see p</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_charType.html><B>u_charType</B></A> 
 <DD><I>
Returns a value indicating a character category according to Unicode
2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>u_charDigitValue</B>(UChar c)
 <DD><I>
Retrives the decimal numeric value of a digit character</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  <!2><A HREF="#DOC.93">UCharScript</A>  U_EXPORT2  <B>u_charScript</B>(UChar ch)
 <DD><I>

Returns the script associated with a character</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <B></B>
 <DD><I>
The following functions are java specific</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isIDStart.html><B>u_isIDStart</B></A> 
 <DD><I>
A convenience method for determining if a Unicode character 
is allowed to start in a Unicode identifier</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isIDPart.html><B>u_isIDPart</B></A> 
 <DD><I>
A convenience method for determining if a Unicode character
may be part of a Unicode identifier other than the starting
character</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isIDIgnorable.html><B>u_isIDIgnorable</B></A> 
 <DD><I>
A convenience method for determining if a Unicode character 
should be regarded as an ignorable character 
in a Unicode identifier</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isJavaIDStart.html><B>u_isJavaIDStart</B></A> 
 <DD><I>
A convenience method for determining if a Unicode character
is allowed as the first character in a Java identifier</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_isJavaIDPart.html><B>u_isJavaIDPart</B></A> 
 <DD><I>
A convenience method for determining if a Unicode character 
may be part of a Java identifier other than the starting
character</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <B></B>
 <DD><I>
Functions to change character case</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_tolower.html><B>u_tolower</B></A> 
 <DD><I>
The given character is mapped to its lowercase equivalent according to
Unicode 2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_toupper.html><B>u_toupper</B></A> 
 <DD><I>
The given character is mapped to its uppercase equivalent according to Unicode
2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_totitle.html><B>u_totitle</B></A> 
 <DD><I>
The given character is mapped to its titlecase equivalent according to Unicode
2</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  const  char*  U_EXPORT2  <B>u_getVersion</B>(void)
 <DD><I>

The function is used to get the Unicode standard Version that is used
</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCharCharacterIterator.html><B>UCharCharacterIterator</B></A> 
 <DD><I>
A concrete subclass of CharacterIterator that iterates over the
characters in a UnicodeString</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_open.html><B>ucnv_open</B></A> 
 <DD><I>
Creates a UConverter object with the names specified as a C string</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_openU.html><B>ucnv_openU</B></A> 
 <DD><I>
Creates a Unicode converter with the names specified as unicode string</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  UConverter*  U_EXPORT2  <B>ucnv_openCCSID</B>(int32_t codepage, UCNV_PLATFORM platform, <!2><A HREF="#DOC.301">UErrorCode</A> * err)
 <DD><I>
Creates a UConverter object using a CCSID number</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  void  U_EXPORT2  <B>ucnv_close</B>(UConverter * converter)
 <DD><I>
Deletes the unicode converter</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  void  U_EXPORT2  <B>ucnv_getSubstChars</B>(const UConverter * converter, char *subChars, int8_t * len, <!2><A HREF="#DOC.301">UErrorCode</A> * err)
 <DD><I>
Fills in the output parameter, subChars, with the substitution characters
as multiple bytes</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_setSubstChars.html><B>ucnv_setSubstChars</B></A> 
 <DD><I>
Sets the substitution chars when converting from unicode to a codepage</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  void  U_EXPORT2  <B>ucnv_getInvalidChars</B>(const UConverter * converter, char *errBytes, int8_t * len, <!2><A HREF="#DOC.301">UErrorCode</A> * err)
 <DD><I>
Fills in the output parameter, errBytes, with the error characters from the
last failing conversion</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  void  U_EXPORT2  <B>ucnv_getInvalidUChars</B>(const UConverter * converter, char *errUChars, int8_t * len, <!2><A HREF="#DOC.301">UErrorCode</A> * err)
 <DD><I>
Fills in the output parameter, errChars, with the error characters from the
last failing conversion</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_reset.html><B>ucnv_reset</B></A> 
 <DD><I>
Resets the state of stateful conversion to the default state</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_getMaxCharSize.html><B>ucnv_getMaxCharSize</B></A> 
 <DD><I>
Returns the maximum length of bytes used by a character</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_getMinCharSize.html><B>ucnv_getMinCharSize</B></A> 
 <DD><I>
Returns the minimum byte length for characters in this codepage</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>ucnv_getDisplayName</B>(const UConverter * converter, const char *displayLocale, UChar * displayName, int32_t displayNameCapacity, <!2><A HREF="#DOC.301">UErrorCode</A> * err)
 <DD><I>
Returns the display name of the converter passed in based on the Locale passed in,
in the case the locale contains no display name, the internal ASCII name will be
filled in</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_getName.html><B>ucnv_getName</B></A> 
 <DD><I>
Gets the name of the converter (zero-terminated)</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_getCCSID.html><B>ucnv_getCCSID</B></A> 
 <DD><I>
Gets a codepage number associated with the converter</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_getPlatform.html><B>ucnv_getPlatform</B></A> 
 <DD><I>
Gets a codepage platform associated with the converter</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_getType.html><B>ucnv_getType</B></A> 
 <DD><I>
Gets the type of conversion associated with the converter
e</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_getStarters.html><B>ucnv_getStarters</B></A> 
 <DD><I>
Gets the "starter" bytes for the converters of type MBCS
will fill in an <TT>ILLEGAL_ARGUMENT_ERROR</TT> if converter passed in
is not MBCS</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  UCNV_ToUCallBack  U_EXPORT2  <B>ucnv_getToUCallBack</B>(const UConverter * converter)
 <DD><I>
Gets the current calback function used by the converter when illegal or invalid sequence found</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  UCNV_FromUCallBack  U_EXPORT2  <B>ucnv_getFromUCallBack</B>(const UConverter * converter)
 <DD><I>
Gets the current callback function used by the converter when illegal or invalid sequence found</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  UCNV_ToUCallBack  U_EXPORT2  <B>ucnv_setToUCallBack</B>(UConverter * converter, UCNV_ToUCallBack action, <!2><A HREF="#DOC.301">UErrorCode</A> * err)
 <DD><I>
Gets the current callback function used by the converter when illegal or invalid sequence found
</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  UCNV_FromUCallBack  U_EXPORT2  <B>ucnv_setFromUCallBack</B>(UConverter * converter, UCNV_FromUCallBack action, <!2><A HREF="#DOC.301">UErrorCode</A> * err)
 <DD><I>
Gets the current callback function used by the converter when illegal or invalid sequence found
</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_fromUnicode.html><B>ucnv_fromUnicode</B></A> 
 <DD><I>
Transcodes an array of unicode characters to an array of codepage characters</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_toUnicode.html><B>ucnv_toUnicode</B></A> 
 <DD><I>
Converts an array of codepage characters into an array of unicode characters</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_fromUChars.html><B>ucnv_fromUChars</B></A> 
 <DD><I>
Transcodes the source Unicode string to the target string in a codepage encoding
with the specified Unicode converter</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_toUChars.html><B>ucnv_toUChars</B></A> 
 <DD><I>
Transcode the source string in codepage encoding to the target string in
Unicode encoding</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>ucnv_flushCache</B>(void)
 <DD><I>
SYSTEM API
Iterates through every cached converter and frees all the unused ones</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_getAvailableName.html><B>ucnv_getAvailableName</B></A> 
 <DD><I>
provides a string containing the internal name (based on the alias file) of the converter</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>ucnv_countAvailable</B>(void)
 <DD><I>
returns the number of available converters</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  const  char*  U_EXPORT2  <B>ucnv_getDefaultName</B>(void)
 <DD><I>
returns the current default converter name</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucnv_setDefaultName.html><B>ucnv_setDefaultName</B></A> 
 <DD><I>
sets the current default converter name</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.6.html><B></B></A> 
 <DD><I>
The C API for Collator performs locale-sensitive
<code>String</code> comparison</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>typedef  void*  <B>UCollator</B>
 <DD><I>A collator </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.7.html><B></B></A> 
 <DD><I>
UCOL_LESS is returned if source string is compared to be less than target
string in the u_strcoll() method</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCollationResult.html><B>UCollationResult</B></A> 
 <DD><I>Possible values for a comparison result </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.8.html><B></B></A> 
 <DD><I>
UCOL_NO_NORMALIZATION : Accented characters will not be decomposed for sorting</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UNormalizationMode.html><B>UNormalizationMode</B></A> 
 <DD><I>Possible collation normalization modes </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UNormalizationOption.html><B>UNormalizationOption</B></A> 
 <DD><I>Possible normalization options </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.9.html><B></B></A> 
 <DD><I>
Base letter represents a primary difference</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UCollationStrength.html><B>UCollationStrength</B></A> 
 <DD><I>Possible collation strengths </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.10.html><B></B></A> 
 <DD><I>
<tt>u_normalize</tt> transforms Unicode text into an equivalent composed or
decomposed form, allowing for easier sorting and searching of text</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_normalize.html><B>u_normalize</B></A> 
 <DD><I>
Normalize a string</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_open.html><B>ucol_open</B></A> 
 <DD><I>
Open a UCollator for comparing strings</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_openRules.html><B>ucol_openRules</B></A> 
 <DD><I>
Open a UCollator for comparing strings</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_close.html><B>ucol_close</B></A> 
 <DD><I>
Close a UCollator</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_strcoll.html><B>ucol_strcoll</B></A> 
 <DD><I>
Compare two strings</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_greater.html><B>ucol_greater</B></A> 
 <DD><I>
Determine if one string is greater than another</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_greaterOrEqual.html><B>ucol_greaterOrEqual</B></A> 
 <DD><I>
Determine if one string is greater than or equal to another</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_equal.html><B>ucol_equal</B></A> 
 <DD><I>
Compare two strings for equality</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_getStrength.html><B>ucol_getStrength</B></A> 
 <DD><I>
Get the collation strength used in a UCollator</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_setStrength.html><B>ucol_setStrength</B></A> 
 <DD><I>
Set the collation strength used in a UCollator</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_getNormalization.html><B>ucol_getNormalization</B></A> 
 <DD><I>
Get the normalization mode used in a UCollator</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_setNormalization.html><B>ucol_setNormalization</B></A> 
 <DD><I>
Set the normalization mode used in a UCollator</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_getDisplayName.html><B>ucol_getDisplayName</B></A> 
 <DD><I>
Get the display name for a UCollator</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_getAvailable.html><B>ucol_getAvailable</B></A> 
 <DD><I>
Get a locale for which collation rules are available</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_countAvailable.html><B>ucol_countAvailable</B></A> 
 <DD><I>
Determine how many locales have collation rules available</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_getRules.html><B>ucol_getRules</B></A> 
 <DD><I>
Get the collation rules from a UCollator</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_getSortKey.html><B>ucol_getSortKey</B></A> 
 <DD><I>
Get a sort key for a string from a UCollator</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_keyHashCode.html><B>ucol_keyHashCode</B></A> 
 <DD><I>
Generate a hash code for a collation key</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> struct  <B>UCollationElements</B>
 <DD><I>The UCollationElements struct </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.11.html><B></B></A> 
 <DD><I>
The UCollationElements  is used as an iterator to walk through
each character of an international string</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  <!2><A HREF="#DOC.181">UCollationElements</A>*  <B>ucol_openElements</B>( const <!2><A HREF="#DOC.154">UCollator</A> *coll, const UChar *text, int32_t textLength, <!2><A HREF="#DOC.301">UErrorCode</A> *status)
 <DD><I>
Open the collation elements for a string</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>#define <B>UCOL_PRIMARYMASK</B>
 <DD><I>Bit mask for primary collation strength </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>#define <B>UCOL_SECONDARYMASK</B>
 <DD><I>Bit mask for secondary collation strength </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>#define <B>UCOL_TERTIARYMASK</B>
 <DD><I>Bit mask for tertiary collation strength </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>#define <B>UCOL_NULLORDER</B>
 <DD><I>This indicates the last element in a UCollationElements has been consumed</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_closeElements.html><B>ucol_closeElements</B></A> 
 <DD><I>
Close a UCollationElements</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_reset.html><B>ucol_reset</B></A> 
 <DD><I>
Reset the collation elements to their initial state</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_next.html><B>ucol_next</B></A> 
 <DD><I>
Get the ordering priority of the next collation element in the text</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_previous.html><B>ucol_previous</B></A> 
 <DD><I>
Get the ordering priority of the previous collation element in the text</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_getMaxExpansion.html><B>ucol_getMaxExpansion</B></A> 
 <DD><I>
Get the maximum length of any expansion sequences that end with the 
specified comparison order</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_setText.html><B>ucol_setText</B></A> 
 <DD><I>
Set the text containing the collation elements</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_getOffset.html><B>ucol_getOffset</B></A> 
 <DD><I>
Get the offset of the current source character</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ucol_setOffset.html><B>ucol_setOffset</B></A> 
 <DD><I>
Set the offset of the current source character</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.12.html><B></B></A> 
 <DD><I>
Date Format C API  consists of functions that convert dates and
times from their internal representations to textual form and back again in a
language-independent manner</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>typedef  void*  <B>UDateFormat</B>
 <DD><I>A date formatter </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UDateFormatStyle.html><B>UDateFormatStyle</B></A> 
 <DD><I>The possible date/time format styles </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_open.html><B>udat_open</B></A> 
 <DD><I>
Open a new UDateFormat for formatting and parsing dates and times</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_openPattern.html><B>udat_openPattern</B></A> 
 <DD><I>
Open a new UDateFormat for formatting dates and times</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_close.html><B>udat_close</B></A> 
 <DD><I>
Close a UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_clone.html><B>udat_clone</B></A> 
 <DD><I>
Open a copy of a UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_format.html><B>udat_format</B></A> 
 <DD><I>
Format a date using an UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_parse.html><B>udat_parse</B></A> 
 <DD><I>
Parse a string into an date/time using a UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_isLenient.html><B>udat_isLenient</B></A> 
 <DD><I>
Determine if an UDateFormat will perform lenient parsing</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_setLenient.html><B>udat_setLenient</B></A> 
 <DD><I>
Specify whether an UDateFormat will perform lenient parsing</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_getCalendar.html><B>udat_getCalendar</B></A> 
 <DD><I>
Get the UCalendar associated with an UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_setCalendar.html><B>udat_setCalendar</B></A> 
 <DD><I>
Set the UCalendar associated with an UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_getNumberFormat.html><B>udat_getNumberFormat</B></A> 
 <DD><I>
Get the UNumberFormat associated with an UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_setNumberFormat.html><B>udat_setNumberFormat</B></A> 
 <DD><I>
Set the UNumberFormat associated with an UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_getAvailable.html><B>udat_getAvailable</B></A> 
 <DD><I>
Get a locale for which date/time formatting patterns are available</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_countAvailable.html><B>udat_countAvailable</B></A> 
 <DD><I>
Determine how many locales have date/time  formatting patterns available</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_get2DigitYearStart.html><B>udat_get2DigitYearStart</B></A> 
 <DD><I>
Get the year relative to which all 2-digit years are interpreted</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_set2DigitYearStart.html><B>udat_set2DigitYearStart</B></A> 
 <DD><I>
Set the year relative to which all 2-digit years will be interpreted</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_toPattern.html><B>udat_toPattern</B></A> 
 <DD><I>
Extract the pattern from a UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_applyPattern.html><B>udat_applyPattern</B></A> 
 <DD><I>
Set the pattern used by an UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UDateFormatSymbolType.html><B>UDateFormatSymbolType</B></A> 
 <DD><I>The possible types of date format symbols </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> struct  <B>UDateFormatSymbols</B>
 <DD><I>Date format symbols </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_getSymbols.html><B>udat_getSymbols</B></A> 
 <DD><I>
Get the symbols associated with an UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_countSymbols.html><B>udat_countSymbols</B></A> 
 <DD><I>
Count the number of particular symbols for an UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=udat_setSymbols.html><B>udat_setSymbols</B></A> 
 <DD><I>
Set the symbols associated with an UDateFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.13.html><B></B></A> 
 <DD><I>

A <code>Locale</code> represents a specific geographical, political,
or cultural region</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>#define <B>uloc_ENGLISH</B>
 <DD><I>

Useful constants for language</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>#define <B>uloc_FRANCE</B>
 <DD><I>

Useful constants for country</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  const  char*  U_EXPORT2  <B>uloc_getDefault</B>(void)
 <DD><I>

Gets the system's default locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  void  U_EXPORT2  <B>uloc_setDefault</B>(const char* localeID, <!2><A HREF="#DOC.301">UErrorCode</A>* status)
 <DD><I>

Sets the system's default locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>uloc_getLanguage</B>(const char* localeID, char* language, int32_t languageCapacity, <!2><A HREF="#DOC.301">UErrorCode</A>* err)
 <DD><I>

Gets the language code for the specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>uloc_getCountry</B>(const char* localeID, char* country, int32_t countryCapacity, <!2><A HREF="#DOC.301">UErrorCode</A>* err)
 <DD><I>

Gets the  country code for the specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>uloc_getVariant</B>(const char* localeID, char* variant, int32_t variantCapacity, <!2><A HREF="#DOC.301">UErrorCode</A>* err)
 <DD><I>

Gets the variant code for the specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>uloc_getName</B>(const char* localeID, char* name, int32_t nameCapacity, <!2><A HREF="#DOC.301">UErrorCode</A>* err)
 <DD><I>

Gets the full name for the specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  const  char*  U_EXPORT2  <B>uloc_getISO3Language</B>(const char* localeID)
 <DD><I>

Gets the ISO language code for the specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  const  char*  U_EXPORT2  <B>uloc_getISO3Country</B>(const char* localeID)
 <DD><I>

Gets the ISO country code for the specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  uint32_t  U_EXPORT2  <B>uloc_getLCID</B>(const char* localeID)
 <DD><I>

Gets the Win32 LCID value for the specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>uloc_getDisplayLanguage</B>(const char* locale, const char* inLocale, UChar* language, int32_t languageCapacity, <!2><A HREF="#DOC.301">UErrorCode</A>* status)
 <DD><I>

Gets the language name suitable for display for the specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>uloc_getDisplayCountry</B>(const char* locale, const char* inLocale, UChar* country, int32_t countryCapacity, <!2><A HREF="#DOC.301">UErrorCode</A>* status)
 <DD><I>

Gets the country name suitable for display for the specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>uloc_getDisplayVariant</B>(const char* locale, const char* inLocale, UChar* variant, int32_t variantCapacity, <!2><A HREF="#DOC.301">UErrorCode</A>* status)
 <DD><I>

Gets the variant code suitable for display for the specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>uloc_getDisplayName</B>(const char* localeID, const char* inLocaleID,  UChar* result, int32_t maxResultSize, <!2><A HREF="#DOC.301">UErrorCode</A>* err)
 <DD><I>

Gets the full name suitable for display for the specified locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=uloc_getAvailable.html><B>uloc_getAvailable</B></A> 
 <DD><I>

Gets the specified locale from a list of all available locales</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>uloc_countAvailable</B>(void)
 <DD><I>

Gets the size of the all available locale list</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=uloc_getISOLanguages.html><B>uloc_getISOLanguages</B></A> 
 <DD><I>

Gets a list of all available language codes defined in ISO 639</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=uloc_getISOCountries.html><B>uloc_getISOCountries</B></A> 
 <DD><I>

Gets a list of all available 2-letter country codes defined in ISO 639</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  const  char*  U_EXPORT2  <B>uloc_getDataDirectory</B>(void)
 <DD><I>

Gets the directory containing the locale data files</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  void  U_EXPORT2  <B>uloc_setDataDirectory</B>(const char* newDirectory)
 <DD><I>

Sets the directory containing the locale data files</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.14.html><B></B></A> 
 <DD><I>
Provides means to produce concatenated messages in language-neutral way</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_formatMessage.html><B>u_formatMessage</B></A> 
 <DD><I>
Format a message for a locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_parseMessage.html><B>u_parseMessage</B></A> 
 <DD><I>
Parse a message</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=Unicode.html><B>Unicode</B></A> 
 <DD><I>
The Unicode class allows you to query the properties associated with individual 
Unicode character values</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UnicodeString.html><B>UnicodeString</B></A> 
 <DD><I>
UnicodeString is a concrete implementation of the abstract class 
UnicodeText</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UNumberFormat.html><B>UNumberFormat</B></A> 
 <DD><I>
Number Format C API  Provides functions for
formatting and parsing a number</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UNumberFormatStyle.html><B>UNumberFormatStyle</B></A> 
 <DD><I>The possible number format styles</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_open.html><B>unum_open</B></A> 
 <DD><I>
Open a new UNumberFormat for formatting and parsing numbers</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_openPattern.html><B>unum_openPattern</B></A> 
 <DD><I>
Open a new UNumberFormat for formatting and parsing numbers</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_close.html><B>unum_close</B></A> 
 <DD><I>
Close a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_clone.html><B>unum_clone</B></A> 
 <DD><I>
Open a copy of a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_format.html><B>unum_format</B></A> 
 <DD><I>
Format an integer using a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_formatDouble.html><B>unum_formatDouble</B></A> 
 <DD><I>
Format a double using a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_parse.html><B>unum_parse</B></A> 
 <DD><I>
Parse a string into an integer using a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_parseDouble.html><B>unum_parseDouble</B></A> 
 <DD><I>
Parse a string into a double using a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_getAvailable.html><B>unum_getAvailable</B></A> 
 <DD><I>
Get a locale for which number formatting patterns are available</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_countAvailable.html><B>unum_countAvailable</B></A> 
 <DD><I>
Determine how many locales have number formatting patterns available</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UNumberFormatAttribute.html><B>UNumberFormatAttribute</B></A> 
 <DD><I>The possible UNumberFormat numeric attributes </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_getAttribute.html><B>unum_getAttribute</B></A> 
 <DD><I>
Get a numeric attribute associated with a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_setAttribute.html><B>unum_setAttribute</B></A> 
 <DD><I>
Set a numeric attribute associated with a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_getDoubleAttribute.html><B>unum_getDoubleAttribute</B></A> 
 <DD><I>
Get a numeric attribute associated with a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_setDoubleAttribute.html><B>unum_setDoubleAttribute</B></A> 
 <DD><I>
Set a numeric attribute associated with a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UNumberFormatTextAttribute.html><B>UNumberFormatTextAttribute</B></A> 
 <DD><I>The possible UNumberFormat text attributes </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_getTextAttribute.html><B>unum_getTextAttribute</B></A> 
 <DD><I>
Get a text attribute associated with a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_setTextAttribute.html><B>unum_setTextAttribute</B></A> 
 <DD><I>
Set a text attribute associated with a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_toPattern.html><B>unum_toPattern</B></A> 
 <DD><I>
Extract the pattern from a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>#define <B>UNFSYMBOLSMAXSIZE</B>
 <DD><I>The maximum size for a textual number format symbol </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UNumberFormatSymbols.html><B>UNumberFormatSymbols</B></A> 
 <DD><I>The UNumberFormatSymbols struct </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_getSymbols.html><B>unum_getSymbols</B></A> 
 <DD><I>
Get the symbols associated with a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=unum_setSymbols.html><B>unum_setSymbols</B></A> 
 <DD><I>
Set the symbols associated with a UNumberFormat</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=.15.html><B></B></A> 
 <DD><I>
C API representing a collection of resource information pertaining to a given
locale</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>typedef  void*  <B>UResourceBundle</B>
 <DD><I>A UResourceBundle </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <B></B>
 <DD><I>
Functions to create and destroy resource bundles</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ures_open.html><B>ures_open</B></A> 
 <DD><I>
Opens a UResourceBundle, from which users can extract strings by using
their corresponding keys</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ures_openW.html><B>ures_openW</B></A> 
 <DD><I>
Opens a UResourceBundle, from which users can extract strings by using
their corresponding keys</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  const  UChar*  U_EXPORT2  <B>ures_get</B>(const <!2><A HREF="#DOC.275">UResourceBundle</A>* resourceBundle, const char* resourceTag, <!2><A HREF="#DOC.301">UErrorCode</A>* status)
 <DD><I>

returns a resource string, given a resource bundle and a key
</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  const  UChar*  U_EXPORT2  <B>ures_getArrayItem</B>(const <!2><A HREF="#DOC.275">UResourceBundle</A>* resourceBundle, const char* resourceTag, int32_t resourceIndex, <!2><A HREF="#DOC.301">UErrorCode</A>* status)
 <DD><I>
returns a resource string which is part of an array, given a resource bundle
a key to the array and the index of the desired string
</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  const  UChar*  U_EXPORT2  <B>ures_get2dArrayItem</B>(const <!2><A HREF="#DOC.275">UResourceBundle</A>* resourceBundle, const char* resourceTag, int32_t rowIndex, int32_t columnIndex, <!2><A HREF="#DOC.301">UErrorCode</A>* status)
 <DD><I>
returns a resource string which is part of a 2D array, given a resource bundle
a key to the array and the index pair of the desired string
</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  const  UChar*  U_EXPORT2  <B>ures_getTaggedArrayItem</B>(const <!2><A HREF="#DOC.275">UResourceBundle</A>* resourceBundle, const char* resourceTag, const char* itemTag, <!2><A HREF="#DOC.301">UErrorCode</A>* status)
 <DD><I>
returns a resource string which is part of a tagged array, given a resource bundle
a key to the array and the key of the desired string</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>ures_countArrayItems</B>(const <!2><A HREF="#DOC.275">UResourceBundle</A>* resourceBundle, const char* resourceKey, <!2><A HREF="#DOC.301">UErrorCode</A>* err)
 <DD><I>


</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  void  U_EXPORT2  <B>ures_close</B>(<!2><A HREF="#DOC.275">UResourceBundle</A>* resourceBundle)
 <DD><I>
close a resource bundle, all pointers returned from the various ures_getXXX calls
on this particular bundle are INVALID henceforth</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ures_getVersionNumber.html><B>ures_getVersionNumber</B></A> 
 <DD><I>
Return the version number associated with this ResourceBundle</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>u_strlen</B>(const UChar *s)
 <DD><I>
Determine the length of an array of UChar
</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_strcat.html><B>u_strcat</B></A> 
 <DD><I>
Concatenate two ustrings</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_strncat.html><B>u_strncat</B></A> 
 <DD><I>
Concatenate two ustrings</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  UChar*  U_EXPORT2  <B>u_strchr</B>(const UChar *s, UChar c)
 <DD><I>
Find the first occurrence of a specified character in a ustring</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif>CAPI  int32_t  U_EXPORT2  <B>u_strcmp</B>(const UChar *s1, const UChar *s2)
 <DD><I>
Compare two ustrings for bitwise equality</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_strncmp.html><B>u_strncmp</B></A> 
 <DD><I>
Compare two ustrings for bitwise equality</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_strcpy.html><B>u_strcpy</B></A> 
 <DD><I>
Copy a ustring</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_strncpy.html><B>u_strncpy</B></A> 
 <DD><I>
Copy a ustring</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_uastrcpy.html><B>u_uastrcpy</B></A> 
 <DD><I>
Copy a byte string encoded in the default codepage to a ustring</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_uastrncpy.html><B>u_uastrncpy</B></A> 
 <DD><I>
Copy a byte string encoded in the default codepage to a ustring</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=u_austrcpy.html><B>u_austrcpy</B></A> 
 <DD><I>
Copy ustring to a byte string encoded in the default codepage</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ICU_VERSION.html><B>ICU_VERSION</B></A> 
 <DD><I>
ICU package code version number</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=UFieldPosition.html><B>UFieldPosition</B></A> 
 <DD><I>A struct representing a range of text containing a specific field </I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=ClassID.html><B>ClassID</B></A> 
 <DD><I>
ClassID is used to identify classes without using RTTI, since RTTI
is not yet supported by all C++ compilers</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> <A HREF=U_COMMON_API.html><B>U_COMMON_API</B></A> 
 <DD><I>
Control of symbol import/export</I>
<DT>
<IMG BORDER=0 SRC=icon1.gif> enum  <B>UErrorCode</B>
 <DD><I>Error code to replace exception handling </I>
</DL>
<A NAME="DOC.DOCU">
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
