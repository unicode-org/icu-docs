<html><head><TITLE>SimpleDateFormat</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  U_I18N_API SimpleDateFormat : public <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A> </H2><BLOCKQUOTE>

SimpleDateFormat is a concrete class for formatting and parsing dates in a
language-independent manner
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=95>
<param name=classes value="CFormat,MFormat.html,CDateFormat,MDateFormat.html,CSimpleDateFormat,MSimpleDateFormat.html">
<param name=before value="M,M,M">
<param name=after value="Md_SP,Md_,M">
<param name=indent value="0,1,2">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Fields</h3><DD><DT><A HREF="#DOC.45.42"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>  <B>fgErasTag</B> </B>
 <DD><I>
Resource bundle file suffix and tag names used by this class</I>
<DT><A HREF="#DOC.45.55"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  <!1><A HREF="UDate.html">UDate</A>  <B>fgSystemDefaultCentury</B> </B>
 <DD><I>
If a start date is set to this value, that indicates that the system default
start is in effect for this instance</I>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.45.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>SimpleDateFormat</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
Construct a SimpleDateFormat using the default pattern for the default
locale</I>
<DT><A HREF="#DOC.45.2"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>SimpleDateFormat</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
Construct a SimpleDateFormat using the given pattern and the default locale</I>
<DT><A HREF="#DOC.45.3"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>SimpleDateFormat</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, const Locale& locale, <!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
Construct a SimpleDateFormat using the given pattern and locale</I>
<DT><A HREF="#DOC.45.4"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>SimpleDateFormat</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!1><A HREF="DateFormatSymbols.html">DateFormatSymbols</A>* formatDataToAdopt, <!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
Construct a SimpleDateFormat using the given pattern and locale-specific
symbol data</I>
<DT><A HREF="#DOC.45.5"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>SimpleDateFormat</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, const <!1><A HREF="DateFormatSymbols.html">DateFormatSymbols</A>& formatData, <!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
Construct a SimpleDateFormat using the given pattern and locale-specific
symbol data</I>
<DT><A HREF="#DOC.45.36"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>SimpleDateFormat</B>(const <!2><A HREF="SimpleDateFormat.html#DOC.45.5">SimpleDateFormat</A>&) </B>
 <DD><I>
Copy constructor</I>
<DT><A HREF="#DOC.45.37"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="SimpleDateFormat.html#DOC.45.5">SimpleDateFormat</A>&  <B>operator=</B>(const <!2><A HREF="SimpleDateFormat.html#DOC.45.5">SimpleDateFormat</A>&) </B>
 <DD><I>
Assignment operator</I>
<DT><A HREF="#DOC.45.38"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <B>~SimpleDateFormat</B>() </B>
 <DD><I>
Destructor</I>
<DT><A HREF="#DOC.45.6"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!2><A HREF="Format.html#DOC.25.8">Format</A>*  <B>clone</B>(void) const  </B>
 <DD><I>
Clone this Format object polymorphically</I>
<DT><A HREF="#DOC.45.7"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>operator==</B>(const <!2><A HREF="Format.html#DOC.25.8">Format</A>& other) const  </B>
 <DD><I>
Return true if the given Format objects are semantically equal</I>
<DT><A HREF="#DOC.45.8"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>( <!1><A HREF="UDate.html">UDate</A> date, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos) const  </B>
 <DD><I>
Format a date or time, which is the standard millis since 24:00 GMT, Jan
1, 1970</I>
<DT><A HREF="#DOC.45.9"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>( const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
Format a date or time, which is the standard millis since 24:00 GMT, Jan
1, 1970</I>
<DT><A HREF="#DOC.45.39"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
Redeclared DateFormat method</I>
<DT><A HREF="#DOC.45.40"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>(<!1><A HREF="UDate.html">UDate</A> date, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Redeclared DateFormat method</I>
<DT><A HREF="#DOC.45.10"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UDate.html">UDate</A>  <B>parse</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!1><A HREF="ParsePosition.html">ParsePosition</A>& pos) const  </B>
 <DD><I>
Parse a date/time string starting at the given parse position</I>
<DT><A HREF="#DOC.45.11"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UDate.html">UDate</A>  <B>parse</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
Parse a date/time string</I>
<DT><A HREF="#DOC.45.12"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>set2DigitYearStart</B>(<!1><A HREF="UDate.html">UDate</A> d, <!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
Set the start UDate used to interpret two-digit year strings</I>
<DT><A HREF="#DOC.45.13"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UDate.html">UDate</A>  <B>get2DigitYearStart</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
Get the start UDate used to interpret two-digit year strings</I>
<DT><A HREF="#DOC.45.41"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>toPattern</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Return a pattern string describing this date format</I>
<DT><A HREF="#DOC.45.14"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>toLocalizedPattern</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
Return a localized pattern string describing this date format</I>
<DT><A HREF="#DOC.45.15"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>applyPattern</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern) </B>
 <DD><I>
Apply the given unlocalized pattern string to this date format</I>
<DT><A HREF="#DOC.45.16"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>applyLocalizedPattern</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
Apply the given localized pattern string to this date format</I>
<DT><A HREF="#DOC.45.17"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  const  <!1><A HREF="DateFormatSymbols.html">DateFormatSymbols</A>*  <B>getDateFormatSymbols</B>(void) const  </B>
 <DD><I>
Gets the date/time formatting symbols (this is an object carrying
the various strings and other symbols used in formatting: e</I>
<DT><A HREF="#DOC.45.18"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>adoptDateFormatSymbols</B>(<!1><A HREF="DateFormatSymbols.html">DateFormatSymbols</A>* newFormatSymbols) </B>
 <DD><I>
Set the date/time formatting symbols</I>
<DT><A HREF="#DOC.45.19"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setDateFormatSymbols</B>(const <!1><A HREF="DateFormatSymbols.html">DateFormatSymbols</A>& newFormatSymbols) </B>
 <DD><I>
Set the date/time formatting data</I>
<DT><A HREF="#DOC.45.20"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!1><A HREF="UClassID.html">UClassID</A>  <B>getStaticClassID</B>(void) </B>
 <DD><I>
Return the class ID for this class</I>
<DT><A HREF="#DOC.45.21"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UClassID.html">UClassID</A>  <B>getDynamicClassID</B>(void) const  </B>
 <DD><I>
Returns a unique class ID POLYMORPHICALLY</I>
<DT><A HREF="#DOC.45.31"> <IMG BORDER=0 SRC=icon1.gif></A> static  void  <B>translatePattern</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& originalPattern, <!1><A HREF="UnicodeString.html">UnicodeString</A>& translatedPattern, const <!1><A HREF="UnicodeString.html">UnicodeString</A>& from, const <!1><A HREF="UnicodeString.html">UnicodeString</A>& to, <!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
Translate a pattern, mapping each character in the from string to the
corresponding character in the to string</I>
<DT><A HREF="#DOC.45.44"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>parseAmbiguousDatesAsAfter</B>(<!1><A HREF="UDate.html">UDate</A> startDate, <!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
Sets the starting date of the 100-year window that dates with 2-digit years
are considered to fall within</I>
</DL></DL>
<hr><H3>Inherited from <A HREF="DateFormat.html">DateFormat:</A></h3>

<DL>
<DL>
<DT><h3>Public Classes</h3><DD><DT><IMG SRC=icon2.gif>  enum  <B>EField</B>

<DL>
<DT><A HREF="#DOC.19.1.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>ERA_FIELD</B> </B>
 <DD><I>
These constants are provided for backwards compatibility only,
and are deprecated</I>

</DL>
<DT><IMG SRC=icon2.gif>  enum  <B>EStyle</B>

<DL>
<DT><A HREF="#DOC.19.2.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>FULL</B> </B>
 <DD><I>
These constants are provided for backwards compatibility only,
and are deprecated</I>

</DL>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><IMG SRC=icon2.gif> virtual  void  <B>parseObject</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parse_pos) const 
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  <B>createInstance</B>(void)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  <B>createTimeInstance</B>(<!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> style = kDefault, const Locale& aLocale = Locale::getDefault())
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  <B>createDateInstance</B>(<!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> style = kDefault, const Locale& aLocale = Locale::getDefault())
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  <B>createDateTimeInstance</B>(<!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> dateStyle = kDefault, <!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> timeStyle = kDefault, const Locale& aLocale = Locale::getDefault())
<DT><IMG SRC=icon2.gif> static  const  Locale*  <B>getAvailableLocales</B>(int32_t& count)
<DT><IMG SRC=icon2.gif> virtual  bool_t  <B>isLenient</B>(void) const 
<DT><IMG SRC=icon2.gif> virtual  void  <B>setLenient</B>(bool_t lenient)
<DT><IMG SRC=icon2.gif> virtual  const  <!1><A HREF="Calendar.html">Calendar</A>*  <B>getCalendar</B>(void) const 
<DT><IMG SRC=icon2.gif> virtual  void  <B>adoptCalendar</B>(<!1><A HREF="Calendar.html">Calendar</A>* calendarToAdopt)
<DT><IMG SRC=icon2.gif> virtual  void  <B>setCalendar</B>(const <!1><A HREF="Calendar.html">Calendar</A>& newCalendar)
<DT><IMG SRC=icon2.gif> virtual  const  <!1><A HREF="NumberFormat.html">NumberFormat</A>*  <B>getNumberFormat</B>(void) const 
<DT><IMG SRC=icon2.gif> virtual  void  <B>adoptNumberFormat</B>(<!1><A HREF="NumberFormat.html">NumberFormat</A>* formatToAdopt)
<DT><IMG SRC=icon2.gif> virtual  void  <B>setNumberFormat</B>(const <!1><A HREF="NumberFormat.html">NumberFormat</A>& newNumberFormat)
<DT><IMG SRC=icon2.gif> virtual  const  <!1><A HREF="TimeZone.html">TimeZone</A>&  <B>getTimeZone</B>(void) const 
<DT><IMG SRC=icon2.gif> virtual  void  <B>adoptTimeZone</B>(<!1><A HREF="TimeZone.html">TimeZone</A>* zoneToAdopt)
<DT><IMG SRC=icon2.gif> virtual  void  <B>setTimeZone</B>(const <!1><A HREF="TimeZone.html">TimeZone</A>& zone)
</DL><DL>
<DT><h3>Protected Fields</h3><DD><DT><IMG SRC=icon2.gif> <!1><A HREF="Calendar.html">Calendar</A>*  <B>fCalendar</B>
<DT><IMG SRC=icon2.gif> <!1><A HREF="NumberFormat.html">NumberFormat</A>*  <B>fNumberFormat</B>
</DL></DL>
<hr><H3>Inherited from <A HREF = "Format.html"> Format:</A></h3>

<DL>
<DL>
<DT><h3>Public Methods</h3><DD><DT><IMG SRC=icon2.gif> bool_t  <B>operator!=</B>(const <!2><A HREF="Format.html#DOC.25.8">Format</A>& other) const 
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

SimpleDateFormat is a concrete class for formatting and parsing dates in a
language-independent manner. It allows for formatting (millis -> text),
parsing (text -> millis), and normalization. Formats/Parses a date or time,
which is the standard milliseconds since 24:00 GMT, Jan 1, 1970.
<P>
Clients are encouraged to create a date-time formatter using DateFormat::getInstance(),
getDateInstance(), getDateInstance(), or getDateTimeInstance() rather than
explicitly constructing an instance of SimpleDateFormat.  This way, the client
is guaranteed to get an appropriate formatting pattern for whatever locale the
program is running in.  However, if the client needs something more unusual than
the default patterns in the locales, he can construct a SimpleDateFormat directly
and give it an appropriate pattern (or use one of the factory methods on DateFormat
and modify the pattern after the fact with toPattern() and applyPattern().
<P>
Date/Time format syntax:
<P>
The date/time format is specified by means of a string time pattern. In this
pattern, all ASCII letters are reserved as pattern letters, which are defined
as the following:
<pre>
.   Symbol   Meaning                 Presentation       Example
.   ------   -------                 ------------       -------
.   G        era designator          (Text)             AD
.   y        year                    (Number)           1996
.   M        month in year           (Text & Number)    July & 07
.   d        day in month            (Number)           10
.   h        hour in am/pm (1~12)    (Number)           12
.   H        hour in day (0~23)      (Number)           0
.   m        minute in hour          (Number)           30
.   s        second in minute        (Number)           55
.   S        millisecond             (Number)           978
.   E        day in week             (Text)             Tuesday
.   D        day in year             (Number)           189
.   F        day of week in month    (Number)           2 (2nd Wed in July)
.   w        week in year            (Number)           27
.   W        week in month           (Number)           2
.   a        am/pm marker            (Text)             PM
.   k        hour in day (1~24)      (Number)           24
.   K        hour in am/pm (0~11)    (Number)           0
.   z        time zone               (Text)             Pacific Standard Time
.   '        escape for text
.   ''       single quote                               '
</pre>
The count of pattern letters determine the format.
<P>
(Text): 4 or more, use full form, &lt;4, use short or abbreviated form if it
exists. (e.g., "EEEE" produces "Monday", "EEE" produces "Mon")
<P>
(Number): the minimum number of digits. Shorter numbers are zero-padded to
this amount (e.g. if "m" produces "6", "mm" produces "06"). Year is handled
specially; that is, if the count of 'y' is 2, the Year will be truncated to 2 digits.
(e.g., if "yyyy" produces "1997", "yy" produces "97".)
<P>
(Text & Number): 3 or over, use text, otherwise use number.  (e.g., "M" produces "1",
"MM" produces "01", "MMM" produces "Jan", and "MMMM" produces "January".)
<P>
Any characters in the pattern that are not in the ranges of ['a'..'z'] and
['A'..'Z'] will be treated as quoted text. For instance, characters
like ':', '.', ' ', '#' and '@' will appear in the resulting time text
even they are not embraced within single quotes.
<P>
A pattern containing any invalid pattern letter will result in a failing
UErrorCode result during formatting or parsing.
<P>
Examples using the US locale:
<pre>
.   Format Pattern                         Result
.   --------------                         -------
.   "yyyy.MM.dd G 'at' HH:mm:ss z"    ->>  1996.07.10 AD at 15:08:56 PDT
.   "EEE, MMM d, ''yy"                ->>  Wed, July 10, '96
.   "h:mm a"                          ->>  12:08 PM
.   "hh 'o''clock' a, zzzz"           ->>  12 o'clock PM, Pacific Daylight Time
.   "K:mm a, z"                       ->>  0:00 PM, PST
.   "yyyyy.MMMMM.dd GGG hh:mm aaa"    ->>  1996.July.10 AD 12:08 PM
</pre>
Code Sample:
<pre>
.    UErrorCode success = U_ZERO_ERROR;
.    SimpleTimeZone* pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, "PST");
.    pdt->setStartRule( Calendar::APRIL, 1, Calendar::SUNDAY, 2*60*60*1000);
.    pdt->setEndRule( Calendar::OCTOBER, -1, Calendar::SUNDAY, 2*60*60*1000);
.    
.    // Format the current time.
.    SimpleDateFormat* formatter
.        = new SimpleDateFormat ("yyyy.MM.dd G 'at' hh:mm:ss a zzz", success );
.    GregorianCalendar cal(success);
.    UDate currentTime_1 = cal.getTime(success);
.    FieldPosition fp(0);
.    UnicodeString dateString;
.    formatter->format( currentTime_1, dateString, fp );
.    cout &lt;&lt; "result: " &lt;&lt; dateString &lt;&lt; endl;
.    
.    // Parse the previous string back into a Date.
.    ParsePosition pp(0);
.    UDate currentTime_2 = formatter->parse(dateString, pp );
</pre>
In the above example, the time value "currentTime_2" obtained from parsing
will be equal to currentTime_1. However, they may not be equal if the am/pm
marker 'a' is left out from the format pattern while the "hour in am/pm"
pattern symbol is used. This information loss can happen when formatting the
time in PM.

<p>
When parsing a date string using the abbreviated year pattern ("y" or "yy"),
SimpleDateFormat must interpret the abbreviated year
relative to some century.  It does this by adjusting dates to be
within 80 years before and 20 years after the time the SimpleDateFormat
instance is created. For example, using a pattern of "MM/dd/yy" and a
SimpleDateFormat instance created on Jan 1, 1997,  the string
"01/11/12" would be interpreted as Jan 11, 2012 while the string "05/04/64"
would be interpreted as May 4, 1964.
During parsing, only strings consisting of exactly two digits, as defined by
<code>Unicode::isDigit()</code>, will be parsed into the default century.
Any other numeric string, such as a one digit string, a three or more digit
string, or a two digit string that isn't all digits (for example, "-1"), is
interpreted literally.  So "01/02/3" or "01/02/003" are parsed, using the
same pattern, as Jan 2, 3 AD.  Likewise, "01/02/-3" is parsed as Jan 2, 4 BC.

<p>
If the year pattern has more than two 'y' characters, the year is
interpreted literally, regardless of the number of digits.  So using the
pattern "MM/dd/yyyy", "01/11/12" parses to Jan 11, 12 A.D.

<P>
For time zones that have no names, SimpleDateFormat uses strings GMT+hours:minutes or
GMT-hours:minutes.
<P>
The calendar defines what is the first day of the week, the first week of the
year, whether hours are zero based or not (0 vs 12 or 24), and the timezone.
There is one common number format to handle all the numbers; the digit count
is handled programmatically according to the pattern.

</BLOCKQUOTE>
<DL>

<A NAME="SimpleDateFormat">
<A NAME ="DOC.45.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  SimpleDateFormat(<!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
Construct a SimpleDateFormat using the default pattern for the default
locale.
<P>
[Note:] Not all locales support SimpleDateFormat; for full generality,
use the factory methods in the DateFormat class.
<DL></DL><P>
<A NAME="SimpleDateFormat">
<A NAME ="DOC.45.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  SimpleDateFormat(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
Construct a SimpleDateFormat using the given pattern and the default locale.
The locale is used to obtain the symbols used in formatting (e.g., the
names of the months), but not to provide the pattern.
<P>
[Note:] Not all locales support SimpleDateFormat; for full generality,
use the factory methods in the DateFormat class.
<DL></DL><P>
<A NAME="SimpleDateFormat">
<A NAME ="DOC.45.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  SimpleDateFormat(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, const Locale& locale, <!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
Construct a SimpleDateFormat using the given pattern and locale.
The locale is used to obtain the symbols used in formatting (e.g., the
names of the months), but not to provide the pattern.
<P>
[Note:] Not all locales support SimpleDateFormat; for full generality,
use the factory methods in the DateFormat class.
<DL></DL><P>
<A NAME="SimpleDateFormat">
<A NAME ="DOC.45.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  SimpleDateFormat(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!1><A HREF="DateFormatSymbols.html">DateFormatSymbols</A>* formatDataToAdopt, <!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
Construct a SimpleDateFormat using the given pattern and locale-specific
symbol data.  The formatter takes ownership of the DateFormatSymbols object;
the caller is no longer responsible for deleting it.
<DL></DL><P>
<A NAME="SimpleDateFormat">
<A NAME ="DOC.45.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  SimpleDateFormat(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, const <!1><A HREF="DateFormatSymbols.html">DateFormatSymbols</A>& formatData, <!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
Construct a SimpleDateFormat using the given pattern and locale-specific
symbol data.  The DateFormatSymbols object is NOT adopted; the caller
remains responsible for deleting it.
<DL></DL><P>
<A NAME="SimpleDateFormat">
<A NAME ="DOC.45.36">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  SimpleDateFormat(const <!2><A HREF="SimpleDateFormat.html#DOC.45.5">SimpleDateFormat</A>&)</B></TT>
<DD>
Copy constructor
<DL></DL><P>
<A NAME="operator=">
<A NAME ="DOC.45.37">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="SimpleDateFormat.html#DOC.45.5">SimpleDateFormat</A>&  operator=(const <!2><A HREF="SimpleDateFormat.html#DOC.45.5">SimpleDateFormat</A>&)</B></TT>
<DD>
Assignment operator
<DL></DL><P>
<A NAME="~SimpleDateFormat">
<A NAME ="DOC.45.38">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  ~SimpleDateFormat()</B></TT>
<DD>
Destructor
<DL></DL><P>
<A NAME="clone">
<A NAME ="DOC.45.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!2><A HREF="Format.html#DOC.25.8">Format</A>*  clone(void) const </B></TT>
<DD>
Clone this Format object polymorphically. The caller owns the result and
should delete it when done.
<DL></DL><P>
<A NAME="operator==">
<A NAME ="DOC.45.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  operator==(const <!2><A HREF="Format.html#DOC.25.8">Format</A>& other) const </B></TT>
<DD>
Return true if the given Format objects are semantically equal. Objects
of different subclasses are considered unequal.
<DL></DL><P>
<A NAME="format">
<A NAME ="DOC.45.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format( <!1><A HREF="UDate.html">UDate</A> date, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos) const </B></TT>
<DD>
Format a date or time, which is the standard millis since 24:00 GMT, Jan
1, 1970. Overrides DateFormat pure virtual method.
<P>
Example: using the US locale: "yyyy.MM.dd e 'at' HH:mm:ss zzz" ->>
1996.07.10 AD at 15:08:56 PDT


<DL><DT><B>Returns:</B><DD>A reference to 'toAppendTo'.
<DT><B>Parameters:</B><DD><B>date</B> -           The date-time value to be formatted into a date-time string.
<br><B>toAppendTo</B> -     The result of the formatting operation is appended to this
string.
<br><B>pos</B> -            The formatting position. On input: an alignment field,
if desired. On output: the offsets of the alignment field.
<br></DL><P>
<A NAME="format">
<A NAME ="DOC.45.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format( const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
Format a date or time, which is the standard millis since 24:00 GMT, Jan
1, 1970. Overrides DateFormat pure virtual method.
<P>
Example: using the US locale: "yyyy.MM.dd e 'at' HH:mm:ss zzz" ->>
1996.07.10 AD at 15:08:56 PDT


<DL><DT><B>Returns:</B><DD>A reference to 'toAppendTo'.
<DT><B>Parameters:</B><DD><B>obj</B> -            A Formattable containing the date-time value to be formatted
into a date-time string.  If the type of the Formattable
is a numeric type, it is treated as if it were an
instance of Date.
<br><B>toAppendTo</B> -     The result of the formatting operation is appended to this
string.
<br><B>pos</B> -            The formatting position. On input: an alignment field,
if desired. On output: the offsets of the alignment field.
<br></DL><P>
<A NAME="format">
<A NAME ="DOC.45.39">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
Redeclared DateFormat method
<DL></DL><P>
<A NAME="format">
<A NAME ="DOC.45.40">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format(<!1><A HREF="UDate.html">UDate</A> date, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Redeclared DateFormat method
<DL></DL><P>
<A NAME="parse">
<A NAME ="DOC.45.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UDate.html">UDate</A>  parse( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!1><A HREF="ParsePosition.html">ParsePosition</A>& pos) const </B></TT>
<DD>
Parse a date/time string starting at the given parse position. For
example, a time text "07/10/96 4:5 PM, PDT" will be parsed into a Date
that is equivalent to Date(837039928046).
<P>
By default, parsing is lenient: If the input is not in the form used by
this object's format method but can still be parsed as a date, then the
parse succeeds. Clients may insist on strict adherence to the format by
calling setLenient(false).


<DL><DT><B>Returns:</B><DD>A valid UDate if the input could be parsed.
<DT><B>Parameters:</B><DD><B>text</B> -   The date/time string to be parsed
<br><B>pos</B> -    On input, the position at which to start parsing; on
output, the position at which parsing terminated, or the
start position if the parse failed.
<br><DT><B>See Also:</B><DD><!2><A HREF="DateFormat.html#DOC.19.15">DateFormat::setLenient</A>(boolean)
<br></DL><P>
<A NAME="parse">
<A NAME ="DOC.45.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UDate.html">UDate</A>  parse( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
Parse a date/time string. For example, a time text "07/10/96 4:5 PM, PDT"
will be parsed into a UDate that is equivalent to Date(837039928046).
Parsing begins at the beginning of the string and proceeds as far as
possible.  Assuming no parse errors were encountered, this function
doesn't return any information about how much of the string was consumed
by the parsing.  If you need that information, use the version of
parse() that takes a ParsePosition.


<DL><DT><B>Returns:</B><DD>A valid UDate if the input could be parsed.
<DT><B>Parameters:</B><DD><B>text</B> -   The date/time string to be parsed
<br><B>status</B> -  Filled in with U_ZERO_ERROR if the parse was successful, and with
an error value if there was a parse error.
<br></DL><P>
<A NAME="set2DigitYearStart">
<A NAME ="DOC.45.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  set2DigitYearStart(<!1><A HREF="UDate.html">UDate</A> d, <!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
Set the start UDate used to interpret two-digit year strings.
When dates are parsed having 2-digit year strings, they are placed within
a assumed range of 100 years starting on the two digit start date.  For
example, the string "24-Jan-17" may be in the year 1817, 1917, 2017, or
some other year.  SimpleDateFormat chooses a year so that the resultant
date is on or after the two digit start date and within 100 years of the
two digit start date.
<P>
By default, the two digit start date is set to 80 years before the current
time at which a SimpleDateFormat object is created.
<DL></DL><P>
<A NAME="get2DigitYearStart">
<A NAME ="DOC.45.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UDate.html">UDate</A>  get2DigitYearStart(<!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
Get the start UDate used to interpret two-digit year strings.
When dates are parsed having 2-digit year strings, they are placed within
a assumed range of 100 years starting on the two digit start date.  For
example, the string "24-Jan-17" may be in the year 1817, 1917, 2017, or
some other year.  SimpleDateFormat chooses a year so that the resultant
date is on or after the two digit start date and within 100 years of the
two digit start date.
<P>
By default, the two digit start date is set to 80 years before the current
time at which a SimpleDateFormat object is created.
<DL></DL><P>
<A NAME="toPattern">
<A NAME ="DOC.45.41">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  toPattern(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Return a pattern string describing this date format
<DL></DL><P>
<A NAME="toLocalizedPattern">
<A NAME ="DOC.45.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  toLocalizedPattern(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
Return a localized pattern string describing this date format.
In most cases, this will return the same thing as toPattern(),
but a locale can specify characters to use in pattern descriptions
in place of the ones described in this class's class documentation.
(Presumably, letters that would be more mnemonic in that locale's
language.)  This function would produce a pattern using those
letters.


<DL><DT><B>Parameters:</B><DD><B>result</B> -     Receives the localized pattern.
<br><B>status</B> -     Output param set to success/failure code on
exit. If the pattern is invalid, this will be
set to a failure result.<br></DL><P>
<A NAME="applyPattern">
<A NAME ="DOC.45.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  applyPattern(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern)</B></TT>
<DD>
Apply the given unlocalized pattern string to this date format.
(i.e., after this call, this formatter will format dates according to
the new pattern)


<DL><DT><B>Parameters:</B><DD><B>pattern</B> -    The pattern to be applied.<br></DL><P>
<A NAME="applyLocalizedPattern">
<A NAME ="DOC.45.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  applyLocalizedPattern(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
Apply the given localized pattern string to this date format.
(see toLocalizedPattern() for more information on localized patterns.)


<DL><DT><B>Parameters:</B><DD><B>pattern</B> -    The localized pattern to be applied.
<br><B>status</B> -     Output param set to success/failure code on
exit. If the pattern is invalid, this will be
set to a failure result.<br></DL><P>
<A NAME="getDateFormatSymbols">
<A NAME ="DOC.45.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  const  <!1><A HREF="DateFormatSymbols.html">DateFormatSymbols</A>*  getDateFormatSymbols(void) const </B></TT>
<DD>
Gets the date/time formatting symbols (this is an object carrying
the various strings and other symbols used in formatting: e.g., month
names and abbreviations, time zone names, AM/PM strings, etc.)

<DL><DT><B>Returns:</B><DD>a copy of the date-time formatting data associated
with this date-time formatter.
</DL><P>
<A NAME="adoptDateFormatSymbols">
<A NAME ="DOC.45.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  adoptDateFormatSymbols(<!1><A HREF="DateFormatSymbols.html">DateFormatSymbols</A>* newFormatSymbols)</B></TT>
<DD>
Set the date/time formatting symbols.  The caller no longer owns the
DateFormatSymbols object and should not delete it after making this call.

<DL><DT><B>Parameters:</B><DD><B>newFormatData</B> -  the given date-time formatting data.<br></DL><P>
<A NAME="setDateFormatSymbols">
<A NAME ="DOC.45.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setDateFormatSymbols(const <!1><A HREF="DateFormatSymbols.html">DateFormatSymbols</A>& newFormatSymbols)</B></TT>
<DD>
Set the date/time formatting data
<DL><DT><B>Parameters:</B><DD><B>newFormatData</B> -  the given date-time formatting data.<br></DL><P>
<A NAME="fgErasTag">
<A NAME ="DOC.45.42">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>  fgErasTag</B></TT>
<DD>
Resource bundle file suffix and tag names used by this class
<DL></DL><P>
<A NAME="getStaticClassID">
<A NAME ="DOC.45.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!1><A HREF="UClassID.html">UClassID</A>  getStaticClassID(void)</B></TT>
<DD>
Return the class ID for this class. This is useful only for comparing to
a return value from getDynamicClassID(). For example:
<pre>
.   Base* polymorphic_pointer = createPolymorphicObject();
.   if (polymorphic_pointer->getDynamicClassID() ==
.       erived::getStaticClassID()) ...
</pre>

<DL><DT><B>Returns:</B><DD>The class ID for all objects of this class.
</DL><P>
<A NAME="getDynamicClassID">
<A NAME ="DOC.45.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UClassID.html">UClassID</A>  getDynamicClassID(void) const </B></TT>
<DD>
Returns a unique class ID POLYMORPHICALLY. Pure virtual override. This
method is to implement a simple version of RTTI, since not all C++
compilers support genuine RTTI. Polymorphic operator==() and clone()
methods call this method.


<DL><DT><B>Returns:</B><DD>The class ID for this object. All objects of a
given class have the same class ID.  Objects of
other classes have different class IDs.
</DL><P>
<A NAME="translatePattern">
<A NAME ="DOC.45.31">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  void  translatePattern(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& originalPattern, <!1><A HREF="UnicodeString.html">UnicodeString</A>& translatedPattern, const <!1><A HREF="UnicodeString.html">UnicodeString</A>& from, const <!1><A HREF="UnicodeString.html">UnicodeString</A>& to, <!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
Translate a pattern, mapping each character in the from string to the
corresponding character in the to string. Return an error if the original
pattern contains an unmapped character, or if a quote is unmatched.
Quoted (single quotes only) material is not translated.
<DL></DL><P>
<A NAME="parseAmbiguousDatesAsAfter">
<A NAME ="DOC.45.44">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  parseAmbiguousDatesAsAfter(<!1><A HREF="UDate.html">UDate</A> startDate, <!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
Sets the starting date of the 100-year window that dates with 2-digit years
are considered to fall within
<DL></DL><P>
<A NAME="fgSystemDefaultCentury">
<A NAME ="DOC.45.55">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  <!1><A HREF="UDate.html">UDate</A>  fgSystemDefaultCentury</B></TT>
<DD>
If a start date is set to this value, that indicates that the system default
start is in effect for this instance
<DL></DL><P></DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
