<html><head><TITLE>Normalizer</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  <!1><A HREF="U_COMMON_API.html">U_COMMON_API</A> Normalizer  </H2><BLOCKQUOTE>

<tt>Normalizer</tt> transforms Unicode text into an equivalent composed or
decomposed form, allowing for easier sorting and searching of text
</BLOCKQUOTE>
<hr>

<DL>
<DL>
<DT><h3>Public Classes</h3><DD><DT><A HREF="#DOC.18.1"> <IMG BORDER=0 SRC=icon1.gif></A>  enum  <B>EMode</B> </B>
 <DD><I>The mode of a Normalizer object </I>

<DL>
<DT><A HREF="#DOC.18.1.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>NO_OP</B> </B>
 <DD><I>
Null operation for use with the {@link #Normalizer constructors}
and the static {@link #normalize normalize} method</I>
<DT><A HREF="#DOC.18.1.2"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>COMPOSE</B> </B>
 <DD><I>
Canonical decomposition followed by canonical composition</I>
<DT><A HREF="#DOC.18.1.3"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>COMPOSE_COMPAT</B> </B>
 <DD><I>
Compatibility decomposition followed by canonical composition</I>
<DT><A HREF="#DOC.18.1.4"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DECOMP</B> </B>
 <DD><I>
Canonical decomposition</I>
<DT><A HREF="#DOC.18.1.5"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DECOMP_COMPAT</B> </B>
 <DD><I>
Compatibility decomposition</I>

</DL>
<DT><A HREF="#DOC.18.2"> <IMG BORDER=0 SRC=icon1.gif></A>  enum <B></B> </B>
 <DD><I>The options for a Normalizer object </I>

<DL>
<DT><A HREF="#DOC.18.2.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>IGNORE_HANGUL</B> </B>
 <DD><I>
Option to disable Hangul/Jamo composition and decomposition</I>

</DL>
</DL><DL>
<DT><h3>Public Fields</h3><DD><DT><A HREF="#DOC.18.27"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  UChar  <B>DONE</B> </B>
 <DD><I></I>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.18.3"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Normalizer</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& str, <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> mode) </B>
 <DD><I>
Creates a new <tt>Normalizer</tt> object for iterating over the
normalized form of a given string</I>
<DT><A HREF="#DOC.18.4"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Normalizer</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& str, <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> mode, int32_t opt) </B>
 <DD><I>
Creates a new <tt>Normalizer</tt> object for iterating over the
normalized form of a given string</I>
<DT><A HREF="#DOC.18.5"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Normalizer</B>(const <!1><A HREF="CharacterIterator.html">CharacterIterator</A>& iter, <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> mode) </B>
 <DD><I>
Creates a new <tt>Normalizer</tt> object for iterating over the
normalized form of the given text</I>
<DT><A HREF="#DOC.18.6"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Normalizer</B>(const <!1><A HREF="CharacterIterator.html">CharacterIterator</A>& iter, <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> mode, int32_t opt) </B>
 <DD><I>
Creates a new <tt>Normalizer</tt> object for iterating over the
normalized form of the given text</I>
<DT><A HREF="#DOC.18.28"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Normalizer</B>(const <!2><A HREF="Normalizer.html#DOC.18.28">Normalizer</A>& copy) </B>
 <DD><I>
Copy constructor</I>
<DT><A HREF="#DOC.18.29"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>~Normalizer</B>() </B>
 <DD><I>
Destructor</I>
<DT><A HREF="#DOC.18.7"> <IMG BORDER=0 SRC=icon1.gif></A> static  void  <B>normalize</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> mode, int32_t options, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A> &status) </B>
 <DD><I>
Normalizes a <tt>String</tt> using the given normalization operation</I>
<DT><A HREF="#DOC.18.8"> <IMG BORDER=0 SRC=icon1.gif></A> static  void  <B>compose</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, bool_t compat, int32_t options, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A> &status) </B>
 <DD><I>
Compose a <tt>String</tt></I>
<DT><A HREF="#DOC.18.9"> <IMG BORDER=0 SRC=icon1.gif></A> static  void  <B>decompose</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, bool_t compat, int32_t options, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A> &status) </B>
 <DD><I>
Static method to decompose a <tt>String</tt></I>
<DT><A HREF="#DOC.18.30"> <IMG BORDER=0 SRC=icon1.gif></A> UChar  <B>current</B>(void) const  </B>
 <DD><I>
Return the current character in the normalized text</I>
<DT><A HREF="#DOC.18.10"> <IMG BORDER=0 SRC=icon1.gif></A> UChar  <B>first</B>(void) </B>
 <DD><I>
Return the first character in the normalized text</I>
<DT><A HREF="#DOC.18.11"> <IMG BORDER=0 SRC=icon1.gif></A> UChar  <B>last</B>(void) </B>
 <DD><I>
Return the last character in the normalized text</I>
<DT><A HREF="#DOC.18.12"> <IMG BORDER=0 SRC=icon1.gif></A> UChar  <B>next</B>(void) </B>
 <DD><I>
Return the next character in the normalized text and advance
the iteration position by one</I>
<DT><A HREF="#DOC.18.13"> <IMG BORDER=0 SRC=icon1.gif></A> UChar  <B>previous</B>(void) </B>
 <DD><I>
Return the previous character in the normalized text and decrement
the iteration position by one</I>
<DT><A HREF="#DOC.18.14"> <IMG BORDER=0 SRC=icon1.gif></A> UChar  <B>setIndex</B>(UTextOffset index) </B>
 <DD><I>
Set the iteration position in the input text that is being normalized
and return the first normalized character at that position</I>
<DT><A HREF="#DOC.18.15"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>reset</B>(void) </B>
 <DD><I>
Reset the iterator so that it is in the same state that it was just after
it was constructed</I>
<DT><A HREF="#DOC.18.16"> <IMG BORDER=0 SRC=icon1.gif></A> UTextOffset  <B>getIndex</B>(void) const  </B>
 <DD><I>
Retrieve the current iteration position in the input text that is
being normalized</I>
<DT><A HREF="#DOC.18.17"> <IMG BORDER=0 SRC=icon1.gif></A> UTextOffset  <B>startIndex</B>(void) const  </B>
 <DD><I>
Retrieve the index of the start of the input text</I>
<DT><A HREF="#DOC.18.18"> <IMG BORDER=0 SRC=icon1.gif></A> UTextOffset  <B>endIndex</B>(void) const  </B>
 <DD><I>
Retrieve the index of the end of the input text</I>
<DT><A HREF="#DOC.18.31"> <IMG BORDER=0 SRC=icon1.gif></A> bool_t  <B>operator==</B>(const <!2><A HREF="Normalizer.html#DOC.18.28">Normalizer</A>& that) const  </B>
 <DD><I>
Returns true when both iterators refer to the same character in the same
character-storage object</I>
<DT><A HREF="#DOC.18.19"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="Normalizer.html#DOC.18.28">Normalizer</A>*  <B>clone</B>(void) const  </B>
 <DD><I>
Returns a pointer to a new Normalizer that is a clone of this one</I>
<DT><A HREF="#DOC.18.32"> <IMG BORDER=0 SRC=icon1.gif></A> int32_t  <B>hashCode</B>(void) const  </B>
 <DD><I>
Generates a hash code for this iterator</I>
<DT><A HREF="#DOC.18.20"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setMode</B>(<!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> newMode) </B>
 <DD><I>
Set the normalization mode for this object</I>
<DT><A HREF="#DOC.18.21"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A>  <B>getMode</B>(void) const  </B>
 <DD><I>
Return the basic operation performed by this <tt>Normalizer</tt>

</I>
<DT><A HREF="#DOC.18.22"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setOption</B>(int32_t option, bool_t value) </B>
 <DD><I>
Set options that affect this <tt>Normalizer</tt>'s operation</I>
<DT><A HREF="#DOC.18.23"> <IMG BORDER=0 SRC=icon1.gif></A> bool_t  <B>getOption</B>(int32_t option) const  </B>
 <DD><I>
Determine whether an option is turned on or off</I>
<DT><A HREF="#DOC.18.24"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setText</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& newText, <!2><A HREF="#DOC.301">UErrorCode</A> &status) </B>
 <DD><I>
Set the input text over which this <tt>Normalizer</tt> will iterate</I>
<DT><A HREF="#DOC.18.25"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setText</B>(const <!1><A HREF="CharacterIterator.html">CharacterIterator</A>& newText, <!2><A HREF="#DOC.301">UErrorCode</A> &status) </B>
 <DD><I>
Set the input text over which this <tt>Normalizer</tt> will iterate</I>
<DT><A HREF="#DOC.18.26"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>getText</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) </B>
 <DD><I>
Copies the text under iteration into the UnicodeString referred to by 
"result"</I>
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

<tt>Normalizer</tt> transforms Unicode text into an equivalent composed or
decomposed form, allowing for easier sorting and searching of text.
<tt>Normalizer</tt> supports the standard normalization forms described in
<a href="http://www.unicode.org/unicode/reports/tr15/" target="unicode">
Unicode Technical Report #15</a>.
<p>
Characters with accents or other adornments can be encoded in
several different ways in Unicode.  For example, take the character "Á"
(A-acute).   In Unicode, this can be encoded as a single character (the
"composed" form):
<pre>
00C1    LATIN CAPITAL LETTER A WITH ACUTE</pre>
or as two separate characters (the "decomposed" form):
<pre>
0041    LATIN CAPITAL LETTER A
0301    COMBINING ACUTE ACCENT</pre>
<p>
To a user of your program, however, both of these sequences should be
treated as the same "user-level" character "Á".  When you are searching or
comparing text, you must ensure that these two sequences are treated 
equivalently.  In addition, you must handle characters with more than one
accent.  Sometimes the order of a character's combining accents is
significant, while in other cases accent sequences in different orders are
really equivalent.
<p>
Similarly, the string "ffi" can be encoded as three separate letters:
<pre>
0066    LATIN SMALL LETTER F
0066    LATIN SMALL LETTER F
0069    LATIN SMALL LETTER I</pre>
or as the single character
<pre>
FB03    LATIN SMALL LIGATURE FFI</pre>
<p>
The ffi ligature is not a distinct semantic character, and strictly speaking
it shouldn't be in Unicode at all, but it was included for compatibility
with existing character sets that already provided it.  The Unicode standard
identifies such characters by giving them "compatibility" decompositions
into the corresponding semantic characters.  When sorting and searching, you
will often want to use these mappings.
<p>
<tt>Normalizer</tt> helps solve these problems by transforming text into the
canonical composed and decomposed forms as shown in the first example above.  
In addition, you can have it perform compatibility decompositions so that 
you can treat compatibility characters the same as their equivalents.
Finally, <tt>Normalizer</tt> rearranges accents into the proper canonical
order, so that you do not have to worry about accent rearrangement on your
own.
<p>
<tt>Normalizer</tt> adds one optional behavior, {@link #IGNORE_HANGUL},
that differs from
the standard Unicode Normalization Forms.  This option can be passed
to the {@link #Normalizer constructors} and to the static
{@link #compose compose} and {@link #decompose decompose} methods.  This
option, and any that are added in the future, will be turned off by default.
<p>
There are three common usage models for <tt>Normalizer</tt>.  In the first,
the static {@link #normalize normalize()} method is used to process an
entire input string at once.  Second, you can create a <tt>Normalizer</tt>
object and use it to iterate through the normalized form of a string by
calling {@link #first} and {@link #next}.  Finally, you can use the
{@link #setIndex setIndex()} and {@link #getIndex} methods to perform
random-access iteration, which is very useful for searching.
<p>
<b>Note:</b> <tt>Normalizer</tt> objects behave like iterators and have
methods such as <tt>setIndex</tt>, <tt>next</tt>, <tt>previous</tt>, etc.
You should note that while the <tt>setIndex</tt> and <tt>getIndex</tt> refer
to indices in the underlying <em>input</em> text being processed, the
<tt>next</tt> and <tt>previous</tt> methods it iterate through characters
in the normalized <em>output</em>.  This means that there is not
necessarily a one-to-one correspondence between characters returned
by <tt>next</tt> and <tt>previous</tt> and the indices passed to and
returned from <tt>setIndex</tt> and <tt>getIndex</tt>.  It is for this
reason that <tt>Normalizer</tt> does not implement the
{@link CharacterIterator} interface.
<p>
<b>Note:</b> <tt>Normalizer</tt> is currently based on version 2.1.8
of the <a href="http://www.unicode.org" target="unicode">Unicode Standard</a>.
It will be updated as later versions of Unicode are released.  If you are
using this class on a JDK that supports an earlier version of Unicode, it
is possible that <tt>Normalizer</tt> may generate composed or dedecomposed
characters for which your JDK's {@link java.lang.Character} class does not
have any data.
<p>


</BLOCKQUOTE>
<DL>

<A NAME="DONE">
<A NAME ="DOC.18.27">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  UChar  DONE</B></TT>
<DL></DL><P>
<A NAME="EMode">
<A NAME ="DOC.18.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  enum  EMode</B></TT>
<DD>The mode of a Normalizer object 
<DL></DL><P><DL>

<A NAME="NO_OP">
<A NAME ="DOC.18.1.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  NO_OP</B></TT>
<DD>
Null operation for use with the {@link #Normalizer constructors}
and the static {@link #normalize normalize} method.  This value tells
the <tt>Normalizer</tt> to do nothing but return unprocessed characters
from the underlying String or CharacterIterator.  If you have code which
requires raw text at some times and normalized text at others, you can
use <tt>NO_OP</tt> for the cases where you want raw text, rather
than having a separate code path that bypasses <tt>Normalizer</tt>
altogether.
<p>

<DL><DT><B>See Also:</B><DD><A HREF="#setMode">setMode</A><br></DL><P>
<A NAME="COMPOSE">
<A NAME ="DOC.18.1.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  COMPOSE</B></TT>
<DD>
Canonical decomposition followed by canonical composition.  Used with 
the {@link #Normalizer constructors} and the static 
{@link #normalize normalize}
method to determine the operation to be performed.
<p>
If all optional features (<i>e.g.</i> {@link #IGNORE_HANGUL}) are turned
off, this operation produces output that is in
<a href=http:     * Form</a>
<b>C</b>.
<p>

<DL><DT><B>See Also:</B><DD><A HREF="#setMode">setMode</A><br></DL><P>
<A NAME="COMPOSE_COMPAT">
<A NAME ="DOC.18.1.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  COMPOSE_COMPAT</B></TT>
<DD>
Compatibility decomposition followed by canonical composition.
Used with the {@link #Normalizer constructors} and the static
{@link #normalize normalize} method to determine the operation to be
performed.
<p>
If all optional features (<i>e.g.</i> {@link #IGNORE_HANGUL}) are turned
off, this operation produces output that is in
<a href=http:     * Form</a>
<b>KC</b>.
<p>

<DL><DT><B>See Also:</B><DD><A HREF="#setMode">setMode</A><br></DL><P>
<A NAME="DECOMP">
<A NAME ="DOC.18.1.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DECOMP</B></TT>
<DD>
Canonical decomposition.  This value is passed to the
{@link #Normalizer constructors} and the static 
{@link #normalize normalize}
method to determine the operation to be performed.
<p>
If all optional features (<i>e.g.</i> {@link #IGNORE_HANGUL}) are turned
off, this operation produces output that is in
<a href=http:     * Form</a>
<b>D</b>.
<p>

<DL><DT><B>See Also:</B><DD><A HREF="#setMode">setMode</A><br></DL><P>
<A NAME="DECOMP_COMPAT">
<A NAME ="DOC.18.1.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DECOMP_COMPAT</B></TT>
<DD>
Compatibility decomposition.  This value is passed to the
{@link #Normalizer constructors} and the static 
{@link #normalize normalize}
method to determine the operation to be performed.
<p>
If all optional features (<i>e.g.</i> {@link #IGNORE_HANGUL}) are turned
off, this operation produces output that is in
<a href=http:     * Form</a>
<b>KD</b>.
<p>

<DL><DT><B>See Also:</B><DD><A HREF="#setMode">setMode</A><br></DL><P></DL>

<A NAME="">
<A NAME ="DOC.18.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  enum </B></TT>
<DD>The options for a Normalizer object 
<DL></DL><P><DL>

<A NAME="IGNORE_HANGUL">
<A NAME ="DOC.18.2.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  IGNORE_HANGUL</B></TT>
<DD>
Option to disable Hangul/Jamo composition and decomposition.
This option applies to Korean text, 
which can be represented either in the Jamo alphabet or in Hangul
characters, which are really just two or three Jamo combined
into one visual glyph.  Since Jamo takes up more storage space than
Hangul, applications that process only Hangul text may wish to turn
this option on when decomposing text.
<p>
The Unicode standard treates Hangul to Jamo conversion as a 
canonical decomposition, so this option must be turned <b>off</b> if you
wish to transform strings into one of the standard
<a href="http:     * Unicode Normalization Forms</a>.
<p>

<DL><DT><B>See Also:</B><DD><A HREF="#setOption">setOption</A><br></DL><P></DL>

<A NAME="Normalizer">
<A NAME ="DOC.18.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Normalizer(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& str, <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> mode)</B></TT>
<DD>
Creates a new <tt>Normalizer</tt> object for iterating over the
normalized form of a given string.
<p>

<DL><DT><B>Parameters:</B><DD><B>str</B> -    The string to be normalized.  The normalization
will start at the beginning of the string.
<br><B>mode</B> -   The normalization mode.<br></DL><P>
<A NAME="Normalizer">
<A NAME ="DOC.18.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Normalizer(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& str, <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> mode, int32_t opt)</B></TT>
<DD>
Creates a new <tt>Normalizer</tt> object for iterating over the
normalized form of a given string.
<p>
The <tt>options</tt> parameter specifies which optional
<tt>Normalizer</tt> features are to be enabled for this object.
<p>

<DL><DT><B>Parameters:</B><DD><B>str</B> -    The string to be normalized.  The normalization
will start at the beginning of the string.
<br><B>mode</B> -   The normalization mode.
<br><B>opt</B> -    Any optional features to be enabled.
Currently the only available option is {@link #IGNORE_HANGUL}
If you want the default behavior corresponding to one of the
standard Unicode Normalization Forms, use 0 for this argument<br></DL><P>
<A NAME="Normalizer">
<A NAME ="DOC.18.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Normalizer(const <!1><A HREF="CharacterIterator.html">CharacterIterator</A>& iter, <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> mode)</B></TT>
<DD>
Creates a new <tt>Normalizer</tt> object for iterating over the
normalized form of the given text.
<p>

<DL><DT><B>Parameters:</B><DD><B>iter</B> -   The input text to be normalized.  The normalization
will start at the beginning of the string.
<br><B>mode</B> -   The normalization mode.
<br></DL><P>
<A NAME="Normalizer">
<A NAME ="DOC.18.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Normalizer(const <!1><A HREF="CharacterIterator.html">CharacterIterator</A>& iter, <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> mode, int32_t opt)</B></TT>
<DD>
Creates a new <tt>Normalizer</tt> object for iterating over the
normalized form of the given text.
<p>

<DL><DT><B>Parameters:</B><DD><B>iter</B> -   The input text to be normalized.  The normalization
will start at the beginning of the string.
<br><B>mode</B> -   The normalization mode.
<br><B>opt</B> -    Any optional features to be enabled.
Currently the only available option is {@link #IGNORE_HANGUL}
If you want the default behavior corresponding to one of the
standard Unicode Normalization Forms, use 0 for this argument<br></DL><P>
<A NAME="Normalizer">
<A NAME ="DOC.18.28">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Normalizer(const <!2><A HREF="Normalizer.html#DOC.18.28">Normalizer</A>& copy)</B></TT>
<DD>
Copy constructor
<DL></DL><P>
<A NAME="~Normalizer">
<A NAME ="DOC.18.29">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  ~Normalizer()</B></TT>
<DD>
Destructor
<DL></DL><P>
<A NAME="normalize">
<A NAME ="DOC.18.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  void  normalize(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> mode, int32_t options, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A> &status)</B></TT>
<DD>
Normalizes a <tt>String</tt> using the given normalization operation.
<p>
The <tt>options</tt> parameter specifies which optional
<tt>Normalizer</tt> features are to be enabled for this operation.
Currently the only available option is {@link #IGNORE_HANGUL}.
If you want the default behavior corresponding to one of the standard
Unicode Normalization Forms, use 0 for this argument.
<p>

<DL><DT><B>Parameters:</B><DD><B>source</B> -     the input string to be normalized.
<br><B>aMode</B> -      the normalization mode
<br><B>options</B> -    the optional features to be enabled.
<br><B>result</B> -     The normalized string (on output).
<br><B>status</B> -     The error code.<br></DL><P>
<A NAME="compose">
<A NAME ="DOC.18.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  void  compose(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, bool_t compat, int32_t options, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A> &status)</B></TT>
<DD>
Compose a <tt>String</tt>.
<p>
The <tt>options</tt> parameter specifies which optional
<tt>Normalizer</tt> features are to be enabled for this operation.
Currently the only available option is {@link #IGNORE_HANGUL}.
If you want the default behavior corresponding
to Unicode Normalization Form <b>C</b> or <b>KC</b>,
use 0 for this argument.
<p>

<DL><DT><B>Parameters:</B><DD><B>source</B> -     the string to be composed.
<br><B>compat</B> -     Perform compatibility decomposition before composition.
If this argument is <tt>false</tt>, only canonical
decomposition will be performed.
<br><B>options</B> -    the optional features to be enabled.
<br><B>result</B> -     The composed string (on output).
<br><B>status</B> -     The error code.<br></DL><P>
<A NAME="decompose">
<A NAME ="DOC.18.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  void  decompose(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, bool_t compat, int32_t options, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A> &status)</B></TT>
<DD>
Static method to decompose a <tt>String</tt>.
<p>
The <tt>options</tt> parameter specifies which optional
<tt>Normalizer</tt> features are to be enabled for this operation.
Currently the only available option is {@link #IGNORE_HANGUL}.
The desired options should be OR'ed together to determine the value
of this argument.  If you want the default behavior corresponding
to Unicode Normalization Form <b>D</b> or <b>KD</b>,
use 0 for this argument.
<p>

<DL><DT><B>Returns:</B><DD>the decomposed string.
<DT><B>Parameters:</B><DD><B>str</B> -    the string to be decomposed.
<br><B>compat</B> -     Perform compatibility decomposition.
If this argument is <tt>false</tt>, only canonical
decomposition will be performed.
<br><B>options</B> -    the optional features to be enabled.
<br><B>result</B> -     The composed string (on output).
<br><B>status</B> -     The error code.
<br></DL><P>
<A NAME="current">
<A NAME ="DOC.18.30">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UChar  current(void) const </B></TT>
<DD>
Return the current character in the normalized text
<DL></DL><P>
<A NAME="first">
<A NAME ="DOC.18.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UChar  first(void)</B></TT>
<DD>
Return the first character in the normalized text.  This resets
the <tt>Normalizer's</tt> position to the beginning of the text.
<DL></DL><P>
<A NAME="last">
<A NAME ="DOC.18.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UChar  last(void)</B></TT>
<DD>
Return the last character in the normalized text.  This resets
the <tt>Normalizer's</tt> position to be just before the
the input text corresponding to that normalized character.
<DL></DL><P>
<A NAME="next">
<A NAME ="DOC.18.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UChar  next(void)</B></TT>
<DD>
Return the next character in the normalized text and advance
the iteration position by one.  If the end
of the text has already been reached, {@link #DONE} is returned.
<DL></DL><P>
<A NAME="previous">
<A NAME ="DOC.18.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UChar  previous(void)</B></TT>
<DD>
Return the previous character in the normalized text and decrement
the iteration position by one.  If the beginning
of the text has already been reached, {@link #DONE} is returned.
<DL></DL><P>
<A NAME="setIndex">
<A NAME ="DOC.18.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UChar  setIndex(UTextOffset index)</B></TT>
<DD>
Set the iteration position in the input text that is being normalized
and return the first normalized character at that position.
<p>
<b>Note:</b> This method sets the position in the <em>input</em> text,
while {@link #next} and {@link #previous} iterate through characters
in the normalized <em>output</em>.  This means that there is not
necessarily a one-to-one correspondence between characters returned
by <tt>next</tt> and <tt>previous</tt> and the indices passed to and
returned from <tt>setIndex</tt> and {@link #getIndex}.
<p>

<DL><DT><B>Returns:</B><DD>the first normalized character that is the result of iterating
forward starting at the given index.
@throws IllegalArgumentException if the given index is less than
{@link #getBeginIndex} or greater than {@link #getEndIndex}.
<DT><B>Parameters:</B><DD><B>index</B> -  the desired index in the input text.
<br></DL><P>
<A NAME="reset">
<A NAME ="DOC.18.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  reset(void)</B></TT>
<DD>
Reset the iterator so that it is in the same state that it was just after
it was constructed.  A subsequent call to <tt>next</tt> will return the first
character in the normalized text.  In contrast, calling <tt>setIndex(0)</tt> followed
by <tt>next</tt> will return the <em>second</em> character in the normalized text,
because <tt>setIndex</tt> itself returns the first character
<DL></DL><P>
<A NAME="getIndex">
<A NAME ="DOC.18.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UTextOffset  getIndex(void) const </B></TT>
<DD>
Retrieve the current iteration position in the input text that is
being normalized.  This method is useful in applications such as
searching, where you need to be able to determine the position in
the input text that corresponds to a given normalized output character.
<p>
<b>Note:</b> This method sets the position in the <em>input</em>, while
{@link #next} and {@link #previous} iterate through characters in the
<em>output</em>.  This means that there is not necessarily a one-to-one
correspondence between characters returned by <tt>next</tt> and
<tt>previous</tt> and the indices passed to and returned from
<tt>setIndex</tt> and {@link #getIndex}.

<DL></DL><P>
<A NAME="startIndex">
<A NAME ="DOC.18.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UTextOffset  startIndex(void) const </B></TT>
<DD>
Retrieve the index of the start of the input text.  This is the begin index
of the <tt>CharacterIterator</tt> or the start (i.e. 0) of the <tt>String</tt>
over which this <tt>Normalizer</tt> is iterating
<DL></DL><P>
<A NAME="endIndex">
<A NAME ="DOC.18.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> UTextOffset  endIndex(void) const </B></TT>
<DD>
Retrieve the index of the end of the input text.  This is the end index
of the <tt>CharacterIterator</tt> or the length of the <tt>String</tt>
over which this <tt>Normalizer</tt> is iterating
<DL></DL><P>
<A NAME="operator==">
<A NAME ="DOC.18.31">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool_t  operator==(const <!2><A HREF="Normalizer.html#DOC.18.28">Normalizer</A>& that) const </B></TT>
<DD>
Returns true when both iterators refer to the same character in the same
character-storage object
<DL></DL><P>
<A NAME="clone">
<A NAME ="DOC.18.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="Normalizer.html#DOC.18.28">Normalizer</A>*  clone(void) const </B></TT>
<DD>
Returns a pointer to a new Normalizer that is a clone of this one.
The caller is responsible for deleting the new clone.
<DL></DL><P>
<A NAME="hashCode">
<A NAME ="DOC.18.32">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int32_t  hashCode(void) const </B></TT>
<DD>
Generates a hash code for this iterator
<DL></DL><P>
<A NAME="setMode">
<A NAME ="DOC.18.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setMode(<!2><A HREF="Normalizer.html#DOC.18.1">EMode</A> newMode)</B></TT>
<DD>
Set the normalization mode for this object.
<p>
<b>Note:</b>If the normalization mode is changed while iterating
over a string, calls to {@link #next} and {@link #previous} may
return previously buffers characters in the old normalization mode
until the iteration is able to re-sync at the next base character.
It is safest to call {@link #setText setText()}, {@link #first},
{@link #last}, etc. after calling <tt>setMode</tt>.
<p>

<DL><DT><B>Parameters:</B><DD><B>newMode</B> -  the new mode for this <tt>Normalizer</tt>.
The supported modes are:
<ul>
<li>{@link #COMPOSE}        - Unicode canonical decompositiion
followed by canonical composition.
<li>{@link #COMPOSE_COMPAT} - Unicode compatibility decompositiion
follwed by canonical composition.
<li>{@link #DECOMP}         - Unicode canonical decomposition
<li>{@link #DECOMP_COMPAT}  - Unicode compatibility decomposition.
<li>{@link #NO_OP}          - Do nothing but return characters
from the underlying input text.
</ul>
<br><DT><B>See Also:</B><DD><A HREF="#getMode">getMode</A><br></DL><P>
<A NAME="getMode">
<A NAME ="DOC.18.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="Normalizer.html#DOC.18.1">EMode</A>  getMode(void) const </B></TT>
<DD>
Return the basic operation performed by this <tt>Normalizer</tt>


<DL><DT><B>See Also:</B><DD><A HREF="#setMode">setMode</A><br></DL><P>
<A NAME="setOption">
<A NAME ="DOC.18.22">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setOption(int32_t option, bool_t value)</B></TT>
<DD>
Set options that affect this <tt>Normalizer</tt>'s operation.
Options do not change the basic composition or decomposition operation
that is being performed , but they control whether
certain optional portions of the operation are done.
Currently the only available option is:
<p>
<ul>
<li>{@link #IGNORE_HANGUL} - Do not decompose Hangul syllables into the
Jamo alphabet and vice-versa.  This option is off by default 
(<i>i.e.</i> Hangul processing is enabled) since the Unicode 
standard specifies that Hangul to Jamo is a canonical decomposition.
For any of the standard Unicode Normalization
Forms, you should leave this option off.
</ul>
<p>

<DL><DT><B>Parameters:</B><DD><B>option</B> -   the option whose value is to be set.
<br><B>value</B> -    the new setting for the option.  Use <tt>true</tt> to
turn the option on and <tt>false</tt> to turn it off.
<br><DT><B>See Also:</B><DD><A HREF="#getOption">getOption</A><br></DL><P>
<A NAME="getOption">
<A NAME ="DOC.18.23">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool_t  getOption(int32_t option) const </B></TT>
<DD>
Determine whether an option is turned on or off.
<p>

<DL><DT><B>See Also:</B><DD><A HREF="#setOption">setOption</A><br></DL><P>
<A NAME="setText">
<A NAME ="DOC.18.24">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setText(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& newText, <!2><A HREF="#DOC.301">UErrorCode</A> &status)</B></TT>
<DD>
Set the input text over which this <tt>Normalizer</tt> will iterate.
The iteration position is set to the beginning.
<DL></DL><P>
<A NAME="setText">
<A NAME ="DOC.18.25">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setText(const <!1><A HREF="CharacterIterator.html">CharacterIterator</A>& newText, <!2><A HREF="#DOC.301">UErrorCode</A> &status)</B></TT>
<DD>
Set the input text over which this <tt>Normalizer</tt> will iterate.
The iteration position is set to the beginning.
<DL></DL><P>
<A NAME="getText">
<A NAME ="DOC.18.26">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  getText(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result)</B></TT>
<DD>
Copies the text under iteration into the UnicodeString referred to by 
"result"
<DL><DT><B>Parameters:</B><DD><B>result</B> -  Receives a copy of the text under iteration.<br></DL><P></DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL><DT><B>Author:</B><DD>Laura Werner, Mark Davis
</DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
