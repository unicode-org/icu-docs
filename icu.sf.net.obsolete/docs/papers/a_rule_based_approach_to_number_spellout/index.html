<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 3.0">
<title>A Rule-Based Approach to Number Spellout</title>
</head>

<body LINK="#0000ff">

<p><font SIZE="5">A Rule-Based Approach to Number Spellout</font><br>
<i><font SIZE="4">by Richard Gillam</font><br>
<font SIZE="2">Advisory Software Engineer<br>
Center for Java Technology&#150;Silicon Valley<br>
IBM Corp.</font></i></p>

<p>One of the more important areas of software internationalization is that of numeric
formatting and parsing&#151;that is, the translation of numeric values to their textual
representation and back. But the bulk of the work done in this area has been concerned
with formatting and parsing values written as <i>numerals,</i> and most of that has been
centered on formatting and parsing so-called &quot;Arabic&quot; numerals (since real
Arabic text actually uses a different set of numeral symbols than those used in the West,
we&#146;ll use the term &quot;Western numerals&quot; instead), with most of the rest
centered on Han characters and on other numeration systems that use the same positional
format as Western numerals. Comparatively little work has been done on the problem of
formatting and parsing numeric values expressed in <i>words.</p>
</i>

<p>Spelling out numeric values in words (we&#146;ll use the phrase &quot;number
spellout&quot; to refer to this from now on) is actually a relatively useful capability.
Financial applications spell out numeric values on checks and wire-transfer directives
because spelled-out numbers are harder to counterfeit. Number spellout can also have great
utility in text-to-speech and speech recognition systems, where it would be much more
natural for the user to say &quot;three thousand four hundred twenty-six dollars and
fifty-two cents&quot; than, say, &quot;command dollar three comma four two six point five
two end command.&quot;</p>

<p>We in the Taligent International group (now part of IBM&#146;s Center for Java
Technology) first encountered this problem when a client requested that we add an
internationalizable number-spellout capability to our C++ International Classes product.
After considering and rejecting several approaches, we settled on a simple yet very
powerful approach to this problem that makes use of a list of rules. As a bonus, it turns
out this technology is powerful and extensible enough to work for a variety of other
number-formatting problems that are more complicated than merely translating a number into
Western numerals and back.</p>

<h3>The problem</h3>

<p>Solving the number-spellout problem in English is a relatively easy thing to
do&#151;algorithms to do this are well-known and widely used. The code usually looks
something like this:</p>

<pre>private static final String[] ones =
	{ &quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;, &quot;seven&quot;,
	  &quot;eight&quot;, &quot;nine&quot; };
private static final String[] teens =
	{ &quot;ten&quot;, &quot;eleven&quot;, &quot;twelve&quot;, &quot;thirteen&quot;, &quot;fourteen&quot;, &quot;fifteen&quot;,
     &quot;sixteen&quot;, &quot;seventeen&quot;, &quot;eighteen&quot;, &quot;nineteen&quot; };
private static final String[] tens =
	{ &quot;ten&quot;, &quot;twenty&quot;, &quot;thirty&quot;, &quot;forty&quot;, &quot;fifty&quot;, &quot;sixty&quot;, &quot;seventy&quot;,
	  &quot;eighty&quot;, &quot;ninety&quot; };
private static final String hundred = &quot; hundred&quot;;
private static final String thousands =
	{ &quot; thousand&quot;, &quot; million&quot;, &quot; billion&quot;, &quot; trillion&quot; };

public String spellout(int x) {
	if (x &lt; 10)
		return ones[x];
	if (x &lt; 20)
		return teens[x - 10];
	if (x &lt; 100) {
		if (x % 10 == 0)
			return tens[x / 10];
		else
			return tens[x / 10] + &quot;-&quot; + ones[x % 10];
	}
	if (x &lt; 1000) {
		if (x % 100 == 0)
			return ones[x / 100] + hundred;
		else
			return ones[x / 100] + hundred + &quot; &quot; +
						spellout(x % 100);
	}
	if (x &lt; 1000000) {
		if (x % 1000 == 0)
			return spellout(x / 1000) + thousands[0];
		else
			return spellout(x / 1000) + thousands[0] + &quot; &quot; +
						spellout(x % 1000);
	}
	if (x &lt; 1000000000) {
		if (x % 1000000 == 0)
			return spellout(x / 1000000) + thousands[1];
		else
			return spellout(x / 1000000) + thousands[1] + &quot; &quot; +
						spellout(x % 1000000);
	}
}</pre>

<p>The problem with this approach is that it doesn&#146;t internationalize well. Obviously
the first step would be to alter the algorithm to load all of the words from resource
files rather than hard-coding them. This is a good first step, but it&#146;s not enough.
Other languages need more canned strings than English does.</p>

<p>For instance, the punctuation between the digit positions varies between languages. In
English and French, for example, there&#146;s a hyphen between the tens digit and the ones
digit, but in Spanish, the word &quot;y&quot; separates them. Russian uses a space.
Italian, Greek, and Swedish use nothing at all: the tens and ones digits run together into
a single word.</p>

<p>Likewise, the punctuation between the other digit positions varies between languages,
and often differs from the punctuation between the ones and tens digits. In English and
French, a hyphen is used between the ones and tens digits, but spaces are used between the
others. But in German, the whole number runs together into a single word. In Italian, the
number runs together into a single word when it&#146;s smaller than 100,000, but is broken
into multiple words for large numbers.</p>

<p>So you would also need canned strings for the separators between the words that make up
the number. Unfortunately, this also isn&#146;t good enough. In most languages, the words
for the values from 11 to 19 are based on the words for the values from 1 to 9, but are
not simple concatenations. In English, for example, 15 is &quot;fifteen&quot; and not
&quot;fiveteen.&quot; This also happens for the words for the tens digits in most
languages. In some languages, this kind of thing also applies to other groups of words. In
Spanish, for example, numbers between 30 and 99 are written with &quot;y&quot; between the
digit places: 34 is &quot;treinta y cuatro.&quot; But the numbers between 21 and 29
contract the phrase into a single word: &quot;veinte y cinco&quot; (25) becomes
&quot;veinticinco.&quot; In fact, this contraction cannot be handled algorithmically
because the spelling of the ones digit sometimes changes in contraction. 22 is
&quot;veintidós,&quot; not &quot;veintidos.&quot;</p>

<p>The same thing happens with the hundreds place in Spanish and Greek. In Spanish, for
example, the multiplier and the word for 100 run together into a single word&#151;200 is
&quot;doscientos,&quot; not &quot;dos cientos&quot;&#151;but the multiplier often changes
spelling in contraction&#151;500 is &quot;quinientos,&quot; not &quot;cincocientos.&quot;</p>

<p>So you would need canned strings for the twenties and hundreds in addition to the ones,
teens, and tens. Even this isn&#146;t enough. In many languages, if the multiplier before
the word for &quot;hundred&quot; or &quot;thousand&quot; is 1, it is omitted: in French,
100 is &quot;cent,&quot; not &quot;un cent.&quot; Furthermore, in many languages, the
words for 100, 1000, and so forth pluralize when the multiplier is greater than 1&#151;in
French again, 100 is &quot;cent,&quot; but 200 is &quot;deux cents.&quot; And in Spanish,
the form of the word for 100 also changes when there are digits to the right of it: 100 is
&quot;cien,&quot; but 101 is &quot;ciento uno.&quot;</p>

<p>So we would need additional strings to account for the possible variant spellings of
the words for 100, 1000, and so on. This is a lot of data, and much of it is only
necessary in a few languages. But even with all these variant strings, we still can&#146;t
accommodate even the common European languages fully. You also need variant code in the
algorithm itself. In German, for example, the ones digit comes before the tens digit: 23
is &quot;dreiundzwanzig,&quot; not &quot;zwanzigunddrei.&quot; In French, &quot;et&quot;
is inserted between the tens and ones digits, but only when the ones digit is 1: 21 is
&quot;vingt-et-un,&quot; but 22 is &quot;vingt-deux.&quot; In Italian, when the tens digit
ends with a vowel and the ones digit begins with a vowel, the vowel is dropped from the
tens digit: 50 is &quot;cinquanta,&quot; and 52 is &quot;cinquantadue,&quot; but 51 is
&quot;cinquantuno.&quot; In Greek, the word for each tens digit has an accent mark that
disappears when combined with a ones digit: 30 is &quot;triánta&quot; but 31 is
&quot;triantaéna&quot;.</p>

<p>Another area that has to be variable is major groupings. In American English and the
other European languages, large numbers are grouped by thousands (i.e., after a thousand,
a new word is introduced every factor of 1,000). In British English, however, large
numbers are grouped by million (a &quot;billion&quot; in British English is a
&quot;trillion&quot; in American English; what we call a &quot;billion&quot; is called a
&quot;thousand million&quot; in Britain). More importantly, in Japanese, large numbers are
grouped by <i>ten</i> thousand, rather than by thousand.</p>

<p>Finally, French has a couple peculiarities of its own: In European French, there are no
words for 70, 80, or 90. The numbers from 70 up are rendered as &quot;soixante-dix,&quot;
&quot;soixante et onze,&quot; &quot;soixante-douze,&quot; &quot;soixante-treize,&quot; and
so on (literally, &quot;sixty-ten,&quot; &quot;sixty and eleven,&quot;
&quot;sixty-twelve,&quot; &quot;sixty-thirteen,&quot; etc.) 80 is rendered as &quot;quatre
vingts&quot; (literally, &quot;four twenties&quot;), and the numbers proceed by score from
there (i.e., 81 is &quot;quatre-vingt-un&quot; (&quot;four-twenty-one&quot;), 90 is
&quot;quatre-vingt-dix&quot; (&quot;four-twenty-ten&quot;), 91 is
&quot;quatre-vingt-onze&quot; (&quot;four-twenty-eleven&quot;) and so on). In addition,
the numbers between 1,100 and 1,200 are rendered as &quot;onze cents&#133;&quot;
(literally, &quot;eleven hundred&#133;&quot;) instead of &quot;mille cent&#133;&quot;
(&quot;one thousand one hundred&#133;&quot;).</p>

<p>Clearly, the procedures for spelling out numbers in different languages vary along too
many axes for it to be feasible to design a number-spellout engine based on canned strings
and user-selectable options that will cover everything well. It is theoretically possible,
of course, but such an algorithm would be large and complicated, difficult to use, and
rigid and inflexible. If there were a language with unique requirements the author of the
formatter wasn&#146;t aware of when he wrote the formatter, that language&#146;s numbers
wouldn&#146;t be formattable.</p>

<p>This seemed to leave us with two options: either simply allow a whole new formatting
function to be written for each language, or design a <i>programmable</i> formatter and a
programming language designed specifically for describing how numbers are spelled out. We
at Taligent have come to prefer data-driven extensibility over exposing a subclassing API
when it&#146;s possible to express an object&#146;s behavior in a metalanguage that is
simpler and easier to understand than C++ or Java would be. This is the approach we took
with number spellout.</p>

<h3>Describing spellout procedures</h3>

<p>Despite the widespread differences in how various languages spell out numbers, there
were a few important commonalities: Every language we researched lends itself well to a
recursive algorithm: the digits to the right of the hundreds position, for example,
usually are spelled out the same way whether or not there are any digits to their left.
Likewise, the multiplier on &quot;hundred,&quot; &quot;thousand,&quot; or
&quot;million&quot; usually has the same form as the number would standing alone. This
leads to an algorithm that depends on isolation of certain digits and recursion to do its
job. This type of approach turns out to be simple, elegant, and very powerful and
flexible.</p>

<p>The procedure for formatting a number is expressed as a semicolon-delimited list of <i>rules.</i>
In its simplest form, a rule is simply the text to return when presented with a number, so
the spellout rules for English start out very simply:</p>

<pre>zero;
one;
two;
three;
four;
five;
six;
seven;
eight;
nine;
ten;
eleven;
twelve;
thirteen;
fourteen;
fifteen;
sixteen;
seventeen;
eighteen;
nineteen;
twenty;</pre>

<p>Now, for numbers greater than twenty, we can use this same list of rules to format the
digit in the ones place. We use &quot;&gt;&gt;&quot; to denote that:</p>

<pre>twenty;
twenty-&gt;&gt;;</pre>

<p>When the number is formatted, the ones digit is isolated, the word for it is looked up
in this same list, and then inserted into the result string where the &quot;&gt;&gt;&quot;
was (the &quot;&gt;&gt;&quot;, of course, is deleted).</p>

<p>This approach will work for the numbers from 21 to 29, so we don&#146;t need separate
rules for each of those numbers. We can avoid providing a rule for every number by
specifying the next rule&#146;s <i>base value&#151;</i>that is, the lowest value to which
a rule applies. We do that by appending a number to the front of the rule and separating
it from the rule text with a colon (whitespace after the colon is ignored):</p>

<pre>twenty;
twenty-&gt;&gt;;
30: thirty;</pre>

<p>A rule applies to all numbers from its base value to one less than the next rule&#146;s
base value. If a rule doesn&#146;t specify a base value (such as those is the first list
above), its base value is the previous rule&#146;s base value plus one (and the first rule
in the list has a base value of 0, unless otherwise specified).</p>

<p>The rule for 31 through 39 has the same form as the one for 21 through 29, giving us
this rule set so far:</p>

<pre>zero; one; two; three; four; five; six; seven; eight; nine;
ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen; seventeen;
			eighteen; nineteen;
twenty; twenty-&gt;&gt;;
30: thirty; thirty-&gt;&gt;;</pre>

<p>(Whitespace after semicolons is ignored, allowing you to add, or omit, carriage
returns, spaces, and tabs as appropriate to enhance readability.)</p>

<p>Now, of course, the rules for 21 and 31 are exactly the same as the rules for 20 and
30, except for the hyphen and the &quot;&gt;&gt;&quot; token (we&#146;ll call the
&quot;&gt;&gt;&quot; a <i>substitution</i> from now on). We could abbreviate these two
rules by simply enclosing the added text in brackets:</p>

<pre>twenty[-&gt;&gt;];
30: thirty[-&gt;&gt;];</pre>

<p>A rule with a range of text in brackets is automatically expanded into two rules: one
without the text in brackets, and a second one with the bracketed text (without the
brackets, of course) and a one-higher base value. So this much syntax gets us all the
numbers from 0 to 99:</p>

<pre>zero; one; two; three; four; five; six; seven; eight; nine;
ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen; seventeen;
			eighteen; nineteen;
twenty[-&gt;&gt;];
30: thirty[-&gt;&gt;];
40: forty[-&gt;&gt;];
50: fifty[-&gt;&gt;];
60: sixty[-&gt;&gt;];
70: seventy[-&gt;&gt;];
80: eighty[-&gt;&gt;];
90: ninety[-&gt;&gt;];</pre>

<p>The rule for 100 builds on what comes before it: we already have all the rules we need
to format the tens and ones digits, so we can take advantage of recursion to handle those
digit positions. Again, we use the &quot;&gt;&gt;&quot; notation to denote this:</p>

<pre>100: one hundred;
101: one hundred &gt;&gt;;</pre>

<p>Notice that the meaning of &quot;&gt;&gt;&quot; has changed. In the rules for 20
through 90, &quot;&gt;&gt;&quot; referred to just the ones digit. Here, it refers to the
tens and ones digits together. The meaning of the &quot;&gt;&gt;&quot; token is <i>context-dependent.</i>
Which digits it refers to depends on the rule&#146;s base value. To determine the meaning
of the substitution token, we calculate the rule&#146;s <i>power of 10,</i> which is the
common logarithm of the base value, rounded to the next-lowest integer. So for the 90
rule, the power of 10 is 1 (1.954&#133; rounded down to the nearest integer), and for the
100 rule, the power of 10 is 2 (exactly). When filling in the substitution, we take the
value being formatted modulo 10 to the power of the rule&#146;s power of 10. For 99, the
substitution value would be 99 mod 10, or 9. For 109, the substitution value is 109 mod
100 (because the rule&#146;s power of 10 is now 2), which is also 9. The
context-sensitivity of the substitution token is one of the keys to this language&#146;s
simplicity.</p>

<p>Also note that we begin to see multiple levels of recursion here: If you format 123
with this rule set, you&#146;ll start with &quot;one hundred &gt;&gt;&quot;, and then go
back and look up a rule for 23: This will give you &quot;twenty-&gt;&gt;&quot;, so you now
would have &quot;one hundred twenty-&gt;&gt;&quot;. Then you&#146;d look up the rule for
3, yielding &quot;one hundred twenty-three.&quot;</p>

<p>Also note that we can still use the bracket notation at this level, compressing the two
rules listed above into one:</p>

<pre>100: one hundred[ &gt;&gt;];</pre>

<p>Of course, we can also use this same set of rules to handle the word before
&quot;hundred.&quot; This is denoted with &quot;&lt;&lt;&quot;:</p>

<pre>100: &lt;&lt; hundred[ &gt;&gt;];</pre>

<p>We&#146;ll call &quot;&lt;&lt;&quot; the <i>major substitution</i> and
&quot;&gt;&gt;&quot; the <i>minor substitution.</i> Just as the minor substitution is
filled in by taking the value being formatted modulo 10 to the rule&#146;s power of 10,
the major substitution is filled in by taking the value being formatted divided by 10 to
the rule&#146;s power of 10 (and truncated to an integer, of course). So to format 234,
we&#146;d start with &quot;&lt;&lt; hundred &gt;&gt;&quot;, fill in the minor substitution
by looking up an appropriate rule for 34, giving us &quot;&lt;&lt; hundred
thirty-&gt;&gt;&quot;, fill in the new minor substitution by looking up an appropriate
rule for 4, giving us &quot;&lt;&lt; hundred thirty-four&quot;, and finally, fill in the
major substitution by dividing 234 by 100 and looking up an appropriate rule for 2:
&quot;two hundred thirty-four.&quot;</p>

<p>So the rule for 101 will actually work for all values from 101 to 999. Or will it?</p>

<p>If we try to format 200 with this rule set, we&#146;ll actually use the rule for 101,
which includes a minor substitution. 200&#146;s minor substitution value is 0, so
we&#146;ll get &quot;two hundred zero.&quot; This anomaly is accounted for in the
algorithm, rather than the rule syntax: If a rule has both major and minor substitutions
and the value being formatted has a minor-substitution value of 0, we roll back and use
the rule that <i>precedes</i> the current rule in the list. So the rule for 101 actually
doesn&#146;t cover the entire range from 101 to 999&#151;100, 200, 300, 400, 500, 600,
700, 800, and 900 are covered by the rule for 100 instead.</p>

<p>This small addition to the algorithm simplifies tremendously both the description
language and the actual algorithm. Without it, you&#146;d either need far more rules to
get the right effect, or the algorithm would have to be extended to deal explicitly with
optional text in the rules: Instead of expanding to two rules, a rule that included []
would still be a single rule that would contain both mandatory and optional text. This
drastically increases the state that has to be carried around in each rule just to achieve
the same effect we achieve through the use of the &quot;rollback rule&quot; described
above.</p>

<p>So what if you <i>want</i> &quot;two hundred zero&quot;? Just add it to the rule for
100:</p>

<pre>100: &lt;&lt; hundred zero; &lt;&lt; hundred &gt;&gt;;</pre>

<p>With this combination of new features, we can get from 0 to 999. The rule for 1000
looks just like the rule for 100:</p>

<pre>1000: &lt;&lt; thousand[ &gt;&gt;];</pre>

<p>Here, the rule&#146;s power of 10 is 3, so the meanings of the substitutions change
again. Now the minor substitution handles the value being formatted mod 1000, and the
major substitution handles the value being formatted divided by 1000.</p>

<p>So the full rule set now looks like this:</p>

<pre>zero; one; two; three; four; five; six; seven; eight; nine;
ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen; seventeen;
			eighteen; nineteen;
twenty[-&gt;&gt;];
30: thirty[-&gt;&gt;];
40: forty[-&gt;&gt;];
50: fifty[-&gt;&gt;];
60: sixty[-&gt;&gt;];
70: seventy[-&gt;&gt;];
80: eighty[-&gt;&gt;];
90: ninety[-&gt;&gt;];
100: &lt;&lt; hundred[ &gt;&gt;];
1000: &lt;&lt; thousand[ &gt;&gt;];</pre>

<p>In English, notice that we don&#146;t start using a new word until we get to 1,000,000.
So this set of rules is sufficient to format numbers from 0 all the way to 999,999. What
the major groupings are based on is implicit in where new rules are added to the list. So
each rule covers an ever-larger range of numbers, leading to a full rule set that looks
like this:</p>

<pre>zero; one; two; three; four; five; six; seven; eight; nine;
ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen; seventeen;
			eighteen; nineteen;
twenty[-&gt;&gt;];
30: thirty[-&gt;&gt;];
40: forty[-&gt;&gt;];
50: fifty[-&gt;&gt;];
60: sixty[-&gt;&gt;];
70: seventy[-&gt;&gt;];
80: eighty[-&gt;&gt;];
90: ninety[-&gt;&gt;];
100: &lt;&lt; hundred[ &gt;&gt;];
1000: &lt;&lt; thousand[ &gt;&gt;];
1,000,000: &lt;&lt; million[ &gt;&gt;];
1,000,000,000: &lt;&lt; billion[ &gt;&gt;];
1,000,000,000,000: &lt;&lt; trillion[ &gt;&gt;];
1,000,000,000,000,000: OUT OF RANGE!;</pre>

<p>(We allow commas, periods, and spaces in the base value to enhance readability; the
parser ignores them.)</p>

<p>For British English, which defines a billion as a million million instead of a thousand
million as in the U.S., we just change the frequency of the last few rules:</p>

<pre>1000: &lt;&lt; thousand[ &gt;&gt;];
1,000,000: &lt;&lt; million[ &gt;&gt;];
1,000,000,000,000: &lt;&lt; billion[ &gt;&gt;];
1,000,000,000,000,000,000: OUT OF RANGE!;</pre>

<p>1,000,000,000 will now use the rule for 1,000,000, producing &quot;one thousand
million.&quot;</p>

<p>Note the final rule in each of these lists. Since the upper limit of the range a rule
applies to is determined by the next rule in the list, the last rule in the list has no
upper limit. It applies to every number greater than or equal to its base value. When the
numeric type doesn&#146;t impose an upper limit (our implementation uses the Java <tt>long</tt>
type, whose upper limit is 1.84 × 10<sup>19</sup>), the base value of the last rule in
the list can be used to specify the upper limit for the rule set. It is a useful
convention to code an error message as the last rule&#146;s rule text to show this.</p>

<h3>Trying the approach with foreign languages</h3>

<p>This approach obviously works quite well for English, but what about other languages?
Well, in Spanish, we can handle the numbers from 21 to 29 with more rules:</p>

<pre>cero; uno; dos; tres; cuatro; cinco; seis; siete; ocho; nueve;
diez; once; doce; trece; catorce; quince; dieciséis; diecisiete;
			dieciocho; diecinueve;
veinte; veintiuno; veintidós; veintitrés; veinticuatro;
			veinticinco; veintiséis; veintisiete; veintiocho; veintinueve;
treinta[ y &gt;&gt;];
40: cuarenta[ y &gt;&gt;];
50: cincuenta[ y &gt;&gt;];
60: sesenta[ y &gt;&gt;];
70: setenta[ y &gt;&gt;];
80: ochenta[ y &gt;&gt;];
90: noventa[ y &gt;&gt;];</pre>

<p>Notice also that we can specify that &quot;y&quot; is to go between the tens and ones
digits simply by including &quot;y&quot; instead of &quot;-&quot; in the brackets of the
tens rules.</p>

<p>The differing form of &quot;cien&quot; depending on its context is also easily
handled&#133;</p>

<pre>100: cien;
101: ciento &gt;&gt;;
200: doscientos[ &gt;&gt;];</pre>

<p>&#133;as are the extra words for the hundreds place&#133;</p>

<pre>300: trescientos[ &gt;&gt;];
400: cuatrocientos[ &gt;&gt;];
500: quinientos[ &gt;&gt;];
600: seiscientos[ &gt;&gt;];
700: setecientos[ &gt;&gt;];
800: ochocientos[ &gt;&gt;];
900: novecientos[ &gt;&gt;];</pre>

<p>&#133;and the fact that the word before &quot;mil&quot; is omitted if it&#146;s
&quot;uno&quot;:</p>

<pre>1000: mil[ &gt;&gt;];
2000: &lt;&lt; mil[ &gt;&gt;];</pre>

<p>In German, the numbers from 13 to 19 can be derived algorithmically, so we don&#146;t
need to spell them all out&#133;</p>

<pre>null; eins; zwei; drei; vier; fünf; sechs; sieben; acht; neun;
zehn; elf; zwölf;
&gt;&gt;zehn;</pre>

<p>&#133;and the fact that the ones digit comes before the tens digit is also easily
handled by putting the substitution in a different place&#133;</p>

<pre>20: zwanzig; einundzwanzig; &gt;&gt;undzwanzig;
30: dreißig; einunddreißig; &gt;&gt;unddreißig;
40: vierzig; einundvierzig; &gt;&gt;undvierzig;
50: fünfzig; einundfünfzig; &gt;&gt;undfünfzig;
60: sechzig; einundsechzig; &gt;&gt;undsechzig;
70: siebzig; einundsiebzig; &gt;&gt;undsiebzig;
80: achtzig; einundachtzig; &gt;&gt;undachtzig;
90: neunzig; einundneunzig; &gt;&gt;undneunzig;</pre>

<p>Notice also here that because 1 is &quot;eins&quot; in German rather than
&quot;ein,&quot; we have to special-case the ones place. We&#146;ll look at an extension
that eliminates this problem later.</p>

<p>The rules for spelling out numbers in Han characters (used in Japanese, Chinese, and
Korean) are particularly simple&#133;</p>

<p><img src="fig1.gif" width="373" height="174" alt="fig1.gif (4739 bytes)"> </p>

<p>&#133;and the fact that CJK numerals group by ten thousand is easily handled by the
spacing of the rules:</p>

<p><img src="fig2.gif" width="443" height="132" alt="fig2.gif (3138 bytes)"></p>

<p>In French, things don&#146;t work as well. Again, we have to special-case two-digit
numbers ending in 1&#133;</p>

<pre>zéro; un; deux; trois; quatre; cinq; six; sept; huit; neuf;
dix; onze; douze; treize; quatorze; quinze; seize; dix-sept; dix-huit;
			dix-neuf;
vingt; vingt-et-un; vingt-&gt;&gt;
30: trente; trente-et-un; trente-&gt;&gt;
40: quarante; quarante-et-un; quarante-&gt;&gt;;
50: cinquante; cinquante-et-un; cinquante-&gt;&gt;;
60: soixante; soixante-et-un; soixante-&gt;&gt;;</pre>

<p>&#133;and for the numbers from 70 through 90, we have to throw up our hands and specify
a separate rule for practically every value:</p>

<pre>70: soixante-dix; soixante et onze; soixante-douze; soixante-treize;
			soixante-quatorze; soixante-quinze; soixante-seize;
			soixante-dix-sept; soixante-dix-huit; soixante-dix-neuf;
80: quatre-vingts; quatre-vingt-&gt;&gt;;
90: quatre-vingt-dix; quatre-vingt-onze; quatre-vingt-douze;
			quatre-vingt-treize; quatre-vingt-quatorze;
			quatre-vingt-quinze; quatre-vingt-seize;
			quatre-vingt-dix-sept; quatre-vingt-dix-huit;
			quatre-vingt-dix-neuf;</pre>

<p>We&#146;re then in good shape up to 1099&#133;</p>

<pre>cent[ &gt;&gt;];
200: &lt;&lt; cents[ &gt;&gt;];
1000: mille[ &gt;&gt;];</pre>

<p>&#133;but when we get to 1,100, we run into another problem. 1,100 in French is
&quot;onze cents&quot; (&quot;eleven hundred&quot;), not &quot;mille cent&quot; (&quot;one
thousand one hundred&quot;), so we need to specify a new rule here:</p>

<pre>1100: onze cents[ &gt;&gt;];</pre>

<p>The problem is that this rule&#146;s power of 10 is 3, so the minor substitution will
format the last three digits&#151;1123 will come out at &quot;onze cents cent
vingt-trois&quot; instead of &quot;onze cents vingt-trois.&quot; We can achieve the
correct result with no changes to the formatting algorithm if we can set this rule&#146;s
power of 10 to be 2 instead of 3. To do this, we introduce a new bit of syntax:</p>

<pre>1100&gt;: onze cents[ &gt;&gt;];
1200: mille &gt;&gt;;
2000: &lt;&lt; mille[ &gt;&gt;];</pre>

<p>The &quot;&gt;&quot; after the base value tells the formatter&#146;s constructor (which
builds its internal tables based on the textual description) to reduce the rule&#146;s
power of 10 by 1 from its calculated value. This will cause the formatting algorithm to
take the value being formatted mod 100, instead of 1000, to get the minor-substitution
value. We then add another rule at 1200 to go back to formatting the numbers as
&quot;mille deux cents (etc.)&quot; and another rule at 2000 to put the major substitution
before &quot;mille.&quot; Problem solved.</p>

<h3>The full algorithm</h3>

<p>This approach can be used effectively for every language we researched, although it
takes a little work to handle some. To summarize, then, when a number-spellout formatter
is created, the grammar described above is parsed to build a list of rules. Each rule has
a base value, a power of 10, rule text, and two optional substitutions. The table is
sorted by base value. To format a value, the program binary-searches the rule list to find
the rule with the highest base value less than or equal to the value being formatted. If
the appropriate rule has both major and minor substitutions, but the value being formatted
is an even multiple of ten raised to the rule&#146;s power of 10, we back up and treat the
preceding rule in the list as the appropriate rule. The rule text is copied into the
result string. If the rule has a major substitution, we divide the value being formatted
by 10 raised to the rule&#146;s power of 10 and call ourselves recursively to format the
quotient, inserting the result into the result string at the major substitution position.
Likewise, if the rule has a minor substitution, we divide the value being formatted by 10
raised to the rule&#146;s power of 10 and call ourselves recursively to format the <i>remainder,</i>
inserting the result at the minor substitution position.</p>

<p>To see how this works in practice, consider this example:</p>

<p>We want to format 3,200,540 using the rule set for U.S. English given above. That rule
set, again (with the bracket notation taken out), is</p>

<pre>zero; one; two; three; four; five; six; seven; eight; nine;
ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen; seventeen;
			eighteen; nineteen;
twenty; twenty-&gt;&gt;;
30: thirty; thirty-&gt;&gt;;
40: forty; forty-&gt;&gt;;
50: fifty; fifty-&gt;&gt;;
60: sixty; sixty-&gt;&gt;;
70: seventy; seventy-&gt;&gt;;
80: eighty; eighty-&gt;&gt;;
90: ninety; ninety-&gt;&gt;;
100: &lt;&lt; hundred; &lt;&lt; hundred &gt;&gt;;
1000: &lt;&lt; thousand; &lt;&lt; thousand &gt;&gt;;
1,000,000: &lt;&lt; million; &lt;&lt; million &gt;&gt;;
1,000,000,000: &lt;&lt; billion; &lt;&lt; billion &gt;&gt;;
1,000,000,000,000: &lt;&lt; trillion; &lt;&lt; trillion &gt;&gt;;
1,000,000,000,000,000: OUT OF RANGE!;</pre>

<p>The highest base value less than the value being formatted is 1,000,001, so our result
starts out as</p>

<pre>&lt;&lt; million &gt;&gt;</pre>

<p>This rule&#146;s power of 10 is 6, so to fill in the major substitution, we divide
3,200,540 by 1,000,000, giving us 3. We look up a rule for 3, which gives us</p>

<pre>three million &gt;&gt;</pre>

<p>To fill in the minor substitution, we divide 3,200,540 by 1,000,000 and take the
remainder, giving us 200,540. The closest matching rule is the one for 1,001, giving us</p>

<pre>three million &lt;&lt; thousand &gt;&gt;</pre>

<p>To fill in the major substitution, we now divide 200,540 by 1,000, giving us 200. The
closest matching rule for 200 is the one for 101, but since this rule has two
substitutions and our minor-substitution value (i.e., 200 mod 100) is 0, we roll back and
use the rule for 100 instead. This gives us</p>

<pre>three million &lt;&lt; hundred thousand &gt;&gt;</pre>

<p>To fill in <i>this</i> major substitution, we divide 200 by 100 (the rule&#146;s power
of 10 is 2), giving us 2. Looking up the rule for 2 gives us</p>

<pre>three million two hundred thousand &gt;&gt;</pre>

<p>This rule has no minor substitution, so we fall back to the previous level of recursion
and fill in the minor substitution for 200,540. We divide 200,540 by 1,000 (the
rule&#146;s base value is 1,001, so its power of 10 is 3) and take the remainder, giving
us 540. The closest matching rule has a base value of 101 (we don&#146;t roll back this
time), giving us</p>

<pre>three million two hundred thousand &lt;&lt; hundred &gt;&gt;</pre>

<p>To fill in the major substitution, we divide 540 by 100, giving us 5, and look up the
rule for 5:</p>

<pre>three million two hundred thousand five hundred &gt;&gt;</pre>

<p>Then we take the remainder of 540 over 100, which is 40, and again we score a direct
match on the rule for 40, giving us a finished result of</p>

<pre>three million two hundred thousand five hundred forty</pre>

<h3>Parsing</h3>

<p>By design, all of Taligent&#146;s formatting objects also parse, so we also had to come
up with a parsing algorithm. While the utility of the parsing algorithm is less obvious,
one possible use is in speech-recognition systems.</p>

<p>The design of the formatter is heavily oriented toward formatting, and as it turns out,
applying the rule sets in reverse to translate from words back to a number is much more
complicated and doesn&#146;t scale as well.</p>

<p>To simplify the parsing algorithm&#146;s work, we impose a restriction: the string
passed to the parsing algorithm must contain only the text to be parsed: if the parsing
algorithm fails to use all the characters, this is an error. This allows us to parse the
string right to left, which eliminates some special-case code (in particular, we
don&#146;t need a counterpart for the &quot;rollback rule&quot; in the formatting
algorithm) and allows the parse to be more permissive (both &quot;two hundred&quot; and
&quot;two hundred zero&quot; will parse correctly, as will both &quot;twenty-one
hundred&quot; and &quot;two thousand one hundred&quot;).</p>

<p>If you ignore substitutions for a minute, the basic principle is simple: start with the
first rule in the rule list. Match characters from the rule to characters from the string
being parsed, beginning at the ends of the strings and working your way back to the
beginning. If you find a mismatch, go on to the next rule. If you exhaust the characters
in the string before you exhaust the characters in the rule, that&#146;s also a mismatch,
and you go on to the next rule. If you exhaust the characters in the string and the
characters in the rule at the same time, you have an exact match, and the result of the
parse is that rule&#146;s base value.</p>

<p>Substitutions complicate the picture. There are two cases to consider: rules that end
with substitutions, and rules that don&#146;t. We explicitly ignore rules that end with
substitutions for the first pass. For rules that have substitutions in the middle or
beginning, we match characters until we get to the substitution position. At that point,
the parse function calls itself recursively to fill in the substitution value. If the
recursive call is successful, the outer loop calculates a new result value from the
current rule&#146;s base value and the value of the rule that matched in the recursive
call, and resumes matching characters wherever the recursive call left off.</p>

<p>Rules that end in substitutions come into play when we exhaust the characters in the
rule before we exhaust the characters in the string being parsed. If this happens, we call
ourselves recursively, only now we&#146;re looking for a rule that ends in a substitution.
The idea is that the characters we matched so far may be plugged in as a substitution in
some other rule.</p>

<p>To see how this works in practice, consider the string &quot;seven hundred
eighty-nine&quot;. The first rule in the U.S. set that matches is the rule for 9, which
uses up &quot;nine&quot;. Since we haven&#146;t used up all the characters in the parse
string, we call ourselves recursively, looking for a rule that ends with a substitution
and will consume more characters. The first one we find is the rule for 81, which uses up
&quot;eighty-&quot;. To calculate our result value, we subtract 81 mod 10 from 81, giving
us 80. This is to eliminate all digits to the right of the rule&#146;s power-of-10
position. Then we add 9, the base value of the previous matching rule. So now our result
is 89.</p>

<p>We still haven&#146;t consumed all the characters in the string, though, so we recurse
again, again looking for a rule that ends in a substitution and consumes more characters.
The first one is the rule for 101, which uses up &quot; hundred &quot;. However, this rule
also contains a substitution at the beginning, so it doesn&#146;t count as a match unless
we can match the substitution. So we call ourselves recursively again, looking for a match
for &quot;seven&quot;.</p>

<p>This time around, we&#146;ll find an exact match, and since this consumes all the
characters in the string to be parsed, and in the rule, we&#146;re done. The substitution
value is 7, multiplied by the power of 10 of the rule containing the substitution, which
gives us 700. We already have the minor-substitution value (89), so we add that in, and
we&#146;re done. The result is 789.</p>

<p>There are, however, a few complications. Consider the string &quot;three hundred
twenty-five thousand four hundred thirty-six.&quot; Parsing &quot;hundred thirty-six&quot;
proceeds fairly straightforwardly, but when it comes time to fill in the major
substitution before &quot;hundred,&quot; we&#146;ve got &quot;three hundred twenty-five
thousand four&quot; left to parse. Obviously, 325,004 is not what we want for our major
substitution&#151;that would produce a parse result of 32,500,436. Therefore, when we make
recursive calls, we have to restrict the pool of applicable rules. The stipulation is that
a substitution can only be filled in by a rule with a power of 10 that&#146;s less than
the power of 10 of the rule containing the substitution. This happens naturally in the
formatting algorithm, but we have to account for it specifically in the parsing algorithm.</p>

<p>If we restrict ourselves in this way, then instead of treating &quot;three hundred
twenty-five thousand four&quot; as the major-substitution value for &quot;hundred
thirty-six&quot;, we use only &quot;four&quot; as the major-substitution value, and then
use &quot;four hundred thirty-six&quot; as the minor-substitution value for &quot;three
hundred twenty-five thousand&quot;.</p>

<p>Continuing on, we match &quot;five&quot;, then recurse to produce
&quot;twenty-five&quot;, then recurse again to produce &quot;three hundred
twenty-five&quot;. At this point, we&#146;ve exhausted the string, so we have 325 as the
major-substitution value for &quot;thousand,&quot; giving us 325,000. We already had the
minor-substitution value, 436, so we add that in to produce 325,436, and we&#146;re done.</p>

<p>Russian introduces an additional complication. In Russian, the words for some numbers
are substrings of the words for other numbers. The word for 7 &quot;sem&quot;, but the
word for 8 is &quot;vosem&quot;. The word for 100 is &quot;sto&quot;, but the word for 90
is &quot;devyanosto&quot;. Sometimes the matching algorithm will handle these words
correctly, but sometimes it will stop on the wrong word, either causing a parse error or
the wrong result. To deal with this, we must also keep track of a &quot;best-guess
value.&quot; Any time a rule matches the text, but doesn&#146;t consume all of the
characters in the string to be parsed, we parse as far as we can with that rule, and then
keep track of our result and how many characters we used and continue on through the rule
list. If there&#146;s no undisputed winner (i.e., no rule that, after filling in all its
substitutions, consumes all the characters in the string), then the rule that consumed the
most characters is declared the winner. Only at the outermost level of recursion is
failure to use up all the characters in the string to be parsed declared to be a parse
error. (Even this is a judgment call&#151;failure to use up all the characters really
should only count as a parse error if the caller is parsing a longer string from left to
right and is assuming the characters at the front of the string passed to the
spellout-parse algorithm are part of a number.)</p>

<h3>Negative numbers and fractions</h3>

<p>So far, we&#146;ve considered only nonnegative integers. To be fully general, the
formatting and parsing algorithms must be able to handle negative numbers and numbers with
fractional parts.</p>

<p>To handle negative numbers, we added a <i>negative number rule</i> to the rule list in
addition to the numbered rules. The negative number rule is identified by &quot;-:&quot;
where the rule&#146;s base value would normally go. This rule would be used for formatting
all negative numbers. Its minor-substitution value, instead of being the value being
formatted mod some power of 10, is simply the absolute value of the number being formatted
(a major substitution isn&#146;t allowed). In English, the negative number rule would look
like this:</p>

<pre>-: minus &gt;&gt;;</pre>

<p>Numbers with fractional parts are handled similarly: We define a <i>decimal rule</i>
that is used to format numbers that have fractional parts. The decimal rule is tagged with
&quot;.:&quot; instead of a normal base value, its major substitution is the integral part
of the number, and its minor substitution is the number&#146;s fractional part. In
English, the decimal rule would look like this:</p>

<pre>.: &lt;&lt; point &gt;&gt;;</pre>

<p>The minor substitution in the negative number rule and the major substitution in the
decimal rule work like the other substitutions: they look up the appropriate text for the
substitution value in the same rule set. The minor substitution in the decimal rule is
special. Instead of using the rule set in the normal way, it uses the first ten entries in
the rule set to spell out the fractional part of the number one digit at a time. In other
words, 123.456 would come out as</p>

<pre>one hundred twenty-three point four five six</pre>

<p>This approach is obviously rather arbitrary and inflexible, but it works reasonably
well most of the time. We&#146;ll look at a more advanced and flexible approach later.</p>

<h3>Alternate rule sets</h3>

<p>Our first implementation of the number spellout formatter had the features listed
above, which were sufficient for all of the languages we researched and provided a good
general solution to the problem. This algorithm can be made much more flexible and
powerful through the addition of four new features, none of which complicates the rule
syntax or the formatting algorithm unreasonably.</p>

<p>Consider the problem of writing out English ordinal numbers. At first glance, this
seems like a straightforward changing of names:</p>

<pre>zeroth; first; second; third; fourth; fifth; sixth; seventh; eighth;
			ninth;
tenth; eleventh; twelfth; thirteenth; fourteenth; fifteenth; sixteenth;
			seventeenth; eighteenth; nineteenth;
twentieth; twenty-&gt;&gt;;
30: thirtieth; thirty-&gt;&gt;;
40: fortieth; forty-&gt;&gt;;
50: fiftieth; fifty-&gt;&gt;;
60: sixtieth; sixty-&gt;&gt;;
70: seventieth; seventy-&gt;&gt;;
80: eightieth; eighty-&gt;&gt;;
90: ninetieth; ninety-&gt;&gt;;
100: &lt;&lt; hundredth; &lt;&lt; hundred &gt;&gt;;
1000: &lt;&lt; thousandth; &lt;&lt; thousand &gt;&gt;;
1,000,000: &lt;&lt; millionth; &lt;&lt; million &gt;&gt;;
1,000,000,000: &lt;&lt; billionth; &lt;&lt; billion &gt;&gt;;
1,000,000,000,000: &lt;&lt; trillionth; &lt;&lt; trillion &gt;&gt;;
1,000,000,000,000,000: OUT OF RANGE!;</pre>

<p>But if you use this rule set to format 937, you&#146;ll get &quot;ninth hundred
thirty-seventh&quot; instead of &quot;nine hundred thirty-seventh.&quot; You don&#146;t
actually want to call this rule set recursively to fill in the major substitution values;
you actually want their cardinal-number counterparts. The only way to do this with a
conventional rule set would be to introduce rules at every multiple of 100, 1000,
1,000,000, and so on, which isn&#146;t feasible. Instead, what you really want to do is
leverage the rule set we already have for the cardinal numbers to fill in the major
substitution values.</p>

<p>In other words, we want a single formatter to own more than one rule set, and we want
each rule to be able to specify which of the formatter&#146;s rule sets should be used to
fill in a substitution.</p>

<p>To specify multiple rule sets in a single formatter description, we adopt the
convention that a rule set name begins with %. Each rule set then begins with its name,
followed by a colon. If a substitution should call a rule set other than the one that owns
it, you specify this by putting the rule set name between the substitution characters
(e.g., if a minor substitution should call rule set %foo, you&#146;d say
&quot;&gt;%foo&gt;&quot;). With these additions, a rule set that will handle both cardinal
and ordinal numbers in English would look like this:</p>

<pre>%card:
zero; one; two; three; four; five; six; seven; eight; nine;
ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen;
			seventeen; eighteen; nineteen;
twenty[-&gt;&gt;];
30: thirty[-&gt;&gt;];
40: forty[-&gt;&gt;];
50: fifty[-&gt;&gt;];
60: sixty[-&gt;&gt;];
70: seventy[-&gt;&gt;];
80: eighty[-&gt;&gt;];
90: ninety[-&gt;&gt;];
100: &lt;&lt; hundred[ &gt;&gt;];
1000: &lt;&lt; thousand[ &gt;&gt;];
1,000,000: &lt;&lt; million[ &gt;&gt;];
1,000,000,000: &lt;&lt; billion[ &gt;&gt;];
1,000,000,000,000: &lt;&lt; trillion[ &gt;&gt;];
1,000,000,000,000,000: OUT OF RANGE!;
%ord:
zeroth; first; second; third; fourth; fifth; sixth; seventh; eighth;
			ninth;
tenth; eleventh; twelfth; thirteenth; fourteenth; fifteenth;
			sixteenth; seventeenth; eighteenth; nineteenth;
twentieth; twenty-&gt;&gt;;
30: thirtieth; thirty-&gt;&gt;;
40: fortieth; forty-&gt;&gt;;
50: fiftieth; fifty-&gt;&gt;;
60: sixtieth; sixty-&gt;&gt;;
70: seventieth; seventy-&gt;&gt;;
80: eightieth; eighty-&gt;&gt;;
90: ninetieth; ninety-&gt;&gt;;
100: &lt;%card&lt; hundredth; &lt;%card&lt; hundred &gt;&gt;;
1000: &lt;%card&lt; thousandth; &lt;%cardlt; thousand &gt;&gt;;
1,000,000: &lt;%card&lt; millionth; &lt;%card&lt; million &gt;&gt;;
1,000,000,000: &lt;%card&lt; billionth; &lt;%card&lt; billion &gt;&gt;;
1,000,000,000,000: &lt;%card&lt; trillionth; &lt;%card&lt; trillion &gt;&gt;;
1,000,000,000,000,000: OUT OF RANGE!;</pre>

<p>The formatter&#146;s format() function would now take an additional parameter that
allows the user to specify which rule set to use to format a particular number. This
ability also allows us to specify rule sets for languages that have different inflected
forms for numbers depending on what they&#146;re referring to.</p>

<p>Alternate rule sets also allow us to simplify some of the more complicated rule sets.
In French, for example, a two-digit number has &quot;et&quot; between the digits when the
ones digit is 1, but not when the ones digit is 2 through 9, leading us to require three
rules for each of the multiples of 10:</p>

<pre>20: vingt; vingt-et-un; vingt-&gt;&gt;
30: trente; trente-et-un; trente-&gt;&gt;
40: quarante; quarante-et-un; quarante-&gt;&gt;;
50: cinquante; cinquante-et-un; cinquante-&gt;&gt;;
60: soixante; soixante-et-un; soixante-&gt;&gt;;</pre>

<p>We can eliminate some of this repetition by specifying the ones-digit behavior as a
separate rule set:</p>

<pre>%main:
vingt[-&gt;%%alt-ones&gt;];
30: trente[-&gt;%%alt-ones&gt;];
40: quarante[-&gt;%%alt-ones&gt;];
50: cinquante[-&gt;%%alt-ones&gt;];
60: soixante[-&gt;%%alt-ones&gt;];
%%alt-ones:
	; et-un; =%main=;</pre>

<p>Note a few interesting things about this sample rule set: First, the alternate rule
set&#146;s name begins with two %s. We&#146;ve adopted the convention that rule sets that
are meant to be called only by other rule sets, and not by the formatter&#146;s calling
routine, have names that begin with %%.</p>

<p>Second, %%alt-ones begins with a bare semicolon. This says that the zero rule for this
rule set is the empty string (in some future examples, we&#146;ll use &quot;0:;&quot; for
clarity).</p>

<p>Finally, and most importantly, note the third rule in %%alt-ones: &quot;=%main=;&quot;.
This is a new type of substitution: a <i>same-value substitution.</i> This works the same
way as the other types of substitutions, except that instead of dividing the number being
formatted by something to get a substitution value, the value being formatted is passed
through unchanged as the substitution value. Among other things, this lets one rule set
defer handling of certain ranges of numbers to another rule set instead of having to
re-specify all those rules. This is what we&#146;re using it for here. Same-value
substitutions turn out to be very useful, as we&#146;ll see in some later examples.</p>

<h3>Alternate radices</h3>

<p>The basic number-spellout formatting algorithm is based on powers of 10. It would be a
reasonably simple thing to imagine extending it to allow radices other than 10. Consider
the French rules:</p>

<pre>60: soixante; soixante-et-un; soixante-&gt;&gt;;
70: soixante-dix; soixante et onze; soixante-douze; soixante-treize;
			soixante-quatorze; soixante-quinze; soixante-seize;
			soixante-dix-sept; soixante-dix-huit; soixante-dix-neuf;
80: quatre-vingts; quatre-vingt-&gt;&gt;;
90: quatre-vingt-dix; quatre-vingt-onze; quatre-vingt-douze;
			quatre-vingt-treize; quatre-vingt-quatorze;
			quatre-vingt-quinze; quatre-vingt-seize;
			quatre-vingt-dix-sept; quatre-vingt-dix-huit;
			quatre-vingt-dix-neuf;
cent[ &gt;&gt;];</pre>

<p>French has no words for 70, 80 or 90. 80 is rendered as &quot;quatre-vingts&quot;
(&quot;four twenties&quot;), and numbers progress by score. Thus, for example, 72 is
&quot;soixante douze&quot; (&quot;sixty-twelve&quot;) and 98 is
&quot;quatre-vingt-dix-huit&quot; (&quot;eighty-eighteen,&quot; or literally,
&quot;four-twenty-ten-eight&quot;). There is no good way to handle this kind of thing with
the original rule syntax, so we had to specify individual rules for all the numbers
between 70 and 79 and between 90 and 99.</p>

<p>Alternate rule sets can be used to solve this problem to some degree&#133;</p>

<pre>%main:
vingt[-&gt;%%alt-ones&gt;];
30: trente[-&gt;%%alt-ones&gt;];
40: quarante[-&gt;%%alt-ones&gt;];
50: cinquante[-&gt;%%alt-ones&gt;];
60: soixante[-&gt;%%alt-ones&gt;];
71: soixante et onze;
72: soixante-&gt;%%teens&gt;;
80: quatre-vingts; quatre-vingt-&gt;&gt;;
90: quatre-vingt-&gt;%%teens&gt;;
100: cent[ &gt;&gt;];
%%alt-ones:
	; et-un; =%main=;
%%teens:
	dix; onze; douze; treize; quatorze; quinze; seize; dix-sept;
				dix-huit; dix-neuf; =%main=;</pre>

<p>&#133;but a more elegant approach would be to specify that the sixties and eighties
proceed by score. We can do this by specifying an alternate radix for these rules. The
alternate radix follows the base value and is separated from it by a slash:</p>

<pre>60/20: soixante[-&gt;%%alt-ones&gt;];
71: soixante et onze;
72/20: soixante-&gt;%%alt-ones&gt;;
80: quatre-vingts;
81/20: quatre-vingt-&gt;&gt;;
100: cent[ &gt;&gt;];</pre>

<p>To fill in the minor substitution for the rules for 60, 72, and 81, we divide the value
being formatted by <i>20</i> rather than 10. This means the ones digit can be anything up
to 19, and we can recurse and look up the words for 11 through 19 in their normal
positions in the rule list without having to specify them again in a new rule list. (71 is
a pathological case in French; it always requires its own rule.)</p>

<p>Alternate radices could also be used to format a number in a base other than 10. For
example, say we wanted to format dozens:</p>

<pre>zero; one; two; three; four; five; six; seven; eight; nine; ten;
			eleven;
12/12: &lt;&lt; dozen[and &gt;&gt;];
144/12: &lt;&lt; gross[ &gt;&gt;];</pre>

<h3>Fraction rule sets</h3>

<p>Alternate rule sets can also be used to great effect in formatting numbers with
fractional parts. In some languages, &quot;point four five six&quot; is not allowed; you
need to say &quot;and four hundred fifty-six thousandths&quot; instead. We can handle this
by allowing the minor substitution in a decimal rule to call another rule set:</p>

<pre>%main;
	zero; one; two; three; four; five; six; seven; eight; nine;
	(and so on&#133;)
	.: &lt;&lt; and &gt;%%dec&gt;;
%%dec:
	10: &lt;%main&lt; tenths;
	100: &lt;%main&lt; hundredths;
	1000: &lt;%main&lt; thousands;
	10,000: &lt;%main&lt; ten-thousandths;
	(and so on&#133;)</pre>

<p>When a rule set is called from the minor substitution of a decimal rule (i.e., when it
is being used to format the fractional part of a number), it is called a <i>fraction rule
set.</i> The base values and substitutions in a fraction rule set have different meanings
than they do in a normal rule set: In a fraction rule set, an appropriate rule is found by
multiplying the number being formatted by the base value of each rule one by one until we
get an integral result (or until the list is exhausted, in which case the last rule is
used and the numerator is rounded). In other words, the base values represent possible <i>denominators</i>
for the fraction. The major substitution value is obtained by multiplying the value being
formatted by the rule&#146;s base value: that is, it is the <i>numerator</i> of the
fraction. Thus, formatting 123.456 with this rule set will yield &quot;one hundred
twenty-three and four hundred fifty-six thousandths,&quot; while formatting 123.45 will
yield &quot;one hundred twenty-three and forty-five hundredths.&quot;</p>

<p>There are a couple of small problems with this rule set that are easily solved with
alternate rule sets. First, values below 1 will come out with &quot;zero and&quot; on the
front. If you want to see 0.45 as &quot;forty-five hundredths&quot;, you would have to add
another rule set:</p>

<pre>%main;
	zero; one; two; three; four; five; six; seven; eight; nine;
	(and so on&#133;)
	.: &lt;%%and&lt;&gt;%%dec&gt;;
%%and:
	0:;
	1: =%main= and ;
%%dec:
	10: &lt;%main&lt; tenths;
	100: &lt;%main&lt; hundredths;
	1000: &lt;%main&lt; thousands;
	10,000: &lt;%main&lt; ten-thousandths;
	(and so on&#133;)</pre>

<p>Also, as written, the above rule set will format 4.1 as &quot;four and one
tenths,&quot; which is wrong. We can also handle this with another rule set:</p>

<pre>%main;
	zero; one; two; three; four; five; six; seven; eight; nine;
	(and so on&#133;)
	.: &lt;%%and&lt;&gt;%%dec&gt;;
%%and:
	0:;
	1: =%main= and ;
%%dec:
	10: &lt;%main&lt; tenth&lt;%%s&lt;;
	100: &lt;%main&lt; hundredth&lt;%%s&lt;;
	1000: &lt;%main&lt; thousand&lt;%%s&lt;;
	10,000: &lt;%main&lt; ten-thousandth&lt;%%s&lt;;
	(and so on&#133;)
%%s:
	s; ; s;</pre>

<p>%%s will produce an s with a value of anything other than 1; for 1, it will return the
empty string. (Of course, this trick is only guaranteed to work in English; for languages
where you can&#146;t pluralize a word so easily, each rule in %%dec would have to branch
to a separate rule set with the appropriate singular and plural words in it.)</p>

<p>Notice that we now have two major substitutions in the same rule for every rule in
%%dec. This is allowed. A rule may only have two substitutions, but there are no
restrictions on their type (other than that major substitutions are not allowed in
negative number rules and minor substitutions are not allowed in fraction rule sets).</p>

<p>It&#146;s worth pointing out that this approach to formatting the fractional part of a
number isn&#146;t infinitely flexible. It lets you specify which denominators you care
about, which can be quite useful, as the examples show. But if you want the system to take
an arbitrary floating-point value and automatically format it as a fraction using the
closest integral denominator, this design won&#146;t allow that.</p>

<h3>Formatting as numerals</h3>

<p>One of the primary uses for a number-spellout engine is to write out the amount on a
check. Normally, check amounts are written with the dollar amount in words and the cents
amount in numerals: &quot;One hundred twenty-three and 45/100 dollars&quot; or &quot;One
hundred twenty-three dollars and 45 cents.&quot; This implies another feature should be
added to the number spellout engine to allow the spelling out of part or all of a number
in numerals.</p>

<p>We use the substitution notation for this. Instead of specifying a rule set to use to
fill in a substitution, you can specify that a substitution be filled in with numerals.</p>

<p>In our implementation of the system, we do this by putting a pattern string for a Java
DecimalFormat object between the substitution characters: for example,
&quot;&gt;00&gt;&quot; means &quot;fill in the minor substitution by writing out the value
in digits with a minimum of two digits.&quot; &quot;&lt;#,##0.###&lt;&quot; means
&quot;fill in the major substitution by writing out its value with a minimum of one digit
to the left of the decimal, up to three decimal places, and commas separating the
thousands.&quot; &quot;=0=&quot; means &quot;fill in the same-value substitution [i.e.,
write out the value being formatted] in numerals, with a minimum of one digit.&quot;
Although DecimalFormat allows other things at the beginning of a pattern, to make the rule
parser for the spellout formatter simpler, we require that the DecimalFormat pattern begin
with a # or a 0.</p>

<p>Using this, we can write check amounts out in the first format with the following
rules:</p>

<pre>%usr:
	0: =%%main= and 00/100 dollars;
	.: &lt;%%main&lt; and &gt;%%cents&gt; dollars;
%%main:
zero; one; two; three; four; five; six; seven; eight; nine;
ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen;
			seventeen; eighteen; nineteen;
twenty[-&gt;&gt;];
30: thirty[-&gt;&gt;];
40: forty[-&gt;&gt;];
50: fifty[-&gt;&gt;];
60: sixty[-&gt;&gt;];
70: seventy[-&gt;&gt;];
80: eighty[-&gt;&gt;];
90: ninety[-&gt;&gt;];
100: &lt;&lt; hundred[ &gt;&gt;];
1000: &lt;&lt; thousand[ &gt;&gt;];
1,000,000: &lt;&lt; million[ &gt;&gt;];
1,000,000,000: &lt;&lt; billion[ &gt;&gt;];
1,000,000,000,000: &lt;&lt; trillion[ &gt;&gt;];
1,000,000,000,000,000: OUT OF RANGE!;
%%cents:
	100: &lt;00&lt;/100;</pre>

<p>And the second format would use the following rules:</p>

<pre>%usr:
	0: =%%main= dollars;
	.: &lt;&lt; and &gt;%%cents&gt;;
%%main:
zero; one; two; three; four; five; six; seven; eight; nine;
ten; eleven; twelve; thirteen; fourteen; fifteen; sixteen;
			seventeen; eighteen; nineteen;
twenty[-&gt;&gt;];
30: thirty[-&gt;&gt;];
40: forty[-&gt;&gt;];
50: fifty[-&gt;&gt;];
60: sixty[-&gt;&gt;];
70: seventy[-&gt;&gt;];
80: eighty[-&gt;&gt;];
90: ninety[-&gt;&gt;];
100: &lt;&lt; hundred[ &gt;&gt;];
1000: &lt;&lt; thousand[ &gt;&gt;];
1,000,000: &lt;&lt; million[ &gt;&gt;];
1,000,000,000: &lt;&lt; billion[ &gt;&gt;];
1,000,000,000,000: &lt;&lt; trillion[ &gt;&gt;];
1,000,000,000,000,000: OUT OF RANGE!;
%%cents:
	100: &lt;0&lt; cent&lt;%%s&lt;;
%%s:
	s; ; s;</pre>

<h3>Other uses</h3>

<p>One of the great strengths of this rule-based technique for formatting numbers is that
it can be used not only for spelling out numeric values in words, but also for a wide
variety of other number-formatting tasks that are more complex than simple Western-numeral
output.</p>

<p>For instance, it works very well for formatting major and minor units when they
aren&#146;t related by a factor of 10. One way of formatting a number of seconds as hours,
minutes, and seconds would be</p>

<pre>%usr:
	0: 0 seconds; 1 second; &lt;0&lt; seconds;
	60: =%%hms=;
%%hms:
	0: =00=;
	60/60: &lt;00&lt;:&gt;&gt;;
	3600/60: &lt;0&lt;:&gt;&gt;;</pre>

<p>It can also be useful for formatting fractional values. American stock prices, which
are usually in eighths or sixteenths of a dollar instead of cents, could be formatted this
way:</p>

<pre>%main:
	0: =0=;
	.: &lt;0&lt;&gt;%%frac&gt;;
%%frac:
	2: ' 1/2;
	4: ' &lt;0&lt;/4;
	8: ' &lt;0&lt;/8;
	16: ' &lt;0&lt;/16;
	32: ' &lt;0&lt;/32;
	100: .&lt;00&lt;;</pre>

<p>[The apostrophes are an extra little bit of syntax that allows a rule to begin with
leading whitespace: If the first character in a rule&#146;s rule text is an apostrophe,
the apostrophe is deleted (if you <i>want</i> the first character to be an apostrophe, you
put two apostrophes).]</p>

<p>This approach can also be used for message formatting:</p>

<pre>The search found no files.;
The search found one file.;
The search found =0= files.;</pre>

<p>or</p>

<pre>%usr:
	There =%%main= free space on the disk.
%%main:
	is no;
	are =0= bytes of;
	1024/1024: is &lt;0&lt;K of;
	1,048,576/1024: are &lt;0&lt;Mb of;</pre>

<p>This example also shows how we can change the units used to denominate a quantity
depending on its magnitude.</p>

<p>The rule-based approach is also useful for numeration systems other than Western
numerals. We&#146;ve already seen how we can use the rule-based formatter to show numbers
using CJK numerals (i.e., Han characters). Roman numerals would look like this:</p>

<pre>; I; II; III; IV; V; VI; VII; VIII; IX;
10: X[&gt;&gt;];
20: XX[&gt;&gt;];
30: XXX[&gt;&gt;];
40: XL[&gt;&gt;];
50: L[&gt;&gt;];
60: LX[&gt;&gt;];
70: LXX[&gt;&gt;];
80: LXXX[&gt;&gt;];
90: XC[&gt;&gt;];
100: C[&gt;&gt;];
200: CC[&gt;&gt;];
300: CCC[&gt;&gt;];
400: CD[&gt;&gt;];
500: D[&gt;&gt;];
600: DC[&gt;&gt;];
700: DCC[&gt;&gt;];
800: DCCC[&gt;&gt;];
900: CM[&gt;&gt;];
1000: M[&gt;&gt;];
2000: MM[&gt;&gt;];
3000: MMM[&gt;&gt;];
4000: OUT OF RANGE!;</pre>

<p>And finally, we can come full circle and use the rule-based formatter to format regular
Western numerals:</p>

<pre>0; 1; 2; 3; 4; 5; 6; 7; 8; 9;
10: &lt;&lt;&gt;&gt;;
100: &lt;&lt;&gt;&gt;;
1000: &lt;&lt;,&gt;&gt;;
1,000,000: &lt;&lt;,&gt;&gt;;
1,000,000,000: &lt;&lt;,&gt;&gt;;
1,000,000,000,000: &lt;&lt;,&gt;&gt;;
1,000,000,000,000,000: OUT OF RANGE!;
-: -&gt;&gt;;
.: &lt;&lt;.&gt;&gt;;</pre>

<h3>Limitations</h3>

<p>While this particular rule-based approach to formatting is suitable for most numeric
formatting tasks, there are some things it doesn&#146;t handle at all, or which require an
inordinate amount of work.</p>

<p>For instance, the way numbers with fractional parts are handled handles the most common
cases, but will break down in some of the more esoteric instances, such as showing
irrational values symbolically (e.g., rendering 2.7182818&#133; as &quot;e&quot;) or
rendering any floating-point value as the nearest possible fraction.</p>

<p>In the same way, the way negative numbers are handled works well in the most common
cases, but becomes rather unwieldy when a negative number is rendered as something other
than the absolute value with an added string at the beginning or ending. This situation
will generally only come up when 0 is rendered as something other than 0. (In date
formatting, for example, dates are usually stored as the number of seconds before or after
some reference date and then translated into a displayable format according to the
conventions of some calendar. In that type of situation, the formatted forms of negative
numbers aren&#146;t related to the formatted forms of their absolute values.)</p>

<p>Finally, this approach to formatting and parsing is based on the different component
parts of the formatted number being related to each other through multiplication and
division. If a substitution value should be derived through addition and subtraction, or
through exponentiation and logarithms, this can generally only be done through the use of
many extra rules and alternate rule sets. This makes the display of numbers in scientific
notation a little cumbersome: the exponent can&#146;t be a substitution value with the
rest of the form in a single rule&#146;s rule text. Instead, you need a new rule supplying
a new exponent value at each power of 10 position. </p>

<h3>Conclusion</h3>

<p>The rule-based approach to numeric formatting is a simple, yet powerful and versatile,
solution to a wide variety of numeric-formatting problems. Not only is it an excellent
solution for the number-spellout problem, providing a simple way to accommodate the
various ways different languages spell out numbers, but it also provides solutions to many
other number-formatting problems that are beyond the capabilities of a conventional
numeric-formatting engine.</p>

<p>IBM has filed patent applications for this technology, but intends to make the Java
implementation freely available. C and C++ implementations are available as part of
IBM&#146;s International Classes technology. Look for information on both at <a
HREF="http://www.ibm.com/java"><ftt>http://www.ibm.com/java</a>.</p>
</body>
</html>
