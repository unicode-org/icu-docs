<HTML>
<HEAD>
  <META NAME="GENERATOR" CONTENT="Adobe PageMill 2.0 Mac">
  <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
  <META NAME="Author" CONTENT="Mark Davis, Doug Felt, John Raley">
  <TITLE>International Text in JDK 1.2</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">

<H1><CENTER>International Text in JDK 1.2</CENTER></H1>

<H3><CENTER>by Mark Davis, Doug Felt and John Raley</CENTER></H3>

<P>&nbsp;</P>

<P>A primary design goal of Java is to enable developers to write software
that can be deployed easily across a variety of world markets. These markets
use very different languages, written in a variety of writing systems. To
be acceptable in these markets, you must be able to present text in a way
that conforms to the rules of the their writing systems.</P>

<P><FONT COLOR="#000000">Displaying English text correctly is relatively
simple</FONT>&shy;&shy;though not quite as simple as you may think! Other
writing systems, particularly Arabic and Hebrew, are much more complex than
English; <FONT COLOR="#000000">requiring reshaping and reordering of text
for acceptable display</FONT>.&nbsp;<FONT COLOR="#000000">Moreover, in a
Graphical User Interface (GUI) you need to measure text properly; and if
you are editing text, you also have to hit-test it to find out what the
mouse is selecting, highlight the text to show the selection, break the
text into pieces that fit onto a line, and so on.</FONT></P>

<P><FONT COLOR="#000000">Fortunately, in the Java Development Kit (JDK)
version 1.2, the new </FONT><TT>TextLayout</TT><FONT COLOR="#000000"> class
and its supporting classes can perform these functions for you, even if
the text has multiple styles and contains characters from a mixture of different
writing systems, including Arabic and Hebrew. In this paper we discuss several
problems posed by these writing systems, and then describe how you can use
the new </FONT><TT>TextLayout</TT><FONT COLOR="#000000"> classes to handle
these problems easily and efficiently.</FONT></P>

<P>Even if you write English-only software, you will find that using <TT>TextLayout</TT>
is more convenient than writing your own utility for displaying and measuring
text.&nbsp;Additionally, you get much better typography than you could manage
by yourself without a great deal of effort.!</P>

<H3><HR ALIGN=LEFT><A NAME="International Text"></A>International Text</H3>

<P><FONT COLOR="#000000">Before delving into the additional problems posed
by complicated writing systems, let's briefly review two fundamental issues
you'll encounter even in simple writing systems when using today's graphical
interfaces.<BR>
<BR>
First, unless you are working with a monospace font, different characters
have different widths. Some programmers may not be used to this, and expect
to be able to right-align columns of numbers, for example, simply by padding
with spaces. When characters differ in width, using spaces to position text
is no longer possible. All positioning and measuring of text has to take
into account exactly which characters are used, and not merely how many.<BR>
<BR>
Second, much text nowadays uses multiple fonts and styles. In such text
even the same character can have different shapes and widths, depending
on how it is styled. So programmers must keep track of the style of each
character, and use this information whenever positioning, measuring or rendering
text that contains multiple styles. <BR>
<BR>
Complicated writing systems, such as Hebrew and Arabic, present additional
complications: </FONT><A HREF="#Shaping">shaping</A><FONT COLOR="#000000">
and </FONT><A HREF="#Ordering">ordering</A><FONT COLOR="#000000">. Let's
examine these in more detail.</FONT></P>

<H4><HR ALIGN=LEFT><A NAME="Shaping"></A>Shaping</H4>

<P>The particular shape used to represent a character is called a <I>glyph</I>.
Many different glyphs can be used to represent a single character, depending
on the font and style (italic, bold, and so on). Glyphs can also vary depending
on the glyphs before and after them. This shows up even in English: if you
write some cursive text by hand, for example, the glyphs change in this
way.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="5" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 1. Cursive Forms in Arabic</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><IMG SRC="images/image16.gif" ALIGN="BOTTOM" WIDTH="24" HEIGHT="78" NATURALSIZEFLAG=
"3"></TD>
<TD ALIGN="CENTER" VALIGN="TOP"><IMG SRC="images/image17.gif" WIDTH="23" HEIGHT="78" ALIGN="BOTTOM" NATURALSIZEFLAG=
"3"></TD>
<TD ALIGN="CENTER" VALIGN="TOP"><IMG SRC="images/image18.gif" WIDTH="28" HEIGHT="78" ALIGN="BOTTOM" NATURALSIZEFLAG=
"3"></TD>
<TD VALIGN="TOP" ALIGN="CENTER"><IMG SRC="images/image19.gif" WIDTH="35" HEIGHT="78" ALIGN="BOTTOM" NATURALSIZEFLAG=
"3"></TD></TR>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP">Unconnected</TD>
<TD ALIGN="CENTER" VALIGN="TOP">Connect on right</TD>
<TD ALIGN="CENTER" VALIGN="TOP">&nbsp;Connect on both sides</TD>
<TD VALIGN="TOP" ALIGN="CENTER">Connect on left</TD></TR>
</TABLE>
</CENTER></P>

<P>Some writing systems, particularly Arabic, require this feature. Unlike
in English, cursive forms are <I>mandatory </I>in Arabic&shy;&shy;it is
unacceptable to present the text without using cursive forms. Sometimes
these cursive forms differ radically in shape. For example, the Arabic letter
<I>heh</I> has the four cursive forms shown in Figure 1. Although the shapes
vary widely, such cursive shape-changing is not fundamentally different
from cursive writing in English.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="5" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 2. English Ligatures</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><IMG SRC="images/image12.gif" WIDTH="51" HEIGHT="84" ALIGN="BOTTOM" NATURALSIZEFLAG=
"3"></TD>
<TD ALIGN="CENTER" VALIGN="TOP"><IMG SRC="images/image13.gif" WIDTH="48" HEIGHT="84" ALIGN="BOTTOM" NATURALSIZEFLAG=
"3"></TD></TR>
<TR>
<TD WIDTH="33%" ALIGN="CENTER" VALIGN="TOP">(a)</TD>
<TD WIDTH="33%" ALIGN="CENTER" VALIGN="TOP">(b)</TD></TR>
</TABLE>
</CENTER></P>

<P>Sometimes glyphs change shape even more, and merge together into another
glyph. For example, most English fonts contain special glyphs to account
for the overhang on the letter <I>f</I> colliding with following glyphs.
Look at Figure 2 to see an example of this. When two different glyphs (a)
merge to form such a single glyph (b), that new glyph is called a <I>ligature</I>.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="5" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 3. Arabic Ligatures</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><IMG SRC="images/image9.gif" WIDTH="56" HEIGHT="78" ALIGN="BOTTOM" NATURALSIZEFLAG=
"3"></TD>
<TD ALIGN="CENTER" VALIGN="TOP"><IMG SRC="images/image11.gif" WIDTH="35" HEIGHT="78" ALIGN="BOTTOM" NATURALSIZEFLAG=
"3"></TD></TR>
<TR>
<TD WIDTH="33%" ALIGN="CENTER" VALIGN="TOP">(a)</TD>
<TD WIDTH="34%" ALIGN="CENTER" VALIGN="TOP">(b)</TD></TR>
</TABLE>
</CENTER></P>

<P>Arabic has ligatures as well, although the shapes change more radically
than they do in English. In Figure 3, we see how the two Arabic characters
(a) form a ligature (b). Once again, unlike in English, some of these ligatures
are are <I>mandatory </I>in Arabic&shy;&shy;it is unacceptable to present
the text without using these ligatures.</P>

<P>From this discussion you should remember the cardinal rules for international
GUI text:</P>

<BLOCKQUOTE>
  <UL>
    <LI><I>Glyphs are the visual representations of characters.</I>
    <LI><I>The shapes, sizes, and positions of glyphs are dependent on their
    context.</I>
    <LI><I>Drawing or measuring out of context will give the wrong answer.</I>
  </UL>
</BLOCKQUOTE>

<H4><HR ALIGN=LEFT><A NAME="Ordering"></A>Ordering</H4>

<P>Text which uses the Unicode character encoding (used in Java) is stored
in memory in <I>logical order</I>.&nbsp; Logical order is the order in which
characters and words are read and written.&nbsp; Logical order can differ
from <I>visual order</I>, the order in which corresponding glyphs appear.</P>

<P>Every writing system (or <I>script</I>) has a <I>script order</I>, which
is the visual order for glyphs in that writing system.&nbsp;For example,
the script order for Roman text is left-to-right, while for Arabic and Hebrew
it is right-to-left.&nbsp;In addition to script order, some writing systems
have other rules for arranging glyphs and words on lines of text.&nbsp;Arabic
and Hebrew numbers run left-to-right, even though the letters run right-to-left.&nbsp;
(This means that Arabic and Hebrew, even with no embedded English text,
is truly bidirectional.) For another example, Hindi writing is left-to-right,
but a <I>short i</I> will rearrange so that it is to the left of a logically
preceding consonant.</P>

<P>A writing system's visual order must be maintained, even when languages
are mixed together.&nbsp; Figure 4 shows this with an Arabic phrase in an
English sentence.&nbsp; (To keep things clearer, we will represent Arabic
or Hebrew text by uppercase letters in the figures from here on. In addition,
we will show the internal characters in a set of character boxes, with the
corresponding displayed glyphs below it, and make spaces visible by using
an underbar.)</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 4. Bidirectional (BIDI) Text</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><P ALIGN=LEFT><IMG SRC="images/image22.gif" WIDTH="582" HEIGHT="167" ALIGN=
"BOTTOM" NATURALSIZEFLAG="3"></TD></TR>
</TABLE>
</CENTER></P>

<P>The Arabic words are displayed in right-to-left order, even though they
appear in English text.&nbsp; Note that the italic Arabic is logically after
the plain Arabic, and so is visually to the left of the plain Arabic.</P>

<P>When displaying a line with a mixture of both left-to-right and right-to-left
text, the <I>base direction</I> is significant.&nbsp;If the text is basically
English, for example, with some embedded Arabic, then the base direction
is left to right. If the text is basically Arabic, with some embedded English
or numbers, then the base direction is right to left.</P>

<P>A base direction determines the order in which segments of text with
a common direction are displayed. In Figure 5, the base direction is left
to right, as shown by the blue arrow. There are three directional runs within
this text: first left to right, then right to left, and then left to right
again (the final period). For more information about the precise algorithm
used to order glyphs within a line, see the description of the Bidirectional
Algorithm in <I>The Unicode Standard, Version 2.0, Section 3.11</I>.</P>

<P>It is common to allow graphics to be embedded in the flow of text, such
as in HTML or in word processors. These <I>inline</I> graphics behave like
glyphs in terms of flowing with the text, line-wrapping, and so on. Notice
that such inline graphics also need to be positioned using the bidirectional
algorithm, since otherwise they would also cause bidirectional text to break.</P>

<H2><HR ALIGN=LEFT><TT>TextLayout</TT></H2>

<P>Now that we have discussed just a few of the complications involved in
international text, we will show you how the <TT>TextLayout</TT> class handles
these cases for you. In this section we will illustrate the main operations
involved in dealing with GUI text.&nbsp; For each operation, we will outline
the na&iuml;ve approach to doing the operation with plain English text,
illustrate why this approach fails, and then show how to use <TT>TextLayout</TT>
instead. These operations include:</P>

<UL>
  <LI><A HREF="#Drawing">Drawing</A>
  <LI><A HREF="#Caret Display">Caret Display</A>
  <LI><A HREF="#Hit Testing">Hit Testing</A>
  <LI><A HREF="#Selection Highlighting">Selection Highlighting</A>
  <LI><A HREF="#Caret Movement">Caret Movement</A>
  <LI><A HREF="#Layout Metrics">Layout Metrics</A>
  <LI><A HREF="#Line Break">Line Break</A>
</UL>

<H4><HR ALIGN=LEFT><A NAME="Drawing"></A>Drawing</H4>

<P>The na&iuml;ve approach to drawing styled text into a <TT>Graphics</TT>
is pretty simple:&nbsp; First, set a drawing position for the text.&nbsp;
Then, for each <I>style run</I> (that is, each substring of characters with
the same style), set the appropriate <TT>Font</TT> on the <TT>Graphics</TT>,
draw all of the characters in the style run, then update the drawing position
by the width of the glyphs.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 5. Na&iuml;ve Drawing Failure</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><P ALIGN=LEFT><IMG SRC="images/image23.gif" WIDTH="417" HEIGHT="80" ALIGN=
"BOTTOM" NATURALSIZEFLAG="3"></TD></TR>
</TABLE>
</CENTER></P>

<P>This approach fails badly for bidirectional text. The style run boundaries
will break the directional runs in the embedded Arabic text, and the style
runs will be drawn in the wrong order. Compare the correct ordering in Figures
4 with the incorrect ordering in Figure 5, where the Arabic text is incorrectly
broken into two pieces by the na&iuml;ve algorithm.</P>

<P><TT>TextLayout</TT> displays text with correct shaping and ordering,
even with mixed-style, bidirectional text.&nbsp; <FONT COLOR="#000000">Figure
6 shows how <TT>TextLayout</TT> can be used to draw the text in Figure 4</FONT>.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 6. Drawing Text</H4>
</CAPTION>
<TR>
<TD VALIGN="TOP"><PRE> myGraphics.translate(x, y);
 <TT>TextLayout</TT> layout = new <TT>TextLayout</TT>(styledString); 
 myGraphics.draw(layout, 0, 0);</PRE>
</TD></TR>
</TABLE>
</CENTER></P>

<P>To store information about styles on text, <TT>TextLayout</TT> uses the
new extensible style mechanism in JDK 1.2, which allows much better specification
of text styles than in JDK 1.1. <FONT COLOR="#000000">This paper won't go
into the details of this style mechanism, and instead just use <TT>styledString</TT>
to represent styled text, as in this example.</FONT></P>

<P>The two numeric parameters to <TT>draw()</TT> specify the location in
the graphics where the <I>origin</I> of the <TT>TextLayout</TT> will appear.&nbsp;
The origin is at or near the leftmost point of the baseline.&nbsp; In this
example, the graphics system is translated to the desired origin, and the
<TT>TextLayout</TT> is then drawn at location (0, 0).&nbsp;</P>

<P>Translating the graphics system is especially convenient when drawing
<TT>Shapes</TT> returned from <TT>TextLayout</TT> (see below), since they
are relative to the origin of the <TT>TextLayout</TT> which produced them.&nbsp;
In all further examples, it is assumed that the graphics system has been
translated such that <TT>TextLayouts</TT> may be drawn at (0, 0).</P>

<P><FONT COLOR="#000000">To correctly shape and order the glyphs representing
a line of text, <TT>TextLayout</TT> must know the full context of that text.
If the text fits on a single line, such as a single-word label for a button
or menu, or a line in a dialog box, you can construct a <TT>TextLayout</TT>
directly from the text. But, if you have more text than will fit on a single
line and need to break it into multiple lines, or want to break text on
a single line into tabbed segments, you cannot construct a <TT>TextLayout</TT>
directly. This is because the Unicode bidirectional algorithm sometimes
requires an entire paragraph of context. In these cases, you must use a
<TT>LineBreakMeasurer</TT> so that you can provide sufficient context. We
discuss <TT>LineBreakMeasurer</TT> in more detail below.</FONT></P>

<P>We previously discussed the base direction, and the effect that it has
on the ordering of runs in a line. Normally, the base direction is set using
an attribute on the text. If that attribute is missing, <TT>TextLayout</TT>
follows the Unicode bidirectional algorithm in deriving the base direction
from the initial characters of a paragraph.</P>

<H4><HR ALIGN=LEFT><A NAME="Caret Display"></A>Caret Display</H4>

<P>In editable text, a <I>caret</I> is used to graphically represent the
<I>current insertion offset</I>, the position in the text where new characters
will be inserted. Typically, a caret is shown as a blinking vertical bar
between two glyphs.&nbsp; New characters will be inserted and displayed
at the caret's location.&nbsp; For simple left-to-right text, the caret's
horizontal position could be na&iuml;vely computed by adding the widths
of the glyphs between the beginning of the line and the insertion offset.&nbsp;
The caret is then drawn as a vertical line whose height is the height of
the text line.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 7. Naive Caret Failure</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><P ALIGN=LEFT><IMG SRC="images/image27.gif" WIDTH="582" HEIGHT="143" ALIGN=
"BOTTOM" NATURALSIZEFLAG="3"></TD></TR>
</TABLE>
</CENTER></P>

<P>With bidirectional text, caret display is more complicated than this.
The na&iuml;ve algorithm adds the widths of glyphs before a character offset,
not the widths of glyphs to the left of a glyph offset. That will cause
the failure shown in Figure 7, where the caret is drawn in the wrong place.
Moreover, if we add the widths of glyphs out of their context, then their
metrics will not match the display, since shaping may take place.</P>

<P><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 8. Dual Carets</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><P ALIGN=LEFT><IMG SRC="images/image28.gif" WIDTH="582" HEIGHT="143" ALIGN=
"BOTTOM" NATURALSIZEFLAG="3"></TD></TR>
</TABLE>
</P>

<P>There is another serious problem with caret display in bidirectional
text: insertion offsets on directional boundaries have two possible caret
positions.&nbsp; Look at the current insertion offset in Figure 8, between
the '_' and the 'A'.&nbsp;Since in the display text the two corresponding
glyphs wind up not being adjacent, this character offset corresponds to
two possible visual positions: after the '_', and before the 'A'. (In our
examples, we show the carets with bars to show the glyph they correspond
to.) If an Arabic character were entered, its glyph would appear immediately
before (to the right of) the 'A'; if an English character were entered,
its glyph would appear after (to the right of the '_').</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 9. Displaying Carets</H4>
</CAPTION>
<TR>
<TD VALIGN="TOP"><PRE> Shape[] caretShapes = layout.getCaretShapes(hit);
 myGraphics.setColor(STRONG_CARET_COLOR); 
 myGraphics.draw(caretShapes[0]);
 if (caretShapes[1] != null) { 
  myGraphics.setColor(WEAK_CARET_COLOR); 
  myGraphics.draw(caretShapes[1]); 
 }</PRE>
</TD></TR>
</TABLE>
</CENTER></P>

<P><TT>TextLayout</TT> handles the complexities of caret display, as shown
in Figure 9.&nbsp; Given an insertion offset, the <TT>getCaretShapes()</TT>
method will return a two-element array of <TT>Shape</TT>, referred to here
as <TT>caretShapes</TT>.&nbsp; The value in <TT>caretShapes[0]</TT> represents
the strong (primary) caret, while the value in <TT>caretShapes[1]</TT> represents
a weak (secondary) caret (if it exists). You then simply draw the <TT>Shapes</TT>
returned from <TT>getCaretShapes()</TT>. In this example the strong caret's
color is different from the weak caret's color.&nbsp; This is a common way
to differentiate the two carets.</P>

<H4><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 10. Angled Carets</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><P ALIGN=LEFT><IMG SRC="images/image29.gif" WIDTH="250" HEIGHT="77" ALIGN=
"BOTTOM" NATURALSIZEFLAG="3"></TD></TR>
</TABLE>
</CENTER></H4>

<P><TT>TextLayout</TT> will produce angled carets for italic and oblique
glyphs. These caret positions are also used as the boundaries between glyphs
for highlighting and hit-testing, to produce a consistent user experience.
Figure 10 some samples of this.</P>

<P>If you would prefer to use your own shapes for carets, you can also retrieve
the position and angle of the carets from the <TT>TextLayout</TT>, and draw
them yourself. You also don't have to use dual carets: <TT>TextLayout</TT>
lets you choose a different policy to use for displaying carets if you want.</P>

<H4><HR ALIGN=LEFT><A NAME="Hit Testing"></A>Hit Testing</H4>

<P>Often, a location in a graphics device is to be converted to a offset
in text. For example, when a user clicks the mouse on selectable text, the
location of the mouse must be converted to an offset in the text for use
as one end of the selection range.&nbsp; Logically this is the inverse of
the caret positioning operation. Hit testing in simple left-to-right text
is essentially a process of measuring glyph widths until the glyph at the
correct location is found. This position is then mapped back to a character
offset.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 11. Hit Testing</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><P ALIGN=LEFT><IMG SRC="images/image30.gif" WIDTH="582" HEIGHT="142" ALIGN=
"BOTTOM" NATURALSIZEFLAG="3"></TD></TR>
</TABLE>
</CENTER></P>

<P>The problems with this approach in bidirectional text are similar to
those for caret display. As Figure 11 shows, a single visual location in
the display can correspond to two very different offsets in the source text.
Fortunately, the <I>side</I> of the offset can help to distinguish the two
alternatives.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 12. Hit-testing</H4>
</CAPTION>
<TR>
<TD VALIGN="TOP"><PRE>TextHitInfo hit = layout.hitTestChar(x, y);
int insertionOffset = hit.getInsertionOffset();</PRE>
</TD></TR>
</TABLE>
</CENTER></P>

<P><TT>TextLayout</TT> takes care of hit testing for you.&nbsp; <TT>TextLayout</TT>'s
method <TT>hitTestChar()</TT> takes <I>x</I> and <I>y</I> coordinates from
the mouse as arguments, and returns an instance of a <TT>TextHitInfo</TT>
class, which indicates the insertion offset for the specified position,
and which side the hit was on.&nbsp; (The insertion offset is the nearest
one in the text: if it is off one end of the line then the offsets at that
end is returned.) Figure 12 shows an example of this in use.</P>

<P>Hit testing and caret positioning are consistent with each other. Maintaining
this invariant in italic text, in which the carets are angled, requires
both the <I>x</I> and <I>y</I> coordinates of the point.&nbsp; Thus, <TT>hitTestChar()</TT>
takes both coordinates as parameters, not just the <I>x</I> coordinate.&nbsp;
This also allows this method to handle future extensions that require both
coordinates, such as vertical text for Japanese, Chinese and Korean.</P>

<H4><HR ALIGN=LEFT><A NAME="Selection Highlighting"></A>Selection Highlighting</H4>

<P>A selected range of characters is represented graphically using a <I>highlight
region</I>, an area in which glyphs are displayed with inverse video, or
against a background color which is different from other glyphs'.&nbsp;
Highlight regions, like carets, are more complicated for bidirectional text
than for simple left-to-right text. A contiguous range of characters may
not have a contiguous highlight region on screen, if the selection range
includes both left-to-right and right-to-left characters. See Figure 13.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 13. Contiguous Characters--Logical Highlighting</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><P ALIGN=LEFT><IMG SRC="images/lhigh.gif" WIDTH="582" HEIGHT="162" ALIGN=
"BOTTOM" NATURALSIZEFLAG="3"></TD></TR>
</TABLE>
</CENTER></P>

<P>Conversely, a highlight region showing a visually contiguous range of
glyphs may not correspond to a single contiguous range of characters. See
Figure 14.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 14. Contiguous Glyphs--Visual Highlighting</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><P ALIGN=LEFT><IMG SRC="images/vhigh.gif" WIDTH="582" HEIGHT="162" ALIGN=
"BOTTOM" NATURALSIZEFLAG="3"></TD></TR>
</TABLE>
</CENTER></P>

<P>This results in two strategies for selection highlighting:&nbsp;<I>logical
highlighting</I> and <I>visual highlighting</I>. With logical highlighting,
the selected characters are always contiguous in the text model, and the
highlight region is allowed to be discontiguous. With visual highlighting,
there may be more than one range of selected characters, but the highlight
region is always contiguous. Logical highlighting is simpler for the programmer
to use, since the selected characters are always contiguous in the text.
<TT>TextLayout</TT> supports both logical and visual highlighting.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 15. Highlighting</H4>
</CAPTION>
<TR>
<TD VALIGN="TOP"><PRE>Shape highlightRegion = layout.getLogicalHighlightShape(hit1, hit2); 
graphics.setColor(HIGHLIGHT_COLOR); 
graphics.fill(highlightRegion); 
graphics.draw(layout, 0, 0);</PRE>
</TD></TR>
</TABLE>
</CENTER></P>

<P>You can use <TT>TextLayout</TT> to create highlight regions. The method
<TT>getLogicalHighlightShape()</TT> takes two insertion offsets as parameters
and returns a <TT>Shape</TT> representing the highlight region for the selection
range corresponding to the two offsets.&nbsp; A simple way to show highlighting
is to fill this <TT>Shape</TT> with the highlight color, then draw the <TT>TextLayout</TT>
over the <TT>Shape.</TT>This is illustrated in Figure 15.</P>

<H4><HR ALIGN=LEFT><A NAME="Caret Movement"></A>Caret Movement</H4>

<P>All text editors allow arrow keys to move the caret.&nbsp; Users expect
the caret to move visually in the direction of the arrow key.&nbsp; In left-to-right
text, moving the insertion offset is simple:&nbsp;the right arrow key increases
the insertion offset by one, and the left arrow key decreases it by one.&nbsp;
In bidirectional text, or in text with ligatures, this would cause the caret
to jump across glyphs at direction boundaries and move in the reverse direction
within different directional runs.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 16. Contiguous Glyphs--Visual Highlighting</H4>
</CAPTION>
<TR>
<TD ALIGN="CENTER" VALIGN="TOP"><P ALIGN=LEFT><IMG SRC="images/image33.gif" WIDTH="582" HEIGHT="162" ALIGN=
"BOTTOM" NATURALSIZEFLAG="3"></TD></TR>
</TABLE>
</CENTER></P>

<P>Smooth arrow movement requires the character offset to not move uniformly.
For example, if the current insertion offset is within a run of right-to-left
characters, the right arrow key will decrease the insertion offset, and
the left arrow key will increase it. Directional boundaries are even more
complicated, and cause the character offset to jump around quite a bit.
Figure 16 illustrates using the arrow key to move the caret across a boundary.
Progressing through the three screen positions from left to right correspond
to progressing through the character offsets 7, then 19, then 18!</P>

<P>Additionally, certain glyphs should never have a caret between them;&nbsp;
instead, the caret should move around as if these glyphs were representing
a single character.&nbsp; For example, there should never be a caret between
an <I>o</I> and an umlaut wherever they are represented by two separate
characters.&nbsp; See <I>The Unicode Standard, Version 2.0, Chapter 5</I>,
for more information.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 17. Moving the Caret</H4>
</CAPTION>
<TR>
<TD VALIGN="TOP"><PRE><TT> TextHitInfo newInsertionOffset = layout.getNextRightHit(insertionOffset);</TT> 
<TT> if (newInsertionOffset != null) {</TT> 
  Shape[] caretShapes = layout.getCaretShapes(<TT>newInsertionOffset</TT>);
<TT>&nbsp;&nbsp;// draw</TT> carets...
  <TT>insertionOffset = newInsertionOffset;</TT>
 }</PRE>
</TD></TR>
</TABLE>
</CENTER></P>

<P><TT>TextLayout</TT> will compute the insertion offset resulting from
a left or right arrow key.&nbsp; Given a <TT>TextHitInfo</TT> representing
the current insertion offset, the method <TT>getNextRightHit()</TT> will
return a <TT>TextHitInfo</TT> representing the correct insertion offset
resulting from a right arrow key.&nbsp; The strong caret is used to compute
the next caret position; the definition of this depends on the caret policy
(see above). For the left arrow key, <TT>getNextLeftHit()</TT> works analogously.</P>

<P>Figure 17 demonstrates how a client might respond to a right arrow key
by moving the current insertion offset, represented by <TT>insertionOffset</TT>.&nbsp;
If there isn't a caret to the right of the current caret, <TT>getNextRightHit()</TT>
returns <TT>null</TT>.</P>

<H4><HR ALIGN=LEFT><A NAME="Layout Metrics"></A>Layout Metrics</H4>

<P><TT>TextLayout</TT> provides graphical metrics for the entire range of
text it represents. Metrics available from <TT>TextLayout</TT> include ascent,
descent, leading, advance, visible advance, and the bounding rectangle.</P>

<P>Ascent, descent, and leading are properties of fonts. A font's <I>ascent</I>
is the distance from the tops of the tallest glyphs to the baseline. A font's
<I>descent</I> is the distance from the baseline to the bottom of the descenders
on the font's glyphs. The <I>leading</I> is the recommended vertical distance
from the bottom of the descenders to the top of the next line in a multi-line
setting.</P>

<P>A <TT>TextLayout</TT> may have more than one font associated with different
style runs. The ascent, descent for a <TT>TextLayout</TT> are the maximum
values for these metrics in the fonts used in the <TT>TextLayout</TT>.&nbsp;
(The computation of the TextLayout's leading is slightly more complicated&shy;&shy;not
just the maximum of its fonts' leadings.)</P>

<P>The <I>advance</I> of a <TT>TextLayout</TT> is its length (the distance
from the left edge of the leftmost glyph to the right edge of the rightmost
glyph). For clarity, the advance is sometimes called the <I>total advance</I>.&nbsp;
The <I>visible advance</I> is the length of the <TT>TextLayout</TT> without
its trailing whitespace.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 18. Drawing a Bounding Box</H4>
</CAPTION>
<TR>
<TD VALIGN="TOP"><PRE>graphics.draw(layout, 0, 0); 
Rectangle2D bounds = layout.getBounds(); 
graphics.drawRect(bounds.getX()-1, bounds.getY()-1, 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bounds.getWidth()+2, bounds.getHeight()+2);</PRE>
</TD></TR>
</TABLE>
</CENTER></P>

<P>The <I>bounding box</I> encloses the text in the <TT>TextLayout</TT>.
It includes all the visible glyphs and the caret boundaries (some of these
may hang over the origin or origin + advance). To retrieve the bounding
box for a <TT>TextLayout</TT>, call <TT>getBounds()</TT>. The bounding box
is relative to the origin of the <TT>TextLayout</TT>, not to any particular
screen position. The code in Figure 18 draws a <TT>TextLayout</TT> inside
of its bounding box.</P>

<H4><HR ALIGN=LEFT><A NAME="Line Break"></A>Line Break</H4>

<P>The examples above show common uses for <TT>TextLayout</TT> in a single-line
context.&nbsp; <TT>TextLayout</TT> can also be used to display a piece of
text across multiple lines.&nbsp; For example,&nbsp; you might take a paragraph
of text, line-wrap the text to a certain width, and display the paragraph
as multiple lines of text.&nbsp; When you do this, you do not create the
<TT>TextLayouts</TT> representing lines of text directly.&nbsp; Instead,
<TT>LineBreakMeasurer</TT>, a companion class, generates them for you.</P>

<P>When text is displayed in multiple lines, the length of the lines is
usually determined by the width of the display area. <I>Line breaking</I>
(or <I>line wrapping</I>) is the process of determining where lines begin
and end, given a graphical width in which lines must fit. The most common
strategy for line break is to place as many words on each line as will fit.
This strategy is implemented in <TT>LineBreakMeasurer</TT>. Other more complex
line break strategies use hyphenation, or attempt to minimize the differences
in line length within paragraphs. These alternative strategies can be implemented
by using low-level calls.</P>

<P>You may be wondering why <TT>LineBreakMeasurer</TT> is required;&nbsp;
that is, why you can't measure the text and create <TT>TextLayouts</TT>
for it yourself.&nbsp; Recall that in some cases, bidirectional ordering
cannot be performed correctly unless all of the text in a paragraph is available.&nbsp;
<TT>LineBreakMeasurer</TT> encapsulates enough information about the context
to produce correct <TT>TextLayouts</TT>.</P>

<P>To break a paragraph of text into lines, construct a <TT>LineBreakMeasurer</TT>
with the entire paragraph.&nbsp; You can then use <TT>LineBreakMeasurer</TT>
to walk through the text, generating <TT>TextLayouts</TT> for each line.
Specifically, the method <TT>nextLayout()</TT> returns a <TT>TextLayout</TT>
whose visible advance does not exceed the given width. LineBreakMeasurer
maintains an offset within the text. Initially, the offset is at the start
of the text; each call to <TT>nextLayout()</TT> moves the offset by the
character count of the <TT>TextLayout</TT> that was returned. Once this
offset reaches the end of the text, a call to <TT>nextLayout()</TT> returns
<TT>null</TT>.</P>

<P><CENTER><TABLE BORDER="0" CELLSPACING="0" CELLPADDING="0">
<CAPTION ALIGN="BOTTOM"><H4>Figure 19. Line Breaking</H4>
</CAPTION>
<TR>
<TD VALIGN="TOP"><PRE><TT>Point2D pen = initialPosition;</TT> 
<TT>LineBreakMeasurer measurer =</TT> 
  <TT>new LineBreakMeasurer(styledText, myBreakIterator);</TT>
<TT>while (true) {</TT>
<TT>  TextLayout</TT> <TT>layout = measurer.nextLayout(wrappingWidth);</TT>
<TT>  if (layout == null) break;</TT>
<TT>&nbsp;&nbsp;pen.y += layout.getAscent();</TT> 
<TT>&nbsp;&nbsp;float dx = 0;</TT>
<TT>  if (layout.isLeftToRight())</TT>
<TT>   dx = wrappingWidth - layout.getAdvance();</TT> 
<TT>&nbsp;&nbsp;layout.draw(graphics, pen.x + dx, pen.y);</TT> 
<TT>&nbsp;&nbsp;pen.y += layout.getDescent() + layout.getLeading();</TT>
<TT>}</TT></PRE>
</TD></TR>
</TABLE>
</CENTER></P>

<P>Figure 19 shows how to break a text segment into lines and draw the lines
into a <TT>Graphics</TT>. This code aligns the lines either to a left margin
or a right margin, depending on whether the base text direction is left-to-right
or right-to-left.</P>

<P>Every call to <TT>nextLayout()</TT>requires a width in which the <TT>TextLayout</TT>
will fit.&nbsp; By varying this width, you can break text to fit into complicated
areas, such as an HTML page with images in fixed positions, or into tab-stop
fields. You can optionally pass in a <TT>BreakIterator</TT> to tell <TT>LineBreakMeasurer</TT>
where valid breakpoints are; if you don't supply one then the break iterator
for the default locale is used.</P>

<H2><HR ALIGN=LEFT>Conclusion</H2>

<P><TT>TextLayout</TT>, a class in the JDK 1.2, provides for correct display
of text in English, Arabic, Hebrew, and other languages.&nbsp; Furthermore,
<TT>TextLayout</TT> facilitates user interaction with text by providing
caret display, hit-testing, selection, and line breaking capabilities.&nbsp;
With <TT>TextLayout</TT>, you will find that working with international
text is as easy as working with English text.&nbsp; You will also find that
<TT>TextLayout</TT> is useful for English-only software, since it composes
multiple text styles on a line and provides convenient measurement and line
breaking.</P>

<P>There are many ways to use <TT>TextLayout</TT> that we haven't discussed
here.&nbsp;It supports full and partial justification, a variety of text
attributes, text with multiple baselines, and custom carets.&nbsp; There
also are low-level services that give you complete control over the glyph
mapping and glyph positioning, if you are doing more sophisticated programs
such as desktop publishing. Some of these topics will be covered in future
publications.</P>

<P>A common question people ask is about <TT>TextLayout</TT> performance.
What do you pay to get all of these features? The architecture of <TT>TextLayout</TT>
is designed to 'fastpath' the standard cases of simple, monodirectional
text&shy;&shy;there should be no significant performance impact for using
<TT>TextLayout</TT> for such cases. When the text does include Arabic or
Hebrew text, then there is some performance impact in using <TT>TextLayout</TT>,
commensurate with the additional requirements it has to satisfy. However,
this is typically on the order of microseconds per character on today's
machines, which is dominated by normal drawing code.</P>

<P>This article describes the current state of <TT>TextLayout</TT> and its
related classes.&nbsp; Since version 1.2 of the JDK has not yet shipped,
there may be small differences between classes described here and those
included in the final version of the JDK.&nbsp; The initial version of <TT>TextLayout</TT>
supports simple writing systems such as Latin, Greek, Cyrillic, Japanese,
Korean, and Chinese, and bidirectional writing systems such as Arabic and
Hebrew.&nbsp; Future versions of <TT>TextLayout</TT> will add full support
for Indic and Thai writing systems, and vertical display of Japanese and
Chinese.</P>

<P>If you would like to know more about internationalization in Java, see
JavaSoft's <A HREF="http://www.javasoft.com/products/jdk/1.1/docs/guide/intl/index.html">internationalization
page</A>.&nbsp; Information about Unicode character encoding can be found
at the <A HREF="http://www.unicode.org/">Unicode Consortium</A> site.</P>

<H3><HR ALIGN=LEFT>Acknowledgements</H3>

<P>John Fitzpatrick, who has recently moved from Taligent to the bottom
of the earth, played a crucial role in the design and implementation of
Text Layout. Kathleen Wilson is the manager for both the text and international
groups, and is responsible for the successful organization of the project.
The text and international groups are moving into the IBM Centre for Java
Technology (Silicon Valley). We would like to thank Gina Poole, Maire Weick,
Pat Sueltz, Sue Williams, and Elizabeth Nichols at IBM for their continued
support of our contributions into the JDK.</P>

<P>The text layout classes in JDK 1.2 form just one part of the Java 2D
support, which adds a wide variety of graphic capabilities to Java. Without
the help of people at JavaSoft, including Jerry Evans, Brian Beck, Tim Prinzing,
and Jeet Kaul, this work would not have been possible.</P>

<P>We would also like to thank &lt;TBD&gt; for their feedback on drafts
of this document.</P>

<P><HR ALIGN=LEFT SIZE="0"></P>

<H3>Biographies</H3>

<P><FONT SIZE=-1>Dr. Mark Davis is the director of the Core Technologies
department at Taligent, Inc, a wholly owned subsidiary of IBM. Mark co-founded
the Unicode effort, and is the president of the Unicode Consortium. He is
a principal co-author and editor of the Unicode Standard, Version 1.0 and
the new Version 2.0. Mark has considerable expertise in both management
and software development. At various times, his department has included
software groups covering text, international, operating system services,
Windows porting, and technical communications. Technically, he specializes
in object-oriented programming and in the architecture and implementation
of international and text software: ranging from the years he spent programming
in Switzerland, to co-authoring the Macintosh KanjiTalk and the Macintosh
Script Manager (which later became WorldScript), to authoring the Arabic
and Hebrew Macintosh systems, and more recently to architecting the bulk
of the Java 1.1 international libraries.</FONT></P>

<P><FONT SIZE=-1>Doug Felt has worked as a programmer for over 14 years.
After graduating from Stanford University in 1982, he worked for two unsuccessful
startups and in his own business before becoming a programmer at Stanford,
where he spent seven years developing innovative educational software with
Stanford faculty. He joined Taligent shortly after its founding, and has
been part of the Text and International team working in C++ and Java for
the past two years.</FONT></P>

<P><FONT SIZE=-1>John Raley, a resident of San Francisco, CA, has written
text editing software on a variety of platforms, including Macintosh, Windows,
Unix, and Java. As part of the Text and International team at Taligent,
he contributed to the development of Line Layout services for Java. Additionally,
he worked on a styled text editor for Java 1.0, and wrote an editor for
IBM's OpenClass framework. John received his Master's degree in Computer
Science from Virginia Tech in 1996.</FONT></P>

<P><HR ALIGN=LEFT></P>

<P>Copyright 1997, Taligent, Inc. All rights reserved. Java is a trademark
of Sun Microsystems, Inc. Unicode is a trademark of Unicode, Inc.
</BODY>
</HTML>
