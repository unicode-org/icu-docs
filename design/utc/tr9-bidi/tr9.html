<!doctype HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Content-Language" content="en-us">
<link rel="stylesheet" href="http://www.unicode.org/reports/reports.css" type="text/css">
<meta name="GENERATOR" content="Microsoft FrontPage 6.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>UAX #9: The Bidirectional Algorithm</title>
<style type="text/css">
<!--
div.Section1
	{page:Section1;}
-->
</style>
</head>

<body>

<table class="header" cellspacing="0" cellpadding="0" width="100%">
  <tr>
    <td class="icon"><a href="http://www.unicode.org">
    <img align="middle" alt="[Unicode]" border="0" src="http://www.unicode.org/webscripts/logo60s2.gif" width="34" height="33"></a>&nbsp;&nbsp;<a class="bar" href="http://www.unicode.org/reports/">Technical 
    Reports</a></td>
  </tr>
  <tr>
    <td class="gray">&nbsp;</td>
  </tr>
</table>
<div class="body">
  <h2 align="center">Unicode Standard Annex #9</h2>
  <h1>The Bidirectional Algorithm</h1>
  <table border="1" cellpadding="2" width="90%">
    <tr>
      <td valign="top" width="20%">Version</td>
      <td valign="top">Unicode 4.1.0</td>
    </tr>
    <tr>
      <td valign="top">Authors</td>
      <td valign="top">Mark Davis (<a href="mailto:mark.davis@us.ibm.com">mark.davis@us.ibm.com</a>)</td>
    </tr>
    <tr>
      <td valign="top">Date</td>
      <td valign="top">2005-03-25</td>
    </tr>
    <tr>
      <td valign="top">This Version</td>
      <td valign="top"><a href="http://www.unicode.org/reports/tr9/tr9-15.html">http://www.unicode.org/reports/tr9/tr9-15.html</a></td>
    </tr>
    <tr>
      <td valign="top">Previous Version</td>
      <td valign="top"><a href="http://www.unicode.org/reports/tr9/tr9-14.html">http://www.unicode.org/reports/tr9/tr9-14.html</a></td>
    </tr>
    <tr>
      <td valign="top">Latest Version</td>
      <td valign="top"><a href="http://www.unicode.org/reports/tr9/">
      http://www.unicode.org/reports/tr9/</a></td>
    </tr>
    <tr>
      <td valign="top"><span>Revision</span></td>
      <td valign="top"><span><a href="#Modifications">15</a></span></td>
    </tr>
  </table>
  <p><br>
  </p>
  <h3><i>Summary</i></h3>
  <p><i>This document describes specifications for the positioning of characters flowing from right 
  to left, such as Arabic or Hebrew.</i></p>
  <h3><i>Status</i></h3>
  <p><i>This document has been reviewed by Unicode members and other interested parties, 
  and has been approved for publication by the Unicode Consortium. This is a stable document and may 
  be used as reference material or cited as a normative reference by other specifications.</i></p>
  <blockquote>
    <p><i><b>A Unicode Standard Annex (UAX)</b> forms an integral part of the Unicode Standard, but 
    is published as a separate document. The Unicode Standard may require conformance to normative 
    content in a Unicode Standard Annex, if so specified in the Conformance chapter of that version 
    of the Unicode Standard. The version number of a UAX document corresponds to the version number 
    of the Unicode Standard at the last point that the UAX document was updated.</i></p>
  </blockquote>
  <p><i>Please submit corrigenda and other comments with the online reporting form [<a href="#Feedback">Feedback</a>]. 
  Related information that is useful in understanding this document is found in
  <a href="#References">References</a>. For the latest version of the Unicode Standard see [<a href="#Unicode">Unicode</a>]. 
  For a list of current Unicode Technical Reports see [<a href="#Reports">Reports</a>]. For more 
  information about versions of the Unicode Standard, see [<a href="#Versions">Versions</a>].</i></p>
  <h3><i>Contents</i></h3>
 
		<ul class="toc">
			<li>1&nbsp; <a href="#3.1_Bidirectional_Behavior">Introduction</a></li>
			<li>2&nbsp; <a href="#Directional_Formatting_Codes">Directional Formatting Codes</a>
			<ul class="toc">
			<li>2.1&nbsp; <a href="#Explicit_Directional_Embedding">Explicit 
			Directional Embedding</a> 
			</li>
			<li>2.2&nbsp; <a href="#Explicit_Directional_Overrides">Explicit 
			Directional Overrides</a> 
			</li>
			<li>2.3&nbsp; <a href="#Terminating_Explicit_Directional_Code">
			Terminating Explicit Directional Code</a> 
			</li>
			<li>2.4&nbsp; <a href="#Implicit_Directional_Marks">Implicit Directional 
			Marks</a> 
			</li></ul></li>
			<li>3&nbsp; <a href="#Basic_Display_Algorithm">Basic Display Algorithm</a>
			<ul class="toc">
			<li>3.1&nbsp; <a href="#Definitions">Definitions</a>: <a href="#BD1">BD1</a>,
			<a href="#BD2">BD2</a>, <a href="#BD3">BD3</a>, <a href="#BD4">BD4</a>
			 <a href="#BD5">BD5</a>, <a href="#BD6">BD6</a>, <a href="#BD7">BD7</a>
			</li>
			<li>3.2&nbsp; <a href="#Bidirectional_Character_Types">Bidirectional 
			Character Types</a> 
			</li>
			<li>3.3&nbsp; <a href="#Resolving_Embedding_Levels">Resolving Embedding 
			Levels</a> 
			<ul class="toc">
				<li>3.3.1&nbsp; <a href="#The_Paragraph_Level">The Paragraph Level</a>:
				 <a href="#P1">P1</a>, <a href="#P2">P2</a>, <a href="#P3">P3</a>
				</li>
				<li>3.3.2&nbsp; <a href="#Explicit_Levels_and_Directions">Explicit 
				Levels and Directions</a>: <a href="#X1">X1</a>, <a href="#X2">
				X2</a>, <a href="#X3">X3</a>, <a href="#X4">X4</a>,
				<a href="#X5">X5</a>, <a href="#X6">X6</a>, <a href="#X7">X7</a>,
				 <a href="#X8">X8</a>, <a href="#X9">X9</a>, <a href="#X10">X10</a>
				</li>
				<li>3.3.3&nbsp; <a href="#Resolving_Weak_Types">Resolving Weak Types</a>:
				<a href="#W1">W1</a>, <a href="#W2">W2</a>, <a href="#W3">W3</a>,
				<a href="#W4">W4</a>, <a href="#W5">W5</a>, <a href="#W6">W6</a>,
				 <a href="#W7">W7</a>
				</li>
				<li>3.3.4&nbsp; <a href="#Resolving_Neutral_Types">Resolving Neutral 
				Types</a>:  <a href="#N1">N1</a>, <a href="#N2">N2</a>
				</li>
				<li>3.3.5&nbsp; <a href="#Resolving_Implicit_Levels">Resolving 
				Implicit Levels</a>:  <a href="#I1">I1</a>, <a href="#I2">I2</a>
				</li>
			</ul>
			</li>
			<li>3.4&nbsp; <a href="#Reordering_Resolved_Levels">Reordering Resolved 
			Levels</a>: <a href="#L1">L1</a>, <a href="#L2">L2</a>,
			 <a href="#L3">L3</a>, <a href="#L4">L4</a>
			</li>
			<li> 3.5 <a href="#Shaping">Shaping</a>
			</li>
			</ul>			</li>
			<li>4&nbsp; <a href="#Bidirectional_Conformance">Bidirectional 
			Conformance</a> 
			<ul class="toc"><li> 4.1&nbsp; <a href="#Boundary_Neutrals">Boundary Neutrals</a>
			</li>
			<li>4.2&nbsp; <a href="#Explicit_Formatting_Codes">Explicit 
			Formatting_Codes</a> 
			</li>
			<li>4.3&nbsp; <a href="#Higher-Level_Protocols">Higher-Level Protocols</a>:
			<a href="#HL1">HL1</a>, <a href="#HL1">HL2</a>, <a href="#HL3">HL3</a>,
			 <a href="#HL4">HL4</a>, <a href="#HL5">HL5</a>, <a href="#HL6">HL6</a>
			</li>
			</ul>			
			</li>
			<li> 5&nbsp; <a href="#Implementation_Notes">Implementation Notes</a>
			<ul class="toc">
			<li> 5.1&nbsp; <a href="#Reference_Code">Reference Code</a>
			</li>
			<li> 5.2&nbsp; <a href="#Retaining_Format_Codes">Retaining Format Codes</a>
			</li>
			<li> 5.3&nbsp; <a href="#Joiners">Joiners</a>
			</li>
			<li> 5.4&nbsp; <a href="#Vertical_Text">Vertical Text</a>
			</li>
			<li> 5.5&nbsp; <a href="#Usage">Usage</a>
			</li>
			</ul>			</li>
			<li> 6&nbsp; <a href="#Mirroring">Mirroring</a></li>
			<li> <a href="#Acknowledgements">Acknowledgements</a></li>
			<li> <a href="#References">References</a></li>
			<li> <a href="#Modifications">Modifications</a></li>
		</ul>
 
  <hr>
  <h2 align="left"><a name="3.1_Bidirectional_Behavior"></a>1 Introduction</h2>
  <p>The Unicode Standard prescribes a <em>memory</em> representation order known as logical order. 
  When text is presented in horizontal lines, most scripts display characters from left to right. 
  However, there are several scripts (such as Arabic or Hebrew) where the natural ordering of 
  horizontal text in display is from right to left. If all of the text has the same horizontal 
  direction, then the ordering of the display text is unambiguous. However, when bidirectional text 
  (a mixture of left-to-right and right-to-left horizontal text) is present, some ambiguities can 
  arise in determining the ordering of the displayed characters.</p>
  <p>This document describes the algorithm used to determine the directionality for bidirectional 
  Unicode text. The algorithm extends the implicit model currently employed by a number of existing 
  implementations and adds explicit format codes for special circumstances. In most cases, there is 
  no need to include additional information with the text to obtain correct display ordering.</p>
  <p>However, in the case of bidirectional text, there are circumstances where an implicit 
  bidirectional ordering is not sufficient to produce comprehensible text. To deal with these cases, 
  a minimal set of directional formatting codes is defined to control the ordering of characters 
  when rendered. This allows exact control of the display ordering for legible interchange and also 
  ensures that plain text used for simple items like filenames or labels can always be correctly 
  ordered for display.</p>
  <p>The directional formatting codes are used <i>only</i> to influence the display ordering of 
  text. In all other respects they should be ignored--they have no effect on the comparison of text, 
  nor on word breaks, parsing, or numeric analysis.</p>
  <p>When working with bidirectional text, the characters are still interpreted in logical 
  order--only the display is affected. The display ordering of bidirectional text depends upon the 
  directional properties of the characters in the text.</p>
  <blockquote>
    <p><i>Note: The changes in </i><a href="#Bidirectional_Conformance">4. Bidirectional Conformance</a><i> 
    override clause C13 of Unicode 4.0 [<a href="#Unicode">Unicode</a>], and tighten the conformance 
    requirements.</i></p>
  </blockquote>
  <h2><a name="Directional_Formatting_Codes"></a>2 Directional Formatting Codes</h2>
  <p>Two types of explicit codes are used to modify the standard implicit Unicode bidirectional 
  algorithm. In addition, there are implicit ordering codes, the <i>right-to-left</i> and <i>
  left-to-right</i> marks. All of these codes are limited to the current paragraph; thus their 
  effects are terminated by a <i>paragraph separator</i>. The directional types left-to-right and 
  right-to-left are called <i>strong types</i>, and characters of those types are called strong 
  directional characters. The directional types associated with numbers are called <i>weak types</i>, 
  and characters of those types are called weak directional characters.</p>
  <p>Although the term <em>embedding</em> is used for some explicit codes, the text within the scope 
  of the codes is not independent of the surrounding text. Characters within an embedding can affect 
  the ordering of characters outside, and vice versa. The algorithm is designed so that the use of 
  explicit codes can be equivalently represented by out-of-line information, such as stylesheet 
  information. However, any alternative representation will be defined by reference to the behavior 
  of the explicit codes in this algorithm.</p>
  <h3>2.1 <a name="Explicit_Directional_Embedding">Explicit Directional Embedding</a></h3>
  <p>The following codes signal that a piece of text is to be treated as embedded. For example, an 
  English quotation in the middle of an Arabic sentence could be marked as being embedded 
  left-to-right text. If there were a Hebrew phrase in the middle of the English quotation, then 
  that phrase could be marked as being embedded right-to-left. These codes allow for nested 
  embeddings.</p>
  <table border="0" cellspacing="2" cellpadding="2">
    <tr>
      <th valign="TOP">RLE</th>
      <td valign="TOP">Right-to-Left Embedding&nbsp;&nbsp;</td>
      <td valign="TOP">Treat the following text as embedded right-to-left.</td>
    </tr>
    <tr>
      <th valign="TOP">LRE</th>
      <td valign="TOP">Left-to-Right Embedding&nbsp;&nbsp;</td>
      <td valign="TOP">Treat the following text as embedded left-to-right.</td>
    </tr>
  </table>
  <p>The precise meaning of these codes will be made clear in the discussion of the algorithm. The 
  effect of right-left line direction, for example, can be accomplished by simply embedding the text 
  with RLE...PDF.</p>
  <h3>2.2 <a name="Explicit_Directional_Overrides">Explicit Directional Overrides</a></h3>
  <p>The following codes allow the bidirectional character types to be overridden when required for 
  special cases, such as for part numbers. These codes allow for nested directional overrides.</p>
  <table border="0" cellspacing="2" cellpadding="2">
    <tr>
      <th valign="TOP">RLO</th>
      <td valign="TOP">Right-to-Left Override&nbsp;&nbsp;</td>
      <td valign="TOP">Force following characters to be treated as strong right-to-left characters.</td>
    </tr>
    <tr>
      <th valign="TOP">LRO</th>
      <td valign="TOP">Left-to-Right Override&nbsp;&nbsp;</td>
      <td valign="TOP">Force following characters to be treated as strong left-to-right characters.</td>
    </tr>
  </table>
  <p>The precise meaning of these codes will be made clear in the discussion of the algorithm. The 
  right-to-left override, for example, can be used to force a part number made of mixed English, 
  digits and Hebrew letters to be written from right to left.</p>
  <h3>2.3 <a name="Terminating_Explicit_Directional_Code">Terminating Explicit Directional Code</a></h3>
  <p>The following code terminates the effects of the last explicit code (either embedding or 
  override) and restores the bidirectional state to what it was before that code was encountered.</p>
  <table border="0" cellspacing="2" cellpadding="2">
    <tr>
      <th valign="TOP" align="LEFT">
      <p align="LEFT">PDF</th>
      <td valign="TOP">Pop Directional Format&nbsp;&nbsp;</td>
      <td valign="TOP">Restore the bidirectional state to what it was before the last LRE, RLE, RLO, 
      LRO.</td>
    </tr>
  </table>
  <h3>2.4 <a name="Implicit_Directional_Marks">Implicit Directional Marks</a></h3>
  <p>These characters are very light-weight codes. They act exactly like right-to-left or 
  left-to-right characters, except that they do not display or have any other semantic effect. Their 
  use is generally more convenient than the explicit embeddings or overrides since their scope is 
  much more local.</p>
  <table border="0" cellspacing="2" cellpadding="2">
    <tr>
      <th valign="TOP" align="LEFT">
      <p align="LEFT">RLM</th>
      <td valign="TOP">Right-to-Left Mark&nbsp;&nbsp;</td>
      <td valign="TOP">Right-to-left zero-width character</td>
    </tr>
    <tr>
      <th valign="TOP" align="LEFT">
      <p align="LEFT">LRM</th>
      <td valign="TOP">Left-to-Right Mark&nbsp;&nbsp;</td>
      <td valign="TOP">Left-to-right zero-width character</td>
    </tr>
  </table>
  <p>There is no special mention of the implicit directional marks in the following algorithm. That 
  is because their effect on bidirectional ordering is exactly the same as a corresponding strong 
  directional character; the only difference is that they do not appear in the display.</p>
  <h2>3 <a name="Basic_Display_Algorithm">Basic Display Algorithm</a></h2>
  <p>The Bidirectional Algorithm takes a stream of text as input, and proceeds in three main phases:
  </p>
  <ul>
    <li>Separation of the input text into paragraphs. The rest of the algorithm affects only the 
    text between paragraph separators.</li>
    <li>Resolution of the embedding levels of the text. In this phase, the directional character 
    types, plus the explicit format codes, are used to produce resolved embedding levels.</li>
    <li>Reordering the text for display on a line-by-line basis using the resolved embedding levels, 
    once the text has been broken into lines.</li>
  </ul>
  <p>The algorithm only reorders text within a paragraph; characters in one paragraph have no effect 
  on characters in a different paragraph. Paragraphs are divided by the Paragraph Separator or 
  appropriate Newline Function <span>(for guidelines on the handling of CR, LF, and CRLF, see <i>
  Section 4.4, Directionality </i>and <i>Section 5.8, Newline Guidelines </i></span>of [<a href="#Unicode">Unicode</a>]<span>)</span>. 
  Paragraphs may also be determined by higher-level protocols: for example, the text in two 
  different cells of a table will be in different paragraphs.</p>
  <p>Combining characters always attach to the preceding base character in the memory 
  representation. Even after reordering for display and performing character shaping, the glyph 
  representing a combining character will attach to the glyph representing its base character in 
  memory. Depending on the line orientation and the placement direction of base letterform glyphs, 
  it may, for example, attach to the glyph on the left, or on the right, or above.</p>
  <p>In the following text, the normative definitions and rules are distinguished by the following 
  numbering:</p>
  <div align="center">
    <table border="1" cellspacing="2" cellpadding="0">
      <caption><b>Table 3-5. Normative Definitions and Rules</b></caption>
      <tr>
        <th align="LEFT">
        <p align="LEFT">Numbering</th>
        <th align="LEFT">
        <p align="LEFT">Section</th>
      </tr>
      <tr>
        <td>BDn</td>
        <td>Definitions</td>
      </tr>
      <tr>
        <td>Pn</td>
        <td>Paragraph levels</td>
      </tr>
      <tr>
        <td>Xn</td>
        <td>Explicit levels and directions</td>
      </tr>
      <tr>
        <td>Wn</td>
        <td>Weak types</td>
      </tr>
      <tr>
        <td>Nn</td>
        <td>Neutral types</td>
      </tr>
      <tr>
        <td>In</td>
        <td>Implicit levels</td>
      </tr>
      <tr>
        <td>Ln</td>
        <td>Resolved levels</td>
      </tr>
    </table>
  </div>
  <h3>3.1 <a name="Definitions">Definitions</a></h3>
  <p><a name="BD1">BD1</a>. The <i>bidirectional characters types</i> are values assigned to each 
  Unicode character, including unassigned characters.</p>
  <p><a name="BD2">BD2</a>. <i>Embedding levels </i>are numbers that indicate how deeply the text is 
  nested, and the default direction of text on that level. The minimum embedding level of text is 
  zero, and the maximum explicit depth is level 61.</p>
  <blockquote>
    <p>Embedding levels are explicitly set by both override format codes and by embedding format 
    codes; higher numbers mean the text is more deeply nested. The reason for having a limitation is 
    to provide a precise stack limit for implementations to guarantee the same results. Sixty-one 
    levels is far more than sufficient for ordering, even with mechanically generated formatting; 
    the display becomes rather muddied with more than a small number of embeddings.</p>
  </blockquote>
  <p><a name="BD3">BD3</a>. The default direction of the current embedding level (for a character in 
  question) is called the <i>embedding direction</i>. It is <b>L</b> if the embedding level is even, 
  and <b>R</b> if the embedding level is odd.</p>
  <blockquote>
    <p>For example, in a particular piece of text, Level 0 is plain English text, Level 1 is plain 
    Arabic text, possibly embedded within English level 0 text. Level 2 is English text, possibly 
    embedded within Arabic level 1 text, and so on. Unless their direction is overridden, English 
    text and numbers will always be an even level; Arabic text (excluding numbers) will always be an 
    odd level. The exact meaning of the embedding level will become clear when the reordering 
    algorithm is discussed, but the following provides an example of how the algorithm works.</p>
  </blockquote>
  <p><a name="BD4">BD4</a>. The <i>paragraph embedding level</i> is the embedding level that 
  determines the default bidirectional orientation of the text in that paragraph.</p>
  <p><a name="BD5">BD5</a>. The direction of the paragraph embedding level is called the <i>
  paragraph direction</i>.</p>
  <ul>
    <li>In some contexts the paragraph direction is also known as the <i>base direction</i>.</li>
  </ul>
  <p><a name="BD6">BD6</a>. The <i>directional override status</i> determines whether the 
  bidirectional type of characters is to be reset with explicit directional controls. This status 
  has three states:</p>
  <div align="center">
    <center>
    <table border="1" cellspacing="2" cellpadding="2">
      <caption><b>Table 3-6. Directional Override Status</b></caption>
      <tr>
        <th align="LEFT">
        <p align="LEFT">Status</th>
        <th align="LEFT">
        <p align="LEFT">Interpretation</th>
      </tr>
      <tr>
        <th align="LEFT">
        <p align="LEFT">neutral</th>
        <td>no override is currently active</td>
      </tr>
      <tr>
        <th align="LEFT">
        <p align="LEFT">right-to-left</th>
        <td>characters are to be reset to <b>R</b></td>
      </tr>
      <tr>
        <th align="LEFT">
        <p align="LEFT">left-to-right</th>
        <td>characters are to be reset to <b>L</b></td>
      </tr>
    </table>
    </center>
  </div>
  <p><a name="BD7">BD7</a>. A <i>level run</i> is a maximal substring of characters that have the 
  same embedding level. It is maximal in that no character immediately before or after the substring 
  has the same level <span>(a level run is also known as a <i>directional run)</i>.</span></p>
  <h4>Example</h4>
  <p>In the following examples, case is used to indicate different implicit character types for 
  those unfamiliar with right-to-left letters. Uppercase letters stand for right-to-left characters 
  (such as Arabic or Hebrew), while lowercase letters stand for left-to-right characters (such as 
  English or Russian).</p>
  <pre><b>Memory:         </b>   car is THE CAR in arabic

<b>Character types:</b>   LLL-LL-RRR-RRR-LL-LLLLLL

<b>Resolved levels:</b>   000000011111110000000000</pre>
  <p>Notice that the neutral character (space) between THE and CAR gets the level of the surrounding 
  characters. This is how the implicit directional marks have an effect. By inserting appropriate 
  directional marks around neutral characters, the level of the neutral characters can be changed.</p>
  <h3>3.2 <a name="Bidirectional_Character_Types">Bidirectional Character Types</a></h3>
  <p>The normative bidirectional character types for each character are specified in the
  <a href="http://www.unicode.org/Public/UNIDATA/">Unicode Character Database</a> <a href="#UCD">[UCD]</a> 
  and are summarized in Table&nbsp;3-7. <span>This is a summary only: there are exceptions to the general 
  scope. For example, certain characters such as U+0CBF KANNADA VOWEL SIGN I are given Type L 
  (instead of NSM) to preserve canonical equivalence.</span></p>
  <div align="center">
    <center>
    <table border="0" cellspacing="0" cellpadding="2" class="noBorder">
      <tr>
        <td class="noborder">
        <p align="center"><b>Table 3-7. Bidirectional Character Types</b></td>
      </tr>
      <tr>
        <td align="CENTER" class="noborder">
        <table border="1" cellspacing="1" cellpadding="2">
          <tr>
            <th valign="TOP" align="LEFT">
            <p align="LEFT">Category</th>
            <th valign="TOP" align="LEFT">
            <p align="LEFT">Type</th>
            <th valign="TOP" align="LEFT">
            <p align="LEFT">Description</th>
            <th valign="TOP" align="LEFT">
            <p align="LEFT"><span>General </span>Scope</th>
          </tr>
          <tr>
            <th rowspan="7" align="LEFT">
            <p align="LEFT">Strong</th>
            <td valign="TOP"><b>L</b></td>
            <td valign="TOP">Left-to-Right</td>
            <td valign="TOP">LRM, Most alphabetic, syllabic, Han ideographic characters, digits that 
            are neither European nor Arabic<span>, ...</span></td>
          </tr>
          <tr>
            <td valign="TOP"><b>LRE</b></td>
            <td valign="TOP">Left-to-Right Embedding</td>
            <td valign="TOP">LRE</td>
          </tr>
          <tr>
            <td valign="TOP"><b>LRO</b></td>
            <td valign="TOP">Left-to-Right Override</td>
            <td valign="TOP">LRO</td>
          </tr>
          <tr>
            <td valign="TOP"><b>R</b></td>
            <td valign="TOP">Right-to-Left</td>
            <td valign="TOP">RLM, Hebrew alphabet, most punctuation specific to that script<span>, 
            ...</span></td>
          </tr>
          <tr>
            <td valign="TOP"><b>AL</b></td>
            <td valign="TOP">Right-to-Left Arabic</td>
            <td valign="TOP">Arabic, Thaana, and Syriac alphabets, most punctuation specific to 
            those scripts<span>, ...</span></td>
          </tr>
          <tr>
            <td valign="TOP"><b>RLE</b></td>
            <td valign="TOP">Right-to-Left Embedding</td>
            <td valign="TOP">RLE</td>
          </tr>
          <tr>
            <td valign="TOP"><b>RLO</b></td>
            <td valign="TOP">Right-to-Left Override</td>
            <td valign="TOP">RLO</td>
          </tr>
          <tr>
            <th rowspan="8" align="LEFT">
            <p align="LEFT">Weak</th>
            <td valign="TOP"><b>PDF</b></td>
            <td valign="TOP">Pop Directional Format</td>
            <td valign="TOP">PDF</td>
          </tr>
          <tr>
            <td valign="TOP"><b>EN</b></td>
            <td valign="TOP">European Number</td>
            <td valign="TOP">European digits, Eastern Arabic-Indic digits, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>ES</b></td>
            <td valign="TOP">European Number Separator</td>
            <td valign="TOP">Plus Sign, Minus Sign</td>
          </tr>
          <tr>
            <td valign="TOP"><b>ET</b></td>
            <td valign="TOP">European Number Terminator</td>
            <td valign="TOP">Degree, Currency symbols, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>AN</b></td>
            <td valign="TOP">Arabic Number</td>
            <td valign="TOP">Arabic-Indic digits, Arabic decimal &amp; thousands separators, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>CS</b></td>
            <td valign="TOP">Common Number Separator</td>
            <td valign="TOP">Colon, Comma, Full Stop (Period), Non-breaking space, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>NSM</b></td>
            <td valign="TOP">Non-Spacing Mark</td>
            <td valign="TOP">Characters marked Mn (Non-Spacing Mark) and Me (Enclosing Mark) in the 
            Unicode Character Database.</td>
          </tr>
          <tr>
            <td valign="TOP"><b>BN</b></td>
            <td valign="TOP">Boundary Neutral</td>
            <td valign="TOP"><span>Most </span>formatting and control characters, other than those 
            explicitly given types above.</td>
          </tr>
          <tr>
            <th rowspan="4" align="LEFT">
            <p align="LEFT">Neutral</th>
            <td valign="TOP"><b>B</b></td>
            <td valign="TOP">Paragraph Separator</td>
            <td valign="TOP">Paragraph Separator, appropriate Newline Functions, higher-protocol 
            paragraph determination.</td>
          </tr>
          <tr>
            <td valign="TOP"><b>S</b></td>
            <td valign="TOP">Segment Separator</td>
            <td valign="TOP">Tab</td>
          </tr>
          <tr>
            <td valign="TOP"><b>WS</b></td>
            <td valign="TOP">Whitespace</td>
            <td valign="TOP">Space, Figure Space, Line Separator, Form Feed, General Punctuation 
            Spaces, ...</td>
          </tr>
          <tr>
            <td valign="TOP"><b>ON</b></td>
            <td valign="TOP">Other Neutrals</td>
            <td valign="TOP">All other characters, including OBJECT REPLACEMENT CHARACTER.</td>
          </tr>
        </table>
        </td>
      </tr>
    </table>
    </center>
  </div>
  <ul>
    <li>The term European digits is used to refer to decimal forms common in Europe and elsewhere, 
    and Arabic-Indic digits to refer to the native Arabic forms. (See <i>Section&nbsp;8.2, Arabic</i> of 
    [<a href="#Unicode">Unicode</a>], for more details on naming digits.)</li>
    <li>Unassigned characters are given strong types in the algorithm. This is an explicit exception 
    to the general Unicode conformance requirements with respect to unassigned characters. As 
    characters become assigned in the future, these bidirectional types may change. <span>For 
    assignments to character types see </span><span>DerivedBidiClass.txt in </span>the <span>
    <a href="#UCD">[UCD]</a>.</span></li>
    <li>Private use characters can be assigned different values by a conformant implementation.</li>
    <li>For the purpose of the bidirectional algorithm, inline objects (such as graphics) are 
    treated as if they are an OBJECT REPLACEMENT CHARACTER (U+FFFC).</li>
    <li>As of Unicode 4.0, the Bidirectional Character Types of a few Indic characters were altered 
    so that the Bidirectional Algorithm preserves <a name="canonical_equivalence">canonical 
    equivalence</a>. That is, two canonically equivalent strings will result in equivalent ordering 
    after applying the algorithm. This invariant will be maintained in the future.<p>Note, however, 
    that the Bidirectional Algorithm does <i>not</i> preserve compatibility equivalence.</li>
  </ul>
  <p>Table&nbsp;3-8 lists additional abbreviations used in the examples and internal character types used 
  in the algorithm.</p>
  <div align="center">
    <center>
    <table border="1" cellspacing="1" cellpadding="2">
      <caption><b>Table 3-8. Abbreviations for Examples and Internal Types</b></caption>
      <tr>
        <th valign="TOP"><b>Symbol</b></th>
        <th valign="TOP"><b>Description</b></th>
      </tr>
      <tr>
        <td valign="TOP">N</td>
        <td valign="TOP">Neutral or Separator (B, S, WS, ON)</td>
      </tr>
      <tr>
        <td valign="TOP">e</td>
        <td valign="TOP">The text ordering type (L or R) that matches the embedding level direction 
        (even or odd)</td>
      </tr>
      <tr>
        <td valign="TOP">sor</td>
        <td valign="TOP">The text ordering type (L or R) assigned to the position before a level 
        run.</td>
      </tr>
      <tr>
        <td valign="TOP">eor</td>
        <td valign="TOP">The text ordering type (L or R) assigned to the position after a level run.</td>
      </tr>
    </table>
    </center>
  </div>
  <h3><br>
  3.3 <a name="Resolving_Embedding_Levels">Resolving Embedding Levels</a></h3>
  <p>The body of the bidirectional algorithm uses character types and explicit codes to produce a 
  list of resolved levels. This resolution process consists of five steps: (1) determining the 
  paragraph level; (2) determining explicit embedding levels and directions; (3) resolving weak 
  types; (4) resolving neutral types; and (5) resolving implicit embedding levels.</p>
  <h3>3.3.1 <a name="The_Paragraph_Level">The Paragraph Level</a></h3>
  <p><i><a name="P1">P1</a>. Split the text into separate paragraphs. A paragraph separator is kept 
  with the previous paragraph. Within each paragraph, apply all the other rules of this algorithm.</i></p>
  <p><i><a name="P2">P2</a>. In each paragraph, find the first character of type L, AL, or R.</i></p>
  <p>Because paragraph separators delimit text in this algorithm, this will generally be the first 
  strong character after a paragraph separator or at the very beginning of the text. Note that the 
  characters of type LRE, LRO, RLE, RLO are ignored in this rule. This is because typically they are 
  used to indicate that the embedded text is the <i>opposite</i> direction than the paragraph level.</p>
  <p><i><a name="P3">P3</a>. If a character is found in P2 and it is of type AL or R, then set the 
  paragraph embedding level to one; otherwise, set it to zero.</i></p>
  <p>Note that when a higher-level protocol specifies the paragraph level, it is not necessary to 
  apply rules P2 and P3.</p>
  <h3>3.3.2 <a name="Explicit_Levels_and_Directions">Explicit Levels and Directions</a></h3>
  <p>All explicit embedding levels are determined from the embedding and override codes, by applying 
  the explicit level rules X1 through X9. These rules are applied as part of the same logical pass 
  over the input.</p>
  <h4>Explicit Embeddings</h4>
  <p><i><a name="X1">X1</a>. Begin by setting the current embedding level to the paragraph embedding 
  level. Set the directional override status to neutral. Process each character iteratively, 
  applying rules X2 through X9. Only embedding levels from 0 to 61 are valid in this phase.</i></p>
  <p>In the resolution of levels in rules I1 and I2, the maximum embedding level of 62 can be 
  reached.</p>
  <p><i><a name="X2">X2</a>. With each RLE, compute the least greater <b>odd</b> embedding level.</i></p>
  <blockquote>
    <p><i>a. If this new level would be valid, then this embedding code is valid. Remember (push) 
    the current embedding level and override status. Reset the current level to this new level, and 
    reset the override status to <b>neutral</b>.</i></p>
    <p><i>b. If the new level would not be valid, then this code is invalid. Don&#39;t change the 
    current level or override status.</i></p>
  </blockquote>
  <p>For example, level 0 =&gt; 1; levels 1, 2 =&gt; 3; levels 3, 4 =&gt; 5; ...59,60 =&gt; 61; above 60, no 
  change (don’t change levels with RLE if the new level would be invalid).</p>
  <p><i><a name="X3">X3</a>. With each LRE, compute the least greater <b>even</b> embedding level.</i></p>
  <blockquote>
    <p><i>a. If this new level would be valid, then this embedding code is valid. Remember (push) 
    the current embedding level and override status. Reset the current level to this new level, and 
    reset the override status to <b>neutral</b>.</i></p>
    <p><i>b. If the new level would not be valid, then this code is invalid. Don&#39;t change the 
    current level or override status.</i></p>
  </blockquote>
  <p>For example, levels 0, 1 =&gt; 2; levels 2, 3 =&gt; 4; levels 4, 5 =&gt; 6; ...58, 59 =&gt; 60; above 59, 
  no change (don’t change levels with LRE if the new level would be invalid).</p>
  <h4>Explicit Overrides</h4>
  <p>An explicit directional override sets the embedding level in the same way the explicit 
  embedding codes do, but also changes the directional character type of affected characters to the 
  override direction.</p>
  <p><i><a name="X4">X4</a>. With each RLO, compute the least greater <b>odd</b> embedding level.</i></p>
  <blockquote>
    <p><i>a. If this new level would be valid, then this embedding code is valid. Remember (push) 
    the current embedding level and override status. Reset the current level to this new level, and 
    reset the override status to <b>right-to-left</b>.</i></p>
    <p><i>b. If the new level would not be valid, then this code is invalid. Don&#39;t change the 
    current level or override status.</i></p>
  </blockquote>
  <p><i><a name="X5">X5</a>. With each LRO, compute the least greater <b>even</b> embedding level.</i></p>
  <blockquote>
    <p><i>a. If this new level would be valid, then this embedding code is valid. Remember (push) 
    the current embedding level and override status. Reset the current level to this new level, and 
    reset the override status to <b>left-to-right</b>.</i></p>
    <p><i>b. If the new level would not be valid, then this code is invalid. Don&#39;t change the 
    current level or override status.</i></p>
  </blockquote>
  <p><i><a name="X6">X6</a>. For all types besides RLE, LRE, RLO, LRO, and PDF:</i></p>
  <blockquote>
    <p><i>a. Set the level of the current character to the current embedding level.</i></p>
    <p><i>b.&nbsp; Whenever the directional override status is not neutral, reset the current 
    character type to the directional override status.</i></p>
  </blockquote>
  <p>If the directional override status is neutral, then characters retain their normal types: 
  Arabic characters stay AL, Latin characters stay L, neutrals stay N, and so on. If the directional 
  override status is R, then characters become R. If the directional override status is L, then 
  characters become L.</p>
  <h4>Terminating Embeddings and Overrides</h4>
  <p>There is a single code to terminate the scope of the current explicit code, whether an 
  embedding or a directional override. All codes and pushed states are completely popped at the end 
  of paragraphs.</p>
  <p><i><a name="X7">X7</a>. With each PDF, determine the matching embedding or override code. If 
  there was a valid matching code, restore (pop) the last remembered (pushed) embedding level and 
  directional override.</i></p>
  <p><i><a name="X8">X8</a>. All explicit directional embeddings and overrides are completely 
  terminated at the end of each paragraph. Paragraph separators are <b>not</b> included in the 
  embedding.</i></p>
  <p><i><a name="X9">X9</a>. Remove all RLE, LRE, RLO, LRO, PDF, and BN codes.</i></p>
  <ul>
    <li>Note that an implementation does not have to actually remove the codes, it just has to 
    behave as though the codes were not present for the remainder of the algorithm. Conformance does 
    not require any particular placement of these codes as long as all other characters are ordered 
    correctly.
    <p>See <a href="#Implementation_Notes">5. Implementation Notes</a> for information on 
    implementing the algorithm without removing the formatting codes.</li>
    <li>The Zero Width Joiner and Non Joiner affect the shaping of the adjacent characters; those 
    that are adjacent in the original backing-store order, even though those characters may end up 
    being rearranged to be non-adjacent by the BIDI algorithm. For more information, see
    <a href="#Joiners">Joiners</a>.</li>
  </ul>
  <p><i><a name="X10">X10</a>. The remaining rules are applied to each run of characters at the same 
  level. For each run, determine the <i>start-of-level-run</i> (<b>sor</b>) and <i>end-of-level-run</i> 
  (<b>eor</b>) type, either L or R. This depends on the higher of the two levels on either side of 
  the boundary (at the start or end of the paragraph, the level of the &#39;other&#39; run is the base 
  embedding level). If the higher level is odd, the type is R, otherwise it is L.</i></p>
  <p>For example:</p>
  <pre><b>Levels:</b>  0   0   0   1   1   1   2

<b>Runs:</b>   &lt;--- 1 ---&gt; &lt;--- 2 ---&gt; &lt;3&gt;</pre>
  <p>Run 1 is at level 0, <i>sor</i> is L, <i>eor</i> is R.<br>
  Run 2 is at level 1, <i>sor</i> is R, <i>eor</i> is L.<br>
  Run 3 is at level 2, <i>sor</i> is L, <i>eor</i> is L.<br>
  </p>
  <p>For two adjacent runs, the <i>eor</i> of the first run is the same as the <i>sor</i> of the 
  second.</p>
  <h3>3.3.3 <a name="Resolving_Weak_Types">Resolving Weak Types</a></h3>
  <p>Weak types are now resolved one level run at a time. At level run boundaries where the type of 
  the character on the other side of the boundary is required, the type assigned to <i>sor</i> or <i>
  eor</i> is used.</p>
  <p>Non-spacing marks are now resolved based on the previous characters.</p>
  <p><i><a name="W1">W1</a>. Examine each non-spacing mark (NSM) in the level run, and change the 
  type of the NSM to the type of the previous characte</i><em>r. If the NSM is at the start of the 
  level run, it will get the type of <strong>sor</strong>.</em></p>
  <p>Assume in this example that <i>sor</i> is R:</p>
  <blockquote>
    <pre>AL  NSM NSM =&gt; AL  AL  AL

<i>sor</i> NSM     =&gt; <i>sor</i> R</pre>
  </blockquote>
  <p>The text is next parsed for numbers. This pass will change the directional types European 
  Number Separator, European Number Terminator, and Common Number Separator to be European Number 
  text, Arabic Number text, or Other Neutral text. The text to be scanned may have already had its 
  type altered by directional overrides. If so, then it will not parse as numeric.</p>
  <p><i><a name="W2">W2</a>. Search backwards from each instance of a European number until the 
  first strong type (R, L, AL, or <b>sor</b>) is found.&nbsp; If an AL is found, change the type of 
  the European number to Arabic number.</i></p>
  <blockquote>
    <pre>AL EN    =&gt; AL AN

AL N EN  =&gt; AL N AN

<i>sor</i> N EN =&gt; <i>sor</i> N EN

L N EN   =&gt; L N EN

R N EN   =&gt; R N EN</pre>
  </blockquote>
  <p><i><a name="W3">W3</a>. Change all ALs to R.</i></p>
  <p><i><a name="W4">W4</a>. A single European separator between two European numbers changes to a 
  European number. A single common separator between two numbers of the same type changes to that 
  type:</i></p>
  <blockquote>
    <pre>EN ES EN =&gt; EN EN EN

EN CS EN =&gt; EN EN EN

AN CS AN =&gt; AN AN AN</pre>
  </blockquote>
  <p><i><a name="W5">W5</a>. A sequence of European terminators adjacent to European numbers changes 
  to all European numbers:</i></p>
  <blockquote>
    <pre>ET ET EN =&gt; EN EN EN

EN ET ET =&gt; EN EN EN

AN ET EN =&gt; AN EN EN</pre>
  </blockquote>
  <p><i><a name="W6">W6</a>. Otherwise, separators and terminators change to Other Neutral:</i></p>
  <blockquote>
    <pre>AN ET    =&gt; AN ON

L  ES EN =&gt; L  ON EN

EN CS AN =&gt; EN ON AN

ET AN    =&gt; ON AN</pre>
  </blockquote>
  <p><i><a name="W7">W7</a>. Search backwards from each instance of a European number until the 
  first strong type (R, L, or <b>sor</b>) is found. If an L is found,&nbsp; then change the type of 
  the European number to L.</i></p>
  <blockquote>
    <pre><tt>L  N EN </tt>=<tt>&gt; L  N  L</tt>

<tt>R  N EN </tt>=<tt>&gt; R  N  EN</tt></pre>
  </blockquote>
  <h3>3.3.4 <a name="Resolving_Neutral_Types">Resolving Neutral Types</a></h3>
  <p>Neutral types are now resolved one level run at a time. At level run boundaries where the type 
  of the character on the other side of the boundary is required, the type assigned to <i>sor</i> or
  <i>eor</i> is used.</p>
  <p>The next phase resolves the direction of the neutrals. The results of this phase are that all 
  neutrals become either <b>R</b> or <b>L</b>. Generally, neutrals take on the direction of the 
  surrounding text. In case of a conflict, they take on the embedding direction.</p>
  <p><i><a name="N1">N1</a>. A sequence of neutrals takes the direction of the surrounding strong 
  text if the text on both sides has the same direction. European and Arabic numbers <span>act as if</span> 
  they </i><em>were R<span> in terms of their influence on neutrals</span>. Start-of-level-run (<strong>sor</strong>) 
  and end-of-level-run (<strong>eor</strong>) are used at level run boundaries.</em></p>
  <blockquote>
    <pre>R  N  R  =&gt; R  R  R

L  N  L  =&gt; L  L  L

R  N  AN =&gt; R  R  AN

AN N  R  =&gt; AN R  R

R  N  EN =&gt; R  R  EN

EN N  R  =&gt; EN R  R</pre>
  </blockquote>
  <p><span>Note that any AN or EN remaining after W7 will be in an right-to-left context.</span></p>
  <p><i><a name="N2">N2</a>. Any remaining neutrals take the embedding direction.</i></p>
  <blockquote>
    <pre>N =&gt; e</pre>
  </blockquote>
  <p>Assume in this example that <i>eor</i> is L, and <i>sor</i> is R. <span>Then an application of 
  N1 and N2 yields the following:</span></p>
  <blockquote>
    <pre>L   N <i>eor</i> =&gt; L   L <i>eor</i>

R   N <i>eor</i> =&gt; R   e <i>eor</i>

<i>sor</i> N L   =&gt; <i>sor</i> e L

<i>sor</i> N R   =&gt; <i>sor</i> R R</pre>
  </blockquote>
  <p><i>Examples.</i> A list of numbers separated by neutrals and embedded in a directional run will 
  come out in the run’s order.</p>
  <pre><b>Storage:</b>	he said &quot;THE VALUES ARE 123, 456, 789, OK&quot;.

<b>Display:</b>	he said &quot;KO ,789 ,456 ,123 ERA SEULAV EHT&quot;.</pre>
  <p>In this case, both the comma and the space between the numbers take on the direction of the 
  surrounding text (uppercase = right-to-left), ignoring the numbers. The commas are not considered 
  part of the number since they are not surrounded on both sides (see number parsing). However, if 
  there is an adjacent left-to-right sequence, then European numbers will adopt that direction:</p>
  <pre><b>Storage:</b>	he said &quot;IT IS A bmw 500, OK.&quot;

<b>Display:</b>	he said &quot;.KO ,bmw 500 A SI TI&quot;</pre>
  <h3>3.3.5 <a name="Resolving_Implicit_Levels">Resolving Implicit Levels</a></h3>
  <p>In the final phase, the embedding level of text may be increased, based upon the resolved 
  character type. Right-to-left text will always end up with an odd level, and left-to-right and 
  numeric text will always end up with an even level. In addition, numeric text will always end up 
  with a higher level than the paragraph level. (Note that it is possible for text to end up at 
  levels higher than 61 as a result of this process.) This results in the following rules:</p>
  <p><i><a name="I1">I1</a>. </i><em>For all characters with an even (left-to-right) embedding 
  direction, those of type R go up one level and those of type AN or EN go up two levels.</em></p>
  <p><i><a name="I2">I2</a>. </i><em>For all characters with an</em><i> odd (right-to-left)</i><em> 
  embedding direction</em><i>, those</i><em> of type L, EN or AN</em><i> go up one level.</i></p>
  <p>Table&nbsp;3-10 summarizes the results of the implicit algorithm.</p>
  <div align="center">
    <center>
    <table border="1" cellspacing="1" cellpadding="2">
      <caption><b>Table 3-10. Resolving Implicit Levels</b></caption>
      <tr>
        <th rowspan="2">Type</th>
        <th colspan="2">Embedding Level</th>
      </tr>
      <tr>
        <th>Even</th>
        <th>Odd</th>
      </tr>
      <tr>
        <td valign="TOP"><b>L</b></td>
        <td valign="TOP">EL</td>
        <td valign="TOP">EL+1</td>
      </tr>
      <tr>
        <td valign="TOP"><b>R</b></td>
        <td valign="TOP">EL+1</td>
        <td valign="TOP">EL</td>
      </tr>
      <tr>
        <td valign="TOP"><b>AN</b></td>
        <td valign="TOP">EL+2</td>
        <td valign="TOP">EL+1</td>
      </tr>
      <tr>
        <td valign="TOP"><b>EN</b></td>
        <td valign="TOP">EL+2</td>
        <td valign="TOP">EL+1</td>
      </tr>
    </table>
    </center>
  </div>
  <h3>3.4 <a name="Reordering_Resolved_Levels">Reordering Resolved Levels</a></h3>
  <p>The following algorithm describes the logical process of finding the correct display order. As 
  described before, this logical process is not necessarily the actual implementation, which may 
  diverge for efficiency as long as it produces the same results. As opposed to resolution phases, 
  this algorithm acts on a per-line basis,<i> and is applied <b>after</b> any line wrapping is 
  applied to the paragraph.</i></p>
  <p>The process of breaking a paragraph into one or more lines that fit within particular bounds is 
  outside the scope of the bidirectional algorithm. Where character shaping is involved, it can be 
  somewhat more complicated (see <i>Section 8.2 Arabic</i> of [<a href="#Unicode">Unicode</a>]). 
  Logically there are the following steps: </p>
  <ul>
    <li>The levels of the text are determined according to the bidirectional algorithm.</li>
    <li>The characters are shaped into glyphs according to their context <i>(taking the embedding 
    levels into account for mirroring!).</i></li>
    <li>The accumulated widths of those glyphs <i>(in logical order)</i> are used to determine line 
    breaks.</li>
    <li>For each line, rules L1-L4 are used to reorder the characters on that line.</li>
    <li>The glyphs corresponding to the characters on the line are displayed in that order.</li>
  </ul>
  <p><i><a name="L1">L1</a>. On each line, reset the embedding level of the following characters to 
  the paragraph embedding level:</i> </p>
  <ol>
    <li><i>segment separators,</i></li>
    <li><i>paragraph separators,</i></li>
    <li><i>any sequence of whitespace characters preceding a segment separator or paragraph 
    separator, and</i></li>
    <li><i>any sequence of white space characters at the end of the line.</i></li>
  </ol>
  <ul>
    <li>The types of characters used here are the <i>original</i> types, not those modified by the 
    previous phase.</li>
    <li>Since a Paragraph Separator breaks lines, there will be at most one per line, at the end of 
    that line.</li>
  </ul>
  <p>In combination with the following rule, this means that trailing white space will appear at the 
  visual end of the line (in the paragraph direction). Tabulation will always have a consistent 
  direction within a paragraph.</p>
  <p><i><a name="L2">L2</a>. From the highest level found in the text to the lowest odd level on 
  each line<span>, including intermediate levels not actually present in the text, </span>reverse 
  any contiguous sequence of characters that are at that level or higher.</i></p>
  <p>This reverses a progressively larger series of substrings. The following four examples 
  illustrate this. <span>In these examples, the paragraph embedding level for the first and third 
  examples is assumed to be 0 (left to right direction), and for the second and fourth is assumed to 
  be 1 (right to left direction).</span></p>
  <h5><span>Example 1 (embedding level = 0)</span></h5>
  <pre><b>Memory:</b>              car means CAR.

<b>Resolved levels:</b>     00000000001110

<b>Reverse level 1:</b>     car means RAC.</pre>
  <h5><span>Example 2 (embedding level = 1)</span></h5>
  <pre><b>Memory:</b>              car MEANS CAR.

<b>Resolved levels:</b>     22211111111111

<b>Reverse level 2:</b>     rac MEANS CAR.

<b>Reverse levels 1-2:</b>  .RAC SNAEM car</pre>
  <h5><span>Example 3 (embedding level = 0)</span></h5>
  <pre><b>Memory:</b>              he said &quot;car MEANS CAR.&quot;

<b>Resolved levels:</b>     000000000222111111111100

<b>Reverse level 2:</b>     he said &quot;rac MEANS CAR.&quot;

<b>Reverse levels 1-2:</b>  he said &quot;RAC SNAEM car.&quot;</pre>
  <h5><span>Example 4 (embedding level = 1)</span></h5>
  <pre><b>Memory:</b>              DID YOU SAY ‘he said &quot;car MEANS CAR&quot;’?

<b>Resolved levels:</b>     11111111111112222222224443333333333211

<b>Reverse level 4:</b>     DID YOU SAY ‘he said &quot;rac MEANS CAR&quot;’?

<b>Reverse levels 3-4:</b>  DID YOU SAY ‘he said &quot;RAC SNAEM car&quot;’?

<b>Reverse levels 2-4:</b>  DID YOU SAY ‘&quot;rac MEANS CAR&quot; dias eh’?

<b>Reverse levels 1-4:</b>  ?‘he said &quot;RAC SNAEM car&quot;’ YAS UOY DID</pre>
  <p><i><a name="L3">L3</a>. Combining marks applied to a right-to-left base character will at this 
  point precede their base character. If the rendering engine expects them to follow the base 
  characters in the final display process, then the ordering of the marks and the base character 
  must be reversed.</i></p>
  <p>Many font designers provide default metrics for combining marks that support rendering by 
  simple overhang. Because of the reordering for right-to-left characters, it is common practice to 
  make the glyphs for most combining characters overhang to the left (thus assuming the characters 
  will be applied to left-to-right base characters) and make the glyphs for combining characters in 
  right-to-left scripts overhang to the right (thus assuming that the characters will be applied to 
  right-to-left base characters). With such fonts, the display ordering of the marks and base glyphs 
  may need to be adjusted when combining marks are applied to &quot;unmatching&quot; base characters. See <i>
  Section 5.14, Rendering Non-Spacing Marks</i> of [<a href="#Unicode">Unicode</a>] for more 
  information.</p>
  <p><i><a name="L4">L4</a>. A character that possesses the mirrored property as specified by 
  Section&nbsp;4.7, Mirrored of [<a href="#Unicode">Unicode</a>] must be depicted by a mirrored glyph if 
  the resolved directionality of that character is R.</i></p>
  <p>For example, U+0028 left parenthesis—which is interpreted in the Unicode Standard as an opening 
  parenthesis—appears as &quot;<b>(</b>&quot; when its resolved level is even, and as the mirrored glyph &quot;<b>)</b>&quot; 
  when its resolved level is odd.</p>
  <h3>3.5 <a name="Shaping">Shaping</a></h3>
  <p>Shaping is logically applied <i>after</i> the bidirectional algorithm is used, and limited to 
  characters within the same directional run. For example, suppose that we have the following string 
  of Arabic characters in memory as characters 1, 2, 3, and 4, and where the first two characters 
  are overridden to be LTR. To show both paragraph directions, the next two are embedded, but with 
  the normal RTL direction.</p>
  <blockquote>
    <div align="center">
      <center>
      <table cellspacing="0" cellpadding="4" border="1">
        <tr>
          <td>
          <p align="center">1</td>
          <td>
          <p align="center">2</td>
          <td>
          <p align="center">3</td>
          <td>
          <p align="center">4</td>
        </tr>
        <tr>
          <td>
          <p align="center"><font size="6">ج</font><br>
          <tt>062C<br>
          JEEM</tt></td>
          <td>
          <p align="center"><font size="6">ع</font><br>
          <tt>0639<br>
          AIN</tt></td>
          <td>
          <p align="center"><font size="6">ل</font><br>
          <tt>0644<br>
          LAM</tt></td>
          <td>
          <p align="center"><font size="6">م</font><br>
          <tt>0645<br>
          MEEM</tt></td>
        </tr>
        <tr>
          <td>
          <p align="center"><b>L</b></td>
          <td>
          <p align="center"><b>L</b></td>
          <td>
          <p align="center"><b>R</b></td>
          <td>
          <p align="center"><b>R</b></td>
        </tr>
      </table>
      </center>
    </div>
  </blockquote>
  <p>One can use embedding codes to get this effect in plain text, or use markup in HTML, as in the 
  examples below. (The red text would be for the right-to-left paragraph direction.)</p>
  <ul>
    <li>LRM<font color="#FF0000">/RLM</font> LRO&nbsp;<i>JEEM&nbsp;AIN</i>&nbsp;PDF RLO&nbsp;<i>LAM&nbsp;MEEM</i>&nbsp;PDF</li>
    <li>&lt;p dir=&quot;ltr&quot;<font color="#FF0000">/&quot;rtl&quot;</font>&gt;LRO&nbsp;<i>JEEM&nbsp;AIN</i>&nbsp;PDF RLO&nbsp;<i>LAM&nbsp;MEEM</i>&nbsp;PDF&lt;/p&gt;</li>
    <li>&lt;p dir=&quot;ltr&quot;<font color="#FF0000">/&quot;rtl&quot;</font>&gt;&lt;bdo&nbsp;dir=&quot;ltr&quot;&gt;<i>JEEM&nbsp;AIN</i>&lt;/bdo&gt;&lt;bdo&nbsp;dir=&quot;rtl&quot;&gt;<i>LAM&nbsp;MEEM</i>&lt;/bdo&gt;&lt;/p&gt;</li>
  </ul>
  <p>The resulting shapes will be the following, according to the paragraph direction:</p>
  <div align="center">
    <center>
    <table cellspacing="0" cellpadding="8" border="1">
      <tr>
        <th width="50%">
        <p align="center">Left-Right Paragraph</th>
        <th width="50%">
        <p align="center">Right-Left Paragraph</th>
      </tr>
      <tr>
        <td width="50%">
        <table cellspacing="0" cellpadding="4" border="1">
          <tr>
            <td>
            <p align="center"><font color="#00ff00"><b>1</b></font></td>
            <td>
            <p align="center"><font color="#00ff00"><b>2</b></font></td>
            <td>
            <p align="center"><font color="#ff0000"><b>4</b></font></td>
            <td>
            <p align="center"><font color="#ff0000"><b>3</b></font></td>
          </tr>
          <tr>
            <td>
            <p align="center"><font size="6">ﺞ</font><tt><br>
            JEEM-F</tt></td>
            <td>
            <p align="center"><font size="6">ﻋ</font><tt><br>
            AIN-I</tt></td>
            <td>
            <p align="center"><font size="6">ﻢ</font><tt><br>
            MEEM-F</tt></td>
            <td>
            <p align="center"><font size="6">ﻟ</font><tt><br>
            LAM-I</tt></td>
          </tr>
        </table>
        </td>
        <td width="50%">
        <table cellspacing="0" cellpadding="4" border="1">
          <tr>
            <td>
            <p align="center"><font color="#ff0000"><b>4</b></font></td>
            <td>
            <p align="center"><font color="#ff0000"><b>3</b></font></td>
            <td>
            <p align="center"><font color="#00ff00"><b>1</b></font></td>
            <td>
            <p align="center"><font color="#00ff00"><b>2</b></font></td>
          </tr>
          <tr>
            <td>
            <p align="center"><font size="6">ﻢ</font><tt><br>
            MEEM-F</tt></td>
            <td>
            <p align="center"><font size="6">ﻟ</font><tt><br>
            LAM-I</tt></td>
            <td>
            <p align="center"><font size="6">ﺞ</font><tt><br>
            JEEM-F</tt></td>
            <td>
            <p align="center"><font size="6">ﻋ</font><tt><br>
            AIN-I</tt></td>
          </tr>
        </table>
        </td>
      </tr>
    </table>
    </center>
  </div>
  <h2>4 <a name="Bidirectional_Conformance">Bidirectional Conformance</a><a name="Conformance"></a></h2>
  <p>A process that claims conformance to this specification shall satisfy the the following 
  clauses:</p>
  <table border="0" cellspacing="0" cellpadding="4" class="noborder">
    <tr>
      <td valign="top" class="noborder"><i>C1.</i></td>
      <td valign="top" class="noborder"><i>In the absence of a permissible higher-level protocol, a 
      process that renders text shall display all visible representations of characters (excluding 
      format characters) in the order described by <a href="#Basic_Display_Algorithm">Section 3. 
      Basic Display Algorithm </a>of this specification. In particular, this includes definitions
      <a href="#BD1">BD1</a>- <a href="#BD7">BD7</a> and steps </i><a href="#P1">P1</a>-<a href="#P3">P3</a>,
      <a href="#X1">X1</a>-<a href="#X10">X10</a>, <a href="#W1">W1</a>-<a href="#W7">W7</a>,
      <a href="#N1">N1</a>-<a href="#N2">N2</a>, <a href="#I1">I1</a>-<a href="#I2">I2</a>, and
      <a href="#L1">L1</a>-<a href="#L4">L4</a>.</td>
    </tr>
  </table>
  <ul>
    <li>As is the case for all other Unicode algorithms, this is a <i>logical</i> description — 
    particular implementations can have more efficient mechanisms as long as they produce the same 
    results. See C19 in Chapter 3 of the Unicode Standard and the notes following.</li>
    <li>The bidirectional algorithm specifies part of the intrinsic semantics of right-to-left 
    characters, and is thus required for conformance to the Unicode Standard where any such 
    characters are displayed.</li>
  </ul>
  <table border="0" cellspacing="0" cellpadding="4" class="noborder">
    <tr>
      <td valign="top" class="noborder"><i>C2.</i></td>
      <td valign="top" class="noborder"><i>The only permissible higher-level protocols are those 
      listed in <a href="#Higher-Level_Protocols">Section </a></i><a href="#Higher-Level_Protocols">
      4.3. Higher-Level Protocols</a>: <a href="#HL1">HL1</a>, <a href="#HL1">HL2</a>,
      <a href="#HL3">HL3</a>, <a href="#HL4">HL4</a>, <a href="#HL5">HL5</a>, and <a href="#HL6">HL6</a>.</td>
    </tr>
  </table>
  <blockquote>
    <p><i>Note: These clauses override clause C13 of Unicode 4.0 [<a href="#Unicode">Unicode</a>], 
    and tighten the conformance requirements.</i></p>
  </blockquote>
  <h3>4.1 <a name="Boundary_Neutrals">Boundary Neutrals</a></h3>
  <p>The goal in marking a format or control character as BN is that it have no effect on the rest 
  of the algorithm. <span>(ZWJ and ZWNJ are exceptions; see <a href="#X9">X9</a>).</span> Since the 
  precise ordering of format characters with respect to others is not required for conformance, 
  implementations are free to handle them in different ways for efficiency as long as the ordering 
  of the other characters is preserved.</p>
  <h3>4.2 <a name="Explicit_Formatting_Codes">Explicit Formatting Codes</a></h3>
  <p>As with any Unicode characters, systems do not have to support any particular explicit 
  directional formatting code (although it is not generally useful to include a terminating code 
  without including the initiator). Generally, conforming systems will fall into three classes: </p>
  <ul>
    <li><i>No bidirectional formatting.</i> This implies that the system does not visually interpret 
    characters from right-to-left scripts. </li>
    <li><i>Implicit bidirectionality.</i> The implicit bidirectional algorithm and the directional 
    marks RLM and LRM are supported. </li>
    <li><i>Full bidirectionality.</i> The implicit bidirectional algorithm, the implicit directional 
    marks, and the explicit directional embedding codes are supported: RLM, LRM, LRE, RLE, LRO, RLO, 
    PDF.</li>
  </ul>
  <h3>4.3 <a name="Higher-Level_Protocols">Higher-Level Protocols</a></h3>
  <p>The following clauses are the only permissible ways for systems to apply higher-level protocols 
  to the ordering of bidirectional text. Some of the clauses apply to <i>segments</i> of structured 
  text. This refers to the situation where text is interpreted as being structured, whether with 
  explicit markup such as XML or HTML, or internally structured such as in a word processor or 
  spreadsheet. In such a case, a segment is span of text that is distinguished in some way by the 
  structure.<br>
&nbsp; </p>
  <table border="0" cellspacing="0" cellpadding="4" class="noborder">
    <tr>
      <td valign="top" class="noborder">
      <p class="noborder"><i><a name="HL1">HL1</a>.</i></td>
      <td valign="top" class="noborder">
      <p class="noborder"><i>Override P3, and set the paragraph embedding level explicitly</i></p>
      <ul>
        <li>
        <p class="noborder">A higher-level protocol may set the paragraph level explicitly, and 
        ignore P3. This can be done on the basis of the context, such as on a table cell, paragraph, 
        document, or system level.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td valign="top" class="noborder"><i><a name="HL2">HL2</a>.</i></td>
      <td valign="top" class="noborder"><i>Override W2, and set EN or AN explicitly</i>
      <ul>
        <li>A higher-level process may reset characters of type EN to AN or vice versa, and ignore 
        W2. For example, style sheet or markup information can be used within a span of text to 
        override the setting of EN text to be always be AN, or vice versa.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td valign="top" class="noborder"><i><a name="HL3">HL3</a>.</i></td>
      <td valign="top" class="noborder"><i>Emulate directional overrides or embedding codes</i>
      <ul>
        <li>A higher-level protocol can impose a directional override or embedding on a segment of 
        structured text. The behavior must always be defined by reference to what would happen if 
        the equivalent explicit codes as defined in the algorithm were inserted into the text. For 
        example, a style sheet or markup can set the embedding level on a span of text.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td valign="top" class="noborder"><i><a name="HL4">HL4</a>.</i></td>
      <td valign="top" class="noborder"><i>Apply the bidi algorithm to segments</i>
      <ul>
        <li>The bidi algorithm can be applied independently to one or more segments of structured 
        text. For example, when displaying a document consisting of textual data and visible markup 
        in an editor, a higher-level process can handle syntactic elements in the markup separately 
        from the textual data.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td valign="top" class="noborder"><i><a name="HL5">HL5</a>.</i></td>
      <td valign="top" class="noborder"><i>Provide artificial context</i>
      <ul>
        <li>Text can be processed by the bidi algorithm as if it were preceded by a character of a 
        given type, and/or followed by a character of a given type. This allows a piece of text that 
        is extracted from a longer sequence of text to behave as it did in the larger context.</li>
      </ul>
      </td>
    </tr>
    <tr>
      <td valign="top" class="noborder"><i><a name="HL6">HL6</a>.</i></td>
      <td valign="top" class="noborder"><i>Limit Mirroring</i>
      <ul>
        <li>Mirroring can be limited to a subset of the possible characters, to as few as those that 
        have a mirroring character in BidiMirroring.txt in the UCD. The &quot;best fit&quot; characters can 
        also be excluded.</li>
      </ul>
      </td>
    </tr>
  </table>
  <p>Clauses #1 and #3 are not logically necessary; they are covered by applications of clauses #4 
  and #5. However, they are included for clarity because they are more common operations.</p>
  <p>As an example of the application of #4, suppose an XML document contains the following 
  fragment. (Note: this is a simplified example for illustration: element names, attribute names, 
  and attribute values could all be involved.)</p>
  <ul>
    <li>ARABICenglishARABIC&lt;e1 type=&#39;ab&#39;&gt;ARABICenglish&lt;e2 type=&#39;cd&#39;&gt;english</li>
  </ul>
  <p>This can be analyzed as being 5 different segments:</p>
  <ol type="a">
    <li>ARABICenglishARABIC</li>
    <li>&lt;e1 type=&#39;ab&#39;&gt;</li>
    <li>ARABICenglish</li>
    <li>&lt;e2 type=&#39;cd&#39;&gt;</li>
    <li>english</li>
  </ol>
  <p>To make the XML file readable as source text, the display in an editor could order these 
  elements all in a uniform direction (e.g. all left-to-right), and apply the bidi algorithm to each 
  field separately. It could also choose to order the element names, attribute names and attribute 
  values uniformly in the same direction (e.g. all left-to-right). For final display, the markup 
  could be ignored, allowing all of the text (segments a, c, and e) to be reordered together.</p>
  <p>When text using a higher-level protocol is to be converted to Unicode plain text, for 
  consistent appearance formatting codes should be inserted to ensure that the order matches that of 
  the higher-level protocol.</p>
  <h2>5 <a name="Implementation_Notes">Implementation Notes</a></h2>
  <h3>5.1 <a name="Reference_Code">Reference Code</a></h3>
  <p align="left">There are two versions of BIDI reference code available. Both have been tested to 
  produce identical results. One version is written in Java, while the other is written in C++. The 
  Java version is designed to closely follow the steps of the algorithm as described below. The C++ 
  code is designed to show one of the optimization methods that can be applied to the algorithm, 
  using a state table for one phase.</p>
  <blockquote>
    <p align="left">Note: one of the most effective optimizations is to first test for right-to-left 
    characters, and not invoke the BIDI algorithm unless they are present.</p>
  </blockquote>
  <p align="left">The code is in the directories <a href="BidiReferenceJava/">BidiReferenceJava</a> 
  and <a href="BidiReferenceCpp/">BidiReferenceCpp</a>. Implementers are encouraged to use this 
  resource to test their implementations.</p>
  <h3>5.2 <a name="Retaining_Format_Codes">Retaining Format Codes</a></h3>
  <p>Some implementations may wish to retain the format codes when running the algorithm. The 
  following provides a summary of how this may be done. Note that this summary is an informative 
  implementation guideline; it should provide the same results as the explicit algorithm above, but 
  in case of any deviation the explicit algorithm is the normative statement for conformance. </p>
  <ul>
    <li>In rule X9, instead of removing the format codes, assign the embedding level to each 
    embedding character, and turn it into BN.</li>
    <li>In rule X10, assign L or R to the last of a sequence of adjacent BNs according to the eor / 
    sor, and set the level to the higher of the two levels.</li>
    <li>In rule W1, search backwards from each NSM to the first character in the level run whose 
    type is not BN, and set the NSM to its type. If the NSM is the first non-BN character, it will 
    get the type of sor.</li>
    <li>In rule W4, scan past BN types that are adjacent to ES or CS.</li>
    <li>In rule W5, change all appropriate sequences of ET and BN, not just ET.</li>
    <li>In rule W6, change all BN types adjacent to ET, ES, CS to ON as well.</li>
    <li>In rule W7 scan past BN</li>
    <li>In rules N1 and N2 treat BNs adjoining neutrals same as those neutrals</li>
    <li>In rules I1 and I2 ignore BN</li>
    <li>In rule L1, include format codes and BN together with whitespace characters in the sequences 
    whose level gets reset before a separator or line break. Resolve any LRE, RLE, LRO, RLO, PDF or 
    BN to the level of the preceding character if there is one, otherwise to the base level.</li>
  </ul>
  <p>Implementations that display visible representations of format characters will want to adjust 
  this process in order to position the format characters optimally for editing.</p>
  <h3>5.3 <a name="Joiners">Joiners</a></h3>
  <p>As described under <a href="#X9">X9</a>, the Zero Width Joiner and Non Joiner affect the 
  shaping of the adjacent characters—those that are adjacent in the original backing-store 
  order—even though those characters may end up being rearranged to be non-adjacent by the BIDI 
  algorithm. In order to determine the joining behavior of a particular character after applying the 
  BIDI algorithm, there are two main strategies.</p>
  <ul>
    <li>When shaping, an implementation can refer back to the original backing store to see if there 
    were adjacent ZWNJ or ZWJ characters.</li>
    <li>Alternatively, the implementation can replace ZWJ and ZWNJ by an out-of-band character 
    property associated with those adjacent characters, so that the information does not interfere 
    with the BIDI algorithm and the information is preserved across rearrangement of those 
    characters. Once the BIDI algorithm has been applied, that out-of-band information can then be 
    used for proper shaping.</li>
  </ul>
  <h3>5.4 <a name="Vertical_Text">Vertical Text</a><a name="bk3"></a></h3>
  <p>In the case of vertical line orientation, the bidirectional algorithm is still used to 
  determine the levels of the text. However, these levels are not used to reorder the text, since 
  the characters are usually ordered uniformly from top to bottom. Instead, the levels are used to 
  determine the rotation of the text. Sometimes vertical lines follow a vertical baseline in which 
  each character is oriented as normal (with no rotation), with characters ordered from top to 
  bottom whether they are Hebrew, numbers, or Latin. When setting text using the Arabic script in 
  vertical lines, it is more common to employ a horizontal baseline that is rotated by 90° 
  counterclockwise so that the characters are ordered from top to bottom. Latin text and numbers may 
  be rotated 90° clockwise so that the characters are also ordered from top to bottom.</p>
  <p>The bidirectional algorithm also comes into effect when some characters are ordered from bottom 
  to top. For example, this happens with a mixture of Arabic and Latin glyphs when all the glyphs 
  are rotated uniformly 90° clockwise. (The choice of whether text is to be presented horizontally 
  or vertically, or whether text is to be rotated, is not specified by the Unicode Standard, and is 
  left up to higher-level protocols.)</p>
  <h3>5.5 <a name="Usage">Usage</a></h3>
  <p>Because of the implicit character types and the heuristics for resolving neutral and numeric 
  directional behavior, the implicit bidirectional ordering will generally produce the correct 
  display without any further work. However, problematic cases may occur when a right-to-left 
  paragraph begins with left-to-right characters, or there are nested segments of 
  different-direction text, or there are weak characters on directional boundaries. In these cases, 
  embeddings or directional marks may be required to get the right display. Part numbers may also 
  require directional overrides.</p>
  <p>The most common problematic case is that of neutrals on the boundary of an embedded language. 
  This can be addressed by setting the level of the embedded text correctly. For example, with all 
  the text at level 0 the following occurs:</p>
  <pre><b>Memory:  </b>he said &quot;I NEED WATER!&quot;, and expired.

<b>Display: </b>he said &quot;RETAW DEEN I!&quot;, and expired.</pre>
  <p>If the exclamation mark is to be part of the Arabic quotation, then the user can select the 
  text <i>I NEED WATER!</i> and explicitly mark it as embedded Arabic, which produces the following 
  result:</p>
  <pre><b>Memory:</b>  he said &quot;<b>&lt;RLE&gt;</b>I NEED WATER!<b>&lt;PDF&gt;</b>&quot;, and expired.

<b>Display:</b> he said &quot;!RETAW DEEN I&quot;, and expired.</pre>
  <p>A simpler method of doing this is to place a right directional mark (RLM) after the exclamation 
  mark. Since the exclamation mark is now not on a directional boundary, this produces the correct 
  result.</p>
  <pre><b>Memory:</b>  he said &quot;I NEED WATER!<b>&lt;RLM&gt;</b>&quot;, and expired.

<b>Display:</b> he said &quot;!RETAW DEEN I&quot;, and expired.</pre>
  <p>This latter approach is preferred since it does not make use of the stateful format codes, 
  which can easily get out of sync if not fully supported by editors and other string manipulation. 
  The stateful format codes are generally only needed for more complex (and rare) cases such as 
  double embeddings, as in the following:</p>
  <pre><b>Memory:</b>  DID YOU SAY ‘<b>&lt;LRE&gt;</b>he said &quot;I NEED WATER!<b>&lt;RLM&gt;</b>&quot;, and expired.<b>&lt;PDF&gt;</b>’?

<b>Display:</b> ?‘he said &quot;!RETAW DEEN I&quot;, and expired.’ YAS UOY DID</pre>
  <h3>Migrating from 2.0 to 3.0</h3>
  <p>In the Unicode 3.0 Character Database, new bidirectional character types <span>were</span> 
  introduced to make the body of the algorithm depend only on the types of characters, and not on 
  the character values. The changes from the 2.0 bidirectional types are listed in Table 3-9:</p>
  <div align="center">
    <center>
    <table border="1" cellspacing="2" cellpadding="0">
      <caption><b>Table 3-9. New Bidirectional Types in Unicode 3.0</b></caption>
      <tr>
        <th valign="TOP">Characters</th>
        <th valign="TOP">New Bidirectional Type</th>
      </tr>
      <tr>
        <td valign="TOP"><i>All characters with General Category Me, Mn</i></td>
        <td valign="TOP"><i>NSM</i></td>
      </tr>
      <tr>
        <td valign="TOP"><i>All characters of type R in the Arabic ranges (0600-06FF, FB50-FDFF, 
        FE70-FEFE)<br>
        (Letters in the Thaana and Syriac ranges also have this value.)</i></td>
        <td valign="TOP"><i>AL</i></td>
      </tr>
      <tr>
        <td valign="TOP"><i>The explicit embedding characters: LRO, RLO, LRE, RLE, PDF</i></td>
        <td valign="TOP"><i>LRO, RLO, LRE, RLE, PDF, respectively</i></td>
      </tr>
      <tr>
        <td valign="TOP"><i>Formatting characters and controls (General Category Cf and Cc) that 
        were of bidirectional type ON</i></td>
        <td valign="TOP"><i>BN</i></td>
      </tr>
      <tr>
        <td valign="TOP"><i>Zero Width Space</i></td>
        <td valign="TOP"><i>BN</i></td>
      </tr>
    </table>
    </center>
  </div>
  <p>Implementations that use older property tables can adjust to the modifications in the 
  bidirectional algorithm by algorithmically remapping the above characters to the new types.</p>
  <h2 align="left">6 <a name="Mirroring">Mirroring</a></h2>
  <p>The mirrored property is important to ensure that the correct character codes are used for the 
  desired semantic. This is of particular importance where the name of a character does not indicate 
  the intended semantic, such as with <code>U+0028 &quot;(&quot; LEFT PARENTHESIS</code>. While the name 
  indicates that it is a left parenthesis, the character really expresses an <i>open parenthesis</i>
  <font size="3">— the <i>leading</i> character in a parenthetical phrase, not the trailing one.</font>
  </p>
  <p>Note that in some contexts, some of the characters that have the mirrored property are 
  sometimes not rendered with mirrored glyphs. A higher level protocol can limit mirroring action 
  (rule <a href="#L4">L4</a>) to a subset of those with the mirroring property. See also <i>
  <a href="#Higher-Level_Protocols">Section 4.3 Higher-Level Protocols</a></i>. Except in such 
  cases, mirroring must be done by an application of rule L4, to ensure that the correct character 
  code is used to express the intended semantic of the character.</p>
  <p>Implementing rule <a href="#L4">L4</a> calls for mirrored glyphs. These glyphs may not be exact
  <i>graphical</i> mirror images. <font size="3">For example, clearly an italic parenthesis is not 
  an exact mirror image of another: </font><code>&quot;</code><font size="3"><i>(</i></font><code>&quot;</code><font size="3"> 
  vs </font><code>&quot;</code><font size="3"><i>)</i></font><code>&quot;</code><font size="3">. </font>
  Instead, mirror glyphs are those acceptable as mirrors within the normal parameters of the font in 
  which they are represented<font size="3">.</font></p>
  <p><font size="3">In implementation, sometimes pairs of characters are acceptable mirrors for one 
  another: for example</font>, <code>U+0028 &quot;(&quot; LEFT PARENTHESIS</code> and <code>U+0029 &quot;<span>)</span>&quot; 
  RIGHT PARENTHESIS</code> or <code>U+22E0 &quot;</code>⋠<code>&quot; DOES NOT PRECEDE OR EQUAL</code> and
  <code>U+22E1 &quot;</code>⋡<code>&quot; DOES NOT SUCCEED OR EQUAL</code>. Other characters such as <code>
  U+2231 &quot;</code>∱<code>&quot; CLOCKWISE INTEGRAL</code> do not have corresponding characters that can be 
  used for acceptable mirrors. The informative Bidi Mirroring data file <a href="#Data">[Data]</a>, 
  lists the paired characters with acceptable mirror glyphs. A comment in the file indicates where 
  the pairs are &quot;best fit&quot;: they should be acceptable in rendering, although ideally the mirrored 
  glyphs may have somewhat different shapes.</p>
  <h2><a name="Acknowledgements">Acknowledgements</a></h2>
  <p>Thanks to the following people for their contributions to the Bidirectional Algorithm or for 
  their feedback on earlier versions of this document: Alaa Ghoneim (علاء غنيم), Ahmed Talaat (أحمد 
  طلعت), Asmus Freytag, Avery Bishop, Behdad Esfahbod (بهداد اسفهبد), Doug Felt, Eric Mader, <span>
  Ernest Cline, </span>Gidi Shalom-Bendor (גידי שלום-בן דור), Isai Scheinberg, Israel Gidali (ישראל 
  גידלי), Joe Becker, John McConnell, Jonathan Kew, Jonathan Rosenne (יונתן רוזן), Khaled Sherif (خالد 
  شريف), Kamal Mansour (كمال منصور), Kenneth Whistler, Maha Hassan (مها حسن), Markus Scherer, Martin 
  Dürst, Mati Allouche (מתתיהו &nbsp;אלוש), Michel Suignard, Mike Ksar<span> (<span lang="AR-JO">ميشيل 
  قصار</span>)</span>, Murray Sargent, Paul Nelson, Rick McGowan, Roozbeh Pournader (روزبه پورنادر), 
  Steve Atkin, and Thomas Milo (تُومَاسْ مِيلُو).</p>
  <h2><a name="References">References</a></h2>
  <table cellspacing="12" cellpadding="0" border="0" class="noborder" style="border-collapse: collapse">
    <tr>
      <td valign="top" width="1" class="noborder"><a name="Data">[Data]</a></td>
      <td valign="top" class="noborder">Bidi Mirroring<br>
      The latest data file is:<a href="http://www.unicode.org/Public/UNIDATA/BidiMirroring.txt"><br>
      http://www.unicode.org/Public/UNIDATA/BidiMirroring.txt</a>.<br>
      The data file at the time of publication is:<br>
      <a href="http://www.unicode.org/Public/4.1.0/ucd/BidiMirroring.txt">http://www.unicode.org/Public/4.1.0/ucd/BidiMirroring.txt</a>.</td>
    </tr>
    <tr>
      <td class="noborder" valign="top" width="1">[<a name="Feedback">Feedback</a>]</td>
      <td class="noborder" valign="top">Reporting Errors and Requesting Information Online<i><br>
      </i><a href="http://www.unicode.org/reporting.html">http://www.unicode.org/reporting.html</a></td>
    </tr>
    <tr>
      <td class="noborder" valign="top" width="1"><a name="Reports">Reports</a>]</td>
      <td class="noborder" valign="top">Unicode Technical Reports<br>
      <a href="http://www.unicode.org/reports/">http://www.unicode.org/reports/<br>
      </a><i>For information on the status and development process for technical reports, and for a 
      list of technical reports.</i></td>
    </tr>
    <tr>
      <td class="noborder" valign="top" width="1">[<a name="UCD">UCD</a>]</td>
      <td class="noborder" valign="top">Unicode Character Database.<br>
      <a href="http://www.unicode.org/ucd/">http://www.unicode.org/ucd/</a><br>
      <i>For an overview of the Unicode Character Database and a list of its associated files</i></td>
    </tr>
    <tr>
      <td class="noborder" valign="top" width="1">[<a name="Unicode">Unicode</a>]</td>
      <td class="noborder" valign="top">The Unicode Consortium.
      <a href="http://www.unicode.org/versions/Unicode4.0.0/">The Unicode Standard, Version 4.0</a>. 
      Reading, MA, Addison-Wesley, 2003. 0-321-18578-1.</td>
    </tr>
    <tr>
      <td class="noborder" valign="top" width="1">[<a name="Versions">Versions</a>]</td>
      <td class="noborder" valign="top">Versions of the Unicode Standard<br>
      <a href="http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a><br>
      <i>For information on version numbering, and citing and referencing the Unicode Standard, 
      the Unicode Character Database, and Unicode Technical Reports.</i></td>
    </tr>
    </table>
  <h2><a name="Modifications">Modifications</a></h2>
  <p>The following summarizes modifications from previous revisions of this document.</p>
  <h3><b>Revision <a name="TrackingNumber15">15</a></b>:</h3>
  <ul>
    <li><span>Minor editing</span></li>
    <li><span>Fixed Section Number for Mirroring</span></li>
    <li><span>Changed &quot;Tracking Number&quot; to Revision</span></li>
    <li><span>Added note on U+0CBF KANNADA VOWEL SIGN I</span></li>
    <li><span>Added note after N1, and clarified example after N2.</span></li>
    <li><span>Fixed references to sections of the Unicode Standard</span></li>
  </ul>
  <h3><b>Revision </b><a name="TrackingNumber14">14</a>:</h3>
  <ul>
    <li><span>Aliased directional run and level run</span></li>
    <li><span>Pointed to DerivedBidiClass.txt for unassigned character assignments.</span></li>
  </ul>
  <h3><b>Revision </b><a name="TrackingNumber13">13</a>:</h3>
  <ul>
    <li><a href="#Bidirectional_Conformance">4. Bidirectional Conformance</a>: added explicit 
    clauses.</li>
    <li><a href="#Higher-Level_Protocols">4.3. Higher-Level Protocols</a>:
    <ul>
      <li>Added clarifying text, and renumbered options.</li>
      <li>Removed option regarding number shaping (since it was irrelevant to bidirectional 
      ordering).</li>
      <li>Broadened the ability to override on the basis of context, and clarified number handling.</li>
      <li>Made clear that bidi could be applied to segments</li>
    </ul>
    </li>
    <li><a href="#3.1_Bidirectional_Behavior">1. Introduction</a>: added note that the changes in
    <a href="#Bidirectional_Conformance">4. Bidirectional Conformance</a> override clause C13 of 
    Unicode 4.0 [<a href="#Unicode">Unicode</a>], and tighten the conformance requirements from what 
    they had been previously.</li>
    <li>Minor editing for clarification.</li>
  </ul>
  <h3><b>Revision </b><a name="TrackingNumber11">11</a>:</h3>
  <ul>
    <li>Updated for Unicode 4.0.</li>
    <li>Added note on <a href="#canonical_equivalence">canonical equivalence</a></li>
    <li>Added <a href="#Joiners">Joiners</a> section on ZWJ and ZWNJ</li>
    <li>Clarified <a href="#L2">L2</a> and examples following.</li>
    <li>Added a section on the interaction of <a href="#Shaping">shaping</a> and bidirectional 
    reordering.</li>
    <li>Moved lists for unassigned characters into UCD.html (also now explicit in 
    DerivedBidiClass.txt)</li>
    <li>Updated references for Newline Guidelines (since the UAX is incorporated into the 4.0 book)</li>
    <li>The first two sections were rearranged, with <a href="#Reference_Code">Reference Code</a> 
    going into <a href="#Implementation_Notes">Implementation Notes</a>, and <a href="#Mirroring">
    Mirroring</a> in its own section at the end.
    <ul>
      <li>This is <i>not</i> highlighted in the proposed text.</li>
    </ul>
    </li>
    <li>Sections were renumbered and the table of contents is more detailed.
    <ul>
      <li>This is <i>not</i> highlighted in the proposed text.</li>
    </ul>
    </li>
    <li>Misc editing.</li>
  </ul>
  <h3><b>Revision </b><a name="TrackingNumber10">10</a>:</h3>
  <ul>
    <li>Updated for Unicode 3.2.</li>
    <li>Updated UAX boilerplate in the status section.</li>
  </ul>
  <h3><b>Revision </b><a name="TrackingNumber9">9</a>:</h3>
  <ul>
    <li>Clarified the language of <a href="#P2">P2</a></li>
    <li>Corrected the implementation note on &quot;Retaining Format Codes&quot; in
    <a href="#Implementation_Notes">Implementation Notes</a></li>
    <li>Minor editing</li>
  </ul>
  <hr>
  <p class="copyright">Copyright © 2000-200<span>5</span> Unicode, Inc. All Rights Reserved. The 
  Unicode Consortium makes no expressed or implied warranty of any kind, and assumes no liability 
  for errors or omissions. No liability is assumed for incidental and consequential damages in 
  connection with or arising out of the use of the information or programs contained or accompanying 
  this technical report. The Unicode <a href="http://www.unicode.org/copyright.html">Terms of Use</a> 
  apply.</p>
  <p class="copyright">Unicode and the Unicode logo are trademarks of Unicode, Inc., and are 
  registered in some jurisdictions.</div>

</body>

</html>
