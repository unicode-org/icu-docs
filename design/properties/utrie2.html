<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html >
<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<meta name="COPYRIGHT" content="Copyright (C) 2008, International Business Machines Corporation and others. All Rights Reserved." />
<title>ICU UTrie Version 2</title>
</head>
<body>
<div id="doc-contents">
<h1 id="i6qz">ICU UTrie Version 2</h1><div id="dyjk" style="text-align: right;">Markus Scherer<br id="dyjk0">Created 2008-08-27<br>Stable URL: <a title="http://bugs.icu-project.org/trac/browser/icuhtml/trunk/design/properties/utrie2.html" href="http://bugs.icu-project.org/trac/browser/icuhtml/trunk/design/properties/utrie2.html" id="iz4b">http://bugs.icu-project.org/trac/browser/icuhtml/trunk/design/properties/utrie2.html</a> <br id="dyjk1"></div>ICU UTrie ("version 1") see <a title="source/common/utrie.h" href="http://bugs.icu-project.org/trac/browser/icu/trunk/source/common/utrie.h" id="wod:">source/common/utrie.h</a> and <a title="src/com/ibm/icu/impl/Trie.java" href="http://bugs.icu-project.org/trac/browser/icu4j/trunk/src/com/ibm/icu/impl/Trie.java" id="u47r">src/com/ibm/icu/impl/Trie.java</a> <br id="i6qz0"><h2 id="v-ey">Goals</h2><ul id="r0lr"><li id="r0lr0">Easier to use</li></ul><ul id="v-ey0"><li id="v-ey3">Smaller runtime code</li><li id="r0lr1">Better performance for UTF-8 string processing</li></ul><h2 id="v-ey5">Before UTrie<br id="ccex"></h2>ICU's original
CompactByteArray and its siblings only supported BMP code points. They
used an index table with the upper 7 bits and a data table with the
lower 9 bits of a BMP code point. UTrie added support for supplementary
code points.<br id="xrgo"><h2 id="rpjn">UTrie Version 1<br id="rpjn0"></h2>The current UTrie was designed in 2001 for fast processing of UTF-16 text, initially in the normalization code. The usage model is optimized for BMP code points, without looking up data for supplementary code points (or even detecting surrogates) unless the data value for a lead surrogate indicates that some of its associated supplementary code points are not "inert" (have non-trivial data).<br id="lv3:"><br id="e5v5">UTrie was then adopted for collation with the same usage model; and adopted for character properties and case mappings etc. but with separately assembling whole code points and doing by-code-point rather than by-code-unit lookups.<br id="yezy"><br id="yezy0">An option was added for making the Latin-1 portion of the data array linear, for the Latin-1 fastpath in the collation code.<br id="kcup"><br id="kcup0"><b id="kcup1">The version 1 design in short:</b><br id="cq3p1"><ul id="cq3p2"><li id="cq3p3">Fast UTF-16 processing by code unit, without having to assemble complete code points before lookup</li><li id="cq3p4">Data value for a lead surrogate code unit</li><ol id="nan8"><li id="nan80">indicates whether the 1024 supplementary code points associated with it have non-trivial data,<br id="nan81"></li><li id="nan82">and, if so, contains an offset into the index table to use with a second lookup for the trail surrogate code unit<br id="nan83"></li></ol><li id="nan84">Lookup by code point was bolted on</li><li id="nan86">UTF-8 was ignored</li></ul><h2 id="cq3p0">Issues</h2><h3 id="xrgo0">"Folded Trie" Hard to Use<br id="a2ni"></h3>As a result of the design goal, the two-table structure from the preceding CompactXyzArray was retained for maximum speed, still limited to BMP code points to keep the size of the index table reasonable. To support supplementary code points, the data value for a lead surrogate code unit contains an indicator for "some of my supplementary code points have real data", and in that case also an offset needed for a second lookup with the trail surrogate.<br id="an4c"><br id="an4c0">At build time, one "folding" function has to be provided, and at runtime its inverse function has to be set. These functions, and the value format (bit fields) for lead surrogate code units, are custom-designed for each piece of code (normalization, collation, ...) using UTrie.<br id="cuu8"><br id="cuu80"><b id="afi7">Issues</b>: This technique is hard to explain, and the custom value format and folding functions take some thought. In addition, there is data for 1024 more entities than there are Unicode code points: <i id="lews">There is different data for lead surrogate code <u id="lews0">units</u> and lead surrogate code <u id="lews1">points</u>.</i><br id="lews2"><br id="lews3">As a mitigating factor, default folding functions were later added for less-sophisticated usage models.<br id="pjcj"><br id="pjcj0"><b id="pjcj1">Another issue</b>: There
are too many runtime macros to access data: By code point, BMP code
point, Latin-1 code point (only if built that way),
BMP-or-lead-surrogate, surrogate pair, or
lead-surrogate-data-plus-trail-surrogate. (In addition to UTF-16
iteration convenience macros.)<br id="arfz"><h3 id="erjg">Bolt-On Code Point Lookup</h3>There are by-code-point access macros that work with this data structure. They have two branches: For BMP code points (with an added conditional for lead surrogate code <u id="g8050">points</u>), and for supplementary code points (lead lookup, call to folding function, maybe trail lookup).<br id="e38e"><br id="e38e0"><b id="afi70">Issue </b>(not a big one): Clunky, and a fair bit of code, although it works fine. On the other hand, <i id="pa7e">this has become the most common usage model</i>, because we have not bothered designing highly optimized, custom UTF-16 data and folding functions for anything other than normalization and collation.<br id="d6tu"><h3 id="d6tu0">Large "Empty" Tries</h3>Regardless of the data in the UTrie, the index table is always at least 4kB large. This is because<br id="afi71"><ul id="afi72"><li id="afi73">The index table is linear for BMP code points</li><li id="afi74">UTrie uses 11 bits of a BMP code point for the index table, and only 5 bits for the data table</li></ul><br id="t2sp">11 bits for the index table, with 16-bit index values, is 2^11 * 16b = 2048 * 2B = 4kB.<br id="z2i3"><br id="t2sp0">The 11:5 bit split is the result of measuring the sizes of data using UTrie at the time (normalization &amp; character properties?), and picking the split with the minimum total data size. The data measured there was relatively large. (Later, after adding more properties, we split the character properties into more pieces, each with its own UTrie. This might benefit from a smaller index table.)<br id="t2sp1"><br id="wn:y0"><b id="afi76">Issue</b> (not a big one?): The relatively large size of a UTrie even for little data is a bit inconvenient. Some environments are very sensitive to memory usage.<br id="l:gf"><h3 id="bz5i">Not Designed for UTF-8</h3>The only reasonable way to use UTrie for UTF-8 text processing is to assemble full code points (U8_NEXT()), check for errors (c&lt;0), and use the per-code-point lookup, which is clunky (see above). With a Latin-1-linear UTrie, ASCII characters can be looked up fast.<br id="fr.6"><br id="bqhq"><b id="yger">Issue</b>: Inconvenient to use with UTF-8. Sub-optimal performance.<br id="urw1"><h3 id="n44o">Too Many Options</h3>Latin-1-linear is optional.<br id="efka"><br id="kbex">There are too many options and function parameters for building a UTrie. For example, parameters for maximum build-time data size are ok for offline build tools but hard to use and not appropriate for runtime use.<br id="t4c.0"><br id="t4c.1"><b id="kbex0">Issue</b>: Options require documentation and thinking. Those that affect the data structure (Latin-1-linear) are not changeable without data format versioning.<br id="kbex1"><br id="kbex2">Mitigating factor: Build-time options that do not affect the data structure are changeable. (UTrie is not public API.)<br id="xvy-"><h3 id="skdg">Builder "Memory" Management</h3>At build time, the data is already allocated as needed, rather than starting from a linear array with a data entry per Unicode code point. The maximum length of the build-time data array is set at the beginning.<br id="p5ab"><br id="p5ab0"><b id="bghc">Small issue</b>: If the initial data length is too small, then adding too much data will result in error return values.<br id="i4jd"><br id="i4jd0">In a tool (like gennorm), the code would have to be changed to increase the number. At runtime, one could either specify a large data array or retry building the UTrie with a larger size.<br id="k_f5"><br id="glli">Also, there is a function to set the same value for a range of code points (e.g., properties for Han characters). The version 1 builder code loses track of such data blocks if a different value is set for the same range.<br id="ob0w"><br id="ob0w0"><b id="bghc0">Tiny issue</b>: With a pathological call pattern (changing the value of the same range of code points thousands of times), the data array will overflow even if only a very small number of data blocks would suffice.<br id="bivk"><br id="ob0w1">These are not very problematic in practice because the UTrie is not directly available through public API, and it is built without pathological call patterns.<br id="bqhq0"><h2 id="ftyd">UTrie Version 2</h2>I propose a new version to address most or all of the version-1 issues.<br id="a2ni0"><h3 id="a2ni1">Three-table Lookup Instead of "Folding"<br id="x:a2"></h3>I believe now that the "folding" is overkill, with its custom data structure, custom folding functions, and different data for lead surrogate code units vs. code points.<br id="fdrx"><br id="fdrx0"><b id="nock">The natural alternative</b> is a three-table (double-index) data structure,
to keep it small with support for all of Unicode. No separate data for lead surrogate code <u id="n4.v">units</u>. By-code-point lookup is much simpler. However, this slows down BMP lookups. If this is a problem,
then <u id="wg0u">an additional BMP-only index table can be added</u> (either at build time or at runtime) for faster
from-BMP lookups, mostly for use with the fast-UTF-16 usage model.<br id="vdww"><br id="vdww0">I believe that for fastest UTF-16 processing the same general idea as with version 1 can be used anyway: For those optimized processes, there is generally only trivial data for surrogate code points, so they could be handled as "no data" when unpaired surrogates are encountered (malformed UTF-16). Indicators for "some of my supplementary code points have real data" could be stored for lead surrogate code points and the initial lookup could still be by code unit, to avoid always checking the code unit for surrogates. If there is a special indicator, then simply do assemble the full code point and do another lookup for that. This should be hardly slower than for version 1 (which would make a function call), and only occurs for relatively rare supplementary code points.<br id="o4yb"><br id="o4yb0"><b id="h..q">Advantages</b>: Simpler structure, much simpler per-code-point lookups, no custom folding functions, not necessarily custom value formats, easier to explain and use. Fewer runtime macros. Much smaller "empty" tries if the BMP-only index table is not added.<br id="d9v."><br id="h..q0"><b id="pbzs">Done</b>: Benchmark the performance benefit and size increase of adding the BMP-only index vs. always using the three-table lookup. Needs a realistic piece of code using this processing model. (Performance difference is significant. Tested mostly FCD quick check but also NFC.)<br id="alju"><h3 id="d1e0">No Option for Latin-1-Linear Data</h3>Latin-1-linear data appears to be only used in collation. Together with copying Latin-1 UCA data to each tailoring table, we speed up the data access, but the data becomes bigger, which can be a problem for low-memory environments.<br id="i90f"><br id="i90f0"><b id="ooau">Instead</b>, in collation we could allocate and compute a linear Latin-1 table with UCA fallback data at load time.<br id="kdve"><br id="kdve0"><b id="kdve1">Advantages</b>: Removes an option, could make some collation tables smaller.<br id="efka0"><br id="efka1">I would also remove as many of the build-time options as possible.<br id="te9m"><h3 id="urw11">UTF-8 and Smaller "Empty" Tries</h3>For UTF-8, with its 6 data bits per trail byte, the natural split of code point bits for the three lookup tables is <b id="zli5">9:6:6</b>, with the first 9 bits only partially used. (272 entries in the first index table.) ASCII data is linear, followed by a special data values block that is used for illegal UTF-8 byte sequences (including for trail bytes in lead position).<br id="nm2v"><br id="nm2v0">Two special (short) index blocks are used for lead bytes for 2-byte and 3-byte UTF-8. They differ from the regular index entries where lead bytes (C0, C1, E0, ED) may start illegal but "structurally ok" byte sequences; lookups for these result in special illegal-UTF-8 data values. 3-byte UTF-8 lookups and normal lookups share most second-index-table blocks, except that UTF-8 needs two additional index blocks for lead bytes E0 and ED for non-shortest/illegal forms.<br id="haz7"><br id="haz70">With this, a reasonably-sized macro can be written with inline code for BMP lookups, without explicit detection of non-shortest forms or surrogates (which just result in values from the special data block), and without having to assemble a BMP code point.<br id="onsa"><div id="onsa0" style="margin-left: 40px;">Sketch of UTRIE2_U8_NEXT():<br id="onsa1">Read one byte<br id="t:7.">if &lt;C0 (ASCII, or trail byte in lead position): result=ascii[byte]<br id="vfny">else if &lt;E0 (2-byte lead) and followed by 1 valid trail byte: result=data[index_2B[lead]+trail]<br id="cssf">else if &lt;F0 (3-byte lead) and followed by 2 valid trail bytes: result=data[index[index_3B[lead]+trail1]+trail2]<br id="e9jt">else call function to handle illegal sequences and 4-byte UTF-8<br id="o9t."></div><br id="o9t.0">If a BMP-only index table is added (for fast UTF-16), it's half as long as for version 1 because of the 10:6 bits split rather than the 11:5 split.<br id="hgrf"><br id="hgrf0"><b id="ynfk">Advantages</b>: Fast data lookups for UTF-8 text. Smaller "empty" tries, especially without BMP-only index table.<br id="n78p"><br id="n78p0"><b id="n78p1">Disadvantage</b>: Larger data blocks tend to compress somewhat less well.<br id="ftyd0"><br id="fg:q"><b id="wa:g">Done</b>: Benchmark the performance benefit of this optimized UTF-8-iteration-lookup vs. U8_NEXT()→error check→version-2 code point lookup. (A UTF-8 version of the FCD quick check is significantly faster with the optimized lookup. Up to about 2/3 faster for 1/2-byte UTF-8, up to about 1/3 faster for 3-byte UTF-8.)<br id="wa:g0"><br id="wa:g1">If the performance benefit is very small, then the additional index and data blocks could be omitted (but they are short) and the bits split could be different from 9:6:6 (but if a BMP-only index table is added, the last number should still be increased to greater than 5).<br id="yyd."><br id="yyd.0">It seems like there is little reason not to design it this way even if the performance benefit is small, unless there is otherwise not enough evidence that the redesign as a whole is worth it.<br id="bghc1"><h3 id="gxda">Better Builder "Memory" Management</h3>When working on a new UTrie version, I am planning to use data block reference counting at build time (fairly easy), and to eliminate the initial guess for the data array length and just growing the data array as needed (trivial).<br id="fi3w"><h2 id="fi3w0">Is It Worth It?</h2><b id="njyb">Disadvantages</b>: Takes some time to design, code, test, and benchmark. (Less than 2 weeks for C++? Starting from existing version 1, not from scratch.) Could be used immediately in non-persistent data structures (including hardcoded Unicode data), but version 1 would have to remain in use until we are ready to version-upgrade all affected data formats. (Collation, RBBI, and StringPrep. We could support both versions at runtime.)<br id="s.50"><br id="s.500"><b id="s.501">Done</b>: Benchmark normalization-type UTF-16 processing code with version 1 vs. version 2. (Mixed model has the same performance as version 1, using the same data structure.)<br id="q4p3"><b id="hk25">Done</b>: Benchmark the performance benefit of the optimized UTF-8-iteration-lookup vs. U8_NEXT()→error check→version-<u id="smo2">1</u> code point lookup. (Mixed model: Some 40%..200% faster.)<br id="t82q"><b id="rlyj">Done</b>: Compare data sizes with version 1 vs. version 2. (Mixed model: 0..10% bigger tries, based on debug output from makedata building all data files. Note that much ICU data is not in tries.)<br id="yyd.2"><br id="bqhq1"><b id="ck2g">Done</b>: Weigh advantages and disadvantages, benchmark results and size differences. Decide. (Recommending mixed model, see near the bottom of this document.)<br><h2>Experiments, Decisions and Results</h2><div style="text-align: right;">Markus Scherer 2008-sep-24<br></div><b>Shift sizes and code point bits: </b>The 9:6:6 bits split chosen for optimal UTF-8 performance, or any x:y:6 split, makes some tries up to 20% larger because data blocks cannot be overlapped as well. Instead, <b>I am opting for x:y:5 splits</b> like in version 1. In order to maintain UTF-8 performance, data blocks for code points up to U+07FF still use a block length of 64, so that 2-byte UTF-8 lookup can use a 5:6 split regardless of the split for other code points. Together, the changes for 1/2-byte UTF-8 make tries a little bit larger than in version 1, by 0..10%.<br><br><b>Index shift: </b>UTrie version 1 supports up to 256k data values by shifting index values left two bits. This is rarely necessary, but we do have data, for example for Unihan collation, with tries holding about 72000 data values, which is a little more than one per Han character. I experimented with not shifting the index values, but the performance did not improve, trie sizes went down only marginally, and it would have needed a more complicated data structure and builder to support a total of more than 64k data values. I am opting to <b>keep the index shift</b> and the 256k data values limit.<br><br><b>Three-table lookup: </b>This proves to be a good replacement for the version 1 "folding" mechanism. It is relatively easy to build, uses small runtime code, and there is no complicated mechanism exposed to UTrie2 users. With x:y:5 splits, trie sizes increase at most by a few percent, and much of that is due to the special 1/2-byte UTF-8 data. With a pure three-table structure, a 9:7:5 bits split and no linear BMP index, some trie sizes actually <u>de</u>crease by up to 20%.<br><br><b>Linear BMP index: </b>The drawback of the three-table lookup is that
high-performance UTF-16 code (normalization &amp; collation) becomes
noticeably slower, by roughly a third. I tried to work around this with an
optional runtime BMP index table which is trivial to build but costs
4kB of memory (at x:y:5) and adds complexity back into using tries. Performance results were inconclusive, possibly due to code alignment or due to it using
two arrays and pointers (one for the runtime BMP index) where for FCD (16-bit values) the
version 1 code uses just one (with index and data sharing an array).
(With a BMP index inside the serialized form, version 2 also uses just one array and pointer.) Always adding the linear BMP index table to the serialized form makes
tries always larger than in version 1. I am opting to <b>add the linear BMP index</b> table for best performance, and to reduce the size increase by <b>truncating the first index table</b> (see mixed model below) and not adding special 3-byte UTF-8 index portions (see the following UTF-8 section).<br><br><b>UTF-8 performance: </b>Comparing FCD UTRIE2_U8_NEXT_16() vs. U8_NEXT()+UTRIE_GET16()<sub>(version 1)</sub>, ASCII becomes roughly three times faster and 2-byte UTF-8 (e.g., Cyrillic) becomes roughly twice as fast. The improvement is lower, but still significant, for 3-byte UTF-8. The best 3-byte UTF-8 performance seems to be with a 9:6:6 bits split (as expected), but with 9:7:5 it is not much slower. Using an 11:5 split with a linear BMP index table in the serialized form (like in a version 1 UTrie) was just as fast as the 9:7:5 on one machine, but a little slower again on another machine. Given the size increase for the additional index blocks just for 3-byte UTF-8 compared with the small performance gain relative to using a linear BMP table, I am opting to <b>not design the index specially for 3-byte UTF-8</b>. This then also allows for flexibility in the choice of the second-index block size: Where the special 3-byte UTF-8 index portions work better with a 9:7:5 bits split (so that the lead byte alone is used with the first index table), without these special index portions a different bits split can be chosen to minimize the average trie size.<br><br><b>Mixed model: I am opting for a compromise:</b><br><ul><li><b>BMP: 11:5 bits split with linear index</b> like in version 1.</li><li>The last single-value code point range (ending with U+10FFFF) is stored with its starting code point (<b>highStart</b>) and its lookup value. Supplementary code points in this high range yield a fixed value. For trie enumeration, the starting code point even serves to cut short BMP enumeration.</li><li>For <b>supplementary </b>code points between U+10000 and the highStart, a normal <b>three-table lookup</b> is performed. The first index table is <b>truncated according to highStart</b> and does not have entries for the BMP either. If highStart&lt;=U+10000 then there is no index-1 table at all. The best bits split seems to be <b>10:6:5</b>.<br></li><li>UTF-8:<br></li><ul><li>Linear ASCII data, plus error values for UTF-8 trail bytes in lead position, for maximum single-byte performance. (First 0xc0=192 data values.)<br></li><li>5:6 bits split and special index table for 2-byte UTF-8, for maximum 2-byte performance. (A null data block of 64 entries, and compaction using a 64-entry block length for data for code points up to U+07FF.)<br></li><li>3-byte UTF-8 uses the normal BMP data structure, and the "next" macros handle U+0000..U+CFFF inline.<br></li></ul></ul><br><b>Results: </b>Users need not learn about "folding" or another complicated mechanism. The implementation takes no parameters other than those necessary for defining the contents of the trie. Such tries are between 0% and 10% larger than version 1 tries, optimized UTF-16 performance is maintained, UTF-8 "next" is fast, and code point lookups are simpler than in version 1. "Empty" tries will still be about as large as before (actually very slightly larger).<br><h2>Other Changes etc.</h2><h3>Error Value</h3>UTrie (version 1) only has one distinguished value, the <b>initialValue</b> that is preset for all code points. UTrie2 adds a second distinguished value, the <b>errorValue</b>, which is returned for out-of-range code points and illegal UTF-8 byte sequences. I am using this in the converter selector, where the initialValue is all-zeros (by default, code points cannot be converted by any of the converters) but the errorValue is all-ones (convertible by all converters). During conversion selection for a string, per-code point bit vectors are ANDed together, and the all-ones errorValue does not modify the result while the all-zeros initialValue would make the string not convertible at all. (The actual conversion will replace illegal UTF-8 with U+FFFD or similar.)<br><h3>Build-Time Enumeration</h3>UTrie can only enumerate a runtime trie.<br>UTrie2 has a function to enumerate a build-time trie, and it works before and after serialization.<br>UTrie2 also has a function to enumerate the supplementary code points associated with a lead surrogate, replacing the folding callback function with a simpler and more familiar mechanism.<br><br>All of the UTrie2 enumeration functions have nearly the same signatures (and use callback types identical to those used with UTrie) and share a common implementation.<br><h2>Issue: Efficient UTF-16 String Processing vs. By-Code-Point Lookup</h2>The new design is simpler partly because it does not provide for separate lookup values for lead surrogate code <u>points</u> vs. code <u>units</u>. By-code-point lookups are therefore simpler. Efficient UTF-16 string processing (in normalization and collation) uses lead surrogate code <u>point</u> values via normal from-BMP lookup.<br><br>However, normalization does not only involve efficient UTF-16 string processing, but there are also by-code-point functions that return normalization-related character properties, such as the canonical combining class. In addition, trie enumeration (used to find code points where properties change, for UnicodeSet building) will deliver the lead surrogate values although they don't really belong into the code point space. All of these functions now need extra care and code to test for lead surrogate code points, and for these to return the initialValue rather than doing a trie lookup. (This is probably a much smaller issue for collation.)<br><br>Choices:<br><ul><li>This may be acceptable. (But complicates by-code-point functions.)<br></li><li>We may try to redesign normalization string processing, for example using the internals of fast/frozen UnicodeSets to span parts of the string that are "inert". (But that adds more data structures and complicates the code further.)</li><li>We may re-introduce the separation of lead surrogate code <u>point</u>/code <u>unit</u> values. <b>[Done]</b> This time I would leave code <u>point</u> values in the normal data structure to keep most use cases simple. <b>[No]</b> There could be 32 extra index-2 entries atop the BMP index-2 table for the lead surrogate code <u>unit</u> lookup. <b>[Yes]</b> Normalization would use an additional BMP index-2 table for UTF-16 string processing, copied from the normal one but with the lead surrogate range overwritten from the extra index-2 part. <b>[No, instead the main index-2 table is optimized for code units.]</b> There may not need to be new public macros if only normalization uses this mechanism.<br>Collation may not need this if it just takes care of the lead surrogate code points in the few by-code-point functions.<br>No other current trie users would use this mechanism.<br>The function that builds a UTrie2 from a UTrie would always copy lead surrogate code <u>unit</u> values, but may still need its boolean parameter for whether to copy them to the lead surrogate code <u>points</u> as well. (If that's what collation needs.) <b>[Not necessary]</b><br></li></ul><h2>Review Feedback and Partial Redesign</h2><div style="text-align: right;">Review 2008-oct-09 with Andy Heninger<br></div>Change to use a single "public" type, UTrie2, instead of an additional UNewTrie2.<br><ul><li>Struct with runtime values and a pointer to the builder data structure.</li><li>Open/close model.</li><li>Single get/enum functions that work either way.</li><li>Remove getData(): Error-prone, and can be replaced with enumeration.</li><li>Full Freezable API: build() becomes freeze(), add isFrozen, clone() becomes cloneAsThawed(). Maybe add regular clone() too which "clones as frozen" (if the source is indeed frozen).</li><li>Can't serialize() multiple times to <i>different </i>valueBits because freeze() will create one single runtime version. (Could cloneAsThawed() and freeze/serialize separately if needed.)</li><li>Remove unserializeDummy(): Open a trie, don't add data, and freeze it.</li><ul><li><b>Withdrawn</b>, keeping the function but renaming to utrie2_openDummy(): The direct function is more efficient than open+freeze, and especially does not add a dependency on the builder code.<br></li></ul><li>Document that macros will crash when used on an un-frozen UTrie2 (or one frozen to the other valueBits).<br></li></ul><br>Remove GETxx_FROM_SUPP() macros: Use utrie2_get32() function instead. (Should be fast enough for supplementary code points.)<br><div style="margin-left: 40px;"><b>Withdrawn</b>, leaving the _SUPP macros: They are already developed, and they are harmless. It is possible to use utrie2_get32() if desired.<br></div><br>Re-add distinct values for lead surrogate code <u>units</u> vs. code <u>points</u>, much like in UTrie version 1, with faster access (_FROM_LEAD macros) for lead code unit access, and with clunkier from-code-point macros, like before. Need utrie2_setLeadSurrogateXyz() function. Remove _FROM_BMP macros [rename to _FROM_LEAD, really]. Keeps fast UTF-16 processing and yet simple by-code-point lookups.<br><br>In order to keep macro expansions small, think about taking some of their implementations (for code point &gt;=U+D800) out into function calls.<br><div style="margin-left: 40px;">Not done yet, possible to do in the future.<br></div><br>Reorganize header file (try anyway):<br><ul><li>Easy-to-use stuff first, including the get32() function.<br></li><li>Then fast-runtime macros for code point access.</li><li>Then fast-runtime macros for UTF-16 and UTF-8.</li><li>Then internals: struct definition and internal macros.<br></li></ul><h2>Final Summary</h2><div style="text-align: right;">2008-oct-22<br></div>Most of the decisions from 2008-sep-24 remain unchanged, with the exception that UTrie2 again supports separate values for lead surrogate code <i>units</i> vs. code <i>points</i> (but does not require the code unit values any more for normal usage).<br><br>The API changes after Andy's initial review make UTrie2 much easier to use than UTrie.<br><br>UTrie2 was added to the ICU4C trunk in SVN revision 24862 on 2008-oct-22. It is initially used in hardcoded Unicode character properties and in the ucnvsel_ (converter selector) implementation.<br>
<br clear="all"/>
</div>
</body>
</html>
