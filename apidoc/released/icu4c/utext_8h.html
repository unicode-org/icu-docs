<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ICU 69.1: utext.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ICU 69.1
   &#160;<span id="projectnumber">69.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bdd9a5d540de89e9fe90efdfc6973a4f.html">common</a></li><li class="navelem"><a class="el" href="dir_f59c6450ff718ff1b085cfd1c36acbd7.html">unicode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">utext.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C API: Abstract Unicode Text API.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="utypes_8h_source.html">unicode/utypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="uchar_8h_source.html">unicode/uchar.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="localpointer_8h_source.html">unicode/localpointer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rep_8h_source.html">unicode/rep.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="unistr_8h_source.html">unicode/unistr.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="chariter_8h_source.html">unicode/chariter.h</a>&quot;</code><br />
</div>
<p><a href="utext_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUTextFuncs.html">UTextFuncs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">(public) Function dispatch table for <a class="el" href="structUText.html" title="UText struct.">UText</a>.  <a href="structUTextFuncs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUText.html">UText</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structUText.html" title="UText struct.">UText</a> struct.  <a href="structUText.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceicu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicu.html">icu</a></td></tr>
<tr class="memdesc:namespaceicu"><td class="mdescLeft">&#160;</td><td class="mdescRight">File <a class="el" href="coll_8h.html" title="C++ API: Collation Service.">coll.h</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:afedc50a892711dbf795af1fb8aac40cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#afedc50a892711dbf795af1fb8aac40cf">UTEXT_CURRENT32</a>(ut)</td></tr>
<tr class="memdesc:afedc50a892711dbf795af1fb8aac40cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline version of <a class="el" href="utext_8h.html#af172215348343ca5cbfe8afa741dca98" title="Get the code point at the current iteration position, or U_SENTINEL (-1) if the iteration has reached...">utext_current32()</a>, for performance-critical situations.  <a href="utext_8h.html#afedc50a892711dbf795af1fb8aac40cf">More...</a><br /></td></tr>
<tr class="separator:afedc50a892711dbf795af1fb8aac40cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b973aeeb5f10f8aec454545f85b6a2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#aa4b973aeeb5f10f8aec454545f85b6a2">UTEXT_NEXT32</a>(ut)</td></tr>
<tr class="memdesc:aa4b973aeeb5f10f8aec454545f85b6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline version of <a class="el" href="utext_8h.html#af0ef1bd96a7aea7c86b527a6175c54ff" title="Get the code point at the current iteration position of the UText, and advance the position to the fi...">utext_next32()</a>, for performance-critical situations.  <a href="utext_8h.html#aa4b973aeeb5f10f8aec454545f85b6a2">More...</a><br /></td></tr>
<tr class="separator:aa4b973aeeb5f10f8aec454545f85b6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa3d9bae7b252622fe8e70e87758205"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a8aa3d9bae7b252622fe8e70e87758205">UTEXT_PREVIOUS32</a>(ut)</td></tr>
<tr class="memdesc:a8aa3d9bae7b252622fe8e70e87758205"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline version of <a class="el" href="utext_8h.html#a282a69979e9479fe9b9c006f81ed74b6" title="Move the iterator position to the character (code point) whose index precedes the current position,...">utext_previous32()</a>, for performance-critical situations.  <a href="utext_8h.html#a8aa3d9bae7b252622fe8e70e87758205">More...</a><br /></td></tr>
<tr class="separator:a8aa3d9bae7b252622fe8e70e87758205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a003b461019bea876827b8b24cb364"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a23a003b461019bea876827b8b24cb364">UTEXT_GETNATIVEINDEX</a>(ut)</td></tr>
<tr class="memdesc:a23a003b461019bea876827b8b24cb364"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline version of <a class="el" href="utext_8h.html#ae60a026b3159c2b95e5d6e0a86ac0a72" title="Get the current iterator position, which can range from 0 to the length of the text.">utext_getNativeIndex()</a>, for performance-critical situations.  <a href="utext_8h.html#a23a003b461019bea876827b8b24cb364">More...</a><br /></td></tr>
<tr class="separator:a23a003b461019bea876827b8b24cb364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74aa6ff1add5886508657997ca8d4747"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a74aa6ff1add5886508657997ca8d4747">UTEXT_SETNATIVEINDEX</a>(ut,  ix)</td></tr>
<tr class="memdesc:a74aa6ff1add5886508657997ca8d4747"><td class="mdescLeft">&#160;</td><td class="mdescRight">inline version of <a class="el" href="utext_8h.html#adc484cb765c4ef02d740b55b9cbc5b34" title="Set the current iteration position to the nearest code point boundary at or preceding the specified i...">utext_setNativeIndex()</a>, for performance-critical situations.  <a href="utext_8h.html#a74aa6ff1add5886508657997ca8d4747">More...</a><br /></td></tr>
<tr class="separator:a74aa6ff1add5886508657997ca8d4747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc916f710c0d3f17fe2a220384bcc8c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a3dc916f710c0d3f17fe2a220384bcc8c">UTEXT_INITIALIZER</a></td></tr>
<tr class="memdesc:a3dc916f710c0d3f17fe2a220384bcc8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">initializer to be used with local (stack) instances of a <a class="el" href="structUText.html" title="UText struct.">UText</a> struct.  <a href="utext_8h.html#a3dc916f710c0d3f17fe2a220384bcc8c">More...</a><br /></td></tr>
<tr class="separator:a3dc916f710c0d3f17fe2a220384bcc8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8da22111033cc0c063d89cae348ec1e4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structUText.html">UText</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a8da22111033cc0c063d89cae348ec1e4">UText</a></td></tr>
<tr class="memdesc:a8da22111033cc0c063d89cae348ec1e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">C typedef for struct <a class="el" href="structUText.html" title="UText struct.">UText</a>.  <a href="utext_8h.html#a8da22111033cc0c063d89cae348ec1e4">More...</a><br /></td></tr>
<tr class="separator:a8da22111033cc0c063d89cae348ec1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29be5a512f69c3a9d871890225d07ec"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ae29be5a512f69c3a9d871890225d07ec">UTextClone</a>(<a class="el" href="structUText.html">UText</a> *dest, const <a class="el" href="structUText.html">UText</a> *src, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> deep, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:ae29be5a512f69c3a9d871890225d07ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type declaration for UText.clone().  <a href="utext_8h.html#ae29be5a512f69c3a9d871890225d07ec">More...</a><br /></td></tr>
<tr class="separator:ae29be5a512f69c3a9d871890225d07ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36bad470545b3183fff611c91312cc10"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a36bad470545b3183fff611c91312cc10">UTextNativeLength</a>(<a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:a36bad470545b3183fff611c91312cc10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type declaration for UText.nativeLength().  <a href="utext_8h.html#a36bad470545b3183fff611c91312cc10">More...</a><br /></td></tr>
<tr class="separator:a36bad470545b3183fff611c91312cc10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829af7190e7cee22c647af949ebb4730"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a829af7190e7cee22c647af949ebb4730">UTextAccess</a>(<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeIndex, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> forward)</td></tr>
<tr class="memdesc:a829af7190e7cee22c647af949ebb4730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type declaration for UText.access().  <a href="utext_8h.html#a829af7190e7cee22c647af949ebb4730">More...</a><br /></td></tr>
<tr class="separator:a829af7190e7cee22c647af949ebb4730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d7c17254aee81ba7ccf7acdf79f2dd"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a62d7c17254aee81ba7ccf7acdf79f2dd">UTextExtract</a>(<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeStart, int64_t nativeLimit, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *dest, int32_t destCapacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a62d7c17254aee81ba7ccf7acdf79f2dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type declaration for UText.extract().  <a href="utext_8h.html#a62d7c17254aee81ba7ccf7acdf79f2dd">More...</a><br /></td></tr>
<tr class="separator:a62d7c17254aee81ba7ccf7acdf79f2dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a84b5d0d434b0f1f71f77841cac3d97"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a0a84b5d0d434b0f1f71f77841cac3d97">UTextReplace</a>(<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeStart, int64_t nativeLimit, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *replacementText, int32_t replacmentLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a0a84b5d0d434b0f1f71f77841cac3d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type declaration for UText.replace().  <a href="utext_8h.html#a0a84b5d0d434b0f1f71f77841cac3d97">More...</a><br /></td></tr>
<tr class="separator:a0a84b5d0d434b0f1f71f77841cac3d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad017072290f396d7bce8fb0712a232e8"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ad017072290f396d7bce8fb0712a232e8">UTextCopy</a>(<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeStart, int64_t nativeLimit, int64_t nativeDest, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> move, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:ad017072290f396d7bce8fb0712a232e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type declaration for UText.copy().  <a href="utext_8h.html#ad017072290f396d7bce8fb0712a232e8">More...</a><br /></td></tr>
<tr class="separator:ad017072290f396d7bce8fb0712a232e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78b6ae4b98958554b7ee15de57e9c30"><td class="memItemLeft" align="right" valign="top">typedef int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#aa78b6ae4b98958554b7ee15de57e9c30">UTextMapOffsetToNative</a>(const <a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:aa78b6ae4b98958554b7ee15de57e9c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type declaration for UText.mapOffsetToNative().  <a href="utext_8h.html#aa78b6ae4b98958554b7ee15de57e9c30">More...</a><br /></td></tr>
<tr class="separator:aa78b6ae4b98958554b7ee15de57e9c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14d770b0feb53e5c4677f998e6b5ad0"><td class="memItemLeft" align="right" valign="top">typedef int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ab14d770b0feb53e5c4677f998e6b5ad0">UTextMapNativeIndexToUTF16</a>(const <a class="el" href="structUText.html">UText</a> *ut, int64_t nativeIndex)</td></tr>
<tr class="memdesc:ab14d770b0feb53e5c4677f998e6b5ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type declaration for UText.mapIndexToUTF16().  <a href="utext_8h.html#ab14d770b0feb53e5c4677f998e6b5ad0">More...</a><br /></td></tr>
<tr class="separator:ab14d770b0feb53e5c4677f998e6b5ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689fd4dcd7e392532f979af8b33273b5"><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a689fd4dcd7e392532f979af8b33273b5">UTextClose</a>(<a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:a689fd4dcd7e392532f979af8b33273b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function type declaration for UText.utextClose().  <a href="utext_8h.html#a689fd4dcd7e392532f979af8b33273b5">More...</a><br /></td></tr>
<tr class="separator:a689fd4dcd7e392532f979af8b33273b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf57d3fd11db28583a36df05ec02295"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structUTextFuncs.html">UTextFuncs</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#acaf57d3fd11db28583a36df05ec02295">UTextFuncs</a></td></tr>
<tr class="memdesc:acaf57d3fd11db28583a36df05ec02295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function dispatch table for <a class="el" href="structUText.html" title="UText struct.">UText</a>.  <a href="utext_8h.html#acaf57d3fd11db28583a36df05ec02295">More...</a><br /></td></tr>
<tr class="separator:acaf57d3fd11db28583a36df05ec02295"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a80155586fa275b28773c9b203f52caba"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="utext_8h.html#a80155586fa275b28773c9b203f52cabaa752c07f9df260b5b0e234e15eab97f9f">UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE</a> = 1
, <a class="el" href="utext_8h.html#a80155586fa275b28773c9b203f52cabaa52bb5c9cacd1f46eb87a856c71c073be">UTEXT_PROVIDER_STABLE_CHUNKS</a> = 2
, <a class="el" href="utext_8h.html#a80155586fa275b28773c9b203f52cabaac67ce6ecf6bf959645e282f7194fbe3b">UTEXT_PROVIDER_WRITABLE</a> = 3
, <a class="el" href="utext_8h.html#a80155586fa275b28773c9b203f52cabaa40c5cd24aea472f3752b4833b9ce63ca">UTEXT_PROVIDER_HAS_META_DATA</a> = 4
, <br />
&#160;&#160;<a class="el" href="utext_8h.html#a80155586fa275b28773c9b203f52cabaa75695072a896ec104b5d77598a7429f7">UTEXT_PROVIDER_OWNS_TEXT</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:a80155586fa275b28773c9b203f52caba"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structUText.html" title="UText struct.">UText</a> provider properties (bit field indexes).  <a href="utext_8h.html#a80155586fa275b28773c9b203f52caba">More...</a><br /></td></tr>
<tr class="separator:a80155586fa275b28773c9b203f52caba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b7b47dd702d9e331586d485013fd1ea"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>UTEXT_MAGIC</b> = 0x345ad82c
 }</td></tr>
<tr class="separator:a6b7b47dd702d9e331586d485013fd1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a731e5f580e2dd29125d657fc73575650"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a731e5f580e2dd29125d657fc73575650">utext_close</a> (<a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:a731e5f580e2dd29125d657fc73575650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close function for <a class="el" href="structUText.html" title="UText struct.">UText</a> instances.  <a href="utext_8h.html#a731e5f580e2dd29125d657fc73575650">More...</a><br /></td></tr>
<tr class="separator:a731e5f580e2dd29125d657fc73575650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3bbaca4b8512ea4ccffb53b6bbc615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a6e3bbaca4b8512ea4ccffb53b6bbc615">utext_openUTF8</a> (<a class="el" href="structUText.html">UText</a> *ut, const char *s, int64_t length, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a6e3bbaca4b8512ea4ccffb53b6bbc615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a read-only <a class="el" href="structUText.html" title="UText struct.">UText</a> implementation for UTF-8 strings.  <a href="utext_8h.html#a6e3bbaca4b8512ea4ccffb53b6bbc615">More...</a><br /></td></tr>
<tr class="separator:a6e3bbaca4b8512ea4ccffb53b6bbc615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b84faeb2a42a991f09cfa95125e3ab6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a2b84faeb2a42a991f09cfa95125e3ab6">utext_openUChars</a> (<a class="el" href="structUText.html">UText</a> *ut, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *s, int64_t length, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a2b84faeb2a42a991f09cfa95125e3ab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a read-only <a class="el" href="structUText.html" title="UText struct.">UText</a> for UChar * string.  <a href="utext_8h.html#a2b84faeb2a42a991f09cfa95125e3ab6">More...</a><br /></td></tr>
<tr class="separator:a2b84faeb2a42a991f09cfa95125e3ab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1035b627c7442bbc371e44591b8b7f08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a1035b627c7442bbc371e44591b8b7f08">utext_openUnicodeString</a> (<a class="el" href="structUText.html">UText</a> *ut, <a class="el" href="classicu_1_1UnicodeString.html">icu::UnicodeString</a> *s, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a1035b627c7442bbc371e44591b8b7f08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a writable <a class="el" href="structUText.html" title="UText struct.">UText</a> for a non-const UnicodeString.  <a href="utext_8h.html#a1035b627c7442bbc371e44591b8b7f08">More...</a><br /></td></tr>
<tr class="separator:a1035b627c7442bbc371e44591b8b7f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedce99c2389ca5e41eedea6c5de975bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#aedce99c2389ca5e41eedea6c5de975bb">utext_openConstUnicodeString</a> (<a class="el" href="structUText.html">UText</a> *ut, const <a class="el" href="classicu_1_1UnicodeString.html">icu::UnicodeString</a> *s, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:aedce99c2389ca5e41eedea6c5de975bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a <a class="el" href="structUText.html" title="UText struct.">UText</a> for a const UnicodeString.  <a href="utext_8h.html#aedce99c2389ca5e41eedea6c5de975bb">More...</a><br /></td></tr>
<tr class="separator:aedce99c2389ca5e41eedea6c5de975bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9cf656b684432d206716190e35e086b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ad9cf656b684432d206716190e35e086b">utext_openReplaceable</a> (<a class="el" href="structUText.html">UText</a> *ut, <a class="el" href="classicu_1_1Replaceable.html">icu::Replaceable</a> *rep, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:ad9cf656b684432d206716190e35e086b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a writable <a class="el" href="structUText.html" title="UText struct.">UText</a> implementation for an ICU Replaceable object.  <a href="utext_8h.html#ad9cf656b684432d206716190e35e086b">More...</a><br /></td></tr>
<tr class="separator:ad9cf656b684432d206716190e35e086b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5674cd8dbf3889f4c2a1991e18b8103"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ab5674cd8dbf3889f4c2a1991e18b8103">utext_openCharacterIterator</a> (<a class="el" href="structUText.html">UText</a> *ut, <a class="el" href="classicu_1_1CharacterIterator.html">icu::CharacterIterator</a> *ci, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:ab5674cd8dbf3889f4c2a1991e18b8103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a <a class="el" href="structUText.html" title="UText struct.">UText</a> implementation over an ICU CharacterIterator.  <a href="utext_8h.html#ab5674cd8dbf3889f4c2a1991e18b8103">More...</a><br /></td></tr>
<tr class="separator:ab5674cd8dbf3889f4c2a1991e18b8103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c33ebb0432549dd4416831529cc5129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a9c33ebb0432549dd4416831529cc5129">utext_clone</a> (<a class="el" href="structUText.html">UText</a> *dest, const <a class="el" href="structUText.html">UText</a> *src, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> deep, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> readOnly, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a9c33ebb0432549dd4416831529cc5129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone a <a class="el" href="structUText.html" title="UText struct.">UText</a>.  <a href="utext_8h.html#a9c33ebb0432549dd4416831529cc5129">More...</a><br /></td></tr>
<tr class="separator:a9c33ebb0432549dd4416831529cc5129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ddfa74dc6b21800ecef9bf78ec7183"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ac5ddfa74dc6b21800ecef9bf78ec7183">utext_equals</a> (const <a class="el" href="structUText.html">UText</a> *a, const <a class="el" href="structUText.html">UText</a> *b)</td></tr>
<tr class="memdesc:ac5ddfa74dc6b21800ecef9bf78ec7183"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two <a class="el" href="structUText.html" title="UText struct.">UText</a> objects for equality.  <a href="utext_8h.html#ac5ddfa74dc6b21800ecef9bf78ec7183">More...</a><br /></td></tr>
<tr class="separator:ac5ddfa74dc6b21800ecef9bf78ec7183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca73bb6edbb923e9592fb12dd1f2df2e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#aca73bb6edbb923e9592fb12dd1f2df2e">utext_nativeLength</a> (<a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:aca73bb6edbb923e9592fb12dd1f2df2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the text.  <a href="utext_8h.html#aca73bb6edbb923e9592fb12dd1f2df2e">More...</a><br /></td></tr>
<tr class="separator:aca73bb6edbb923e9592fb12dd1f2df2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb379348a9d63704cf15202f855d8c86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#acb379348a9d63704cf15202f855d8c86">utext_isLengthExpensive</a> (const <a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:acb379348a9d63704cf15202f855d8c86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if calculating the length of the text could be expensive.  <a href="utext_8h.html#acb379348a9d63704cf15202f855d8c86">More...</a><br /></td></tr>
<tr class="separator:acb379348a9d63704cf15202f855d8c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19b6f9e616e8cd6f0509989495cce62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ac19b6f9e616e8cd6f0509989495cce62">utext_char32At</a> (<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeIndex)</td></tr>
<tr class="memdesc:ac19b6f9e616e8cd6f0509989495cce62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the code point at the requested index, or U_SENTINEL (-1) if it is out of bounds.  <a href="utext_8h.html#ac19b6f9e616e8cd6f0509989495cce62">More...</a><br /></td></tr>
<tr class="separator:ac19b6f9e616e8cd6f0509989495cce62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af172215348343ca5cbfe8afa741dca98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#af172215348343ca5cbfe8afa741dca98">utext_current32</a> (<a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:af172215348343ca5cbfe8afa741dca98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the code point at the current iteration position, or U_SENTINEL (-1) if the iteration has reached the end of the input text.  <a href="utext_8h.html#af172215348343ca5cbfe8afa741dca98">More...</a><br /></td></tr>
<tr class="separator:af172215348343ca5cbfe8afa741dca98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ef1bd96a7aea7c86b527a6175c54ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#af0ef1bd96a7aea7c86b527a6175c54ff">utext_next32</a> (<a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:af0ef1bd96a7aea7c86b527a6175c54ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the code point at the current iteration position of the <a class="el" href="structUText.html" title="UText struct.">UText</a>, and advance the position to the first index following the character.  <a href="utext_8h.html#af0ef1bd96a7aea7c86b527a6175c54ff">More...</a><br /></td></tr>
<tr class="separator:af0ef1bd96a7aea7c86b527a6175c54ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a282a69979e9479fe9b9c006f81ed74b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a282a69979e9479fe9b9c006f81ed74b6">utext_previous32</a> (<a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:a282a69979e9479fe9b9c006f81ed74b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the iterator position to the character (code point) whose index precedes the current position, and return that character.  <a href="utext_8h.html#a282a69979e9479fe9b9c006f81ed74b6">More...</a><br /></td></tr>
<tr class="separator:a282a69979e9479fe9b9c006f81ed74b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b4f05c43927c1e261e3779afb4fc75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ae1b4f05c43927c1e261e3779afb4fc75">utext_next32From</a> (<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeIndex)</td></tr>
<tr class="memdesc:ae1b4f05c43927c1e261e3779afb4fc75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iteration index and return the code point at that index.  <a href="utext_8h.html#ae1b4f05c43927c1e261e3779afb4fc75">More...</a><br /></td></tr>
<tr class="separator:ae1b4f05c43927c1e261e3779afb4fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1227561991ca6c5c6048bc7f697a7ddb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a1227561991ca6c5c6048bc7f697a7ddb">utext_previous32From</a> (<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeIndex)</td></tr>
<tr class="memdesc:a1227561991ca6c5c6048bc7f697a7ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iteration index, and return the code point preceding the one specified by the initial index.  <a href="utext_8h.html#a1227561991ca6c5c6048bc7f697a7ddb">More...</a><br /></td></tr>
<tr class="separator:a1227561991ca6c5c6048bc7f697a7ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60a026b3159c2b95e5d6e0a86ac0a72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ae60a026b3159c2b95e5d6e0a86ac0a72">utext_getNativeIndex</a> (const <a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:ae60a026b3159c2b95e5d6e0a86ac0a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current iterator position, which can range from 0 to the length of the text.  <a href="utext_8h.html#ae60a026b3159c2b95e5d6e0a86ac0a72">More...</a><br /></td></tr>
<tr class="separator:ae60a026b3159c2b95e5d6e0a86ac0a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc484cb765c4ef02d740b55b9cbc5b34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#adc484cb765c4ef02d740b55b9cbc5b34">utext_setNativeIndex</a> (<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeIndex)</td></tr>
<tr class="memdesc:adc484cb765c4ef02d740b55b9cbc5b34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the current iteration position to the nearest code point boundary at or preceding the specified index.  <a href="utext_8h.html#adc484cb765c4ef02d740b55b9cbc5b34">More...</a><br /></td></tr>
<tr class="separator:adc484cb765c4ef02d740b55b9cbc5b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3dd31ef0447087bf79e0ddd94c5f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a2b3dd31ef0447087bf79e0ddd94c5f94">utext_moveIndex32</a> (<a class="el" href="structUText.html">UText</a> *ut, int32_t delta)</td></tr>
<tr class="memdesc:a2b3dd31ef0447087bf79e0ddd94c5f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the iterator position by delta code points.  <a href="utext_8h.html#a2b3dd31ef0447087bf79e0ddd94c5f94">More...</a><br /></td></tr>
<tr class="separator:a2b3dd31ef0447087bf79e0ddd94c5f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7be685a54292cf85337d1413a36df05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ad7be685a54292cf85337d1413a36df05">utext_getPreviousNativeIndex</a> (<a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:ad7be685a54292cf85337d1413a36df05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the native index of the character preceding the current position.  <a href="utext_8h.html#ad7be685a54292cf85337d1413a36df05">More...</a><br /></td></tr>
<tr class="separator:ad7be685a54292cf85337d1413a36df05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d532d7ab06e7463e3236947ccf0905d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a6d532d7ab06e7463e3236947ccf0905d">utext_extract</a> (<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeStart, int64_t nativeLimit, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *dest, int32_t destCapacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a6d532d7ab06e7463e3236947ccf0905d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract text from a <a class="el" href="structUText.html" title="UText struct.">UText</a> into a UChar buffer.  <a href="utext_8h.html#a6d532d7ab06e7463e3236947ccf0905d">More...</a><br /></td></tr>
<tr class="separator:a6d532d7ab06e7463e3236947ccf0905d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad925ba6bff38fb82a1664ff127c94483"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ad925ba6bff38fb82a1664ff127c94483">utext_isWritable</a> (const <a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:ad925ba6bff38fb82a1664ff127c94483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the text can be written (modified) with <a class="el" href="utext_8h.html#ad99a769d1cd16b673838d4598ec6f156" title="Replace a range of the original text with a replacement text.">utext_replace()</a> or <a class="el" href="utext_8h.html#aaf801e5846bb75b47f6e9ded1e777197" title="Copy or move a substring from one position to another within the text, while retaining any metadata a...">utext_copy()</a>.  <a href="utext_8h.html#ad925ba6bff38fb82a1664ff127c94483">More...</a><br /></td></tr>
<tr class="separator:ad925ba6bff38fb82a1664ff127c94483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46302dca5dc2c6da7766d944bcda38fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#a46302dca5dc2c6da7766d944bcda38fb">utext_hasMetaData</a> (const <a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="memdesc:a46302dca5dc2c6da7766d944bcda38fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether there is meta data associated with the text.  <a href="utext_8h.html#a46302dca5dc2c6da7766d944bcda38fb">More...</a><br /></td></tr>
<tr class="separator:a46302dca5dc2c6da7766d944bcda38fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99a769d1cd16b673838d4598ec6f156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ad99a769d1cd16b673838d4598ec6f156">utext_replace</a> (<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeStart, int64_t nativeLimit, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *replacementText, int32_t replacementLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:ad99a769d1cd16b673838d4598ec6f156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace a range of the original text with a replacement text.  <a href="utext_8h.html#ad99a769d1cd16b673838d4598ec6f156">More...</a><br /></td></tr>
<tr class="separator:ad99a769d1cd16b673838d4598ec6f156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf801e5846bb75b47f6e9ded1e777197"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#aaf801e5846bb75b47f6e9ded1e777197">utext_copy</a> (<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeStart, int64_t nativeLimit, int64_t destIndex, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> move, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:aaf801e5846bb75b47f6e9ded1e777197"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy or move a substring from one position to another within the text, while retaining any metadata associated with the text.  <a href="utext_8h.html#aaf801e5846bb75b47f6e9ded1e777197">More...</a><br /></td></tr>
<tr class="separator:aaf801e5846bb75b47f6e9ded1e777197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad73beaba24a19d8f06058f75e9cc23ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#ad73beaba24a19d8f06058f75e9cc23ad">utext_freeze</a> (<a class="el" href="structUText.html">UText</a> *ut)</td></tr>
<tr class="separator:ad73beaba24a19d8f06058f75e9cc23ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf69b0c8fba92943144faa446519b739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utext_8h.html#abf69b0c8fba92943144faa446519b739">utext_setup</a> (<a class="el" href="structUText.html">UText</a> *ut, int32_t extraSpace, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:abf69b0c8fba92943144faa446519b739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common function for use by Text Provider implementations to allocate and/or initialize a new <a class="el" href="structUText.html" title="UText struct.">UText</a> struct.  <a href="utext_8h.html#abf69b0c8fba92943144faa446519b739">More...</a><br /></td></tr>
<tr class="separator:abf69b0c8fba92943144faa446519b739"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C API: Abstract Unicode Text API. </p>
<p>The Text Access API provides a means to allow text that is stored in alternative formats to work with ICU services. ICU normally operates on text that is stored in UTF-16 format, in (UChar *) arrays for the C APIs or as type UnicodeString for C++ APIs.</p>
<p>ICU Text Access allows other formats, such as UTF-8 or non-contiguous UTF-16 strings, to be placed in a <a class="el" href="structUText.html" title="UText struct.">UText</a> wrapper and then passed to ICU services.</p>
<p>There are three general classes of usage for <a class="el" href="structUText.html" title="UText struct.">UText</a>: </p><pre class="fragment">Application Level Use.  This is the simplest usage - applications would
use one of the utext_open() functions on their input text, and pass
the resulting UText to the desired ICU service.

Second is usage in ICU Services, such as break iteration, that will need to
operate on input presented to them as a UText.  These implementations
will need to use the iteration and related UText functions to gain
access to the actual text.

The third class of UText users are "text providers."  These are the
UText implementations for the various text storage formats.  An application
or system with a unique text storage format can implement a set of
UText provider functions for that format, which will then allow
ICU services to operate on that format.
</pre><p><em>Iterating over text</em></p>
<p>Here is sample code for a forward iteration over the contents of a <a class="el" href="structUText.html" title="UText struct.">UText</a></p>
<div class="fragment"><div class="line"><a class="code" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>  c;</div>
<div class="line"><a class="code" href="structUText.html">UText</a>    *ut = whatever();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span> (c=<a class="code" href="utext_8h.html#ae1b4f05c43927c1e261e3779afb4fc75">utext_next32From</a>(ut, 0); c&gt;=0; c=<a class="code" href="utext_8h.html#af0ef1bd96a7aea7c86b527a6175c54ff">utext_next32</a>(ut)) {</div>
<div class="line">   <span class="comment">// do whatever with the codepoint c here.</span></div>
<div class="line">}</div>
<div class="ttc" id="astructUText_html"><div class="ttname"><a href="structUText.html">UText</a></div><div class="ttdoc">UText struct.</div><div class="ttdef"><b>Definition:</b> <a href="utext_8h_source.html#l01328">utext.h:1328</a></div></div>
<div class="ttc" id="aumachine_8h_html_a09fff5c3b5a5b015324dc3ec3cf92809"><div class="ttname"><a href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a></div><div class="ttdeci">int32_t UChar32</div><div class="ttdoc">Define UChar32 as a type for single Unicode code points.</div><div class="ttdef"><b>Definition:</b> <a href="umachine_8h_source.html#l00467">umachine.h:467</a></div></div>
<div class="ttc" id="autext_8h_html_ae1b4f05c43927c1e261e3779afb4fc75"><div class="ttname"><a href="utext_8h.html#ae1b4f05c43927c1e261e3779afb4fc75">utext_next32From</a></div><div class="ttdeci">U_CAPI UChar32 utext_next32From(UText *ut, int64_t nativeIndex)</div><div class="ttdoc">Set the iteration index and return the code point at that index.</div></div>
<div class="ttc" id="autext_8h_html_af0ef1bd96a7aea7c86b527a6175c54ff"><div class="ttname"><a href="utext_8h.html#af0ef1bd96a7aea7c86b527a6175c54ff">utext_next32</a></div><div class="ttdeci">U_CAPI UChar32 utext_next32(UText *ut)</div><div class="ttdoc">Get the code point at the current iteration position of the UText, and advance the position to the fi...</div></div>
</div><!-- fragment --><p>And here is similar code to iterate in the reverse direction, from the end of the text towards the beginning.</p>
<div class="fragment"><div class="line"><a class="code" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a>  c;</div>
<div class="line"><a class="code" href="structUText.html">UText</a>    *ut = whatever();</div>
<div class="line"><span class="keywordtype">int</span>      textLength = <a class="code" href="utext_8h.html#aca73bb6edbb923e9592fb12dd1f2df2e">utext_nativeLength</a>(ut);</div>
<div class="line"><span class="keywordflow">for</span> (c=<a class="code" href="utext_8h.html#a1227561991ca6c5c6048bc7f697a7ddb">utext_previous32From</a>(ut, textLength); c&gt;=0; c=<a class="code" href="utext_8h.html#a282a69979e9479fe9b9c006f81ed74b6">utext_previous32</a>(ut)) {</div>
<div class="line">   <span class="comment">// do whatever with the codepoint c here.</span></div>
<div class="line">}</div>
<div class="ttc" id="autext_8h_html_a1227561991ca6c5c6048bc7f697a7ddb"><div class="ttname"><a href="utext_8h.html#a1227561991ca6c5c6048bc7f697a7ddb">utext_previous32From</a></div><div class="ttdeci">U_CAPI UChar32 utext_previous32From(UText *ut, int64_t nativeIndex)</div><div class="ttdoc">Set the iteration index, and return the code point preceding the one specified by the initial index.</div></div>
<div class="ttc" id="autext_8h_html_a282a69979e9479fe9b9c006f81ed74b6"><div class="ttname"><a href="utext_8h.html#a282a69979e9479fe9b9c006f81ed74b6">utext_previous32</a></div><div class="ttdeci">U_CAPI UChar32 utext_previous32(UText *ut)</div><div class="ttdoc">Move the iterator position to the character (code point) whose index precedes the current position,...</div></div>
<div class="ttc" id="autext_8h_html_aca73bb6edbb923e9592fb12dd1f2df2e"><div class="ttname"><a href="utext_8h.html#aca73bb6edbb923e9592fb12dd1f2df2e">utext_nativeLength</a></div><div class="ttdeci">U_CAPI int64_t utext_nativeLength(UText *ut)</div><div class="ttdoc">Get the length of the text.</div></div>
</div><!-- fragment --><p><em>Characters and Indexing</em></p>
<p>Indexing into text by <a class="el" href="structUText.html" title="UText struct.">UText</a> functions is nearly always in terms of the native indexing of the underlying text storage. The storage format could be UTF-8 or UTF-32, for example. When coding to the <a class="el" href="structUText.html" title="UText struct.">UText</a> access API, no assumptions can be made regarding the size of characters, or how far an index may move when iterating between characters.</p>
<p>All indices supplied to <a class="el" href="structUText.html" title="UText struct.">UText</a> functions are pinned to the length of the text. An out-of-bounds index is not considered to be an error, but is adjusted to be in the range 0 &lt;= index &lt;= length of input text.</p>
<p>When an index position is returned from a <a class="el" href="structUText.html" title="UText struct.">UText</a> function, it will be a native index to the underlying text. In the case of multi-unit characters, it will always refer to the first position of the character, never to the interior. This is essentially the same thing as saying that a returned index will always point to a boundary between characters.</p>
<p>When a native index is supplied to a <a class="el" href="structUText.html" title="UText struct.">UText</a> function, all indices that refer to any part of a multi-unit character representation are considered to be equivalent. In the case of multi-unit characters, an incoming index will be logically normalized to refer to the start of the character.</p>
<p>It is possible to test whether a native index is on a code point boundary by doing a <a class="el" href="utext_8h.html#adc484cb765c4ef02d740b55b9cbc5b34" title="Set the current iteration position to the nearest code point boundary at or preceding the specified i...">utext_setNativeIndex()</a> followed by a <a class="el" href="utext_8h.html#ae60a026b3159c2b95e5d6e0a86ac0a72" title="Get the current iterator position, which can range from 0 to the length of the text.">utext_getNativeIndex()</a>. If the index is returned unchanged, it was on a code point boundary. If an adjusted index is returned, the original index referred to the interior of a character.</p>
<p><em>Conventions for calling <a class="el" href="structUText.html" title="UText struct.">UText</a> functions</em></p>
<p>Most <a class="el" href="structUText.html" title="UText struct.">UText</a> access functions have as their first parameter a (<a class="el" href="structUText.html" title="UText struct.">UText</a> *) pointer, which specifies the <a class="el" href="structUText.html" title="UText struct.">UText</a> to be used. Unless otherwise noted, the pointer must refer to a valid, open <a class="el" href="structUText.html" title="UText struct.">UText</a>. Attempting to use a closed <a class="el" href="structUText.html" title="UText struct.">UText</a> or passing a NULL pointer is a programming error and will produce undefined results or NULL pointer exceptions.</p>
<p>The UText_Open family of functions can either open an existing (closed) <a class="el" href="structUText.html" title="UText struct.">UText</a>, or heap allocate a new <a class="el" href="structUText.html" title="UText struct.">UText</a>. Here is sample code for creating a stack-allocated <a class="el" href="structUText.html" title="UText struct.">UText</a>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">char</span>     *s = whatever();  <span class="comment">// A utf-8 string </span></div>
<div class="line">U_ErrorCode status = <a class="code" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78caa43dbfc9499c5f911d04e1a0ca3bf6f9">U_ZERO_ERROR</a>;</div>
<div class="line"><a class="code" href="structUText.html">UText</a>    ut = <a class="code" href="utext_8h.html#a3dc916f710c0d3f17fe2a220384bcc8c">UTEXT_INITIALIZER</a>;</div>
<div class="line"><a class="code" href="utext_8h.html#a6e3bbaca4b8512ea4ccffb53b6bbc615">utext_openUTF8</a>(ut, s, -1, &amp;status);</div>
<div class="line"><span class="keywordflow">if</span> (<a class="code" href="utypes_8h.html#a4d202200b6aa6f3c965ea370e0c8155f">U_FAILURE</a>(status)) {</div>
<div class="line">    <span class="comment">// error handling</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// work with the UText</span></div>
<div class="line">}</div>
<div class="ttc" id="autext_8h_html_a3dc916f710c0d3f17fe2a220384bcc8c"><div class="ttname"><a href="utext_8h.html#a3dc916f710c0d3f17fe2a220384bcc8c">UTEXT_INITIALIZER</a></div><div class="ttdeci">#define UTEXT_INITIALIZER</div><div class="ttdoc">initializer to be used with local (stack) instances of a UText struct.</div><div class="ttdef"><b>Definition:</b> <a href="utext_8h_source.html#l01558">utext.h:1558</a></div></div>
<div class="ttc" id="autext_8h_html_a6e3bbaca4b8512ea4ccffb53b6bbc615"><div class="ttname"><a href="utext_8h.html#a6e3bbaca4b8512ea4ccffb53b6bbc615">utext_openUTF8</a></div><div class="ttdeci">U_CAPI UText * utext_openUTF8(UText *ut, const char *s, int64_t length, UErrorCode *status)</div><div class="ttdoc">Open a read-only UText implementation for UTF-8 strings.</div></div>
<div class="ttc" id="autypes_8h_html_a3343c1c8a8377277046774691c98d78caa43dbfc9499c5f911d04e1a0ca3bf6f9"><div class="ttname"><a href="utypes_8h.html#a3343c1c8a8377277046774691c98d78caa43dbfc9499c5f911d04e1a0ca3bf6f9">U_ZERO_ERROR</a></div><div class="ttdeci">@ U_ZERO_ERROR</div><div class="ttdoc">No error, no warning.</div><div class="ttdef"><b>Definition:</b> <a href="utypes_8h_source.html#l00449">utypes.h:449</a></div></div>
<div class="ttc" id="autypes_8h_html_a4d202200b6aa6f3c965ea370e0c8155f"><div class="ttname"><a href="utypes_8h.html#a4d202200b6aa6f3c965ea370e0c8155f">U_FAILURE</a></div><div class="ttdeci">#define U_FAILURE(x)</div><div class="ttdoc">Does the error code indicate a failure?</div><div class="ttdef"><b>Definition:</b> <a href="utypes_8h_source.html#l00719">utypes.h:719</a></div></div>
</div><!-- fragment --><p>Any existing <a class="el" href="structUText.html" title="UText struct.">UText</a> passed to an open function <em>must</em> have been initialized, either by the UTEXT_INITIALIZER, or by having been originally heap-allocated by an open function. Passing NULL will cause the open function to heap-allocate and fully initialize a new <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>

<p class="definition">Definition in file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="afedc50a892711dbf795af1fb8aac40cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedc50a892711dbf795af1fb8aac40cf">&#9670;&nbsp;</a></span>UTEXT_CURRENT32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UTEXT_CURRENT32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ut</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((ut)-&gt;chunkOffset &lt; (ut)-&gt;chunkLength &amp;&amp; ((ut)-&gt;chunkContents)[(ut)-&gt;chunkOffset]&lt;0xd800 ? \</div>
<div class="line">    ((ut)-&gt;chunkContents)[((ut)-&gt;chunkOffset)] : <a class="code" href="utext_8h.html#af172215348343ca5cbfe8afa741dca98">utext_current32</a>(ut))</div>
<div class="ttc" id="autext_8h_html_af172215348343ca5cbfe8afa741dca98"><div class="ttname"><a href="utext_8h.html#af172215348343ca5cbfe8afa741dca98">utext_current32</a></div><div class="ttdeci">U_CAPI UChar32 utext_current32(UText *ut)</div><div class="ttdoc">Get the code point at the current iteration position, or U_SENTINEL (-1) if the iteration has reached...</div></div>
</div><!-- fragment -->
<p>inline version of <a class="el" href="utext_8h.html#af172215348343ca5cbfe8afa741dca98" title="Get the code point at the current iteration position, or U_SENTINEL (-1) if the iteration has reached...">utext_current32()</a>, for performance-critical situations. </p>
<p>Get the code point at the current iteration position of the <a class="el" href="structUText.html" title="UText struct.">UText</a>. Returns U_SENTINEL (-1) if the position is at the end of the text.</p>
<dl class="internal"><dt><b><a class="el" href="internal.html#_internal000150">Internal:</a></b></dt><dd>Do not use. This API is for internal use only. ICU 4.4 technology preview </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l00687">687</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="a23a003b461019bea876827b8b24cb364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a003b461019bea876827b8b24cb364">&#9670;&nbsp;</a></span>UTEXT_GETNATIVEINDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UTEXT_GETNATIVEINDEX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ut</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((ut)-&gt;chunkOffset &lt;= (ut)-&gt;nativeIndexingLimit?   \</div>
<div class="line">        (ut)-&gt;chunkNativeStart+(ut)-&gt;chunkOffset :     \</div>
<div class="line">        (ut)-&gt;pFuncs-&gt;mapOffsetToNative(ut))</div>
</div><!-- fragment -->
<p>inline version of <a class="el" href="utext_8h.html#ae60a026b3159c2b95e5d6e0a86ac0a72" title="Get the current iterator position, which can range from 0 to the length of the text.">utext_getNativeIndex()</a>, for performance-critical situations. </p>
<p>Get the current iterator position, which can range from 0 to the length of the text. The position is a native index into the input text, in whatever format it may have (possibly UTF-8 for example), and may not always be the same as the corresponding UChar (UTF-16) index. The returned position will always be aligned to a code point boundary.</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003235">Stable:</a></b></dt><dd>ICU 3.6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l00734">734</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="a3dc916f710c0d3f17fe2a220384bcc8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dc916f710c0d3f17fe2a220384bcc8c">&#9670;&nbsp;</a></span>UTEXT_INITIALIZER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UTEXT_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">                  {                                        \</div>
<div class="line">                  UTEXT_MAGIC,          <span class="comment">/* magic                */</span> \</div>
<div class="line">                  0,                    <span class="comment">/* flags                */</span> \</div>
<div class="line">                  0,                    <span class="comment">/* providerProps        */</span> \</div>
<div class="line">                  sizeof(<a class="code" href="structUText.html">UText</a>),        <span class="comment">/* sizeOfStruct         */</span> \</div>
<div class="line">                  0,                    <span class="comment">/* chunkNativeLimit     */</span> \</div>
<div class="line">                  0,                    <span class="comment">/* extraSize            */</span> \</div>
<div class="line">                  0,                    <span class="comment">/* nativeIndexingLimit  */</span> \</div>
<div class="line">                  0,                    <span class="comment">/* chunkNativeStart     */</span> \</div>
<div class="line">                  0,                    <span class="comment">/* chunkOffset          */</span> \</div>
<div class="line">                  0,                    <span class="comment">/* chunkLength          */</span> \</div>
<div class="line">                  NULL,                 <span class="comment">/* chunkContents        */</span> \</div>
<div class="line">                  NULL,                 <span class="comment">/* pFuncs               */</span> \</div>
<div class="line">                  NULL,                 <span class="comment">/* pExtra               */</span> \</div>
<div class="line">                  NULL,                 <span class="comment">/* context              */</span> \</div>
<div class="line">                  NULL, <a class="code" href="utypes_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="utypes_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,     <span class="comment">/* p, q, r              */</span> \</div>
<div class="line">                  NULL,                 <span class="comment">/* privP                */</span> \</div>
<div class="line">                  0, 0, 0,              <span class="comment">/* a, b, c              */</span> \</div>
<div class="line">                  0, 0, 0               <span class="comment">/* privA,B,C,           */</span> \</div>
<div class="line">                  }</div>
<div class="ttc" id="autypes_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="utypes_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdoc">Define NULL if necessary, to nullptr for C++ and to ((void *)0) for C.</div><div class="ttdef"><b>Definition:</b> <a href="utypes_8h_source.html#l00188">utypes.h:188</a></div></div>
</div><!-- fragment -->
<p>initializer to be used with local (stack) instances of a <a class="el" href="structUText.html" title="UText struct.">UText</a> struct. </p>
<p><a class="el" href="structUText.html" title="UText struct.">UText</a> structs must be initialized before passing them to one of the utext_open functions.</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003255">Stable:</a></b></dt><dd>ICU 3.6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l01558">1558</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="aa4b973aeeb5f10f8aec454545f85b6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b973aeeb5f10f8aec454545f85b6a2">&#9670;&nbsp;</a></span>UTEXT_NEXT32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UTEXT_NEXT32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ut</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((ut)-&gt;chunkOffset &lt; (ut)-&gt;chunkLength &amp;&amp; ((ut)-&gt;chunkContents)[(ut)-&gt;chunkOffset]&lt;0xd800 ? \</div>
<div class="line">    ((ut)-&gt;chunkContents)[((ut)-&gt;chunkOffset)++] : <a class="code" href="utext_8h.html#af0ef1bd96a7aea7c86b527a6175c54ff">utext_next32</a>(ut))</div>
</div><!-- fragment -->
<p>inline version of <a class="el" href="utext_8h.html#af0ef1bd96a7aea7c86b527a6175c54ff" title="Get the code point at the current iteration position of the UText, and advance the position to the fi...">utext_next32()</a>, for performance-critical situations. </p>
<p>Get the code point at the current iteration position of the <a class="el" href="structUText.html" title="UText struct.">UText</a>, and advance the position to the first index following the character. This is a post-increment operation. Returns U_SENTINEL (-1) if the position is at the end of the text.</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003233">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l00703">703</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="a8aa3d9bae7b252622fe8e70e87758205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa3d9bae7b252622fe8e70e87758205">&#9670;&nbsp;</a></span>UTEXT_PREVIOUS32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UTEXT_PREVIOUS32</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ut</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    ((ut)-&gt;chunkOffset &gt; 0 &amp;&amp; \</div>
<div class="line">     (ut)-&gt;chunkContents[(ut)-&gt;chunkOffset-1] &lt; 0xd800 ? \</div>
<div class="line">          (ut)-&gt;chunkContents[--((ut)-&gt;chunkOffset)]  :  <a class="code" href="utext_8h.html#a282a69979e9479fe9b9c006f81ed74b6">utext_previous32</a>(ut))</div>
</div><!-- fragment -->
<p>inline version of <a class="el" href="utext_8h.html#a282a69979e9479fe9b9c006f81ed74b6" title="Move the iterator position to the character (code point) whose index precedes the current position,...">utext_previous32()</a>, for performance-critical situations. </p>
<p>Move the iterator position to the character (code point) whose index precedes the current position, and return that character. This is a pre-decrement operation. Returns U_SENTINEL (-1) if the position is at the start of the text.</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003234">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l00717">717</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="a74aa6ff1add5886508657997ca8d4747"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74aa6ff1add5886508657997ca8d4747">&#9670;&nbsp;</a></span>UTEXT_SETNATIVEINDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UTEXT_SETNATIVEINDEX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ut, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ix&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">    <a class="code" href="umachine_8h.html#abfdc26d020b4fab3ed5ca2b98fe5df43">UPRV_BLOCK_MACRO_BEGIN</a> { \</div>
<div class="line">    int64_t __offset = (ix) - (ut)-&gt;chunkNativeStart; \</div>
<div class="line">    if (__offset&gt;=0 &amp;&amp; __offset&lt;(int64_t)(ut)-&gt;nativeIndexingLimit &amp;&amp; (ut)-&gt;chunkContents[__offset]&lt;0xdc00) { \</div>
<div class="line">        (ut)-&gt;chunkOffset=(int32_t)__offset; \</div>
<div class="line">    } <span class="keywordflow">else</span> { \</div>
<div class="line">        utext_setNativeIndex((ut), (ix)); \</div>
<div class="line">    } \</div>
<div class="line">} <a class="code" href="umachine_8h.html#a983e6cc57f8c1b0c5b9ad9ceb290418a">UPRV_BLOCK_MACRO_END</a></div>
<div class="ttc" id="aumachine_8h_html_a983e6cc57f8c1b0c5b9ad9ceb290418a"><div class="ttname"><a href="umachine_8h.html#a983e6cc57f8c1b0c5b9ad9ceb290418a">UPRV_BLOCK_MACRO_END</a></div><div class="ttdeci">#define UPRV_BLOCK_MACRO_END</div><div class="ttdoc">Defined as &quot;while (false)&quot; by default.</div><div class="ttdef"><b>Definition:</b> <a href="umachine_8h_source.html#l00178">umachine.h:178</a></div></div>
<div class="ttc" id="aumachine_8h_html_abfdc26d020b4fab3ed5ca2b98fe5df43"><div class="ttname"><a href="umachine_8h.html#abfdc26d020b4fab3ed5ca2b98fe5df43">UPRV_BLOCK_MACRO_BEGIN</a></div><div class="ttdeci">#define UPRV_BLOCK_MACRO_BEGIN</div><div class="ttdoc">Defined as the &quot;do&quot; keyword by default.</div><div class="ttdef"><b>Definition:</b> <a href="umachine_8h_source.html#l00169">umachine.h:169</a></div></div>
</div><!-- fragment -->
<p>inline version of <a class="el" href="utext_8h.html#adc484cb765c4ef02d740b55b9cbc5b34" title="Set the current iteration position to the nearest code point boundary at or preceding the specified i...">utext_setNativeIndex()</a>, for performance-critical situations. </p>
<p>Set the current iteration position to the nearest code point boundary at or preceding the specified index. The index is in the native units of the original input text. If the index is out of range, it will be pinned to be within the range of the input text.</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003236">Stable:</a></b></dt><dd>ICU 3.8 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l00750">750</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a8da22111033cc0c063d89cae348ec1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da22111033cc0c063d89cae348ec1e4">&#9670;&nbsp;</a></span>UText</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUText.html">UText</a> <a class="el" href="structUText.html">UText</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>C typedef for struct <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003210">Stable:</a></b></dt><dd>ICU 3.6 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l00001">1</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="a829af7190e7cee22c647af949ebb4730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829af7190e7cee22c647af949ebb4730">&#9670;&nbsp;</a></span>UTextAccess</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> UTextAccess(<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeIndex, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> forward)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type declaration for UText.access(). </p>
<p>Get the description of the text chunk containing the text at a requested native index. The <a class="el" href="structUText.html" title="UText struct.">UText</a>'s iteration position will be left at the requested index. If the index is out of bounds, the iteration position will be left at the start or end of the string, as appropriate.</p>
<p>Chunks must begin and end on code point boundaries. A single code point comprised of multiple storage units must never span a chunk boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the <a class="el" href="structUText.html" title="UText struct.">UText</a> being accessed. </td></tr>
    <tr><td class="paramname">nativeIndex</td><td>Requested index of the text to be accessed. </td></tr>
    <tr><td class="paramname">forward</td><td>If true, then the returned chunk must contain text starting from the index, so that start&lt;=index&lt;limit. If false, then the returned chunk must contain text before the index, so that start&lt;index&lt;=limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the requested index could be accessed. The chunk will contain the requested text. False value if a chunk cannot be accessed (the requested index is out of bounds).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structUText.html" title="UText struct.">UText</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003245">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l01024">1024</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="ae29be5a512f69c3a9d871890225d07ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29be5a512f69c3a9d871890225d07ec">&#9670;&nbsp;</a></span>UTextClone</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structUText.html">UText</a>* UTextClone(<a class="el" href="structUText.html">UText</a> *dest, const <a class="el" href="structUText.html">UText</a> *src, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> deep, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type declaration for UText.clone(). </p>
<p>clone a <a class="el" href="structUText.html" title="UText struct.">UText</a>. Much like opening a <a class="el" href="structUText.html" title="UText struct.">UText</a> where the source text is itself another <a class="el" href="structUText.html" title="UText struct.">UText</a>.</p>
<p>A deep clone will copy both the <a class="el" href="structUText.html" title="UText struct.">UText</a> data structures and the underlying text. The original and cloned <a class="el" href="structUText.html" title="UText struct.">UText</a> will operate completely independently; modifications made to the text in one will not effect the other. Text providers are not required to support deep clones. The user of clone() must check the status return and be prepared to handle failures.</p>
<p>A shallow clone replicates only the <a class="el" href="structUText.html" title="UText struct.">UText</a> data structures; it does not make a copy of the underlying text. Shallow clones can be used as an efficient way to have multiple iterators active in a single text string that is not being modified.</p>
<p>A shallow clone operation must not fail except for truly exceptional conditions such as memory allocation failures.</p>
<p>A <a class="el" href="structUText.html" title="UText struct.">UText</a> and its clone may be safely concurrently accessed by separate threads. This is true for both shallow and deep clones. It is the responsibility of the Text Provider to ensure that this thread safety constraint is met.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A <a class="el" href="structUText.html" title="UText struct.">UText</a> struct to be filled in with the result of the clone operation, or NULL if the clone function should heap-allocate a new <a class="el" href="structUText.html" title="UText struct.">UText</a> struct. </td></tr>
    <tr><td class="paramname">src</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> to be cloned. </td></tr>
    <tr><td class="paramname">deep</td><td>true to request a deep clone, false for a shallow clone. </td></tr>
    <tr><td class="paramname">status</td><td>Errors are returned here. For deep clones, U_UNSUPPORTED_ERROR should be returned if the text provider is unable to clone the original text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created clone, or NULL if the clone operation failed.</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003243">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l00984">984</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="a689fd4dcd7e392532f979af8b33273b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689fd4dcd7e392532f979af8b33273b5">&#9670;&nbsp;</a></span>UTextClose</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void UTextClose(<a class="el" href="structUText.html">UText</a> *ut)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type declaration for UText.utextClose(). </p>
<p>A Text Provider close function is only required for provider types that make allocations in their open function (or other functions) that must be cleaned when the <a class="el" href="structUText.html" title="UText struct.">UText</a> is closed.</p>
<p>The allocation of the <a class="el" href="structUText.html" title="UText struct.">UText</a> struct itself and any "extra" storage associated with the <a class="el" href="structUText.html" title="UText struct.">UText</a> is handled by the common <a class="el" href="structUText.html" title="UText struct.">UText</a> implementation and does not require provider specific cleanup in a close function.</p>
<p>Most <a class="el" href="structUText.html" title="UText struct.">UText</a> provider implementations do not need to implement this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>A <a class="el" href="structUText.html" title="UText struct.">UText</a> object to be closed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003251">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l01182">1182</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="ad017072290f396d7bce8fb0712a232e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad017072290f396d7bce8fb0712a232e8">&#9670;&nbsp;</a></span>UTextCopy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void UTextCopy(<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeStart, int64_t nativeLimit, int64_t nativeDest, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> move, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type declaration for UText.copy(). </p>
<p>Copy or move a substring from one position to another within the text, while retaining any metadata associated with the text. This function is used to duplicate or reorder substrings. The destination index must not overlap the source range.</p>
<p>The text to be copied or moved is inserted at destIndex; it does not replace or overwrite any existing text.</p>
<p>This function need only be implemented for <a class="el" href="structUText.html" title="UText struct.">UText</a> types that support writing.</p>
<p>When using this function, there should be only a single <a class="el" href="structUText.html" title="UText struct.">UText</a> opened onto the underlying native text string. The function is responsible for updating the text chunk within the <a class="el" href="structUText.html" title="UText struct.">UText</a> to reflect the updated iteration position, taking into account any changes to the underlying string's structure caused by the replace operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> representing the text to be operated on. </td></tr>
    <tr><td class="paramname">nativeStart</td><td>The index of the start of the region to be copied or moved </td></tr>
    <tr><td class="paramname">nativeLimit</td><td>The index of the character following the region to be replaced. </td></tr>
    <tr><td class="paramname">nativeDest</td><td>The destination index to which the source substring is copied or moved. </td></tr>
    <tr><td class="paramname">move</td><td>If true, then the substring is moved, not copied/duplicated. </td></tr>
    <tr><td class="paramname">status</td><td>receives any error status. Possible errors include U_NO_WRITE_PERMISSION</td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003248">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l01123">1123</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="a62d7c17254aee81ba7ccf7acdf79f2dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d7c17254aee81ba7ccf7acdf79f2dd">&#9670;&nbsp;</a></span>UTextExtract</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t UTextExtract(<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeStart, int64_t nativeLimit, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *dest, int32_t destCapacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type declaration for UText.extract(). </p>
<p>Extract text from a <a class="el" href="structUText.html" title="UText struct.">UText</a> into a UChar buffer. The range of text to be extracted is specified in the native indices of the <a class="el" href="structUText.html" title="UText struct.">UText</a> provider. These may not necessarily be UTF-16 indices. </p>
<p>The size (number of 16 bit UChars) in the data to be extracted is returned. The full amount is returned, even when the specified buffer size is smaller. </p>
<p>The extracted string will (if you are a user) / must (if you are a text provider) be NUL-terminated if there is sufficient space in the destination buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the <a class="el" href="structUText.html" title="UText struct.">UText</a> from which to extract data. </td></tr>
    <tr><td class="paramname">nativeStart</td><td>the native index of the first character to extract. </td></tr>
    <tr><td class="paramname">nativeLimit</td><td>the native string index of the position following the last character to extract. </td></tr>
    <tr><td class="paramname">dest</td><td>the UChar (UTF-16) buffer into which the extracted text is placed </td></tr>
    <tr><td class="paramname">destCapacity</td><td>The size, in UChars, of the destination buffer. May be zero for precomputing the required size. </td></tr>
    <tr><td class="paramname">status</td><td>receives any error status. If U_BUFFER_OVERFLOW_ERROR: Returns number of UChars for preflighting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of UChars in the data. Does not include a trailing NUL.</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003246">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l01054">1054</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="acaf57d3fd11db28583a36df05ec02295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf57d3fd11db28583a36df05ec02295">&#9670;&nbsp;</a></span>UTextFuncs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structUTextFuncs.html">UTextFuncs</a> <a class="el" href="structUTextFuncs.html">UTextFuncs</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function dispatch table for <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structUTextFuncs.html" title="(public) Function dispatch table for UText.">UTextFuncs</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l01182">1182</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="ab14d770b0feb53e5c4677f998e6b5ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14d770b0feb53e5c4677f998e6b5ad0">&#9670;&nbsp;</a></span>UTextMapNativeIndexToUTF16</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t UTextMapNativeIndexToUTF16(const <a class="el" href="structUText.html">UText</a> *ut, int64_t nativeIndex)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type declaration for UText.mapIndexToUTF16(). </p>
<p>Map from a native index to a UChar offset within a text chunk. Behavior is undefined if the native index does not fall within the current chunk.</p>
<p>This function is required only for text providers that do not use native UTF-16 indexes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> containing the text chunk. </td></tr>
    <tr><td class="paramname">nativeIndex</td><td>Absolute (native) text index, chunk-&gt;start&lt;=index&lt;=chunk-&gt;limit. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Chunk-relative UTF-16 offset corresponding to the specified native index.</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003250">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l01161">1161</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="aa78b6ae4b98958554b7ee15de57e9c30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78b6ae4b98958554b7ee15de57e9c30">&#9670;&nbsp;</a></span>UTextMapOffsetToNative</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t UTextMapOffsetToNative(const <a class="el" href="structUText.html">UText</a> *ut)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type declaration for UText.mapOffsetToNative(). </p>
<p>Map from the current UChar offset within the current text chunk to the corresponding native index in the original source text.</p>
<p>This is required only for text providers that do not use native UTF-16 indexes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the <a class="el" href="structUText.html" title="UText struct.">UText</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Absolute (native) index corresponding to chunkOffset in the current chunk. The returned native index should always be to a code point boundary.</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003249">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l01143">1143</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="a36bad470545b3183fff611c91312cc10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36bad470545b3183fff611c91312cc10">&#9670;&nbsp;</a></span>UTextNativeLength</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64_t UTextNativeLength(<a class="el" href="structUText.html">UText</a> *ut)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type declaration for UText.nativeLength(). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the <a class="el" href="structUText.html" title="UText struct.">UText</a> to get the length of. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length, in the native units of the original text string. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structUText.html" title="UText struct.">UText</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003244">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l00996">996</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="a0a84b5d0d434b0f1f71f77841cac3d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a84b5d0d434b0f1f71f77841cac3d97">&#9670;&nbsp;</a></span>UTextReplace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32_t UTextReplace(<a class="el" href="structUText.html">UText</a> *ut, int64_t nativeStart, int64_t nativeLimit, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *replacementText, int32_t replacmentLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function type declaration for UText.replace(). </p>
<p>Replace a range of the original text with a replacement text.</p>
<p>Leaves the current iteration position at the position following the newly inserted replacement text.</p>
<p>This function need only be implemented on <a class="el" href="structUText.html" title="UText struct.">UText</a> types that support writing.</p>
<p>When using this function, there should be only a single <a class="el" href="structUText.html" title="UText struct.">UText</a> opened onto the underlying native text string. The function is responsible for updating the text chunk within the <a class="el" href="structUText.html" title="UText struct.">UText</a> to reflect the updated iteration position, taking into account any changes to the underlying string's structure caused by the replace operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the <a class="el" href="structUText.html" title="UText struct.">UText</a> representing the text to be operated on. </td></tr>
    <tr><td class="paramname">nativeStart</td><td>the index of the start of the region to be replaced </td></tr>
    <tr><td class="paramname">nativeLimit</td><td>the index of the character following the region to be replaced. </td></tr>
    <tr><td class="paramname">replacementText</td><td>pointer to the replacement text </td></tr>
    <tr><td class="paramname">replacmentLength</td><td>length of the replacement text in UChars, or -1 if the text is NUL terminated. </td></tr>
    <tr><td class="paramname">status</td><td>receives any error status. Possible errors include U_NO_WRITE_PERMISSION</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed number of (native) storage units by which the length of the text expanded or contracted.</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003247">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l01089">1089</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a80155586fa275b28773c9b203f52caba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80155586fa275b28773c9b203f52caba">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="structUText.html" title="UText struct.">UText</a> provider properties (bit field indexes). </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structUText.html" title="UText struct.">UText</a> </dd></dl>
<dl class="stable"><dt><b>Stable:</b></dt><dd>ICU 3.4 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a80155586fa275b28773c9b203f52cabaa752c07f9df260b5b0e234e15eab97f9f"></a>UTEXT_PROVIDER_LENGTH_IS_EXPENSIVE&#160;</td><td class="fielddoc"><p>It is potentially time consuming for the provider to determine the length of the text. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003256">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a80155586fa275b28773c9b203f52cabaa52bb5c9cacd1f46eb87a856c71c073be"></a>UTEXT_PROVIDER_STABLE_CHUNKS&#160;</td><td class="fielddoc"><p>Text chunks remain valid and usable until the text object is modified or deleted, not just until the next time the access() function is called (which is the default). </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003257">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a80155586fa275b28773c9b203f52cabaac67ce6ecf6bf959645e282f7194fbe3b"></a>UTEXT_PROVIDER_WRITABLE&#160;</td><td class="fielddoc"><p>The provider supports modifying the text via the replace() and copy() functions. </p>
<dl class="section see"><dt>See also</dt><dd>Replaceable </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003258">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a80155586fa275b28773c9b203f52cabaa40c5cd24aea472f3752b4833b9ce63ca"></a>UTEXT_PROVIDER_HAS_META_DATA&#160;</td><td class="fielddoc"><p>There is meta data associated with the text. </p>
<dl class="section see"><dt>See also</dt><dd>Replaceable::hasMetaData() </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003259">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a80155586fa275b28773c9b203f52cabaa75695072a896ec104b5d77598a7429f7"></a>UTEXT_PROVIDER_OWNS_TEXT&#160;</td><td class="fielddoc"><p>Text provider owns the text storage. </p>
<p>Generally occurs as the result of a deep clone of the <a class="el" href="structUText.html" title="UText struct.">UText</a>. When closing the <a class="el" href="structUText.html" title="UText struct.">UText</a>, the associated text must also be closed/deleted/freed/ whatever is appropriate. </p><dl class="stable"><dt><b><a class="el" href="stable.html#_stable003260">Stable:</a></b></dt><dd>ICU 3.6 </dd></dl>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l00910">910</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<a id="a6b7b47dd702d9e331586d485013fd1ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b7b47dd702d9e331586d485013fd1ea">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="internal"><dt><b>Internal:</b></dt><dd>Do not use.</dd></dl>
<p>This API is for internal use only. Value used to help identify correctly initialized <a class="el" href="structUText.html" title="UText struct.">UText</a> structs. Note: must be publicly visible so that UTEXT_INITIALIZER can access it. </p>

<p class="definition">Definition at line <a class="el" href="utext_8h_source.html#l01547">1547</a> of file <a class="el" href="utext_8h_source.html">utext.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ac19b6f9e616e8cd6f0509989495cce62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19b6f9e616e8cd6f0509989495cce62">&#9670;&nbsp;</a></span>utext_char32At()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> utext_char32At </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nativeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the code point at the requested index, or U_SENTINEL (-1) if it is out of bounds. </p>
<p>If the specified index points to the interior of a multi-unit character - one of the trail bytes of a UTF-8 sequence, for example - the complete code point will be returned.</p>
<p>The iteration position will be set to the start of the returned code point.</p>
<p>This function is roughly equivalent to the sequence utext_setNativeIndex(index); <a class="el" href="utext_8h.html#af172215348343ca5cbfe8afa741dca98" title="Get the code point at the current iteration position, or U_SENTINEL (-1) if the iteration has reached...">utext_current32()</a>; (There is a subtle difference if the index is out of bounds by being less than zero - utext_setNativeIndex(negative value) sets the index to zero, after which utext_current() will return the char at zero. utext_char32At(negative index), on the other hand, will return the U_SENTINEL value of -1.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed </td></tr>
    <tr><td class="paramname">nativeIndex</td><td>the native index of the character to be accessed. If the index points to other than the first unit of a multi-unit character, it will be adjusted to the start of the character. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the code point at the specified index. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003222">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="a9c33ebb0432549dd4416831529cc5129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c33ebb0432549dd4416831529cc5129">&#9670;&nbsp;</a></span>utext_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a>* utext_clone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td>
          <td class="paramname"><em>deep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td>
          <td class="paramname"><em>readOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone a <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>
<p>This is much like opening a <a class="el" href="structUText.html" title="UText struct.">UText</a> where the source text is itself another <a class="el" href="structUText.html" title="UText struct.">UText</a>.</p>
<p>A deep clone will copy both the <a class="el" href="structUText.html" title="UText struct.">UText</a> data structures and the underlying text. The original and cloned <a class="el" href="structUText.html" title="UText struct.">UText</a> will operate completely independently; modifications made to the text in one will not affect the other. Text providers are not required to support deep clones. The user of clone() must check the status return and be prepared to handle failures.</p>
<p>The standard <a class="el" href="structUText.html" title="UText struct.">UText</a> implementations for UTF8, UChar *, UnicodeString and Replaceable all support deep cloning.</p>
<p>The <a class="el" href="structUText.html" title="UText struct.">UText</a> returned from a deep clone will be writable, assuming that the text provider is able to support writing, even if the source <a class="el" href="structUText.html" title="UText struct.">UText</a> had been made non-writable by means of UText_freeze().</p>
<p>A shallow clone replicates only the <a class="el" href="structUText.html" title="UText struct.">UText</a> data structures; it does not make a copy of the underlying text. Shallow clones can be used as an efficient way to have multiple iterators active in a single text string that is not being modified.</p>
<p>A shallow clone operation will not fail, barring truly exceptional conditions such as memory allocation failures.</p>
<p>Shallow <a class="el" href="structUText.html" title="UText struct.">UText</a> clones should be avoided if the <a class="el" href="structUText.html" title="UText struct.">UText</a> functions that modify the text are expected to be used, either on the original or the cloned <a class="el" href="structUText.html" title="UText struct.">UText</a>. Any such modifications can cause unpredictable behavior. Read Only shallow clones provide some protection against errors of this type by disabling text modification via the cloned <a class="el" href="structUText.html" title="UText struct.">UText</a>.</p>
<p>A shallow clone made with the readOnly parameter == false will preserve the <a class="el" href="utext_8h.html#ad925ba6bff38fb82a1664ff127c94483" title="Return true if the text can be written (modified) with utext_replace() or utext_copy().">utext_isWritable()</a> state of the source object. Note, however, that write operations must be avoided while more than one <a class="el" href="structUText.html" title="UText struct.">UText</a> exists that refer to the same underlying text.</p>
<p>A <a class="el" href="structUText.html" title="UText struct.">UText</a> and its clone may be safely concurrently accessed by separate threads. This is true for read access only with shallow clones, and for both read and write access with deep clones. It is the responsibility of the Text Provider to ensure that this thread safety constraint is met.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>A <a class="el" href="structUText.html" title="UText struct.">UText</a> struct to be filled in with the result of the clone operation, or NULL if the clone function should heap-allocate a new <a class="el" href="structUText.html" title="UText struct.">UText</a> struct. If non-NULL, must refer to an already existing <a class="el" href="structUText.html" title="UText struct.">UText</a>, which will then be reset to become the clone. </td></tr>
    <tr><td class="paramname">src</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> to be cloned. </td></tr>
    <tr><td class="paramname">deep</td><td>true to request a deep clone, false for a shallow clone. </td></tr>
    <tr><td class="paramname">readOnly</td><td>true to request that the cloned <a class="el" href="structUText.html" title="UText struct.">UText</a> have read only access to the underlying text. <br  />
</td></tr>
    <tr><td class="paramname">status</td><td>Errors are returned here. For deep clones, U_UNSUPPORTED_ERROR will be returned if the text provider is unable to clone the original text. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The newly created clone, or NULL if the clone operation failed. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003218">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="a731e5f580e2dd29125d657fc73575650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731e5f580e2dd29125d657fc73575650">&#9670;&nbsp;</a></span>utext_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a>* utext_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close function for <a class="el" href="structUText.html" title="UText struct.">UText</a> instances. </p>
<p>Cleans up, releases any resources being held by an open <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>
<p>If the <a class="el" href="structUText.html" title="UText struct.">UText</a> was originally allocated by one of the utext_open functions, the storage associated with the utext will also be freed. If the <a class="el" href="structUText.html" title="UText struct.">UText</a> storage originated with the application, as it would with a local or static instance, the storage will not be deleted.</p>
<p>An open <a class="el" href="structUText.html" title="UText struct.">UText</a> can be reset to refer to new string by using one of the utext_open() functions without first closing the <a class="el" href="structUText.html" title="UText struct.">UText</a>. <br  />
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> to be closed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>NULL if the <a class="el" href="structUText.html" title="UText struct.">UText</a> struct was deleted by the close. If the <a class="el" href="structUText.html" title="UText struct.">UText</a> struct was originally provided by the caller to the open function, it is returned by this function, and may be safely used again in a subsequent utext_open.</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003211">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="aaf801e5846bb75b47f6e9ded1e777197"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf801e5846bb75b47f6e9ded1e777197">&#9670;&nbsp;</a></span>utext_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void utext_copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nativeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nativeLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>destIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td>
          <td class="paramname"><em>move</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy or move a substring from one position to another within the text, while retaining any metadata associated with the text. </p>
<p>This function is used to duplicate or reorder substrings. The destination index must not overlap the source range.</p>
<p>The text to be copied or moved is inserted at destIndex; it does not replace or overwrite any existing text.</p>
<p>The iteration position is left following the newly inserted text at the destination position.</p>
<p>This function is only available on <a class="el" href="structUText.html" title="UText struct.">UText</a> types that support writing, that is, ones where <a class="el" href="utext_8h.html#ad925ba6bff38fb82a1664ff127c94483" title="Return true if the text can be written (modified) with utext_replace() or utext_copy().">utext_isWritable()</a> returns true.</p>
<p>When using this function, there should be only a single <a class="el" href="structUText.html" title="UText struct.">UText</a> opened onto the underlying native text string. Behavior after a copy operation on a <a class="el" href="structUText.html" title="UText struct.">UText</a> is undefined in any other additional UTexts that refer to the modified string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> representing the text to be operated on. </td></tr>
    <tr><td class="paramname">nativeStart</td><td>The native index of the start of the region to be copied or moved </td></tr>
    <tr><td class="paramname">nativeLimit</td><td>The native index of the character position following the region to be copied. </td></tr>
    <tr><td class="paramname">destIndex</td><td>The native destination index to which the source substring is copied or moved. </td></tr>
    <tr><td class="paramname">move</td><td>If true, then the substring is moved, not copied/duplicated. </td></tr>
    <tr><td class="paramname">status</td><td>receives any error status. Possible errors include U_NO_WRITE_PERMISSION</td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003240">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="af172215348343ca5cbfe8afa741dca98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af172215348343ca5cbfe8afa741dca98">&#9670;&nbsp;</a></span>utext_current32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> utext_current32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the code point at the current iteration position, or U_SENTINEL (-1) if the iteration has reached the end of the input text. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Unicode code point at the current iterator position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003223">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="ac5ddfa74dc6b21800ecef9bf78ec7183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ddfa74dc6b21800ecef9bf78ec7183">&#9670;&nbsp;</a></span>utext_equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> utext_equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compare two <a class="el" href="structUText.html" title="UText struct.">UText</a> objects for equality. </p>
<p>UTexts are equal if they are iterating over the same text, and have the same iteration position within the text. If either or both of the parameters are NULL, the comparison is false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first of the two UTexts to compare. </td></tr>
    <tr><td class="paramname">b</td><td>The other <a class="el" href="structUText.html" title="UText struct.">UText</a> to be compared. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the two UTexts are equal. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003219">Stable:</a></b></dt><dd>ICU 3.6 </dd></dl>

</div>
</div>
<a id="a6d532d7ab06e7463e3236947ccf0905d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d532d7ab06e7463e3236947ccf0905d">&#9670;&nbsp;</a></span>utext_extract()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t utext_extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nativeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nativeLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract text from a <a class="el" href="structUText.html" title="UText struct.">UText</a> into a UChar buffer. </p>
<p>The range of text to be extracted is specified in the native indices of the <a class="el" href="structUText.html" title="UText struct.">UText</a> provider. These may not necessarily be UTF-16 indices. </p>
<p>The size (number of 16 bit UChars) of the data to be extracted is returned. The full number of UChars is returned, even when the extracted text is truncated because the specified buffer size is too small. </p>
<p>The extracted string will (if you are a user) / must (if you are a text provider) be NUL-terminated if there is sufficient space in the destination buffer. This terminating NUL is not included in the returned length. </p>
<p>The iteration index is left at the position following the last extracted character.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the <a class="el" href="structUText.html" title="UText struct.">UText</a> from which to extract data. </td></tr>
    <tr><td class="paramname">nativeStart</td><td>the native index of the first character to extract.\ If the specified index is out of range, it will be pinned to be within 0 &lt;= index &lt;= textLength </td></tr>
    <tr><td class="paramname">nativeLimit</td><td>the native string index of the position following the last character to extract. If the specified index is out of range, it will be pinned to be within 0 &lt;= index &lt;= textLength. nativeLimit must be &gt;= nativeStart. </td></tr>
    <tr><td class="paramname">dest</td><td>the UChar (UTF-16) buffer into which the extracted text is placed </td></tr>
    <tr><td class="paramname">destCapacity</td><td>The size, in UChars, of the destination buffer. May be zero for precomputing the required size. </td></tr>
    <tr><td class="paramname">status</td><td>receives any error status. U_BUFFER_OVERFLOW_ERROR: the extracted text was truncated because the buffer was too small. Returns number of UChars for preflighting. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of UChars in the data to be extracted. Does not include a trailing NUL.</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003232">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="ad73beaba24a19d8f06058f75e9cc23ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad73beaba24a19d8f06058f75e9cc23ad">&#9670;&nbsp;</a></span>utext_freeze()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void utext_freeze </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Freeze a <a class="el" href="structUText.html" title="UText struct.">UText</a>. This prevents any modification to the underlying text itself by means of functions operating on this <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>
<p>Once frozen, a <a class="el" href="structUText.html" title="UText struct.">UText</a> can not be unfrozen. The intent is to ensure that a the text underlying a frozen <a class="el" href="structUText.html" title="UText struct.">UText</a> wrapper cannot be modified via that <a class="el" href="structUText.html" title="UText struct.">UText</a>. </p>
<p>Caution: freezing a <a class="el" href="structUText.html" title="UText struct.">UText</a> will disable changes made via the specific frozen <a class="el" href="structUText.html" title="UText struct.">UText</a> wrapper only; it will not have any effect on the ability to directly modify the text by bypassing the <a class="el" href="structUText.html" title="UText struct.">UText</a>. Any such backdoor modifications are always an error while <a class="el" href="structUText.html" title="UText struct.">UText</a> access is occurring because the underlying text can get out of sync with <a class="el" href="structUText.html" title="UText struct.">UText</a>'s buffering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> to be frozen. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="utext_8h.html#ad925ba6bff38fb82a1664ff127c94483" title="Return true if the text can be written (modified) with utext_replace() or utext_copy().">utext_isWritable()</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003241">Stable:</a></b></dt><dd>ICU 3.6 </dd></dl>

</div>
</div>
<a id="ae60a026b3159c2b95e5d6e0a86ac0a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60a026b3159c2b95e5d6e0a86ac0a72">&#9670;&nbsp;</a></span>utext_getNativeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int64_t utext_getNativeIndex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current iterator position, which can range from 0 to the length of the text. </p>
<p>The position is a native index into the input text, in whatever format it may have (possibly UTF-8 for example), and may not always be the same as the corresponding UChar (UTF-16) index. The returned position will always be aligned to a code point boundary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current index position, in the native units of the text provider. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003228">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="ad7be685a54292cf85337d1413a36df05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7be685a54292cf85337d1413a36df05">&#9670;&nbsp;</a></span>utext_getPreviousNativeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int64_t utext_getPreviousNativeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the native index of the character preceding the current position. </p>
<p>If the iteration position is already at the start of the text, zero is returned. The value returned is the same as that obtained from the following sequence, but without the side effect of changing the iteration position.</p>
<div class="fragment"><div class="line"><a class="code" href="structUText.html">UText</a>  *ut = whatever;</div>
<div class="line">  ...</div>
<div class="line">utext_previous(ut)</div>
<div class="line"><a class="code" href="utext_8h.html#ae60a026b3159c2b95e5d6e0a86ac0a72">utext_getNativeIndex</a>(ut);</div>
<div class="ttc" id="autext_8h_html_ae60a026b3159c2b95e5d6e0a86ac0a72"><div class="ttname"><a href="utext_8h.html#ae60a026b3159c2b95e5d6e0a86ac0a72">utext_getNativeIndex</a></div><div class="ttdeci">U_CAPI int64_t utext_getNativeIndex(const UText *ut)</div><div class="ttdoc">Get the current iterator position, which can range from 0 to the length of the text.</div></div>
</div><!-- fragment --><p>This function is most useful during forwards iteration, where it will get the native index of the character most recently returned from utext_next().</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the native index of the character preceding the current index position, or zero if the current position is at the start of the text. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003231">Stable:</a></b></dt><dd>ICU 3.6 </dd></dl>

</div>
</div>
<a id="a46302dca5dc2c6da7766d944bcda38fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46302dca5dc2c6da7766d944bcda38fb">&#9670;&nbsp;</a></span>utext_hasMetaData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> utext_hasMetaData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether there is meta data associated with the text. </p>
<dl class="section see"><dt>See also</dt><dd>Replaceable::hasMetaData()</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>The <a class="el" href="structUText.html" title="UText struct.">UText</a> to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the underlying text includes meta data. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003238">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="acb379348a9d63704cf15202f855d8c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb379348a9d63704cf15202f855d8c86">&#9670;&nbsp;</a></span>utext_isLengthExpensive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> utext_isLengthExpensive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if calculating the length of the text could be expensive. </p>
<p>Finding the length of NUL terminated strings is considered to be expensive.</p>
<p>Note that the value of this function may change as the result of other operations on a <a class="el" href="structUText.html" title="UText struct.">UText</a>. Once the length of a string has been discovered, it will no longer be expensive to report it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if determining the length of the text could be time consuming. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003221">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="ad925ba6bff38fb82a1664ff127c94483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad925ba6bff38fb82a1664ff127c94483">&#9670;&nbsp;</a></span>utext_isWritable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> utext_isWritable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the text can be written (modified) with <a class="el" href="utext_8h.html#ad99a769d1cd16b673838d4598ec6f156" title="Replace a range of the original text with a replacement text.">utext_replace()</a> or <a class="el" href="utext_8h.html#aaf801e5846bb75b47f6e9ded1e777197" title="Copy or move a substring from one position to another within the text, while retaining any metadata a...">utext_copy()</a>. </p>
<p>For the text to be writable, the text provider must be of a type that supports writing and the <a class="el" href="structUText.html" title="UText struct.">UText</a> must not be frozen.</p>
<p>Attempting to modify text when utext_isWriteable() is false will fail - the text will not be modified, and an error will be returned from the function that attempted the modification.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the <a class="el" href="structUText.html" title="UText struct.">UText</a> to be tested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the text is modifiable.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="utext_8h.html#ad73beaba24a19d8f06058f75e9cc23ad">utext_freeze()</a> </dd>
<dd>
<a class="el" href="utext_8h.html#ad99a769d1cd16b673838d4598ec6f156" title="Replace a range of the original text with a replacement text.">utext_replace()</a> </dd>
<dd>
<a class="el" href="utext_8h.html#aaf801e5846bb75b47f6e9ded1e777197" title="Copy or move a substring from one position to another within the text, while retaining any metadata a...">utext_copy()</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003237">Stable:</a></b></dt><dd>ICU 3.4</dd></dl>

</div>
</div>
<a id="a2b3dd31ef0447087bf79e0ddd94c5f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3dd31ef0447087bf79e0ddd94c5f94">&#9670;&nbsp;</a></span>utext_moveIndex32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> utext_moveIndex32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>delta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the iterator position by delta code points. </p>
<p>The number of code points is a signed number; a negative delta will move the iterator backwards, towards the start of the text. </p>
<p>The index is moved by <code>delta</code> code points forward or backward, but no further backward than to 0 and no further forward than to <a class="el" href="utext_8h.html#aca73bb6edbb923e9592fb12dd1f2df2e" title="Get the length of the text.">utext_nativeLength()</a>. The resulting index value will be in between 0 and length, inclusive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed. </td></tr>
    <tr><td class="paramname">delta</td><td>the signed number of code points to move the iteration position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the position could be moved the requested number of positions while staying within the range [0 - text length]. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003230">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="aca73bb6edbb923e9592fb12dd1f2df2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca73bb6edbb923e9592fb12dd1f2df2e">&#9670;&nbsp;</a></span>utext_nativeLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int64_t utext_nativeLength </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of the text. </p>
<p>Depending on the characteristics of the underlying text representation, this may be expensive. <br  />
 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="utext_8h.html#acb379348a9d63704cf15202f855d8c86" title="Return true if calculating the length of the text could be expensive.">utext_isLengthExpensive()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the text, expressed in native units.</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003220">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="af0ef1bd96a7aea7c86b527a6175c54ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ef1bd96a7aea7c86b527a6175c54ff">&#9670;&nbsp;</a></span>utext_next32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> utext_next32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the code point at the current iteration position of the <a class="el" href="structUText.html" title="UText struct.">UText</a>, and advance the position to the first index following the character. </p>
<p>If the position is at the end of the text (the index following the last character, which is also the length of the text), return U_SENTINEL (-1) and do not advance the index.</p>
<p>This is a post-increment operation.</p>
<p>An inline macro version of this function, <a class="el" href="utext_8h.html#aa4b973aeeb5f10f8aec454545f85b6a2" title="inline version of utext_next32(), for performance-critical situations.">UTEXT_NEXT32()</a>, is available for performance critical use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the Unicode code point at the iteration position. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="utext_8h.html#aa4b973aeeb5f10f8aec454545f85b6a2" title="inline version of utext_next32(), for performance-critical situations.">UTEXT_NEXT32</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003224">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="ae1b4f05c43927c1e261e3779afb4fc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1b4f05c43927c1e261e3779afb4fc75">&#9670;&nbsp;</a></span>utext_next32From()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> utext_next32From </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nativeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the iteration index and return the code point at that index. </p>
<p>Leave the iteration index at the start of the following code point.</p>
<p>This function is the most efficient and convenient way to begin a forward iteration. The results are identical to the those from the sequence </p><div class="fragment"><div class="line">utext_setIndex();</div>
<div class="line"><a class="code" href="utext_8h.html#af0ef1bd96a7aea7c86b527a6175c54ff">utext_next32</a>();</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed. </td></tr>
    <tr><td class="paramname">nativeIndex</td><td>Iteration index, in the native units of the text provider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Code point which starts at or before index, or U_SENTINEL (-1) if it is out of bounds. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003226">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="ab5674cd8dbf3889f4c2a1991e18b8103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5674cd8dbf3889f4c2a1991e18b8103">&#9670;&nbsp;</a></span>utext_openCharacterIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a>* utext_openCharacterIterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicu_1_1CharacterIterator.html">icu::CharacterIterator</a> *&#160;</td>
          <td class="paramname"><em>ci</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a <a class="el" href="structUText.html" title="UText struct.">UText</a> implementation over an ICU CharacterIterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>Pointer to a <a class="el" href="structUText.html" title="UText struct.">UText</a> struct. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be created. If non-NULL, must refer to an already existing <a class="el" href="structUText.html" title="UText struct.">UText</a>, which will then be reset to reference the specified replaceable text. </td></tr>
    <tr><td class="paramname">ci</td><td>A Character Iterator. </td></tr>
    <tr><td class="paramname">status</td><td>Errors are returned here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="structUText.html" title="UText struct.">UText</a>. If a <a class="el" href="structUText.html" title="UText struct.">UText</a> was supplied as input, this will always be used and returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Replaceable </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003217">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="aedce99c2389ca5e41eedea6c5de975bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedce99c2389ca5e41eedea6c5de975bb">&#9670;&nbsp;</a></span>utext_openConstUnicodeString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a>* utext_openConstUnicodeString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classicu_1_1UnicodeString.html">icu::UnicodeString</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a <a class="el" href="structUText.html" title="UText struct.">UText</a> for a const UnicodeString. </p>
<p>The resulting <a class="el" href="structUText.html" title="UText struct.">UText</a> will not be writable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>Pointer to a <a class="el" href="structUText.html" title="UText struct.">UText</a> struct. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be created. If non-NULL, must refer to an initialized <a class="el" href="structUText.html" title="UText struct.">UText</a> struct, which will then be reset to reference the specified input string. </td></tr>
    <tr><td class="paramname">s</td><td>A const UnicodeString to be wrapped. </td></tr>
    <tr><td class="paramname">status</td><td>Errors are returned here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="structUText.html" title="UText struct.">UText</a>. If a <a class="el" href="structUText.html" title="UText struct.">UText</a> was supplied as input, this will always be used and returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003215">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="ad9cf656b684432d206716190e35e086b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9cf656b684432d206716190e35e086b">&#9670;&nbsp;</a></span>utext_openReplaceable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a>* utext_openReplaceable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicu_1_1Replaceable.html">icu::Replaceable</a> *&#160;</td>
          <td class="paramname"><em>rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a writable <a class="el" href="structUText.html" title="UText struct.">UText</a> implementation for an ICU Replaceable object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>Pointer to a <a class="el" href="structUText.html" title="UText struct.">UText</a> struct. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be created. If non-NULL, must refer to an already existing <a class="el" href="structUText.html" title="UText struct.">UText</a>, which will then be reset to reference the specified replaceable text. </td></tr>
    <tr><td class="paramname">rep</td><td>A Replaceable text object. </td></tr>
    <tr><td class="paramname">status</td><td>Errors are returned here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="structUText.html" title="UText struct.">UText</a>. If a <a class="el" href="structUText.html" title="UText struct.">UText</a> was supplied as input, this will always be used and returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>Replaceable </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003216">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="a2b84faeb2a42a991f09cfa95125e3ab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b84faeb2a42a991f09cfa95125e3ab6">&#9670;&nbsp;</a></span>utext_openUChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a>* utext_openUChars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a read-only <a class="el" href="structUText.html" title="UText struct.">UText</a> for UChar * string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>Pointer to a <a class="el" href="structUText.html" title="UText struct.">UText</a> struct. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be created. If non-NULL, must refer to an initialized <a class="el" href="structUText.html" title="UText struct.">UText</a> struct, which will then be reset to reference the specified UChar string. </td></tr>
    <tr><td class="paramname">s</td><td>A UChar (UTF-16) string </td></tr>
    <tr><td class="paramname">length</td><td>The number of UChars in the input string, or -1 if the string is zero terminated. </td></tr>
    <tr><td class="paramname">status</td><td>Errors are returned here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="structUText.html" title="UText struct.">UText</a>. If a pre-allocated <a class="el" href="structUText.html" title="UText struct.">UText</a> was provided, it will always be used and returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003213">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="a1035b627c7442bbc371e44591b8b7f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1035b627c7442bbc371e44591b8b7f08">&#9670;&nbsp;</a></span>utext_openUnicodeString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a>* utext_openUnicodeString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classicu_1_1UnicodeString.html">icu::UnicodeString</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a writable <a class="el" href="structUText.html" title="UText struct.">UText</a> for a non-const UnicodeString. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>Pointer to a <a class="el" href="structUText.html" title="UText struct.">UText</a> struct. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be created. If non-NULL, must refer to an initialized <a class="el" href="structUText.html" title="UText struct.">UText</a> struct, which will then be reset to reference the specified input string. </td></tr>
    <tr><td class="paramname">s</td><td>A UnicodeString. </td></tr>
    <tr><td class="paramname">status</td><td>Errors are returned here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the <a class="el" href="structUText.html" title="UText struct.">UText</a>. If a <a class="el" href="structUText.html" title="UText struct.">UText</a> was supplied as input, this will always be used and returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003214">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="a6e3bbaca4b8512ea4ccffb53b6bbc615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3bbaca4b8512ea4ccffb53b6bbc615">&#9670;&nbsp;</a></span>utext_openUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a>* utext_openUTF8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a read-only <a class="el" href="structUText.html" title="UText struct.">UText</a> implementation for UTF-8 strings. </p>
<p> 
Any invalid UTF-8 in the input will be handled in this way:
a sequence of bytes that has the form of a truncated, but otherwise valid,
UTF-8 sequence will be replaced by a single unicode replacement character, \uFFFD. 
Any other illegal bytes will each be replaced by a \uFFFD.
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>Pointer to a <a class="el" href="structUText.html" title="UText struct.">UText</a> struct. If NULL, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> will be created. If non-NULL, must refer to an initialized <a class="el" href="structUText.html" title="UText struct.">UText</a> struct, which will then be reset to reference the specified UTF-8 string. </td></tr>
    <tr><td class="paramname">s</td><td>A UTF-8 string. Must not be NULL. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the UTF-8 string in bytes, or -1 if the string is zero terminated. </td></tr>
    <tr><td class="paramname">status</td><td>Errors are returned here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="structUText.html" title="UText struct.">UText</a>. If a pre-allocated <a class="el" href="structUText.html" title="UText struct.">UText</a> was provided, it will always be used and returned. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003212">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="a282a69979e9479fe9b9c006f81ed74b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a282a69979e9479fe9b9c006f81ed74b6">&#9670;&nbsp;</a></span>utext_previous32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> utext_previous32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the iterator position to the character (code point) whose index precedes the current position, and return that character. </p>
<p>This is a pre-decrement operation.</p>
<p>If the initial position is at the start of the text (index of 0) return U_SENTINEL (-1), and leave the position unchanged.</p>
<p>An inline macro version of this function, <a class="el" href="utext_8h.html#a8aa3d9bae7b252622fe8e70e87758205" title="inline version of utext_previous32(), for performance-critical situations.">UTEXT_PREVIOUS32()</a>, is available for performance critical use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the previous UChar32 code point, or U_SENTINEL (-1) if the iteration has reached the start of the text. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="utext_8h.html#a8aa3d9bae7b252622fe8e70e87758205" title="inline version of utext_previous32(), for performance-critical situations.">UTEXT_PREVIOUS32</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003225">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="a1227561991ca6c5c6048bc7f697a7ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1227561991ca6c5c6048bc7f697a7ddb">&#9670;&nbsp;</a></span>utext_previous32From()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> utext_previous32From </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nativeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the iteration index, and return the code point preceding the one specified by the initial index. </p>
<p>Leave the iteration position at the start of the returned code point.</p>
<p>This function is the most efficient and convenient way to begin a backwards iteration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed. </td></tr>
    <tr><td class="paramname">nativeIndex</td><td>Iteration index in the native units of the text provider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Code point preceding the one at the initial index, or U_SENTINEL (-1) if it is out of bounds.</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003227">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="ad99a769d1cd16b673838d4598ec6f156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99a769d1cd16b673838d4598ec6f156">&#9670;&nbsp;</a></span>utext_replace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t utext_replace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nativeStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nativeLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>replacementText</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>replacementLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace a range of the original text with a replacement text. </p>
<p>Leaves the current iteration position at the position following the newly inserted replacement text.</p>
<p>This function is only available on <a class="el" href="structUText.html" title="UText struct.">UText</a> types that support writing, that is, ones where <a class="el" href="utext_8h.html#ad925ba6bff38fb82a1664ff127c94483" title="Return true if the text can be written (modified) with utext_replace() or utext_copy().">utext_isWritable()</a> returns true.</p>
<p>When using this function, there should be only a single <a class="el" href="structUText.html" title="UText struct.">UText</a> opened onto the underlying native text string. Behavior after a replace operation on a <a class="el" href="structUText.html" title="UText struct.">UText</a> is undefined for any other additional UTexts that refer to the modified string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the <a class="el" href="structUText.html" title="UText struct.">UText</a> representing the text to be operated on. </td></tr>
    <tr><td class="paramname">nativeStart</td><td>the native index of the start of the region to be replaced </td></tr>
    <tr><td class="paramname">nativeLimit</td><td>the native index of the character following the region to be replaced. </td></tr>
    <tr><td class="paramname">replacementText</td><td>pointer to the replacement text </td></tr>
    <tr><td class="paramname">replacementLength</td><td>length of the replacement text, or -1 if the text is NUL terminated. </td></tr>
    <tr><td class="paramname">status</td><td>receives any error status. Possible errors include U_NO_WRITE_PERMISSION</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The signed number of (native) storage units by which the length of the text expanded or contracted.</dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003239">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="adc484cb765c4ef02d740b55b9cbc5b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc484cb765c4ef02d740b55b9cbc5b34">&#9670;&nbsp;</a></span>utext_setNativeIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void utext_setNativeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>nativeIndex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the current iteration position to the nearest code point boundary at or preceding the specified index. </p>
<p>The index is in the native units of the original input text. If the index is out of range, it will be pinned to be within the range of the input text. </p>
<p>It will usually be more efficient to begin an iteration using the functions <a class="el" href="utext_8h.html#ae1b4f05c43927c1e261e3779afb4fc75" title="Set the iteration index and return the code point at that index.">utext_next32From()</a> or <a class="el" href="utext_8h.html#a1227561991ca6c5c6048bc7f697a7ddb" title="Set the iteration index, and return the code point preceding the one specified by the initial index.">utext_previous32From()</a> rather than setIndex(). </p>
<p>Moving the index position to an adjacent character is best done with <a class="el" href="utext_8h.html#af0ef1bd96a7aea7c86b527a6175c54ff" title="Get the code point at the current iteration position of the UText, and advance the position to the fi...">utext_next32()</a>, <a class="el" href="utext_8h.html#a282a69979e9479fe9b9c006f81ed74b6" title="Move the iterator position to the character (code point) whose index precedes the current position,...">utext_previous32()</a> or <a class="el" href="utext_8h.html#a2b3dd31ef0447087bf79e0ddd94c5f94" title="Move the iterator position by delta code points.">utext_moveIndex32()</a>. Attempting to do direct arithmetic on the index position is complicated by the fact that the size (in native units) of a character depends on the underlying representation of the character (UTF-8, UTF-16, UTF-32, arbitrary codepage), and is not easily knowable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>the text to be accessed. </td></tr>
    <tr><td class="paramname">nativeIndex</td><td>the native unit index of the new iteration position. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003229">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
<a id="abf69b0c8fba92943144faa446519b739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf69b0c8fba92943144faa446519b739">&#9670;&nbsp;</a></span>utext_setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="structUText.html">UText</a>* utext_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>ut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>extraSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Common function for use by Text Provider implementations to allocate and/or initialize a new <a class="el" href="structUText.html" title="UText struct.">UText</a> struct. </p>
<p>To be called in the implementation of utext_open() functions. If the supplied <a class="el" href="structUText.html" title="UText struct.">UText</a> parameter is null, a new <a class="el" href="structUText.html" title="UText struct.">UText</a> struct will be allocated on the heap. If the supplied <a class="el" href="structUText.html" title="UText struct.">UText</a> is already open, the provider's close function will be called so that the struct can be reused by the open that is in progress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ut</td><td>pointer to a <a class="el" href="structUText.html" title="UText struct.">UText</a> struct to be re-used, or null if a new <a class="el" href="structUText.html" title="UText struct.">UText</a> should be allocated. </td></tr>
    <tr><td class="paramname">extraSpace</td><td>The amount of additional space to be allocated as part of this <a class="el" href="structUText.html" title="UText struct.">UText</a>, for use by types of providers that require additional storage. </td></tr>
    <tr><td class="paramname">status</td><td>Errors are returned here. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the <a class="el" href="structUText.html" title="UText struct.">UText</a>, allocated if necessary, with extra space set up if requested. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable003254">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
