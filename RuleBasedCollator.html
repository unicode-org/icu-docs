<html><head><TITLE>RuleBasedCollator</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  U_I18N_API RuleBasedCollator : public <!2><A HREF="Collator.html#DOC.7.24">Collator</A> </H2><BLOCKQUOTE>

The RuleBasedCollator class provides the simple implementation of Collator,
using data-driven tables
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CCollator,MCollator.html,CRuleBasedCollator,MRuleBasedCollator.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
</DL>
<hr><H3>Inherited from <A HREF="Collator.html">Collator:</A></h3>

<DL>
<DL>
<DT><h3>Protected Methods</h3><DD><DT><IMG SRC=icon2.gif> const  <!2><A HREF="Collator.html#DOC.7.24">Collator</A>&  <B>operator=</B>(const <!2><A HREF="Collator.html#DOC.7.24">Collator</A>& other)
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

The RuleBasedCollator class provides the simple implementation of Collator,
using data-driven tables.  The user can create a customized table-based
collation.
<P>
RuleBasedCollator maps characters to collation keys.
<p>
Table Collation has the following restrictions for efficiency (other
subclasses may be used for more complex languages) :
<p>1. If the French secondary ordering is specified in a collation object, 
it is applied to the whole object.
<p>2. All non-mentioned Unicode characters are at the end of the
collation order.
<p>3. Private use characters are treated as identical.  The private
use area in Unicode is 0xE800-0xF8FF.
<p>The collation table is composed of a list of collation rules, where each
rule is of three forms:
<pre>
.    &lt; modifier >
.    &lt; relation > &lt; text-argument >
.    &lt; reset > &lt; text-argument >
</pre>
The following demonstrates how to create your own collation rules:
<UL Type=round>
<LI><strong>Text Argument</strong>: A text argument is any sequence of
characters, excluding special characters (that is, whitespace
characters and the characters used in modifier, relation and reset).
If those characters are desired, you can put them in single quotes
(e.g. ampersand => '&').<P>
<LI><strong>Modifier</strong>: There is a single modifier,
which is used to specify that all secondary differences are
sorted backwards.
<p>'@' : Indicates that secondary differences, such as accents, are 
sorted backwards, as in French.<P>
<LI><strong>Relation</strong>: The relations are the following:
<UL Type=square>
<LI>'&lt;' : Greater, as a letter difference (primary)
<LI>';' : Greater, as an accent difference (secondary)
<LI>',' : Greater, as a case difference (tertiary)
<LI>'=' : Equal
</UL><P>
<LI><strong>Reset</strong>: There is a single reset,
which is used primarily for contractions and expansions, but which
can also be used to add a modification at the end of a set of rules.
<p>'&' : Indicates that the next rule follows the position to where
the reset text-argument would be sorted.

<p>
This sounds more complicated than it is in practice. For example, the
following are equivalent ways of expressing the same thing:
<pre>
.    a &lt; b &lt; c
.    a &lt; b & b &lt; c
.    a &lt; c & a &lt; b
</pre>
Notice that the order is important, as the subsequent item goes immediately
after the text-argument. The following are not equivalent:
<pre>
.    a &lt; b & a &lt; c
.    a &lt; c & a &lt; b
</pre>
Either the text-argument must already be present in the sequence, or some
initial substring of the text-argument must be present. (e.g. "a &lt; b & ae &lt;
e" is valid since "a" is present in the sequence before "ae" is reset). In
this latter case, "ae" is not entered and treated as a single character;
instead, "e" is sorted as if it were expanded to two characters: "a"
followed by an "e". This difference appears in natural languages: in
traditional Spanish "ch" is treated as though it contracts to a single
character (expressed as "c &lt; ch &lt; d"), while in traditional German "ä"
(a-umlaut) is treated as though it expands to two characters (expressed as
"a & ae ; ä &lt; b").
<p><strong>Ignorable Characters</strong>
<p>For ignorable characters, the first rule must start with a relation (the
examples we have used above are really fragments; "a &lt; b" really should be
"&lt; a &lt; b"). If, however, the first relation is not "&lt;", then all the 
text-arguments up to the first "&lt;" are ignorable. For example, ", - &lt; a &lt; b"
makes "-" an ignorable character, as we saw earlier in the word
"black-birds". In the samples for different languages, you see that most
accents are ignorable.
<p><strong>Normalization and Accents</strong>
<p>The Collator object automatically normalizes text internally to separate
accents from base characters where possible. This is done both when
processing the rules, and when comparing two strings. Collator also uses
the Unicode canonical mapping to ensure that combining sequences are sorted
properly (for more information, see <A HREF="http://www.aw.com/devpress">
The Unicode Standard, Version 2.0</A>.)</P>
<p><strong>Errors</strong>
<p>The following are errors:
<UL Type=round>
<LI>A text-argument contains unquoted punctuation symbols
(e.g. "a &lt; b-c &lt; d").
<LI>A relation or reset character not followed by a text-argument
(e.g. "a &lt; , b").
<LI>A reset where the text-argument (or an initial substring of the
text-argument) is not already in the sequence.
(e.g. "a &lt; b & e &lt; f")
</UL>
<pre>
.    Examples:
.    Simple:     "&lt; a &lt; b &lt; c &lt; d"
.    Norwegian:  "&lt; a,A&lt; b,B&lt; c,C&lt; d,D&lt; e,E&lt; f,F&lt; g,G&lt; h,H&lt; i,I&lt; j,J
.                 &lt; k,K&lt; l,L&lt; m,M&lt; n,N&lt; o,O&lt; p,P&lt; q,Q&lt; r,R&lt; s,S&lt; t,T
.                 &lt; u,U&lt; v,V&lt; w,W&lt; x,X&lt; y,Y&lt; z,Z
.                 &lt; å=a°,Å=A°
.                 ;aa,AA&lt; æ,Æ&lt; ø,Ø"
</pre>
<p>To create a table-based collation object, simply supply the collation
rules to the RuleBasedCollator contructor.  For example:
<pre>
.    UErrorCode status = ZERO_ERROR;
.    RuleBasedCollator *mySimple = new RuleBasedCollator(Simple, status);
</pre>
<p>Another example:
<pre>
.    UErrorCode status = ZERO_ERROR;
.    RuleBasedCollator *myNorwegian = new RuleBasedCollator(Norwegian, status);
</pre>
To add rules on top of an existing table, simply supply the orginal rules
and modifications to RuleBasedCollator constructor.  For example,
<pre>
.     Traditional Spanish (fragment): ... & C &lt; ch , cH , Ch , CH ...
.     German (fragment) : ...&lt; y , Y &lt; z , Z
.                         & AE, Ä & AE, ä 
.                         & OE , Ö & OE, ö 
.                         & UE , Ü & UE, ü 
.     Symbols (fragment): ...&lt; y, Y &lt; z , Z
.                         & Question-mark ; '?'
.                         & Ampersand ; '&'
.                         & Dollar-sign ; '$'
<p>To create a collation object for traditional Spanish, the user can take
the English collation rules and add the additional rules to the table.
For example:
<pre>
.     UErrorCode status = ZERO_ERROR;
.     UnicodeString rules(DEFAULTRULES);
.     rules += "& C &lt; ch, cH, Ch, CH";
.     RuleBasedCollator *mySpanish = new RuleBasedCollator(rules, status);
</pre>
<p>In order to sort symbols in the similiar order of sorting their
alphabetic equivalents, you can do the following,
<pre>
.     UErrorCode status = ZERO_ERROR;
.     UnicodeString rules(DEFAULTRULES);
.     rules += "& Question-mark ; '?' & Ampersand ; '&' & Dollar-sign ; '$' ";
.     RuleBasedCollator *myTable = new RuleBasedCollator(rules, status);
</pre>
<p>Another way of creating the table-based collation object, mySimple,
is:
<pre>
.     UErrorCode status = ZERO_ERROR;
.     RuleBasedCollator *mySimple = new
.           RuleBasedCollator(" &lt; a &lt; b & b &lt; c & c &lt; d", status);
</pre>
Or,
<pre>
.     UErrorCode status = ZERO_ERROR;
.     RuleBasedCollator *mySimple = new
.           RuleBasedCollator(" &lt; a &lt; b &lt; d & b &lt; c", status);
</pre>
Because " &lt; a &lt; b &lt; c &lt; d" is the same as "a &lt; b &lt; d & b &lt; c" or
"&lt; a &lt; b & b &lt; c & c &lt; d".

<p>To combine collations from two locales, (without error handling for clarity)
<pre>
.    // Create an en_US Collator object
.    Locale locale_en_US("en", "US", "");
.    RuleBasedCollator* en_USCollator = (RuleBasedCollator*)
.        Collator::createInstance( locale_en_US, success );
.
.    // Create a da_DK Collator object
.    Locale locale_da_DK("da", "DK", "");
.    RuleBasedCollator* da_DKCollator = (RuleBasedCollator*)
.        Collator::createInstance( locale_da_DK, success );
.
.    // Combine the two
.    // First, get the collation rules from en_USCollator
.    UnicodeString rules = en_USCollator->getRules();
.    // Second, get the collation rules from da_DKCollator
.    rules += da_DKCollator->getRules();
.    RuleBasedCollator* newCollator = new RuleBasedCollator( rules, success );
.    // newCollator has the combined rules
</pre>
<p>Another more interesting example would be to make changes on an existing
table to create a new collation object.  For example, add
"& C &lt; ch, cH, Ch, CH" to the en_USCollation object to create your own
English collation object,
<pre>
.    // Create a new Collator object with additional rules
.    rules = en_USCollator->getRules();
.    rules += "& C < ch, cH, Ch, CH";
.    RuleBasedCollator* myCollator = new RuleBasedCollator( rules, success );
.    // myCollator contains the new rules
</pre>

<p>The following example demonstrates how to change the order of
non-spacing accents,
<pre>
.     UChar contents[] = {
.         '=', 0x0301, ';', 0x0300, ';', 0x0302,
.         ';', 0x0308, ';', 0x0327, ',', 0x0303,    // main accents
.         ';', 0x0304, ';', 0x0305, ';', 0x0306,    // main accents
.         ';', 0x0307, ';', 0x0309, ';', 0x030A,    // main accents
.         ';', 0x030B, ';', 0x030C, ';', 0x030D,    // main accents
.         ';', 0x030E, ';', 0x030F, ';', 0x0310,    // main accents
.         ';', 0x0311, ';', 0x0312,                 // main accents
.         '&lt;', 'a', ',', 'A', ';', 'a', 'e', ',', 'A', 'E',
.         ';', 0x00e6, ',', 0x00c6, '&lt;', 'b', ',', 'B',
.         '&lt;', 'c', ',', 'C', '&lt;', 'e', ',', 'E', '&', 
.         'C', '&lt;', 'd', ',', 'D', 0 };
.     UnicodeString oldRules(contents);
.     UErrorCode status = ZERO_ERROR;
.     // change the order of accent characters
.     UChar addOn[] = { '&', ',', 0x0300, ';', 0x0308, ';', 0x0302, 0 };
.     oldRules += addOn;
.     RuleBasedCollator *myCollation = new RuleBasedCollator(oldRules, status);
</pre>

<p> The last example shows how to put new primary ordering in before the
default setting. For example, in Japanese collation, you can either sort
English characters before or after Japanese characters,
<pre>
.     UErrorCode status = ZERO_ERROR;
.     // get en_US collation rules
.     RuleBasedCollator* en_USCollation = 
.         (RuleBasedCollator*) Collator::createInstance(Locale::US, status);
.     // Always check the error code after each call.
.     if (FAILURE(status)) return;
.     // add a few Japanese character to sort before English characters
.     // suppose the last character before the first base letter 'a' in
.     // the English collation rule is 0x2212
.     UChar jaString[] = { '&', 0x2212, '&lt;', 0x3041, ',', 0x3042, '&lt;', 0x3043, ',', 0x3044, 0 };
.     UnicodeString rules( en_USCollation->getRules() );
.     rules += jaString;
.     RuleBasedCollator *myJapaneseCollation = new RuleBasedCollator(rules, status);
</pre>
<p><strong>NOTE</strong>: Typically, a collation object is created with
Collator::createInstance().
<p>
<strong>Note:</strong> <code>RuleBasedCollator</code>s with different Locale,
CollationStrength and Decomposition mode settings will return different
sort orders for the same set of strings. Locales have specific 
collation rules, and the way in which secondary and tertiary differences 
are taken into account, for example, will result in a different sorting order
for same strings.
<p>


</BLOCKQUOTE>
<DL>
</DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL><DT><B>Author:</B><DD>Helena Shih
<DT><B>Version:</B><DD>1.27 4/8/97

<DT><B>See Also:</B><DD><!2><A HREF="Collator.html#DOC.7.24">Collator</A>
<br></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
