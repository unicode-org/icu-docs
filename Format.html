<html><head><TITLE>Format</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  U_I18N_API Format  </H2><BLOCKQUOTE>

Base class for all formats
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=125>
<param name=classes value="CFormat,MFormat.html,CNumberFormat,MNumberFormat.html,CMessageFormat,MMessageFormat.html,CDateFormat,MDateFormat.html">
<param name=before value="M,M|_,MR_,Mr_">
<param name=after value="M,M,M,M">
<param name=indent value="0,0,0,0">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.14.1"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>operator==</B>(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const  </B>
 <DD><I>
Return true if the given Format objects are semantically equal</I>
<DT><A HREF="#DOC.14.9"> <IMG BORDER=0 SRC=icon1.gif></A> bool_t  <B>operator!=</B>(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const  </B>
 <DD><I>
Return true if the given Format objects are not semantically
equal</I>
<DT><A HREF="#DOC.14.2"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!2><A HREF="Format.html#DOC.14.8">Format</A>*  <B>clone</B>() const  </B>
 <DD><I>
Clone this object polymorphically</I>
<DT><A HREF="#DOC.14.3"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const  </B>
 <DD><I>
Formats an object to produce a string</I>
<DT><A HREF="#DOC.14.4"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const  </B>
 <DD><I>
Format an object to produce a string</I>
<DT><A HREF="#DOC.14.5"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>parseObject</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parse_pos) const  </B>
 <DD><I>
Parse a string to produce an object</I>
<DT><A HREF="#DOC.14.6"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>parseObject</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const  </B>
 <DD><I>
Parses a string to produce an object</I>
<DT><A HREF="#DOC.14.7"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="ClassID.html">ClassID</A>  <B>getDynamicClassID</B>() const  </B>
 <DD><I>
Returns a unique class ID POLYMORPHICALLY</I>
</DL><DL>
<DT><h3>Protected Methods</h3><DD><DT><A HREF="#DOC.14.8"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Format</B>() </B>
 <DD><I>
Default constructor for subclass use only</I>
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

Base class for all formats.  This is an abstract base class which
specifies the protocol for classes which convert other objects or
values, such as numeric values and dates, and their string
representations.  In some cases these representations may be
localized or contain localized characters or strings.  For example,
a numeric formatter such as DecimalFormat may convert a numeric
value such as 12345 to the string "$12,345".  It may also parse
the string back into a numeric value.  A date and time formatter
like SimpleDateFormat may represent a specific date, encoded
numerically, as a string such as "Wednesday, February 26, 1997 AD".
<P>
Many of the concrete subclasses of Format employ the notion of
a pattern.  A pattern is a string representation of the rules which
govern the interconversion between values and strings.  For example,
a DecimalFormat object may be associated with the pattern
"$#,##0.00;($#,##0.00)", which is a common US English format for
currency values, yielding strings such as "$1,234.45" for 1234.45,
and "($987.65)" for 987.6543.  The specific syntax of a pattern
is defined by each subclass.
<P>
Even though many subclasses use patterns, the notion of a pattern
is not inherent to Format classes in general, and is not part of
the explicit base class protocol.
<P>
Two complex formatting classes bear mentioning.  These are
MessageFormat and ChoiceFormat.  ChoiceFormat is a subclass of
NumberFormat which allows the user to format different number ranges
as strings.  For instance, 0 may be represented as "no files", 1 as
"one file", and any number greater than 1 as "many files".
MessageFormat is a formatter which utilizes other Format objects to
format a string containing with multiple values.  For instance,
A MessageFormat object might produce the string "There are no files
on the disk MyDisk on February 27, 1997." given the arguments 0,
"MyDisk", and the date value of 2/27/97.  See the ChoiceFormat
and MessageFormat headers for further information.
<P>
If formatting is unsuccessful, a failing UErrorCode is returned when
the Format cannot format the type of object, otherwise if there is
something illformed about the the Unicode replacement character
0xFFFD is returned.
<P>
If there is no match when parsing, a parse failure UErrorCode is
retured for methods which take no ParsePosition.  For the method
that takes a ParsePosition, the index parameter is left unchanged.
<P>
[Subclassing.] All base classes that provide static functions that
create objects for Locales must implement the following static:
<pre>
.      public static const Locale* getAvailableLocales(long&)
</pre>

</BLOCKQUOTE>
<DL>

<A NAME="operator==">
<A NAME ="DOC.14.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  operator==(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const </B></TT>
<DD>
Return true if the given Format objects are semantically equal.
Objects of different subclasses are considered unequal.
<DL></DL><P>
<A NAME="operator!=">
<A NAME ="DOC.14.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool_t  operator!=(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const </B></TT>
<DD>
Return true if the given Format objects are not semantically
equal
<DL></DL><P>
<A NAME="clone">
<A NAME ="DOC.14.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!2><A HREF="Format.html#DOC.14.8">Format</A>*  clone() const </B></TT>
<DD>
Clone this object polymorphically.  The caller is responsible
for deleting the result when done.
<DL></DL><P>
<A NAME="format">
<A NAME ="DOC.14.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const </B></TT>
<DD>
Formats an object to produce a string.


<DL><DT><B>Returns:</B><DD>Reference to 'result' parameter.
<DT><B>Parameters:</B><DD><B>obj</B> -        The object to format.
<br><B>result</B> -     Output parameter which will be filled in with the
formatted string.
<br><B>status</B> -     Output parameter filled in with success or failure status.
<br></DL><P>
<A NAME="format">
<A NAME ="DOC.14.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const </B></TT>
<DD>
Format an object to produce a string.  This is a pure virtual method which
subclasses must implement. This method allows polymorphic formatting
of Formattable objects. If a subclass of Format receives a Formattable
object type it doesn't handle (e.g., if a numeric Formattable is passed
to a DateFormat object) then it returns a failing UErrorCode.


<DL><DT><B>Returns:</B><DD>The value passed in as toAppendTo (this allows chaining,
as with UnicodeString::append())
<DT><B>Parameters:</B><DD><B>obj</B> -            The object to format.
<br><B>toAppendTo</B> -     Where the text is to be appended.
<br><B>pos</B> -            On input: an alignment field, if desired.
On output: the offsets of the alignment field.
<br><B>status</B> -         Output param filled with success/failure status.
<br></DL><P>
<A NAME="parseObject">
<A NAME ="DOC.14.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  parseObject(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parse_pos) const </B></TT>
<DD>
Parse a string to produce an object.  This is a pure virtual
method which subclasses must implement.  This method allows
polymorphic parsing of strings into Formattable objects.
<P>
Before calling, set parse_pos.index to the offset you want to
start parsing at in the source.  After calling, parse_pos.index
is the end of the text you parsed.  If error occurs, index is
unchanged.
<P>
When parsing, leading whitespace is discarded (with successful
parse), while trailing whitespace is left as is.
<P>
Example:
<P>
Parsing "_12_xy" (where _ represents a space) for a number,
with index == 0 will result in the number 12, with
parse_pos.index updated to 3 (just before the second space).
Parsing a second time will result in a failing UErrorCode since
"xy" is not a number, and leave index at 3.
<P>
Subclasses will typically supply specific parse methods that
return different types of values. Since methods can't overload
on return types, these will typically be named "parse", while
this polymorphic method will always be called parseObject.  Any
parse method that does not take a parse_pos should set status
to an error value when no text in the required format is at the
start position.


<DL><DT><B>Parameters:</B><DD><B>source</B> -     The string to be parsed into an object.
<br><B>result</B> -     Formattable to be set to the parse result.
If parse fails, return contents are undefined.
<br><B>parse_pos</B> -  The position to start parsing at. Upon return
this param is set to the position after the
last character successfully parsed. If the
source is not parsed successfully, this param
will remain unchanged.<br></DL><P>
<A NAME="parseObject">
<A NAME ="DOC.14.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  parseObject(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const </B></TT>
<DD>
Parses a string to produce an object. This is a convenience method
which calls the pure virtual parseObject() method, and returns a
failure UErrorCode if the ParsePosition indicates failure.


<DL><DT><B>Parameters:</B><DD><B>source</B> -     The string to be parsed into an object.
<br><B>result</B> -     Formattable to be set to the parse result.
If parse fails, return contents are undefined.
<br><B>status</B> -     Output param to be filled with success/failure
result code.<br></DL><P>
<A NAME="getDynamicClassID">
<A NAME ="DOC.14.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="ClassID.html">ClassID</A>  getDynamicClassID() const </B></TT>
<DD>
Returns a unique class ID POLYMORPHICALLY.  Pure virtual method.
This method is to implement a simple version of RTTI, since not all
C++ compilers support genuine RTTI.  Polymorphic operator==() and
clone() methods call this method.
<P>
Concrete subclasses of Format must implement getDynamicClassID()
and also a static method and data member:

static ClassID getStaticClassID() { return (ClassID)&fgClassID; }
static char fgClassID;


<DL><DT><B>Returns:</B><DD>The class ID for this object. All objects of a
given class have the same class ID.  Objects of
other classes have different class IDs.
</DL><P>
<A NAME="Format">
<A NAME ="DOC.14.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Format()</B></TT>
<DD>
Default constructor for subclass use only.  Does nothing.
<DL></DL><P></DL>
<hr>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="NumberFormat.html"> NumberFormat </A><br>
<A HREF="MessageFormat.html"> MessageFormat </A><br>
<A HREF="DateFormat.html"> DateFormat </A><br>
</DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
