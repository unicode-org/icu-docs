<html><head><TITLE>GregorianCalendar</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  U_I18N_API GregorianCalendar : public <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A> </H2><BLOCKQUOTE>

Concrete class which provides the standard calendar used by most of the world
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CCalendar,MCalendar.html,CGregorianCalendar,MGregorianCalendar.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Classes</h3><DD><DT><A HREF="#DOC.26.46"> <IMG BORDER=0 SRC=icon1.gif></A>  enum  <B>EEras</B> </B>
 <DD><I>
Useful constants for GregorianCalendar and TimeZone</I>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.26.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GregorianCalendar</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& success) </B>
 <DD><I>
Constructs a default GregorianCalendar using the current time in the default time
zone with the default locale</I>
<DT><A HREF="#DOC.26.2"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GregorianCalendar</B>(<!1><A HREF="TimeZone.html">TimeZone</A>* zoneToAdopt, <!2><A HREF="#DOC.320">UErrorCode</A>& success) </B>
 <DD><I>
Constructs a GregorianCalendar based on the current time in the given time zone
with the default locale</I>
<DT><A HREF="#DOC.26.3"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GregorianCalendar</B>(const <!1><A HREF="TimeZone.html">TimeZone</A>& zone, <!2><A HREF="#DOC.320">UErrorCode</A>& success) </B>
 <DD><I>
Constructs a GregorianCalendar based on the current time in the given time zone
with the default locale</I>
<DT><A HREF="#DOC.26.4"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GregorianCalendar</B>(const Locale& aLocale, <!2><A HREF="#DOC.320">UErrorCode</A>& success) </B>
 <DD><I>
Constructs a GregorianCalendar based on the current time in the default time zone
with the given locale</I>
<DT><A HREF="#DOC.26.5"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GregorianCalendar</B>(<!1><A HREF="TimeZone.html">TimeZone</A>* zoneToAdopt, const Locale& aLocale, <!2><A HREF="#DOC.320">UErrorCode</A>& success) </B>
 <DD><I>
Constructs a GregorianCalendar based on the current time in the given time zone
with the given locale</I>
<DT><A HREF="#DOC.26.6"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GregorianCalendar</B>(const <!1><A HREF="TimeZone.html">TimeZone</A>& zone, const Locale& aLocale, <!2><A HREF="#DOC.320">UErrorCode</A>& success) </B>
 <DD><I>
Constructs a GregorianCalendar based on the current time in the given time zone
with the given locale</I>
<DT><A HREF="#DOC.26.7"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GregorianCalendar</B>(int32_t year, int32_t month, int32_t date, <!2><A HREF="#DOC.320">UErrorCode</A>& success) </B>
 <DD><I>
Constructs a GregorianCalendar with the given AD date set in the default time
zone with the default locale</I>
<DT><A HREF="#DOC.26.8"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GregorianCalendar</B>(int32_t year, int32_t month, int32_t date, int32_t hour, int32_t minute, <!2><A HREF="#DOC.320">UErrorCode</A>& success) </B>
 <DD><I>
Constructs a GregorianCalendar with the given AD date and time set for the
default time zone with the default locale</I>
<DT><A HREF="#DOC.26.9"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GregorianCalendar</B>(int32_t year, int32_t month, int32_t date, int32_t hour, int32_t minute, int32_t second, <!2><A HREF="#DOC.320">UErrorCode</A>& success) </B>
 <DD><I>
Constructs a GregorianCalendar with the given AD date and time set for the
default time zone with the default locale</I>
<DT><A HREF="#DOC.26.47"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <B>~GregorianCalendar</B>() </B>
 <DD><I>
Destructor</I>
<DT><A HREF="#DOC.26.48"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>GregorianCalendar</B>(const <!2><A HREF="GregorianCalendar.html#DOC.26.6">GregorianCalendar</A>& source) </B>
 <DD><I>
Copy constructor</I>
<DT><A HREF="#DOC.26.49"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="GregorianCalendar.html#DOC.26.6">GregorianCalendar</A>&  <B>operator=</B>(const <!2><A HREF="GregorianCalendar.html#DOC.26.6">GregorianCalendar</A>& right) </B>
 <DD><I>
Default assignment operator</I>
<DT><A HREF="#DOC.26.50"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>*  <B>clone</B>(void) const  </B>
 <DD><I>
Create and return a polymorphic copy of this calendar</I>
<DT><A HREF="#DOC.26.10"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setGregorianChange</B>(<!1><A HREF="UDate.html">UDate</A> date, <!2><A HREF="#DOC.320">UErrorCode</A>& success) </B>
 <DD><I>
Sets the GregorianCalendar change date</I>
<DT><A HREF="#DOC.26.11"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UDate.html">UDate</A>  <B>getGregorianChange</B>(void) const  </B>
 <DD><I>
Gets the Gregorian Calendar change date</I>
<DT><A HREF="#DOC.26.12"> <IMG BORDER=0 SRC=icon1.gif></A> bool_t  <B>isLeapYear</B>(int32_t year) const  </B>
 <DD><I>
Return true if the given year is a leap year</I>
<DT><A HREF="#DOC.26.13"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>operator==</B>(const <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>& that) const  </B>
 <DD><I>
Compares the equality of two GregorianCalendar objects</I>
<DT><A HREF="#DOC.26.14"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>equivalentTo</B>(const <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>& other) const  </B>
 <DD><I>
Calendar override</I>
<DT><A HREF="#DOC.26.15"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>add</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field, int32_t amount, <!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
(Overrides Calendar) UDate Arithmetic function</I>
<DT><A HREF="#DOC.26.16"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>roll</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field, int32_t amount, <!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
(Overrides Calendar) Rolls up or down by the given amount in the specified field</I>
<DT><A HREF="#DOC.26.17"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  int32_t  <B>getMinimum</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const  </B>
 <DD><I>
(Overrides Calendar) Returns minimum value for the given field</I>
<DT><A HREF="#DOC.26.18"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  int32_t  <B>getMaximum</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const  </B>
 <DD><I>
(Overrides Calendar) Returns maximum value for the given field</I>
<DT><A HREF="#DOC.26.19"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  int32_t  <B>getGreatestMinimum</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const  </B>
 <DD><I>
(Overrides Calendar) Returns highest minimum value for the given field if varies</I>
<DT><A HREF="#DOC.26.20"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  int32_t  <B>getLeastMaximum</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const  </B>
 <DD><I>
(Overrides Calendar) Returns lowest maximum value for the given field if varies</I>
<DT><A HREF="#DOC.26.21"> <IMG BORDER=0 SRC=icon1.gif></A> int32_t  <B>getActualMinimum</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const  </B>
 <DD><I>
Return the minimum value that this field could have, given the current date</I>
<DT><A HREF="#DOC.26.22"> <IMG BORDER=0 SRC=icon1.gif></A> int32_t  <B>getActualMaximum</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const  </B>
 <DD><I>
Return the maximum value that this field could have, given the current date</I>
<DT><A HREF="#DOC.26.23"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>inDaylightTime</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
(Overrides Calendar) Return true if the current date for this Calendar is in
Daylight Savings Time</I>
<DT><A HREF="#DOC.26.24"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UClassID.html">UClassID</A>  <B>getDynamicClassID</B>(void) const  </B>
 <DD><I>
Override Calendar Returns a unique class ID POLYMORPHICALLY</I>
<DT><A HREF="#DOC.26.25"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!1><A HREF="UClassID.html">UClassID</A>  <B>getStaticClassID</B>(void) </B>
 <DD><I>
Return the class ID for this class</I>
</DL><DL>
<DT><h3>Protected Methods</h3><DD><DT><A HREF="#DOC.26.51"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>computeFields</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
(Overrides Calendar) Converts GMT as milliseconds to time field values</I>
<DT><A HREF="#DOC.26.26"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>computeTime</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& status) </B>
 <DD><I>
(Overrides Calendar) Converts Calendar's time field values to GMT as
milliseconds</I>
</DL></DL>
<hr><H3>Inherited from <A HREF="Calendar.html">Calendar:</A></h3>

<DL>
<DL>
<DT><h3>Public Classes</h3><DD><DT><IMG SRC=icon2.gif>  enum  <B>EDateFields</B>
<DT><IMG SRC=icon2.gif>  enum  <B>EDaysOfWeek</B>
<DT><IMG SRC=icon2.gif>  enum  <B>EMonths</B>
<DT><IMG SRC=icon2.gif>  enum  <B>EAmpm</B>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><IMG SRC=icon2.gif> static  <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>*  <B>createInstance</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& success)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>*  <B>createInstance</B>(<!1><A HREF="TimeZone.html">TimeZone</A>* zoneToAdopt, <!2><A HREF="#DOC.320">UErrorCode</A>& success)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>*  <B>createInstance</B>(const <!1><A HREF="TimeZone.html">TimeZone</A>& zone, <!2><A HREF="#DOC.320">UErrorCode</A>& success)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>*  <B>createInstance</B>(const Locale& aLocale, <!2><A HREF="#DOC.320">UErrorCode</A>& success)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>*  <B>createInstance</B>(<!1><A HREF="TimeZone.html">TimeZone</A>* zoneToAdopt, const Locale& aLocale, <!2><A HREF="#DOC.320">UErrorCode</A>& success)
<DT><IMG SRC=icon2.gif> static  <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>*  <B>createInstance</B>(const <!1><A HREF="TimeZone.html">TimeZone</A>& zoneToAdopt, const Locale& aLocale, <!2><A HREF="#DOC.320">UErrorCode</A>& success)
<DT><IMG SRC=icon2.gif> static  const  Locale*  <B>getAvailableLocales</B>(int32_t& count)
<DT><IMG SRC=icon2.gif> static  <!1><A HREF="UDate.html">UDate</A>  <B>getNow</B>(void)
<DT><IMG SRC=icon2.gif> inline  <!1><A HREF="UDate.html">UDate</A>  <B>getTime</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& status) const 
<DT><IMG SRC=icon2.gif> inline  void  <B>setTime</B>(<!1><A HREF="UDate.html">UDate</A> date, <!2><A HREF="#DOC.320">UErrorCode</A>& status)
<DT><IMG SRC=icon2.gif> bool_t  <B>operator!=</B>(const <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>& that) const 
<DT><IMG SRC=icon2.gif> bool_t  <B>equals</B>(const <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>& when, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const 
<DT><IMG SRC=icon2.gif> bool_t  <B>before</B>(const <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>& when, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const 
<DT><IMG SRC=icon2.gif> bool_t  <B>after</B>(const <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>& when, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const 
<DT><IMG SRC=icon2.gif> void  <B>adoptTimeZone</B>(<!1><A HREF="TimeZone.html">TimeZone</A>* value)
<DT><IMG SRC=icon2.gif> void  <B>setTimeZone</B>(const <!1><A HREF="TimeZone.html">TimeZone</A>& zone)
<DT><IMG SRC=icon2.gif> const  <!1><A HREF="TimeZone.html">TimeZone</A>&  <B>getTimeZone</B>(void) const 
<DT><IMG SRC=icon2.gif> <!1><A HREF="TimeZone.html">TimeZone</A>*  <B>orphanTimeZone</B>(void)
<DT><IMG SRC=icon2.gif> void  <B>setLenient</B>(bool_t lenient)
<DT><IMG SRC=icon2.gif> bool_t  <B>isLenient</B>(void) const 
<DT><IMG SRC=icon2.gif> void  <B>setFirstDayOfWeek</B>(<!2><A HREF="Calendar.html#DOC.3.2">EDaysOfWeek</A> value)
<DT><IMG SRC=icon2.gif> <!2><A HREF="Calendar.html#DOC.3.2">EDaysOfWeek</A>  <B>getFirstDayOfWeek</B>(void) const 
<DT><IMG SRC=icon2.gif> void  <B>setMinimalDaysInFirstWeek</B>(uint8_t value)
<DT><IMG SRC=icon2.gif> uint8_t  <B>getMinimalDaysInFirstWeek</B>(void) const 
<DT><IMG SRC=icon2.gif> int32_t  <B>get</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const 
<DT><IMG SRC=icon2.gif> bool_t  <B>isSet</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const 
<DT><IMG SRC=icon2.gif> void  <B>set</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field, int32_t value)
<DT><IMG SRC=icon2.gif> void  <B>set</B>(int32_t year, int32_t month, int32_t date)
<DT><IMG SRC=icon2.gif> void  <B>set</B>(int32_t year, int32_t month, int32_t date, int32_t hour, int32_t minute)
<DT><IMG SRC=icon2.gif> void  <B>set</B>(int32_t year, int32_t month, int32_t date, int32_t hour, int32_t minute, int32_t second)
<DT><IMG SRC=icon2.gif> void  <B>clear</B>(void)
<DT><IMG SRC=icon2.gif> void  <B>clear</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field)
<DT><IMG SRC=icon2.gif> inline  void  <B>Calendar::internalSet</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field, int32_t value)
</DL><DL>
<DT><h3>Protected Fields</h3><DD><DT><IMG SRC=icon2.gif> bool_t  <B>fIsTimeSet</B>
<DT><IMG SRC=icon2.gif> bool_t  <B>fAreFieldsSet</B>
<DT><IMG SRC=icon2.gif> bool_t  <B>fAreAllFieldsSet</B>
<DT><IMG SRC=icon2.gif> int32_t  <B>fFields</B>[FIELD_COUNT]
<DT><IMG SRC=icon2.gif> bool_t  <B>fIsSet</B>[FIELD_COUNT]
<DT><IMG SRC=icon2.gif> int32_t  <B>fStamp</B>[FIELD_COUNT]
</DL><DL>
<DT><h3>Protected Methods</h3><DD><DT><IMG SRC=icon2.gif> double  <B>getTimeInMillis</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& status) const 
<DT><IMG SRC=icon2.gif> void  <B>setTimeInMillis</B>( double millis, <!2><A HREF="#DOC.320">UErrorCode</A>& status )
<DT><IMG SRC=icon2.gif> void  <B>complete</B>(<!2><A HREF="#DOC.320">UErrorCode</A>& status)
<DT><IMG SRC=icon2.gif> int32_t  <B>internalGet</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const 
<DT><IMG SRC=icon2.gif> void  <B>internalSet</B>(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field, int32_t value)
<DT><IMG SRC=icon2.gif> <!1><A HREF="UDate.html">UDate</A>  <B>internalGetTime</B>(void) const 
<DT><IMG SRC=icon2.gif> void  <B>internalSetTime</B>(<!1><A HREF="UDate.html">UDate</A> time)
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

Concrete class which provides the standard calendar used by most of the world.
<P>
The standard (Gregorian) calendar has 2 eras, BC and AD.
<P>
This implementation handles a single discontinuity, which corresponds by default to
the date the Gregorian calendar was originally instituted (October 15, 1582). Not all
countries adopted the Gregorian calendar then, so this cutover date may be changed by
the caller.
<P>
Prior to the institution of the Gregorian Calendar, New Year's Day was March 25. To
avoid confusion, this Calendar always uses January 1. A manual adjustment may be made
if desired for dates that are prior to the Gregorian changeover and which fall
between January 1 and March 24.

<p>Values calculated for the <code>WEEK_OF_YEAR</code> field range from 1 to
53.  Week 1 for a year is the first week that contains at least
<code>getMinimalDaysInFirstWeek()</code> days from that year.  It thus
depends on the values of <code>getMinimalDaysInFirstWeek()</code>,
<code>getFirstDayOfWeek()</code>, and the day of the week of January 1.
Weeks between week 1 of one year and week 1 of the following year are
numbered sequentially from 2 to 52 or 53 (as needed).

<p>For example, January 1, 1998 was a Thursday.  If
<code>getFirstDayOfWeek()</code> is <code>MONDAY</code> and
<code>getMinimalDaysInFirstWeek()</code> is 4 (these are the values
reflecting ISO 8601 and many national standards), then week 1 of 1998 starts
on December 29, 1997, and ends on January 4, 1998.  If, however,
<code>getFirstDayOfWeek()</code> is <code>SUNDAY</code>, then week 1 of 1998
starts on January 4, 1998, and ends on January 10, 1998; the first three days
of 1998 then are part of week 53 of 1997.

<p>Example for using GregorianCalendar:
<pre>
.    // get the supported ids for GMT-08:00 (Pacific Standard Time)
.    int32_t idsCount;
.    const UnicodeString** ids = TimeZone::createAvailableIDs(-8 * 60 * 60 * 1000, idsCount);
.    // if no ids were returned, something is wrong. get out.
.    if (idsCount == 0) {
.        return;
.    }
.
.    // begin output
.    cout << "Current Time" << endl;
.
.    // create a Pacific Standard Time time zone
.    SimpleTimeZone* pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, *(ids[0]));
.    
.    // set up rules for daylight savings time
.    pdt->setStartRule(Calendar::APRIL, 1, Calendar::SUNDAY, 2 * 60 * 60 * 1000);
.    pdt->setEndRule(Calendar::OCTOBER, -1, Calendar::SUNDAY, 2 * 60 * 60 * 1000);
.    
.    // create a GregorianCalendar with the Pacific Daylight time zone
.    // and the current date and time
.    UErrorCode success = U_ZERO_ERROR;
.    Calendar* calendar = new GregorianCalendar( pdt, success );
.    
.    // print out a bunch of interesting things
.    cout << "ERA: " << calendar->get( Calendar::ERA, success ) << endl;
.    cout << "YEAR: " << calendar->get( Calendar::YEAR, success ) << endl;
.    cout << "MONTH: " << calendar->get( Calendar::MONTH, success ) << endl;
.    cout << "WEEK_OF_YEAR: " << calendar->get( Calendar::WEEK_OF_YEAR, success ) << endl;
.    cout << "WEEK_OF_MONTH: " << calendar->get( Calendar::WEEK_OF_MONTH, success ) << endl;
.    cout << "DATE: " << calendar->get( Calendar::DATE, success ) << endl;
.    cout << "DAY_OF_MONTH: " << calendar->get( Calendar::DAY_OF_MONTH, success ) << endl;
.    cout << "DAY_OF_YEAR: " << calendar->get( Calendar::DAY_OF_YEAR, success ) << endl;
.    cout << "DAY_OF_WEEK: " << calendar->get( Calendar::DAY_OF_WEEK, success ) << endl;
.    cout << "DAY_OF_WEEK_IN_MONTH: " << calendar->get( Calendar::DAY_OF_WEEK_IN_MONTH, success ) << endl;
.    cout << "AM_PM: " << calendar->get( Calendar::AM_PM, success ) << endl;
.    cout << "HOUR: " << calendar->get( Calendar::HOUR, success ) << endl;
.    cout << "HOUR_OF_DAY: " << calendar->get( Calendar::HOUR_OF_DAY, success ) << endl;
.    cout << "MINUTE: " << calendar->get( Calendar::MINUTE, success ) << endl;
.    cout << "SECOND: " << calendar->get( Calendar::SECOND, success ) << endl;
.    cout << "MILLISECOND: " << calendar->get( Calendar::MILLISECOND, success ) << endl;
.    cout << "ZONE_OFFSET: " << (calendar->get( Calendar::ZONE_OFFSET, success )/(60*60*1000)) << endl;
.    cout << "DST_OFFSET: " << (calendar->get( Calendar::DST_OFFSET, success )/(60*60*1000)) << endl;
.
.    cout << "Current Time, with hour reset to 3" << endl;
.    calendar->clear(Calendar::HOUR_OF_DAY); // so doesn't override
.    calendar->set(Calendar::HOUR, 3);
.    cout << "ERA: " << calendar->get( Calendar::ERA, success ) << endl;
.    cout << "YEAR: " << calendar->get( Calendar::YEAR, success ) << endl;
.    cout << "MONTH: " << calendar->get( Calendar::MONTH, success ) << endl;
.    cout << "WEEK_OF_YEAR: " << calendar->get( Calendar::WEEK_OF_YEAR, success ) << endl;
.    cout << "WEEK_OF_MONTH: " << calendar->get( Calendar::WEEK_OF_MONTH, success ) << endl;
.    cout << "DATE: " << calendar->get( Calendar::DATE, success ) << endl;
.    cout << "DAY_OF_MONTH: " << calendar->get( Calendar::DAY_OF_MONTH, success ) << endl;
.    cout << "DAY_OF_YEAR: " << calendar->get( Calendar::DAY_OF_YEAR, success ) << endl;
.    cout << "DAY_OF_WEEK: " << calendar->get( Calendar::DAY_OF_WEEK, success ) << endl;
.    cout << "DAY_OF_WEEK_IN_MONTH: " << calendar->get( Calendar::DAY_OF_WEEK_IN_MONTH, success ) << endl;
.    cout << "AM_PM: " << calendar->get( Calendar::AM_PM, success ) << endl;
.    cout << "HOUR: " << calendar->get( Calendar::HOUR, success ) << endl;
.    cout << "HOUR_OF_DAY: " << calendar->get( Calendar::HOUR_OF_DAY, success ) << endl;
.    cout << "MINUTE: " << calendar->get( Calendar::MINUTE, success ) << endl;
.    cout << "SECOND: " << calendar->get( Calendar::SECOND, success ) << endl;
.    cout << "MILLISECOND: " << calendar->get( Calendar::MILLISECOND, success ) << endl;
.    cout << "ZONE_OFFSET: " << (calendar->get( Calendar::ZONE_OFFSET, success )/(60*60*1000)) << endl; // in hours
.    cout << "DST_OFFSET: " << (calendar->get( Calendar::DST_OFFSET, success )/(60*60*1000)) << endl; // in hours
.
.    delete[] ids;
.    delete calendar; // also deletes pdt
.
</pre>

</BLOCKQUOTE>
<DL>

<A NAME="EEras">
<A NAME ="DOC.26.46">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  enum  EEras</B></TT>
<DD>
Useful constants for GregorianCalendar and TimeZone
<DL></DL><P>
<A NAME="GregorianCalendar">
<A NAME ="DOC.26.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  GregorianCalendar(<!2><A HREF="#DOC.320">UErrorCode</A>& success)</B></TT>
<DD>
Constructs a default GregorianCalendar using the current time in the default time
zone with the default locale.


<DL><DT><B>Parameters:</B><DD><B>success</B> -   Indicates the status of GregorianCalendar object construction.
Returns U_ZERO_ERROR if constructed successfully.<br></DL><P>
<A NAME="GregorianCalendar">
<A NAME ="DOC.26.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  GregorianCalendar(<!1><A HREF="TimeZone.html">TimeZone</A>* zoneToAdopt, <!2><A HREF="#DOC.320">UErrorCode</A>& success)</B></TT>
<DD>
Constructs a GregorianCalendar based on the current time in the given time zone
with the default locale. Clients are no longer responsible for deleting the given
time zone object after it's adopted.


<DL><DT><B>Parameters:</B><DD><B>zoneToAdopt</B> -      The given timezone.
<br><B>success</B> -   Indicates the status of GregorianCalendar object construction.
Returns U_ZERO_ERROR if constructed successfully.<br></DL><P>
<A NAME="GregorianCalendar">
<A NAME ="DOC.26.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  GregorianCalendar(const <!1><A HREF="TimeZone.html">TimeZone</A>& zone, <!2><A HREF="#DOC.320">UErrorCode</A>& success)</B></TT>
<DD>
Constructs a GregorianCalendar based on the current time in the given time zone
with the default locale.


<DL><DT><B>Parameters:</B><DD><B>zone</B> -      The given timezone.
<br><B>success</B> -   Indicates the status of GregorianCalendar object construction.
Returns U_ZERO_ERROR if constructed successfully.<br></DL><P>
<A NAME="GregorianCalendar">
<A NAME ="DOC.26.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  GregorianCalendar(const Locale& aLocale, <!2><A HREF="#DOC.320">UErrorCode</A>& success)</B></TT>
<DD>
Constructs a GregorianCalendar based on the current time in the default time zone
with the given locale.


<DL><DT><B>Parameters:</B><DD><B>aLocale</B> -   The given locale.
<br><B>success</B> -   Indicates the status of GregorianCalendar object construction.
Returns U_ZERO_ERROR if constructed successfully.<br></DL><P>
<A NAME="GregorianCalendar">
<A NAME ="DOC.26.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  GregorianCalendar(<!1><A HREF="TimeZone.html">TimeZone</A>* zoneToAdopt, const Locale& aLocale, <!2><A HREF="#DOC.320">UErrorCode</A>& success)</B></TT>
<DD>
Constructs a GregorianCalendar based on the current time in the given time zone
with the given locale. Clients are no longer responsible for deleting the given
time zone object after it's adopted.


<DL><DT><B>Parameters:</B><DD><B>zoneToAdopt</B> -      The given timezone.
<br><B>aLocale</B> -   The given locale.
<br><B>success</B> -   Indicates the status of GregorianCalendar object construction.
Returns U_ZERO_ERROR if constructed successfully.<br></DL><P>
<A NAME="GregorianCalendar">
<A NAME ="DOC.26.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  GregorianCalendar(const <!1><A HREF="TimeZone.html">TimeZone</A>& zone, const Locale& aLocale, <!2><A HREF="#DOC.320">UErrorCode</A>& success)</B></TT>
<DD>
Constructs a GregorianCalendar based on the current time in the given time zone
with the given locale.


<DL><DT><B>Parameters:</B><DD><B>zone</B> -      The given timezone.
<br><B>aLocale</B> -   The given locale.
<br><B>success</B> -   Indicates the status of GregorianCalendar object construction.
Returns U_ZERO_ERROR if constructed successfully.<br></DL><P>
<A NAME="GregorianCalendar">
<A NAME ="DOC.26.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  GregorianCalendar(int32_t year, int32_t month, int32_t date, <!2><A HREF="#DOC.320">UErrorCode</A>& success)</B></TT>
<DD>
Constructs a GregorianCalendar with the given AD date set in the default time
zone with the default locale.


<DL><DT><B>Parameters:</B><DD><B>year</B> -      The value used to set the YEAR time field in the calendar.
<br><B>month</B> -     The value used to set the MONTH time field in the calendar. Month
value is 0-based. e.g., 0 for January.
<br><B>date</B> -      The value used to set the DATE time field in the calendar.
<br><B>success</B> -   Indicates the status of GregorianCalendar object construction.
Returns U_ZERO_ERROR if constructed successfully.<br></DL><P>
<A NAME="GregorianCalendar">
<A NAME ="DOC.26.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  GregorianCalendar(int32_t year, int32_t month, int32_t date, int32_t hour, int32_t minute, <!2><A HREF="#DOC.320">UErrorCode</A>& success)</B></TT>
<DD>
Constructs a GregorianCalendar with the given AD date and time set for the
default time zone with the default locale.


<DL><DT><B>Parameters:</B><DD><B>year</B> -      The value used to set the YEAR time field in the calendar.
<br><B>month</B> -     The value used to set the MONTH time field in the calendar. Month
value is 0-based. e.g., 0 for January.
<br><B>date</B> -      The value used to set the DATE time field in the calendar.
<br><B>hour</B> -      The value used to set the HOUR_OF_DAY time field in the calendar.
<br><B>minute</B> -    The value used to set the MINUTE time field in the calendar.
<br><B>success</B> -   Indicates the status of GregorianCalendar object construction.
Returns U_ZERO_ERROR if constructed successfully.<br></DL><P>
<A NAME="GregorianCalendar">
<A NAME ="DOC.26.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  GregorianCalendar(int32_t year, int32_t month, int32_t date, int32_t hour, int32_t minute, int32_t second, <!2><A HREF="#DOC.320">UErrorCode</A>& success)</B></TT>
<DD>
Constructs a GregorianCalendar with the given AD date and time set for the
default time zone with the default locale.


<DL><DT><B>Parameters:</B><DD><B>year</B> -      The value used to set the YEAR time field in the calendar.
<br><B>month</B> -     The value used to set the MONTH time field in the calendar. Month
value is 0-based. e.g., 0 for January.
<br><B>date</B> -      The value used to set the DATE time field in the calendar.
<br><B>hour</B> -      The value used to set the HOUR_OF_DAY time field in the calendar.
<br><B>minute</B> -    The value used to set the MINUTE time field in the calendar.
<br><B>second</B> -    The value used to set the SECOND time field in the calendar.
<br><B>success</B> -   Indicates the status of GregorianCalendar object construction.
Returns U_ZERO_ERROR if constructed successfully.<br></DL><P>
<A NAME="~GregorianCalendar">
<A NAME ="DOC.26.47">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  ~GregorianCalendar()</B></TT>
<DD>
Destructor
<DL></DL><P>
<A NAME="GregorianCalendar">
<A NAME ="DOC.26.48">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  GregorianCalendar(const <!2><A HREF="GregorianCalendar.html#DOC.26.6">GregorianCalendar</A>& source)</B></TT>
<DD>
Copy constructor
<DL></DL><P>
<A NAME="operator=">
<A NAME ="DOC.26.49">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="GregorianCalendar.html#DOC.26.6">GregorianCalendar</A>&  operator=(const <!2><A HREF="GregorianCalendar.html#DOC.26.6">GregorianCalendar</A>& right)</B></TT>
<DD>
Default assignment operator
<DL></DL><P>
<A NAME="clone">
<A NAME ="DOC.26.50">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>*  clone(void) const </B></TT>
<DD>
Create and return a polymorphic copy of this calendar
<DL></DL><P>
<A NAME="setGregorianChange">
<A NAME ="DOC.26.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setGregorianChange(<!1><A HREF="UDate.html">UDate</A> date, <!2><A HREF="#DOC.320">UErrorCode</A>& success)</B></TT>
<DD>
Sets the GregorianCalendar change date. This is the point when the switch from
Julian dates to Gregorian dates occurred. Default is 00:00:00 local time, October
15, 1582. Previous to this time and date will be Julian dates.


<DL><DT><B>Parameters:</B><DD><B>date</B> -      The given Gregorian cutover date.
<br><B>success</B> -   Output param set to success/failure code on exit.<br></DL><P>
<A NAME="getGregorianChange">
<A NAME ="DOC.26.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UDate.html">UDate</A>  getGregorianChange(void) const </B></TT>
<DD>
Gets the Gregorian Calendar change date. This is the point when the switch from
Julian dates to Gregorian dates occurred. Default is 00:00:00 local time, October
15, 1582. Previous to this time and date will be Julian dates.


<DL><DT><B>Returns:</B><DD>The Gregorian cutover time for this calendar.
</DL><P>
<A NAME="isLeapYear">
<A NAME ="DOC.26.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool_t  isLeapYear(int32_t year) const </B></TT>
<DD>
Return true if the given year is a leap year. Determination of whether a year is
a leap year is actually very complicated. We do something crude and mostly
correct here, but for a real determination you need a lot of contextual
information. For example, in Sweden, the change from Julian to Gregorian happened
in a complex way resulting in missed leap years and double leap years between
1700 and 1753. Another example is that after the start of the Julian calendar in
45 B.C., the leap years did not regularize until 8 A.D. This method ignores these
quirks, and pays attention only to the Julian onset date and the Gregorian
cutover (which can be changed).


<DL><DT><B>Returns:</B><DD>True if the given year is a leap year; false otherwise.
<DT><B>Parameters:</B><DD><B>year</B> -   The given year.
<br></DL><P>
<A NAME="operator==">
<A NAME ="DOC.26.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  operator==(const <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>& that) const </B></TT>
<DD>
Compares the equality of two GregorianCalendar objects. Objects of different
subclasses are considered unequal.  This is a strict equality test; see the
documentation for Calendar::operator==().


<DL><DT><B>Returns:</B><DD>True if the given GregorianCalendar is the same as this
GregorianCalendar; false otherwise.
<DT><B>Parameters:</B><DD><B>that</B> -   The GregorianCalendar object to be compared with.
<br></DL><P>
<A NAME="equivalentTo">
<A NAME ="DOC.26.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  equivalentTo(const <!2><A HREF="Calendar.html#DOC.3.50">Calendar</A>& other) const </B></TT>
<DD>
Calendar override.
Return true if another Calendar object is equivalent to this one.  An equivalent
Calendar will behave exactly as this one does, but may be set to a different time.
<DL></DL><P>
<A NAME="add">
<A NAME ="DOC.26.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  add(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field, int32_t amount, <!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
(Overrides Calendar) UDate Arithmetic function. Adds the specified (signed) amount
of time to the given time field, based on the calendar's rules.  For more
information, see the documentation for Calendar::add().


<DL><DT><B>Parameters:</B><DD><B>field</B> -    The time field.
<br><B>amount</B> -   The amount of date or time to be added to the field.
<br><B>status</B> -   Output param set to success/failure code on exit. If any value
previously set in the time field is invalid, this will be set to
an error status.<br></DL><P>
<A NAME="roll">
<A NAME ="DOC.26.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  roll(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field, int32_t amount, <!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
(Overrides Calendar) Rolls up or down by the given amount in the specified field.
For more information, see the documentation for Calendar::roll().


<DL><DT><B>Parameters:</B><DD><B>field</B> -    The time field.
<br><B>amount</B> -   Indicates amount to roll.
<br><B>status</B> -   Output param set to success/failure code on exit. If any value
previously set in the time field is invalid, this will be set to
an error status.<br></DL><P>
<A NAME="getMinimum">
<A NAME ="DOC.26.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  int32_t  getMinimum(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const </B></TT>
<DD>
(Overrides Calendar) Returns minimum value for the given field. e.g. for
Gregorian DAY_OF_MONTH, 1.
<DL></DL><P>
<A NAME="getMaximum">
<A NAME ="DOC.26.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  int32_t  getMaximum(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const </B></TT>
<DD>
(Overrides Calendar) Returns maximum value for the given field. e.g. for
Gregorian DAY_OF_MONTH, 31.
<DL></DL><P>
<A NAME="getGreatestMinimum">
<A NAME ="DOC.26.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  int32_t  getGreatestMinimum(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const </B></TT>
<DD>
(Overrides Calendar) Returns highest minimum value for the given field if varies.
Otherwise same as getMinimum(). For Gregorian, no difference.
<DL></DL><P>
<A NAME="getLeastMaximum">
<A NAME ="DOC.26.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  int32_t  getLeastMaximum(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const </B></TT>
<DD>
(Overrides Calendar) Returns lowest maximum value for the given field if varies.
Otherwise same as getMaximum(). For Gregorian DAY_OF_MONTH, 28.
<DL></DL><P>
<A NAME="getActualMinimum">
<A NAME ="DOC.26.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int32_t  getActualMinimum(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const </B></TT>
<DD>
Return the minimum value that this field could have, given the current date.
For the Gregorian calendar, this is the same as getMinimum() and getGreatestMinimum().
<DL></DL><P>
<A NAME="getActualMaximum">
<A NAME ="DOC.26.22">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int32_t  getActualMaximum(<!2><A HREF="Calendar.html#DOC.3.1">EDateFields</A> field) const </B></TT>
<DD>
Return the maximum value that this field could have, given the current date.
For example, with the date "Feb 3, 1997" and the DAY_OF_MONTH field, the actual
maximum would be 28; for "Feb 3, 1996" it s 29.  Similarly for a Hebrew calendar,
for some years the actual maximum for MONTH is 12, and for others 13.
<DL></DL><P>
<A NAME="inDaylightTime">
<A NAME ="DOC.26.23">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  inDaylightTime(<!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
(Overrides Calendar) Return true if the current date for this Calendar is in
Daylight Savings Time. Recognizes DST_OFFSET, if it is set.


<DL><DT><B>Returns:</B><DD>True if the current date for this Calendar is in Daylight Savings Time,
false, otherwise.
<DT><B>Parameters:</B><DD><B>status</B> -  Fill-in parameter which receives the status of this operation.
<br></DL><P>
<A NAME="getDynamicClassID">
<A NAME ="DOC.26.24">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UClassID.html">UClassID</A>  getDynamicClassID(void) const </B></TT>
<DD>
Override Calendar Returns a unique class ID POLYMORPHICALLY. Pure virtual
override. This method is to implement a simple version of RTTI, since not all C++
compilers support genuine RTTI. Polymorphic operator==() and clone() methods call
this method.


<DL><DT><B>Returns:</B><DD>The class ID for this object. All objects of a given class have the
same class ID. Objects of other classes have different class IDs.
</DL><P>
<A NAME="getStaticClassID">
<A NAME ="DOC.26.25">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!1><A HREF="UClassID.html">UClassID</A>  getStaticClassID(void)</B></TT>
<DD>
Return the class ID for this class. This is useful only for comparing to a return
value from getDynamicClassID(). For example:

Base* polymorphic_pointer = createPolymorphicObject();
if (polymorphic_pointer->getDynamicClassID() ==
Derived::getStaticClassID()) ...


<DL><DT><B>Returns:</B><DD>The class ID for all objects of this class.
</DL><P>
<A NAME="computeFields">
<A NAME ="DOC.26.51">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  computeFields(<!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
(Overrides Calendar) Converts GMT as milliseconds to time field values
<DL></DL><P>
<A NAME="computeTime">
<A NAME ="DOC.26.26">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  computeTime(<!2><A HREF="#DOC.320">UErrorCode</A>& status)</B></TT>
<DD>
(Overrides Calendar) Converts Calendar's time field values to GMT as
milliseconds.


<DL><DT><B>Parameters:</B><DD><B>status</B> -   Output param set to success/failure code on exit. If any value
previously set in the time field is invalid, this will be set to
an error status.<br></DL><P></DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
