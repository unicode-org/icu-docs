<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<HTML>
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<meta name="KEYWORDS" content="Unicode, internationalization, globalization, translation, NLS, Unicode papers, Unicode information, Unicode whitepapers, IBM">
<meta name="ABSTRACT" content="The Unicode zone on the developerWorks Web site is your developer resource for building applications for a worldwide audience.">
<meta name="DESCRIPTION" content="The Unicode zone on the developerWorks Web site is your developer resource for building applications for a worldwide audience.">
<TITLE>UTF-16 String Comparison in Code Point Order</TITLE>
</HEAD>
<BODY>
<h1>Binary string comparison with UTF-16</h1>
	
<p>How to efficiently compare UTF-16 strings in code point sort order</p>

	<p>Markus W. Scherer<br>
	Unicode Software Engineer, IBM<br>
	April 2000, updated August 2001</p>

	<p>Originally published on <a href="http://www.ibm.com/developerWorks/unicode/">http://www.ibm.com/developerWorks/unicode/</a></p>
<table width="160" align="RIGHT" border="0" bordercolor="#E3E3E3" bgcolor="#999999">
  <tr bgcolor="#0033CC"> 
    <td height=5 align="center"><b><font color="#FFFFFF">Contents:</font></b></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td class="toc"><a href="#utf-32">UTF-32</A></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td class="toc"><a href="#utf-8">UTF-8</A></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td class="toc"><a href="#utf-16">UTF-16</A></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td class="toc"><a href="#examples">Comparison examples</A></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td class="toc"><a href="#code">Sample C code</A></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td class="toc"><a href="#utf-8-in-utf-16-order">UTF-8/32 string comparison 
      in UTF-16 code unit order</A></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td class="toc"><a href="#resources">Resources</A></td>
  </tr>
</table>
<p><i>This "how-to" article discusses binary string comparison. If "code point 
  sort order" is required, then binary comparisons of UTF-16 strings need special 
  attention. An efficient algorithm and sample code are provided.</i>
<p>In many applications, where culturally correct string comparisons (collation) are not necessary, strings are compared "binary" for performance reasons. Binary string comparison is a lexical comparison of the code <i>unit</i> values (the base units of a string).</p>

    <p>Often, the particular sort order does not matter, as in an internal table lookup with a binary search. Sometimes, however, the sort order needs to match the sort order of a lexical comparison of the code <i>point</i> values (the character set codes encoded in each string).</p>

    <a name="utf-32">
   <h2>UTF-32</h2></a>
     <p>In Unicode, code points are 21-bit integers. UTF-32 strings store code points directly as code units, so that the binary-comparison sort order is naturally the same as the code point sort order.</p>

    <p>The other, more memory-efficient, UTFs would -- with a naïve approach -- need to assemble the code point values from the code units, which would be relatively slow. This is not necessary because of their design: string comparison in code point sort order can be done with UTF-8 and UTF-16 efficiently and based only on code unit comparisons as follows:</p>

    <a name="utf-8">
   <h2>UTF-8</h2></a>
    <p>A comparison of strings in UTF-8 is done entirely as a comparison of the byte sequences. This is possible because of the structure of UTF-8: All lead bytes have higher byte values than the single-byte characters, and within lead, single, and trail byte ranges, the order of code points is preserved as well.</p>

    <a name="utf-16">
   <h2>UTF-16</h2></a>
    <p>In UTF-16, the binary order of code units is only &quot;<em>almost</em>
    the same as code point order&quot;. UTF-16 was designed after characters had been assigned to code points at the upper end of the original, 16-bit, UCS-2 range.  Leading and trailing code units ("surrogates") have smaller values than some single-unit characters.  Otherwise, within single, lead, and trail code unit value ranges, the order is preserved, too.</p>

    <p>This opens the door for a "fix-up" of code unit values that is faster than assembling 21-bit code point values. It does not require an extra branch inside the comparison loop.  The basis for this is that the "surrogate" values are in an area that is aligned along blocks of 2k (0x800) values. In other words, the most significant five bits in the 16-bit values are always the same for surrogates, and are unique to them.  The "fix-up" simply rotates the block of surrogates to the top of the 16-bit value range (up by 0x2000) and the higher blocks down by one block (subtract 0x800, or add 0xf800).  This could be done for each code unit, using a little table of deltas for each 2k block, and adding three machine operations: a shift, a lookup in the 32-element table, and an addition.
    (Note that this table approach uses common C language arithmetic: Instead of
    getting an overflow error when adding 0xf800 to large numbers, unsigned
    16-bit arithmetic in C wraps around to smaller values. This is not used for
    the optimized approach described in the following paragraph.)</p>

    <p>In order to make such a string comparison with &quot;fix-up&quot; as fast
    as the regular one, the following optimizations are used (See
   <a href="#code">Sample C code</a>  below.):</p>

<ul>
  <li>The fix-up needs to be done only once for any pair of strings. In string
    comparisons, the first few units from each string are equal. A
    &quot;fix-up&quot; does not change equality of values and is unnecessary on
    them. Only for the last two units from the two strings - where the units are
    not equal - may a &quot;fix-up&quot; be necessary.</li>
  <li>A string comparison only yields results like &quot;less than&quot;,
    &quot;equal&quot;, and &quot;greater than&quot;. It does not yield a
    distance of strings. Therefore, if the result can be calculated correctly
    without &quot;fix-up&quot;, then none is necessary. The two last units need
    to be &quot;fixed up&quot; only if both are &gt;=U+d800. This is because the
    &quot;fix-up&quot; does not change any values below U+d800, and does not
    move values from one side of this boundary to the other.<br>
    <em>Note: </em>Characters with supplementary code points or code points
    above U+e000 are rarely used, so that the actual &quot;fix-up&quot; code is
    executed only rarely as well.</li>
  <li>In modern CPUs with significant cache and memory latencies and with branch
    prediction, it is faster to use comparisons for the &quot;fix-up&quot; value
    rotation than to use a lookup table.</li>
</ul>

    <p>Note: This &quot;fix-up&quot; may yield unexpected results for malformed
    UTF-16 strings with single, unpaired surrogate code units. Surrogates only
    encode characters if they are used in pairs.</p>

    <a name="examples">
   <h2>Comparison examples</h2></a>

    <p>The following table shows several comparison examples.  Some of them work in UTF-16 without special code, but comparisons of a surrogate value with a single value of 0xe000 or higher, shown in <b>bold</b>, need a local "fix-up."  The "corrected" values are shown in <i>italics</i>.  All values are shown in hexadecimal.</p>

<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0">
    <tr>
        <th>Code point/UTF-32 comparison</th>
        <th>UTF-16 comparison without "fix-up"</th>
        <th>UTF-16 comparison with "fix-up"</th>
        <th>UTF-8 comparison</th>
    </tr>
    <tr>
        <td>61 &lt; 20ac</td>
        <td>61 &lt; 20ac (OK, no surrogates)</td>
        <td>61 &lt; 20ac</td>
        <td>61 &lt; e2 82 ac</td>
    </tr>
    <tr>
        <td>61 &lt; 10002</td>
        <td>61 &lt; d800 dc02 (OK, non-surrogate is below d800)</td>
        <td>61 &lt; <i>f800 fc02</i> (OK, fix-up keeps order)</td>
        <td>61 &lt; f0 90 80 82</td>
    </tr>
    <tr>
        <td>ff61 &lt; 10002</td>
        <td><b>ff61 > d800 dc02 (not code point order)</b></td>
        <td><i>f761 &lt; f800 fc02</i> (OK, code units "fixed up")</td>
        <td>ef bd a1 &lt; f0 90 80 82</td>
    </tr>
    <tr>
        <td>10002 &lt; 23456</td>
        <td>d800 dc02 &lt; d84d dc56 (OK, surrogates on both sides)</td>
        <td>d800 dc02 &lt; d84d dc56</td>
        <td>f0 90 80 82 &lt; f0 a3 91 96</td>
    </tr>
    </table>

    <a name="code">
   <h2>Sample C code</h2></a>

   <p>The following Sample C function compares two zero-terminated UTF-16 strings. The additional code
   is after the loop and skipped if both code units are below 0xd800.</p>

    <pre>
    /* compare zero-terminated UTF-16 strings */
    int utf16_strcmp(unsigned short *s1, unsigned short *s2) {
        unsigned short c1, c2; /* 16 bits */

        /* compare identical prefixes - they do not need to be fixed up */
        for(;;) {
            c1=*s1;
            c2=*s2;
            if(c1==c2) {
                if(c1==0) {
                    return 0;
                }
                ++s1;
                ++s2;
            } else {
                break;
            }
        }

        /* c1!=c2, fix up each one if they're both in or above the surrogate range, then compare them */
        if(c1&gt;=0xd800 &amp;&amp; c2&gt;=0xd800) {
            if(c1&gt;=0xe000) {
                c1-=0x800;
            } else {
                c1+=0x2000;
            }
            if(c2&gt;=0xe000) {
                c2-=0x800;
            } else {
                c2+=0x2000;
            }
        }

        /* now c1 and c2 are in code point order */
        return (int)c1-(int)c2; /* int must be 32 bits wide */
    }</pre>
    
  <a name="utf-8-in-utf-16-order"><h2>UTF-8/32 string comparison in UTF-16 code unit order</h2></a>
  <p>Sometimes, the opposite may be desired: Comparing UTF-8/32 strings in the
  binary order of UTF-16 code units. This can be done with the opposite rotation
  of code unit values in UTF-8/32, similarly reversing the relative order of the code
  point ranges U+e000..U+ffff and U+10000..U+10ffff.</p>
  
  <p>Note that both UTF-8 and UTF-32 strings should never contain
  single-surrogate code points. Also, since in both cases there are unused code
  unit values, a true rotation is not necessary; only one of the two code point
  ranges needs to be moved.</p>
  
  <h3>UTF-32 code point rotation for UTF-16 code unit order</h3>
  
  <p>It is sufficient to move the range U+e000..U+ffff to an arbitrary, unused
  range after the supplementary code points:</p>
  <pre>
        unsigned int c1, c2; /* 32 bits, values 0..0x10ffff */
        if(c1&gt;=0xe000 &amp;&amp; c2&gt;=0xe000) {
            if(c1&lt;0x10000) {
                c1+=0x1f0000;
            }
            if(c2&lt;0x10000) {
                c2+=0x1f0000;
            }
        }
  </pre>
  
  <h3>UTF-8 code point rotation for UTF-16 code unit order</h3>
  
  <p>The lead bytes for the range U+e000..U+ffff are distinct (they are exactly
  0xee and 0xef) and can be moved to the unused byte values 0xfe and 0xff.</p>
  
  <pre>
        unsigned char c1, c2; /* 8 bits, values 0..0xfd */
        if((c1&gt;=0xee &amp;&amp; c2&gt;=0xee) {
            if((c1&amp;0xfe)==0xee) {
                c1+=0x10;
            }
            if((c2&amp;0xfe)==0xee) {
                c2+=0x10;
            }
        }
  </pre>

    <a name="resources">
  <h2>Resources</h2></a>
<ul>
   <li> For details on code units vs. code points, see <a href="http://www.unicode.org/unicode/reports/tr17/">Character Encoding Model</a> on <a href="http://www.unicode.org/">http://www.unicode.org/</a></LI>

    <li>For background on UTF-8, UTF-16, and UTF-32, see <a href="http://www-106.ibm.com/developerworks/library/utfencodingforms/index.html">Forms of Unicode</a> on <i>developerWorks</i></li>

    <li>See the implementation of <code> u_strcmpCodePointOrder()</code> in ICU: <a href="http://dev.icu-project.org/cgi-bin/viewcvs.cgi/*checkout*/icu/source/common/ustring.c">http://oss.software.ibm.com/cvs/icu/~checkout~/icu/source/common/ustring.c</a></li></ul>

</body>
</html>
