<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ICU 65.1: ubrk.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ICU 65.1
   &#160;<span id="projectnumber">65.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_8e7b8192f8ff7e2a9b28a95633402eef.html">icu</a></li><li class="navelem"><a class="el" href="dir_62bbd7d8d356aabb1ca2bb9704fa0335.html">icu4c</a></li><li class="navelem"><a class="el" href="dir_84abeeaa1c31cd817591a3a8c0864234.html">source</a></li><li class="navelem"><a class="el" href="dir_ff9529815edbb9be180a9d3389ef352b.html">common</a></li><li class="navelem"><a class="el" href="dir_c0b05f822e611119fac4b5ce31fb631c.html">unicode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ubrk.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C API: BreakIterator.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="utypes_8h_source.html">unicode/utypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="uloc_8h_source.html">unicode/uloc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="utext_8h_source.html">unicode/utext.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="localpointer_8h_source.html">unicode/localpointer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="parseerr_8h_source.html">unicode/parseerr.h</a>&quot;</code><br />
</div>
<p><a href="ubrk_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceicu"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceicu.html">icu</a></td></tr>
<tr class="memdesc:namespaceicu"><td class="mdescLeft">&#160;</td><td class="mdescRight">File <a class="el" href="coll_8h.html" title="C++ API: Collation Service. ">coll.h</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a08c0431a8c9c65e9578b12978681bbc8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a08c0431a8c9c65e9578b12978681bbc8">UBRK_TYPEDEF_UBREAK_ITERATOR</a></td></tr>
<tr class="memdesc:a08c0431a8c9c65e9578b12978681bbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A text-break iterator.  <a href="#a08c0431a8c9c65e9578b12978681bbc8">More...</a><br /></td></tr>
<tr class="separator:a08c0431a8c9c65e9578b12978681bbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c31c1e5091fb47ab85db522c7536252"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a7c31c1e5091fb47ab85db522c7536252">UBRK_DONE</a>&#160;&#160;&#160;((int32_t) -1)</td></tr>
<tr class="memdesc:a7c31c1e5091fb47ab85db522c7536252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value indicating all text boundaries have been returned.  <a href="#a7c31c1e5091fb47ab85db522c7536252">More...</a><br /></td></tr>
<tr class="separator:a7c31c1e5091fb47ab85db522c7536252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17dc88e0028fd85c622889eea22a6fa"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#ab17dc88e0028fd85c622889eea22a6fa">U_BRK_SAFECLONE_BUFFERSIZE</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:ab17dc88e0028fd85c622889eea22a6fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">A recommended size (in bytes) for the memory buffer to be passed to ubrk_saveClone().  <a href="#ab17dc88e0028fd85c622889eea22a6fa">More...</a><br /></td></tr>
<tr class="separator:ab17dc88e0028fd85c622889eea22a6fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adb85bb46d5f93c87098e11deab50bef4"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a></td></tr>
<tr class="memdesc:adb85bb46d5f93c87098e11deab50bef4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque type representing an ICU Break iterator object.  <a href="#adb85bb46d5f93c87098e11deab50bef4">More...</a><br /></td></tr>
<tr class="separator:adb85bb46d5f93c87098e11deab50bef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac93fd61c60ea0f742f768627aeb275"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a0ac93fd61c60ea0f742f768627aeb275">UBreakIteratorType</a></td></tr>
<tr class="memdesc:a0ac93fd61c60ea0f742f768627aeb275"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible types of text boundaries.  <a href="#a0ac93fd61c60ea0f742f768627aeb275">More...</a><br /></td></tr>
<tr class="separator:a0ac93fd61c60ea0f742f768627aeb275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5d4d3f7f4207d27081409e4b1b6c9a"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9">UWordBreak</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#afc5d4d3f7f4207d27081409e4b1b6c9a">UWordBreak</a></td></tr>
<tr class="memdesc:afc5d4d3f7f4207d27081409e4b1b6c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum constants for the word break tags returned by getRuleStatus().  <a href="#afc5d4d3f7f4207d27081409e4b1b6c9a">More...</a><br /></td></tr>
<tr class="separator:afc5d4d3f7f4207d27081409e4b1b6c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279b748fce440f03722a3ebe0c3a977a"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccd">ULineBreakTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a279b748fce440f03722a3ebe0c3a977a">ULineBreakTag</a></td></tr>
<tr class="memdesc:a279b748fce440f03722a3ebe0c3a977a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum constants for the line break tags returned by getRuleStatus().  <a href="#a279b748fce440f03722a3ebe0c3a977a">More...</a><br /></td></tr>
<tr class="separator:a279b748fce440f03722a3ebe0c3a977a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8be061b386794d29ca7aa5353dc26a9e"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71">USentenceBreakTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a8be061b386794d29ca7aa5353dc26a9e">USentenceBreakTag</a></td></tr>
<tr class="memdesc:a8be061b386794d29ca7aa5353dc26a9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum constants for the sentence break tags returned by getRuleStatus().  <a href="#a8be061b386794d29ca7aa5353dc26a9e">More...</a><br /></td></tr>
<tr class="separator:a8be061b386794d29ca7aa5353dc26a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a026dec40289da8261d787daf3baa588b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a> { <br />
&#160;&#160;<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588ba446d025be7ca2f64dfac303b0a55c0b3">UBRK_CHARACTER</a> = 0, 
<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588ba17772e8ee70d3de4064c71417c574f36">UBRK_WORD</a> = 1, 
<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588ba73e81a0d478daeb2c6de8a63cac1070c">UBRK_LINE</a> = 2, 
<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588bab1b31cbd0fb0b298b87cb67da729ba62">UBRK_SENTENCE</a> = 3, 
<br />
&#160;&#160;<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588ba3d79f0b0db32243e6b85b0b5036f9831">UBRK_TITLE</a> = 4, 
<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588ba6040742b07566e5e3655d4843efaefac">UBRK_COUNT</a> = 5
<br />
 }<tr class="memdesc:a026dec40289da8261d787daf3baa588b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The possible types of text boundaries.  <a href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a026dec40289da8261d787daf3baa588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9836cc79482f82ac12eefb1f70b14b9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9">UWordBreak</a> { <br />
&#160;&#160;<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a8229f94661c6289a6497018ef341801a">UBRK_WORD_NONE</a> = 0, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a54839e74f8aa4ffd4ea7b9d86f3de050">UBRK_WORD_NONE_LIMIT</a> = 100, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a3ec03137beddd2ce1d611cc7798b6e74">UBRK_WORD_NUMBER</a> = 100, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a82e563b42b89e0a49c097d40a54c8621">UBRK_WORD_NUMBER_LIMIT</a> = 200, 
<br />
&#160;&#160;<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a945eb6dd49881b36d4e2c9f592d97197">UBRK_WORD_LETTER</a> = 200, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a66ad49e358ce8a4fba6d6161ec678dd6">UBRK_WORD_LETTER_LIMIT</a> = 300, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a69f55c4740ce6f96ad9b61d859de201f">UBRK_WORD_KANA</a> = 300, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a7d507a35a3813629c11340a3f0f10fec">UBRK_WORD_KANA_LIMIT</a> = 400, 
<br />
&#160;&#160;<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a295f3da24ba9978b5787c1494079c8de">UBRK_WORD_IDEO</a> = 400, 
<a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9a8097221024f5c65d58951ad488d57474">UBRK_WORD_IDEO_LIMIT</a> = 500
<br />
 }<tr class="memdesc:af9836cc79482f82ac12eefb1f70b14b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum constants for the word break tags returned by getRuleStatus().  <a href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:af9836cc79482f82ac12eefb1f70b14b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de005c411b5e5306850f4246d1d7ccd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccd">ULineBreakTag</a> { <a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccda6a91dd50489f1fbc5c8c32c29fcc3fee">UBRK_LINE_SOFT</a> = 0, 
<a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccdaef314dd1a053a6f2ab57c06f3a3d5f1f">UBRK_LINE_SOFT_LIMIT</a> = 100, 
<a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccdad02d1bfcd98382e53c9e83db37fba492">UBRK_LINE_HARD</a> = 100, 
<a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccdae767435243d44e5a22c1db90dd3a8f6e">UBRK_LINE_HARD_LIMIT</a> = 200
 }<tr class="memdesc:a8de005c411b5e5306850f4246d1d7ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum constants for the line break tags returned by getRuleStatus().  <a href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccd">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8de005c411b5e5306850f4246d1d7ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03d8e27f121bcf11eaed0a288786a71"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71">USentenceBreakTag</a> { <a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71addbcb13addb315fc0814a6fb1284c339">UBRK_SENTENCE_TERM</a> = 0, 
<a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71a650703353df53947eb3b996e3e5239f7">UBRK_SENTENCE_TERM_LIMIT</a> = 100, 
<a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71aca695be696e0e48676c109de60bcbbdf">UBRK_SENTENCE_SEP</a> = 100, 
<a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71af573420e1d53a811d6c5c4a07a4f5c8e">UBRK_SENTENCE_SEP_LIMIT</a> = 200
 }<tr class="memdesc:ad03d8e27f121bcf11eaed0a288786a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum constants for the sentence break tags returned by getRuleStatus().  <a href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ad03d8e27f121bcf11eaed0a288786a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4e5fd80d818fb4ec23330d8935b2754d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a4e5fd80d818fb4ec23330d8935b2754d">ubrk_open</a> (<a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a> type, const char *locale, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *text, int32_t textLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a4e5fd80d818fb4ec23330d8935b2754d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a new UBreakIterator for locating text boundaries for a specified locale.  <a href="#a4e5fd80d818fb4ec23330d8935b2754d">More...</a><br /></td></tr>
<tr class="separator:a4e5fd80d818fb4ec23330d8935b2754d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11826cb21213916c2d91579b673d8949"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a11826cb21213916c2d91579b673d8949">ubrk_openRules</a> (const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *rules, int32_t rulesLength, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *text, int32_t textLength, <a class="el" href="structUParseError.html">UParseError</a> *parseErr, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a11826cb21213916c2d91579b673d8949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a new UBreakIterator for locating text boundaries using specified breaking rules.  <a href="#a11826cb21213916c2d91579b673d8949">More...</a><br /></td></tr>
<tr class="separator:a11826cb21213916c2d91579b673d8949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2fecb07846f9f39b6202563d32ba51f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#ae2fecb07846f9f39b6202563d32ba51f">ubrk_openBinaryRules</a> (const uint8_t *binaryRules, int32_t rulesLength, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *text, int32_t textLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:ae2fecb07846f9f39b6202563d32ba51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a new UBreakIterator for locating text boundaries using precompiled binary rules.  <a href="#ae2fecb07846f9f39b6202563d32ba51f">More...</a><br /></td></tr>
<tr class="separator:ae2fecb07846f9f39b6202563d32ba51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6901f59d9c74bc8e16b9994cb1be7679"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a6901f59d9c74bc8e16b9994cb1be7679">ubrk_safeClone</a> (const <a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, void *stackBuffer, int32_t *pBufferSize, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a6901f59d9c74bc8e16b9994cb1be7679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread safe cloning operation.  <a href="#a6901f59d9c74bc8e16b9994cb1be7679">More...</a><br /></td></tr>
<tr class="separator:a6901f59d9c74bc8e16b9994cb1be7679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e398fb0fe194683a000b3989c041fda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a5e398fb0fe194683a000b3989c041fda">ubrk_close</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr class="memdesc:a5e398fb0fe194683a000b3989c041fda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a UBreakIterator.  <a href="#a5e398fb0fe194683a000b3989c041fda">More...</a><br /></td></tr>
<tr class="separator:a5e398fb0fe194683a000b3989c041fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8a6679a8ce36ba5d035b99748c8339"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a8c8a6679a8ce36ba5d035b99748c8339">ubrk_setText</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *text, int32_t textLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a8c8a6679a8ce36ba5d035b99748c8339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an existing iterator to point to a new piece of text.  <a href="#a8c8a6679a8ce36ba5d035b99748c8339">More...</a><br /></td></tr>
<tr class="separator:a8c8a6679a8ce36ba5d035b99748c8339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91bfeb92a3e489e3188f02597f4c9c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#ac91bfeb92a3e489e3188f02597f4c9c7">ubrk_setUText</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, <a class="el" href="structUText.html">UText</a> *text, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:ac91bfeb92a3e489e3188f02597f4c9c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets an existing iterator to point to a new piece of text.  <a href="#ac91bfeb92a3e489e3188f02597f4c9c7">More...</a><br /></td></tr>
<tr class="separator:ac91bfeb92a3e489e3188f02597f4c9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8b67527c5c9d9205a3446506ffeefc"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a4f8b67527c5c9d9205a3446506ffeefc">ubrk_current</a> (const <a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr class="memdesc:a4f8b67527c5c9d9205a3446506ffeefc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the most recently-returned text boundary.  <a href="#a4f8b67527c5c9d9205a3446506ffeefc">More...</a><br /></td></tr>
<tr class="separator:a4f8b67527c5c9d9205a3446506ffeefc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17158fccedcf72481eaca61fffab4ce6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a17158fccedcf72481eaca61fffab4ce6">ubrk_next</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr class="memdesc:a17158fccedcf72481eaca61fffab4ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator to the boundary following the current boundary.  <a href="#a17158fccedcf72481eaca61fffab4ce6">More...</a><br /></td></tr>
<tr class="separator:a17158fccedcf72481eaca61fffab4ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318c950f25ee89a66c989feced3a41f0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a318c950f25ee89a66c989feced3a41f0">ubrk_previous</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr class="memdesc:a318c950f25ee89a66c989feced3a41f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator position to the boundary preceding the current boundary.  <a href="#a318c950f25ee89a66c989feced3a41f0">More...</a><br /></td></tr>
<tr class="separator:a318c950f25ee89a66c989feced3a41f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ae638e98af0830b66ff058b48e7dbcd"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a2ae638e98af0830b66ff058b48e7dbcd">ubrk_first</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr class="memdesc:a2ae638e98af0830b66ff058b48e7dbcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator position to zero, the start of the text being scanned.  <a href="#a2ae638e98af0830b66ff058b48e7dbcd">More...</a><br /></td></tr>
<tr class="separator:a2ae638e98af0830b66ff058b48e7dbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24ffb5cee86ffe1ee8aa0d53093b352f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a24ffb5cee86ffe1ee8aa0d53093b352f">ubrk_last</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr class="memdesc:a24ffb5cee86ffe1ee8aa0d53093b352f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator position to the index immediately <em>beyond</em> the last character in the text being scanned.  <a href="#a24ffb5cee86ffe1ee8aa0d53093b352f">More...</a><br /></td></tr>
<tr class="separator:a24ffb5cee86ffe1ee8aa0d53093b352f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accaaccc55135961f45541bcbab580f9d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#accaaccc55135961f45541bcbab580f9d">ubrk_preceding</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, int32_t offset)</td></tr>
<tr class="memdesc:accaaccc55135961f45541bcbab580f9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the iterator position to the first boundary preceding the specified offset.  <a href="#accaaccc55135961f45541bcbab580f9d">More...</a><br /></td></tr>
<tr class="separator:accaaccc55135961f45541bcbab580f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4724e6d07ea2f27b99a1bba60e4ef76c"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a4724e6d07ea2f27b99a1bba60e4ef76c">ubrk_following</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, int32_t offset)</td></tr>
<tr class="memdesc:a4724e6d07ea2f27b99a1bba60e4ef76c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advance the iterator to the first boundary following the specified offset.  <a href="#a4724e6d07ea2f27b99a1bba60e4ef76c">More...</a><br /></td></tr>
<tr class="separator:a4724e6d07ea2f27b99a1bba60e4ef76c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12fc845896682221749f03e7dc21e3e0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a12fc845896682221749f03e7dc21e3e0">ubrk_getAvailable</a> (int32_t index)</td></tr>
<tr class="memdesc:a12fc845896682221749f03e7dc21e3e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a locale for which text breaking information is available.  <a href="#a12fc845896682221749f03e7dc21e3e0">More...</a><br /></td></tr>
<tr class="separator:a12fc845896682221749f03e7dc21e3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b587f3b0df1b680f4ca3f1d1f151f7e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a8b587f3b0df1b680f4ca3f1d1f151f7e">ubrk_countAvailable</a> (void)</td></tr>
<tr class="memdesc:a8b587f3b0df1b680f4ca3f1d1f151f7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine how many locales have text breaking information available.  <a href="#a8b587f3b0df1b680f4ca3f1d1f151f7e">More...</a><br /></td></tr>
<tr class="separator:a8b587f3b0df1b680f4ca3f1d1f151f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701db54fd2c91c07490cb02ebdd54fa6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a701db54fd2c91c07490cb02ebdd54fa6">ubrk_isBoundary</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, int32_t offset)</td></tr>
<tr class="memdesc:a701db54fd2c91c07490cb02ebdd54fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the specified position is a boundary position.  <a href="#a701db54fd2c91c07490cb02ebdd54fa6">More...</a><br /></td></tr>
<tr class="separator:a701db54fd2c91c07490cb02ebdd54fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4314a5dd63efde9b372ded64b6f0c732"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a4314a5dd63efde9b372ded64b6f0c732">ubrk_getRuleStatus</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi)</td></tr>
<tr class="memdesc:a4314a5dd63efde9b372ded64b6f0c732"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the status from the break rule that determined the most recently returned break position.  <a href="#a4314a5dd63efde9b372ded64b6f0c732">More...</a><br /></td></tr>
<tr class="separator:a4314a5dd63efde9b372ded64b6f0c732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf355cf304090ca6efb10c4318bde45e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#acf355cf304090ca6efb10c4318bde45e">ubrk_getRuleStatusVec</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, int32_t *fillInVec, int32_t capacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:acf355cf304090ca6efb10c4318bde45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the statuses from the break rules that determined the most recently returned break position.  <a href="#acf355cf304090ca6efb10c4318bde45e">More...</a><br /></td></tr>
<tr class="separator:acf355cf304090ca6efb10c4318bde45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad95a44383cba60e20188025ab18c09fe"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#ad95a44383cba60e20188025ab18c09fe">ubrk_getLocaleByType</a> (const <a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, <a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a> type, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:ad95a44383cba60e20188025ab18c09fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the locale of the break iterator.  <a href="#ad95a44383cba60e20188025ab18c09fe">More...</a><br /></td></tr>
<tr class="separator:ad95a44383cba60e20188025ab18c09fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94136054d5d48cf0f945fc8e8301c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#ac94136054d5d48cf0f945fc8e8301c72">ubrk_refreshUText</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, <a class="el" href="structUText.html">UText</a> *text, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:ac94136054d5d48cf0f945fc8e8301c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the subject text string upon which the break iterator is operating without changing any other aspect of the state.  <a href="#ac94136054d5d48cf0f945fc8e8301c72">More...</a><br /></td></tr>
<tr class="separator:ac94136054d5d48cf0f945fc8e8301c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ee5322d0bf7e93db259436b561ae17"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ubrk_8h.html#a83ee5322d0bf7e93db259436b561ae17">ubrk_getBinaryRules</a> (<a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *bi, uint8_t *binaryRules, int32_t rulesCapacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="memdesc:a83ee5322d0bf7e93db259436b561ae17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a compiled binary version of the rules specifying the behavior of a UBreakIterator.  <a href="#a83ee5322d0bf7e93db259436b561ae17">More...</a><br /></td></tr>
<tr class="separator:a83ee5322d0bf7e93db259436b561ae17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C API: BreakIterator. </p>
<h2>BreakIterator C API </h2>
<p>The BreakIterator C API defines methods for finding the location of boundaries in text. Pointer to a UBreakIterator maintain a current position and scan over text returning the index of characters where boundaries occur. </p>
<p>Line boundary analysis determines where a text string can be broken when line-wrapping. The mechanism correctly handles punctuation and hyphenated words. </p>
<p>Note: The locale keyword "lb" can be used to modify line break behavior according to the CSS level 3 line-break options, see <a href="http://dev.w3.org/csswg/css-text/#line-breaking">http://dev.w3.org/csswg/css-text/#line-breaking</a>. For example: "ja@lb=strict", "zh@lb=loose". </p>
<p>Sentence boundary analysis allows selection with correct interpretation of periods within numbers and abbreviations, and trailing punctuation marks such as quotation marks and parentheses. </p>
<p>Note: The locale keyword "ss" can be used to enable use of segmentation suppression data (preventing breaks in English after abbreviations such as "Mr." or "Est.", for example), as follows: "en@ss=standard". </p>
<p>Word boundary analysis is used by search and replace functions, as well as within text editing applications that allow the user to select words with a double click. Word selection provides correct interpretation of punctuation marks within and following words. Characters that are not part of a word, such as symbols or punctuation marks, have word-breaks on both sides. </p>
<p>Character boundary analysis identifies the boundaries of "Extended Grapheme Clusters", which are groupings of codepoints that should be treated as character-like units for many text operations. Please see Unicode Standard Annex #29, Unicode Text Segmentation, <a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a> for additional information on grapheme clusters and guidelines on their use. </p>
<p>Title boundary analysis locates all positions, typically starts of words, that should be set to Title Case when title casing the text. </p>
<p>The text boundary positions are found according to the rules described in Unicode Standard Annex #29, Text Boundaries, and Unicode Standard Annex #14, Line Breaking Properties. These are available at <a href="http://www.unicode.org/reports/tr14/">http://www.unicode.org/reports/tr14/</a> and <a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a>. </p>
<p>In addition to the plain C API defined in this header file, an object oriented C++ API with equivalent functionality is defined in the file <a class="el" href="brkiter_8h.html" title="C++ API: Break Iterator. ">brkiter.h</a>. </p>
<p>Code snippets illustrating the use of the Break Iterator APIs are available in the ICU User Guide, <a href="http://icu-project.org/userguide/boundaryAnalysis.html">http://icu-project.org/userguide/boundaryAnalysis.html</a> and in the sample program icu/source/samples/break/break.cpp </p>

<p class="definition">Definition in file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab17dc88e0028fd85c622889eea22a6fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17dc88e0028fd85c622889eea22a6fa">&#9670;&nbsp;</a></span>U_BRK_SAFECLONE_BUFFERSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define U_BRK_SAFECLONE_BUFFERSIZE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A recommended size (in bytes) for the memory buffer to be passed to ubrk_saveClone(). </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000050">Deprecated:</a></b></dt><dd>ICU 52. Do not rely on <a class="el" href="ubrk_8h.html#a6901f59d9c74bc8e16b9994cb1be7679" title="Thread safe cloning operation. ">ubrk_safeClone()</a> cloning into any provided buffer. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ubrk_8h_source.html#l00327">327</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<a id="a7c31c1e5091fb47ab85db522c7536252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c31c1e5091fb47ab85db522c7536252">&#9670;&nbsp;</a></span>UBRK_DONE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UBRK_DONE&#160;&#160;&#160;((int32_t) -1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value indicating all text boundaries have been returned. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000823">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ubrk_8h_source.html#l00130">130</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<a id="a08c0431a8c9c65e9578b12978681bbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c0431a8c9c65e9578b12978681bbc8">&#9670;&nbsp;</a></span>UBRK_TYPEDEF_UBREAK_ITERATOR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UBRK_TYPEDEF_UBREAK_ITERATOR</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A text-break iterator. </p>
<p>For usage in C programs. </p>

<p class="definition">Definition at line <a class="el" href="ubrk_8h_source.html#l00023">23</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="adb85bb46d5f93c87098e11deab50bef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb85bb46d5f93c87098e11deab50bef4">&#9670;&nbsp;</a></span>UBreakIterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> <a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque type representing an ICU Break iterator object. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000821">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

<p class="definition">Definition at line <a class="el" href="ubrk_8h_source.html#l00028">28</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<a id="a0ac93fd61c60ea0f742f768627aeb275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac93fd61c60ea0f742f768627aeb275">&#9670;&nbsp;</a></span>UBreakIteratorType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a>  <a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The possible types of text boundaries. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000822">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a279b748fce440f03722a3ebe0c3a977a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279b748fce440f03722a3ebe0c3a977a">&#9670;&nbsp;</a></span>ULineBreakTag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccd">ULineBreakTag</a>  <a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccd">ULineBreakTag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum constants for the line break tags returned by getRuleStatus(). </p>
<p>A range of values is defined for each category of word, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values.</p>
<p>The numeric values of all of these constants are stable (will not change).</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000825">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a id="a8be061b386794d29ca7aa5353dc26a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8be061b386794d29ca7aa5353dc26a9e">&#9670;&nbsp;</a></span>USentenceBreakTag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71">USentenceBreakTag</a>  <a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71">USentenceBreakTag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum constants for the sentence break tags returned by getRuleStatus(). </p>
<p>A range of values is defined for each category of sentence, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values.</p>
<p>The numeric values of all of these constants are stable (will not change).</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000826">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a id="afc5d4d3f7f4207d27081409e4b1b6c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5d4d3f7f4207d27081409e4b1b6c9a">&#9670;&nbsp;</a></span>UWordBreak</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9">UWordBreak</a>  <a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9">UWordBreak</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum constants for the word break tags returned by getRuleStatus(). </p>
<p>A range of values is defined for each category of word, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values.</p>
<p>The numeric values of all of these constants are stable (will not change).</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000824">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a026dec40289da8261d787daf3baa588b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026dec40289da8261d787daf3baa588b">&#9670;&nbsp;</a></span>UBreakIteratorType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The possible types of text boundaries. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000822">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a026dec40289da8261d787daf3baa588ba446d025be7ca2f64dfac303b0a55c0b3"></a>UBRK_CHARACTER&#160;</td><td class="fielddoc"><p>Character breaks. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000849">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a026dec40289da8261d787daf3baa588ba17772e8ee70d3de4064c71417c574f36"></a>UBRK_WORD&#160;</td><td class="fielddoc"><p>Word breaks. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000850">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a026dec40289da8261d787daf3baa588ba73e81a0d478daeb2c6de8a63cac1070c"></a>UBRK_LINE&#160;</td><td class="fielddoc"><p>Line breaks. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000851">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a026dec40289da8261d787daf3baa588bab1b31cbd0fb0b298b87cb67da729ba62"></a>UBRK_SENTENCE&#160;</td><td class="fielddoc"><p>Sentence breaks. </p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000852">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a026dec40289da8261d787daf3baa588ba3d79f0b0db32243e6b85b0b5036f9831"></a>UBRK_TITLE&#160;</td><td class="fielddoc"><p>Title Case breaks The iterator created using this type locates title boundaries as described for Unicode 3.2 only. </p>
<p>For Unicode 4.0 and above title boundary iteration, please use Word Boundary iterator.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000051">Deprecated:</a></b></dt><dd>ICU 2.8 Use the word break iterator for titlecasing for Unicode 4 and later. </dd></dl>
</td></tr>
<tr><td class="fieldname"><a id="a026dec40289da8261d787daf3baa588ba6040742b07566e5e3655d4843efaefac"></a>UBRK_COUNT&#160;</td><td class="fielddoc"><p>One more than the highest normal UBreakIteratorType value. </p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000052">Deprecated:</a></b></dt><dd>ICU 58 The numeric value may change over time, see ICU ticket #12420. </dd></dl>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ubrk_8h_source.html#l00099">99</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<a id="a8de005c411b5e5306850f4246d1d7ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de005c411b5e5306850f4246d1d7ccd">&#9670;&nbsp;</a></span>ULineBreakTag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#a8de005c411b5e5306850f4246d1d7ccd">ULineBreakTag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum constants for the line break tags returned by getRuleStatus(). </p>
<p>A range of values is defined for each category of word, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values.</p>
<p>The numeric values of all of these constants are stable (will not change).</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000825">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8de005c411b5e5306850f4246d1d7ccda6a91dd50489f1fbc5c8c32c29fcc3fee"></a>UBRK_LINE_SOFT&#160;</td><td class="fielddoc"><p>Tag value for soft line breaks, positions at which a line break is acceptable but not required. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8de005c411b5e5306850f4246d1d7ccdaef314dd1a053a6f2ab57c06f3a3d5f1f"></a>UBRK_LINE_SOFT_LIMIT&#160;</td><td class="fielddoc"><p>Upper bound for soft line breaks. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8de005c411b5e5306850f4246d1d7ccdad02d1bfcd98382e53c9e83db37fba492"></a>UBRK_LINE_HARD&#160;</td><td class="fielddoc"><p>Tag value for a hard, or mandatory line break. </p>
</td></tr>
<tr><td class="fieldname"><a id="a8de005c411b5e5306850f4246d1d7ccdae767435243d44e5a22c1db90dd3a8f6e"></a>UBRK_LINE_HARD_LIMIT&#160;</td><td class="fielddoc"><p>Upper bound for hard line breaks. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ubrk_8h_source.html#l00180">180</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<a id="ad03d8e27f121bcf11eaed0a288786a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad03d8e27f121bcf11eaed0a288786a71">&#9670;&nbsp;</a></span>USentenceBreakTag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#ad03d8e27f121bcf11eaed0a288786a71">USentenceBreakTag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum constants for the sentence break tags returned by getRuleStatus(). </p>
<p>A range of values is defined for each category of sentence, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values.</p>
<p>The numeric values of all of these constants are stable (will not change).</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000826">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad03d8e27f121bcf11eaed0a288786a71addbcb13addb315fc0814a6fb1284c339"></a>UBRK_SENTENCE_TERM&#160;</td><td class="fielddoc"><p>Tag value for for sentences ending with a sentence terminator ('. </p>
<p>', '?', '!', etc.) character, possibly followed by a hard separator (CR, LF, PS, etc.) </p>
</td></tr>
<tr><td class="fieldname"><a id="ad03d8e27f121bcf11eaed0a288786a71a650703353df53947eb3b996e3e5239f7"></a>UBRK_SENTENCE_TERM_LIMIT&#160;</td><td class="fielddoc"><p>Upper bound for tags for sentences ended by sentence terminators. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad03d8e27f121bcf11eaed0a288786a71aca695be696e0e48676c109de60bcbbdf"></a>UBRK_SENTENCE_SEP&#160;</td><td class="fielddoc"><p>Tag value for for sentences that do not contain an ending sentence terminator ('. </p>
<p>', '?', '!', etc.) character, but are ended only by a hard separator (CR, LF, PS, etc.) or end of input. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad03d8e27f121bcf11eaed0a288786a71af573420e1d53a811d6c5c4a07a4f5c8e"></a>UBRK_SENTENCE_SEP_LIMIT&#160;</td><td class="fielddoc"><p>Upper bound for tags for sentences ended by a separator. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ubrk_8h_source.html#l00205">205</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<a id="af9836cc79482f82ac12eefb1f70b14b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9836cc79482f82ac12eefb1f70b14b9">&#9670;&nbsp;</a></span>UWordBreak</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ubrk_8h.html#af9836cc79482f82ac12eefb1f70b14b9">UWordBreak</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum constants for the word break tags returned by getRuleStatus(). </p>
<p>A range of values is defined for each category of word, to allow for further subdivisions of a category in future releases. Applications should check for tag values falling within the range, rather than for single individual values.</p>
<p>The numeric values of all of these constants are stable (will not change).</p>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000824">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af9836cc79482f82ac12eefb1f70b14b9a8229f94661c6289a6497018ef341801a"></a>UBRK_WORD_NONE&#160;</td><td class="fielddoc"><p>Tag value for "words" that do not fit into any of other categories. </p>
<p>Includes spaces and most punctuation. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9836cc79482f82ac12eefb1f70b14b9a54839e74f8aa4ffd4ea7b9d86f3de050"></a>UBRK_WORD_NONE_LIMIT&#160;</td><td class="fielddoc"><p>Upper bound for tags for uncategorized words. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9836cc79482f82ac12eefb1f70b14b9a3ec03137beddd2ce1d611cc7798b6e74"></a>UBRK_WORD_NUMBER&#160;</td><td class="fielddoc"><p>Tag value for words that appear to be numbers, lower limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9836cc79482f82ac12eefb1f70b14b9a82e563b42b89e0a49c097d40a54c8621"></a>UBRK_WORD_NUMBER_LIMIT&#160;</td><td class="fielddoc"><p>Tag value for words that appear to be numbers, upper limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9836cc79482f82ac12eefb1f70b14b9a945eb6dd49881b36d4e2c9f592d97197"></a>UBRK_WORD_LETTER&#160;</td><td class="fielddoc"><p>Tag value for words that contain letters, excluding hiragana, katakana or ideographic characters, lower limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9836cc79482f82ac12eefb1f70b14b9a66ad49e358ce8a4fba6d6161ec678dd6"></a>UBRK_WORD_LETTER_LIMIT&#160;</td><td class="fielddoc"><p>Tag value for words containing letters, upper limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9836cc79482f82ac12eefb1f70b14b9a69f55c4740ce6f96ad9b61d859de201f"></a>UBRK_WORD_KANA&#160;</td><td class="fielddoc"><p>Tag value for words containing kana characters, lower limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9836cc79482f82ac12eefb1f70b14b9a7d507a35a3813629c11340a3f0f10fec"></a>UBRK_WORD_KANA_LIMIT&#160;</td><td class="fielddoc"><p>Tag value for words containing kana characters, upper limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9836cc79482f82ac12eefb1f70b14b9a295f3da24ba9978b5787c1494079c8de"></a>UBRK_WORD_IDEO&#160;</td><td class="fielddoc"><p>Tag value for words containing ideographic characters, lower limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="af9836cc79482f82ac12eefb1f70b14b9a8097221024f5c65d58951ad488d57474"></a>UBRK_WORD_IDEO_LIMIT&#160;</td><td class="fielddoc"><p>Tag value for words containing ideographic characters, upper limit. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="ubrk_8h_source.html#l00144">144</a> of file <a class="el" href="ubrk_8h_source.html">ubrk.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5e398fb0fe194683a000b3989c041fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e398fb0fe194683a000b3989c041fda">&#9670;&nbsp;</a></span>ubrk_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubrk_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a UBreakIterator. </p>
<p>Once closed, a UBreakIterator may no longer be used. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator to close. </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000831">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a8b587f3b0df1b680f4ca3f1d1f151f7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b587f3b0df1b680f4ca3f1d1f151f7e">&#9670;&nbsp;</a></span>ubrk_countAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_countAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine how many locales have text breaking information available. </p>
<p>This function is most useful as determining the loop ending condition for calls to <a class="el" href="ubrk_8h.html#a12fc845896682221749f03e7dc21e3e0">ubrk_getAvailable</a>. </p><dl class="section return"><dt>Returns</dt><dd>The number of locales for which text breaking information is available. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#a12fc845896682221749f03e7dc21e3e0" title="Get a locale for which text breaking information is available. ">ubrk_getAvailable</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000842">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a4f8b67527c5c9d9205a3446506ffeefc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8b67527c5c9d9205a3446506ffeefc">&#9670;&nbsp;</a></span>ubrk_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_current </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the most recently-returned text boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character index most recently returned by <a class="el" href="ubrk_8h.html#a17158fccedcf72481eaca61fffab4ce6">ubrk_next</a>, <a class="el" href="ubrk_8h.html#a318c950f25ee89a66c989feced3a41f0">ubrk_previous</a>, <a class="el" href="ubrk_8h.html#a2ae638e98af0830b66ff058b48e7dbcd">ubrk_first</a>, or <a class="el" href="ubrk_8h.html#a24ffb5cee86ffe1ee8aa0d53093b352f">ubrk_last</a>. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000834">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a2ae638e98af0830b66ff058b48e7dbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ae638e98af0830b66ff058b48e7dbcd">&#9670;&nbsp;</a></span>ubrk_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the iterator position to zero, the start of the text being scanned. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The new iterator position (zero). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#a24ffb5cee86ffe1ee8aa0d53093b352f" title="Set the iterator position to the index immediately beyond the last character in the text being scanne...">ubrk_last</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000837">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a4724e6d07ea2f27b99a1bba60e4ef76c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4724e6d07ea2f27b99a1bba60e4ef76c">&#9670;&nbsp;</a></span>ubrk_following()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_following </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the iterator to the first boundary following the specified offset. </p>
<p>The value returned is always greater than offset, or UBRK_DONE. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator to use. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to begin scanning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The text boundary following offset, or UBRK_DONE. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#accaaccc55135961f45541bcbab580f9d" title="Set the iterator position to the first boundary preceding the specified offset. ">ubrk_preceding</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000840">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a12fc845896682221749f03e7dc21e3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12fc845896682221749f03e7dc21e3e0">&#9670;&nbsp;</a></span>ubrk_getAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ubrk_getAvailable </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a locale for which text breaking information is available. </p>
<p>A UBreakIterator in a locale returned by this function will perform the correct text breaking for the locale. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the desired locale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A locale for which number text breaking information is available, or 0 if none. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#a8b587f3b0df1b680f4ca3f1d1f151f7e" title="Determine how many locales have text breaking information available. ">ubrk_countAvailable</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000841">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a83ee5322d0bf7e93db259436b561ae17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ee5322d0bf7e93db259436b561ae17">&#9670;&nbsp;</a></span>ubrk_getBinaryRules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_getBinaryRules </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>binaryRules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>rulesCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a compiled binary version of the rules specifying the behavior of a UBreakIterator. </p>
<p>The binary rules may be used with ubrk_openBinaryRules to open a new UBreakIterator more quickly than using ubrk_openRules. The compiled rules are not compatible across different major versions of ICU, nor across platforms of different endianness or different base character set family (ASCII vs EBCDIC). Supports preflighting (with binaryRules=NULL and rulesCapacity=0) to get the rules length without copying them to the binaryRules buffer. However, whether preflighting or not, if the actual length is greater than INT32_MAX, then the function returns 0 and sets *status to U_INDEX_OUTOFBOUNDS_ERROR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator to use. </td></tr>
    <tr><td class="paramname">binaryRules</td><td>Buffer to receive the compiled binary rules; set to NULL for preflighting. </td></tr>
    <tr><td class="paramname">rulesCapacity</td><td>Capacity (in bytes) of the binaryRules buffer; set to 0 for preflighting. Must be &gt;= 0. </td></tr>
    <tr><td class="paramname">status</td><td>Pointer to UErrorCode to receive any errors, such as U_BUFFER_OVERFLOW_ERROR, U_INDEX_OUTOFBOUNDS_ERROR, or U_ILLEGAL_ARGUMENT_ERROR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The actual byte length of the binary rules, if &lt;= INT32_MAX; otherwise 0. If not preflighting and this is larger than rulesCapacity, *status will be set to an error. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#ae2fecb07846f9f39b6202563d32ba51f" title="Open a new UBreakIterator for locating text boundaries using precompiled binary rules. ">ubrk_openBinaryRules</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000848">Stable:</a></b></dt><dd>ICU 59 </dd></dl>

</div>
</div>
<a id="ad95a44383cba60e20188025ab18c09fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad95a44383cba60e20188025ab18c09fe">&#9670;&nbsp;</a></span>ubrk_getLocaleByType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* ubrk_getLocaleByType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uloc_8h.html#adf053345d343f8d82ae080f7a5871f34">ULocDataLocaleType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the locale of the break iterator. </p>
<p>You can choose between the valid and the actual locale. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>break iterator </td></tr>
    <tr><td class="paramname">type</td><td>locale type (valid or actual) </td></tr>
    <tr><td class="paramname">status</td><td>error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>locale string </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000846">Stable:</a></b></dt><dd>ICU 2.8 </dd></dl>

</div>
</div>
<a id="a4314a5dd63efde9b372ded64b6f0c732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4314a5dd63efde9b372ded64b6f0c732">&#9670;&nbsp;</a></span>ubrk_getRuleStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_getRuleStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the status from the break rule that determined the most recently returned break position. </p>
<p>The values appear in the rule source within brackets, {123}, for example. For rules that do not specify a status, a default value of 0 is returned. </p>
<p>For word break iterators, the possible values are defined in enum UWordBreak. </p><dl class="stable"><dt><b><a class="el" href="stable.html#_stable000844">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a id="acf355cf304090ca6efb10c4318bde45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf355cf304090ca6efb10c4318bde45e">&#9670;&nbsp;</a></span>ubrk_getRuleStatusVec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_getRuleStatusVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>fillInVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the statuses from the break rules that determined the most recently returned break position. </p>
<p>The values appear in the rule source within brackets, {123}, for example. The default status value for rules that do not explicitly provide one is zero. </p>
<p>For word break iterators, the possible values are defined in enum UWordBreak. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator to use </td></tr>
    <tr><td class="paramname">fillInVec</td><td>an array to be filled in with the status values. </td></tr>
    <tr><td class="paramname">capacity</td><td>the length of the supplied vector. A length of zero causes the function to return the number of status values, in the normal way, without attempting to store any values. </td></tr>
    <tr><td class="paramname">status</td><td>receives error codes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of rule status values from rules that determined the most recent boundary returned by the break iterator. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000845">Stable:</a></b></dt><dd>ICU 3.0 </dd></dl>

</div>
</div>
<a id="a701db54fd2c91c07490cb02ebdd54fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701db54fd2c91c07490cb02ebdd54fa6">&#9670;&nbsp;</a></span>ubrk_isBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> ubrk_isBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the specified position is a boundary position. </p>
<p>As a side effect, leaves the iterator pointing to the first boundary position at or after "offset". </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator to use. </td></tr>
    <tr><td class="paramname">offset</td><td>the offset to check. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if "offset" is a boundary position. </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000843">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a24ffb5cee86ffe1ee8aa0d53093b352f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ffb5cee86ffe1ee8aa0d53093b352f">&#9670;&nbsp;</a></span>ubrk_last()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the iterator position to the index immediately <em>beyond</em> the last character in the text being scanned. </p>
<p>This is not the same as the last character. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character offset immediately <em>beyond</em> the last character in the text being scanned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#a2ae638e98af0830b66ff058b48e7dbcd" title="Set the iterator position to zero, the start of the text being scanned. ">ubrk_first</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000838">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a17158fccedcf72481eaca61fffab4ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17158fccedcf72481eaca61fffab4ce6">&#9670;&nbsp;</a></span>ubrk_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advance the iterator to the boundary following the current boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character index of the next text boundary, or UBRK_DONE if all text boundaries have been returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#a318c950f25ee89a66c989feced3a41f0" title="Set the iterator position to the boundary preceding the current boundary. ">ubrk_previous</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000835">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a4e5fd80d818fb4ec23330d8935b2754d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5fd80d818fb4ec23330d8935b2754d">&#9670;&nbsp;</a></span>ubrk_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a>* ubrk_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#a026dec40289da8261d787daf3baa588b">UBreakIteratorType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>locale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>textLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a new UBreakIterator for locating text boundaries for a specified locale. </p>
<p>A UBreakIterator may be used for detecting character, line, word, and sentence breaks in text. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The type of UBreakIterator to open: one of UBRK_CHARACTER, UBRK_WORD, UBRK_LINE, UBRK_SENTENCE </td></tr>
    <tr><td class="paramname">locale</td><td>The locale specifying the text-breaking conventions. Note that locale keys such as "lb" and "ss" may be used to modify text break behavior, see general discussion of BreakIterator C API. </td></tr>
    <tr><td class="paramname">text</td><td>The text to be iterated over. May be null, in which case <a class="el" href="ubrk_8h.html#a8c8a6679a8ce36ba5d035b99748c8339" title="Sets an existing iterator to point to a new piece of text. ">ubrk_setText()</a> is used to specify the text to be iterated. </td></tr>
    <tr><td class="paramname">textLength</td><td>The number of characters in text, or -1 if null-terminated. </td></tr>
    <tr><td class="paramname">status</td><td>A UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A UBreakIterator for the specified locale. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#a11826cb21213916c2d91579b673d8949" title="Open a new UBreakIterator for locating text boundaries using specified breaking rules. ">ubrk_openRules</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000827">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="ae2fecb07846f9f39b6202563d32ba51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2fecb07846f9f39b6202563d32ba51f">&#9670;&nbsp;</a></span>ubrk_openBinaryRules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a>* ubrk_openBinaryRules </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>binaryRules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>rulesLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>textLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a new UBreakIterator for locating text boundaries using precompiled binary rules. </p>
<p>Opening a UBreakIterator this way is substantially faster than using ubrk_openRules. Binary rules may be obtained using ubrk_getBinaryRules. The compiled rules are not compatible across different major versions of ICU, nor across platforms of different endianness or different base character set family (ASCII vs EBCDIC). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">binaryRules</td><td>A set of compiled binary rules specifying the text breaking conventions. Ownership of the storage containing the compiled rules remains with the caller of this function. The compiled rules must not be modified or deleted during the life of the break iterator. </td></tr>
    <tr><td class="paramname">rulesLength</td><td>The length of binaryRules in bytes; must be &gt;= 0. </td></tr>
    <tr><td class="paramname">text</td><td>The text to be iterated over. May be null, in which case <a class="el" href="ubrk_8h.html#a8c8a6679a8ce36ba5d035b99748c8339" title="Sets an existing iterator to point to a new piece of text. ">ubrk_setText()</a> is used to specify the text to be iterated. </td></tr>
    <tr><td class="paramname">textLength</td><td>The number of characters in text, or -1 if null-terminated. </td></tr>
    <tr><td class="paramname">status</td><td>Pointer to UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>UBreakIterator for the specified rules. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#a83ee5322d0bf7e93db259436b561ae17" title="Get a compiled binary version of the rules specifying the behavior of a UBreakIterator. ">ubrk_getBinaryRules</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000829">Stable:</a></b></dt><dd>ICU 59 </dd></dl>

</div>
</div>
<a id="a11826cb21213916c2d91579b673d8949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11826cb21213916c2d91579b673d8949">&#9670;&nbsp;</a></span>ubrk_openRules()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a>* ubrk_openRules </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>rules</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>rulesLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>textLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUParseError.html">UParseError</a> *&#160;</td>
          <td class="paramname"><em>parseErr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a new UBreakIterator for locating text boundaries using specified breaking rules. </p>
<p>The rule syntax is ... (TBD) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rules</td><td>A set of rules specifying the text breaking conventions. </td></tr>
    <tr><td class="paramname">rulesLength</td><td>The number of characters in rules, or -1 if null-terminated. </td></tr>
    <tr><td class="paramname">text</td><td>The text to be iterated over. May be null, in which case <a class="el" href="ubrk_8h.html#a8c8a6679a8ce36ba5d035b99748c8339" title="Sets an existing iterator to point to a new piece of text. ">ubrk_setText()</a> is used to specify the text to be iterated. </td></tr>
    <tr><td class="paramname">textLength</td><td>The number of characters in text, or -1 if null-terminated. </td></tr>
    <tr><td class="paramname">parseErr</td><td>Receives position and context information for any syntax errors detected while parsing the rules. </td></tr>
    <tr><td class="paramname">status</td><td>A UErrorCode to receive any errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A UBreakIterator for the specified rules. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#a4e5fd80d818fb4ec23330d8935b2754d" title="Open a new UBreakIterator for locating text boundaries for a specified locale. ">ubrk_open</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000828">Stable:</a></b></dt><dd>ICU 2.2 </dd></dl>

</div>
</div>
<a id="accaaccc55135961f45541bcbab580f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accaaccc55135961f45541bcbab580f9d">&#9670;&nbsp;</a></span>ubrk_preceding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_preceding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the iterator position to the first boundary preceding the specified offset. </p>
<p>The new position is always smaller than offset, or UBRK_DONE. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator to use. </td></tr>
    <tr><td class="paramname">offset</td><td>The offset to begin scanning. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The text boundary preceding offset, or UBRK_DONE. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#a4724e6d07ea2f27b99a1bba60e4ef76c" title="Advance the iterator to the first boundary following the specified offset. ">ubrk_following</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000839">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a318c950f25ee89a66c989feced3a41f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318c950f25ee89a66c989feced3a41f0">&#9670;&nbsp;</a></span>ubrk_previous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t ubrk_previous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the iterator position to the boundary preceding the current boundary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The character index of the preceding text boundary, or UBRK_DONE if all text boundaries have been returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ubrk_8h.html#a17158fccedcf72481eaca61fffab4ce6" title="Advance the iterator to the boundary following the current boundary. ">ubrk_next</a> </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000836">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="ac94136054d5d48cf0f945fc8e8301c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94136054d5d48cf0f945fc8e8301c72">&#9670;&nbsp;</a></span>ubrk_refreshUText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubrk_refreshUText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the subject text string upon which the break iterator is operating without changing any other aspect of the state. </p>
<p>The new and previous text strings must have the same content.</p>
<p>This function is intended for use in environments where ICU is operating on strings that may move around in memory. It provides a mechanism for notifying ICU that the string has been relocated, and providing a new <a class="el" href="structUText.html" title="UText struct. ">UText</a> to access the string in its new position.</p>
<p>Note that the break iterator never copies the underlying text of a string being processed, but always operates directly on the original text provided by the user. Refreshing simply drops the references to the old text and replaces them with references to the new.</p>
<p>Caution: this function is normally used only by very specialized system-level code. One example use case is with garbage collection that moves the text in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The break iterator. </td></tr>
    <tr><td class="paramname">text</td><td>The new (moved) text string. </td></tr>
    <tr><td class="paramname">status</td><td>Receives errors detected by this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000847">Stable:</a></b></dt><dd>ICU 49 </dd></dl>

</div>
</div>
<a id="a6901f59d9c74bc8e16b9994cb1be7679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6901f59d9c74bc8e16b9994cb1be7679">&#9670;&nbsp;</a></span>ubrk_safeClone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a>* ubrk_safeClone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Thread safe cloning operation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>iterator to be cloned </td></tr>
    <tr><td class="paramname">stackBuffer</td><td><em>Deprecated functionality as of ICU 52, use NULL.</em><br />
 user allocated space for the new clone. If NULL new memory will be allocated. If buffer is not large enough, new memory will be allocated. Clients can use the U_BRK_SAFECLONE_BUFFERSIZE. </td></tr>
    <tr><td class="paramname">pBufferSize</td><td><em>Deprecated functionality as of ICU 52, use NULL or 1.</em><br />
 pointer to size of allocated space. If *pBufferSize == 0, a sufficient size for use in cloning will be returned ('pre-flighting') If *pBufferSize is not enough for a stack-based safe clone, new memory will be allocated. </td></tr>
    <tr><td class="paramname">status</td><td>to indicate whether the operation went on smoothly or there were errors An informational status value, U_SAFECLONE_ALLOCATED_ERROR, is used if any allocations were necessary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new clone </dd></dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000830">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="a8c8a6679a8ce36ba5d035b99748c8339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8a6679a8ce36ba5d035b99748c8339">&#9670;&nbsp;</a></span>ubrk_setText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubrk_setText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>textLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an existing iterator to point to a new piece of text. </p>
<p>The break iterator retains a pointer to the supplied text. The caller must not modify or delete the text while the BreakIterator retains the reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The iterator to use </td></tr>
    <tr><td class="paramname">text</td><td>The text to be set </td></tr>
    <tr><td class="paramname">textLength</td><td>The length of the text </td></tr>
    <tr><td class="paramname">status</td><td>The error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000832">Stable:</a></b></dt><dd>ICU 2.0 </dd></dl>

</div>
</div>
<a id="ac91bfeb92a3e489e3188f02597f4c9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91bfeb92a3e489e3188f02597f4c9c7">&#9670;&nbsp;</a></span>ubrk_setUText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ubrk_setUText </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ubrk_8h.html#adb85bb46d5f93c87098e11deab50bef4">UBreakIterator</a> *&#160;</td>
          <td class="paramname"><em>bi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structUText.html">UText</a> *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets an existing iterator to point to a new piece of text. </p>
<p>All index positions returned by break iterator functions are native indices from the <a class="el" href="structUText.html" title="UText struct. ">UText</a>. For example, when breaking UTF-8 encoded text, the break positions returned by <a class="el" href="ubrk_8h.html#a17158fccedcf72481eaca61fffab4ce6">ubrk_next</a>, <a class="el" href="ubrk_8h.html#a318c950f25ee89a66c989feced3a41f0">ubrk_previous</a>, etc. will be UTF-8 string indices, not UTF-16 positions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bi</td><td>The iterator to use </td></tr>
    <tr><td class="paramname">text</td><td>The text to be set. This function makes a shallow clone of the supplied <a class="el" href="structUText.html" title="UText struct. ">UText</a>. This means that the caller is free to immediately close or otherwise reuse the <a class="el" href="structUText.html" title="UText struct. ">UText</a> that was passed as a parameter, but that the underlying text itself must not be altered while being referenced by the break iterator. </td></tr>
    <tr><td class="paramname">status</td><td>The error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="stable"><dt><b><a class="el" href="stable.html#_stable000833">Stable:</a></b></dt><dd>ICU 3.4 </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
