<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta http-equiv="Content-Language" content="en-us">
<title>BOCU-1</title>
</head>

<body>

<h1>BOCU-1</h1>
<p>A MIME-compatible application of the <a href="http://oss.software.ibm.com/icu/docs/papers/binary_ordered_compression_for_unicode.html">Binary
Ordered Compression for Unicode</a> base algorithm.</p>
<p align="right">Markus Scherer &amp; Mark Davis<br>
San José 2002-jan-29</p>
<h2>Summary</h2>
<p>This document describes a Unicode encoding for the storage and exchange of
text data. It is stateful and provides a good byte/code point ratio while being
directly usable in SMTP emails, database fields and other contexts.</p>
<h2>Introduction</h2>
<p>The most popular encoding for Unicode text data exchange is UTF-8. It is
relatively simple and widely applicable: MIME/email/HTML/XML, in-process use in
some systems, etc. However, UTF-8 uses more bytes per code point for non-Latin
scripts than language-specific codepages.</p>
<p>In some markets where scripts other than Latin are used, the high bytes/code
point ratio of UTF-8 (and of UTF-16 for scripts other than Latin and CJK
ideographs) has been criticized and used as a motivation to not use Unicode for
the exchange of documents in some languages. Larger document sizes are also
a problem in low-bandwidth environments such as wireless networks for handheld
systems.</p>
<p><a href="http://www.unicode.org/unicode/reports/tr6/">SCSU</a> was created as a Unicode compression scheme with a byte/code point ratio
similar to language-specific codepages. It has not been widely adopted although
it fulfills the criteria for an IANA charset and is registered as one. SCSU is not suitable for MIME
&quot;text&quot; media types, i.e.,
it cannot be used directly in emails and similar protocols. SCSU requires a
complicated encoder design for good performance.</p>
<p>BOCU-1 combines the wide applicability of UTF-8 with the compactness of SCSU.
It is useful for short strings and maintains code point order.</p>
<h2>Basic features of BOCU-1</h2>
<p>BOCU-1 is a stateful, byte-oriented, encoding of Unicode. Like SCSU it can be
classified as a Character Encoding Scheme (CES) or as a Transfer Encoding Syntax
(TES). It is a &quot;charset&quot; according to IANA, and it is suitable for
MIME &quot;text&quot; media types.</p>
<p>BOCU-1 is more complicated than UTF-8 but much simpler than SCSU. Its
inter-character state consists of a single integer. It is deterministic, i.e.,
the
same complete input text is always encoded the same way by all encoders.</p>
<p>The byte/code point ratio is 1 for runs of code points from the same block of
0x80 code points (and for Hiragana), and 2 for runs of CJK Unihan code points, as with SCSU. This
is much better than UTF-8 for Indic scripts, Russian, Greek, Arabic, Hebrew,
etc. The
startup overhead is very low (similar to SCSU), which makes it useful for very short strings like
individual names. The maximum number of bytes per code point is four.</p>
<p>The lexical order of BOCU-1 bytes is the same
as the code point order of the original text &mdash; like UTF-8 but unlike SCSU &mdash;
which allows the compression of large, sorted lists of strings.</p>
<p>The C0 control codes NUL, CR and LF and nine others are encoded with the same
byte values as in US-ASCII, and those byte values are used <em>only </em>for the
encoding of these twelve C0 control codes. This makes BOCU-1 suitable for MIME
&quot;text&quot; media types, directly usable in emails and generally &quot;friendly&quot; for
ASCII-based tools. The SUB control and its byte value 1A is included in this set
to avoid problems in DOS/Windows/OS/2 systems where 1A is interpreted as an
end-of-file marker in text mode.</p>

<p>The state is reset at each C0 control (U+0000..U+001F, includes CR, LF, TAB).
CRLF-separated lines do not affect each other's encoding. Together with BOCU-1
being deterministic, this allows line-based file comparisons (diff) and makes BOCU-1 usable
with RCS, CVS and other source-code control systems (unlike SCSU). This also allows some
limited random access.</p>

<p>Similarly, the state is also reset at each Newline (U+0085), Line Separator
(U+2028) and Paragraph Separator (U+2029). This is for texts using non-C0 line
and paragraph break controls.</p>

<p>Byte values for single-byte codes and lead bytes overlap with trail bytes.
So unlike UTF-8, character boundaries cannot be determined in random access, except
by backing up to a reset point.</p>

<p>Byte values 7F..9F (DEL and C1 control codes) are used as lead and trail bytes.</p>

<p>US-ASCII characters (code points U+0021..U+007E) are not encoded with the
same bytes as in US-ASCII. Therefore, the charset must be specified with a
signature byte sequence or in a higher-level protocol.</p>

<h2>Signature byte sequence</h2>
<p>An initial U+FEFF is encoded in BOCU-1 with the three bytes FC EE 27.</p>
<h2>Encoding algorithm</h2>
<p>The basic algorithm is as described in <a href="http://oss.software.ibm.com/icu/docs/papers/binary_ordered_compression_for_unicode.html">Binary
Ordered Compression for Unicode</a>.</p>
<p>BOCU-1 differs from the generic algorithm by using a different set of byte
value ranges and by encoding U+0000..U+0020 directly with byte values 00..20. In
addition, the space character U+0020 does not affect the state. This is to avoid large difference values at the beginning and end of
each word.</p>
<p>Partial pseudo-code for a per-code point encoding function is as follows:</p>
<pre>
encode(int &amp;prev, int c) {
    if(c&lt;=0x20) {
        output (byte)c;
        if(c!=0x20) {
            prev=0x40;
        }
    } else {
        int diff=c-prev;
        // encode diff in 1..4 bytes and output them

        // adjust prev
        if(c is Hiragana) {
            prev=middle of Hiragana;
        } else if(c is CJK Unihan) {
            prev=middle of CJK Unihan;
        } else if(c is Hangul) {
            prev=middle of Hangul;
        } else if(c is Newline or LS or PS) {
            prev=0x40;
        } else {
            prev=(c&amp;~0x7f)+0x40;
        }
    }
}
</pre>
<h2>Sample C code</h2>
<p>The sample C code serves as the full specification of
BOCU-1. Every conformant encoder and decoder must generate equivalent output and
detect any illegal input code points and illegal input byte sequences. Recovery
from illegal input is not specified. Single surrogates are encoded if present in
the input (e.g., unmatched single surrogate code units in UTF-16). Proper input
of supplementary code points (e.g., matched surrogate pairs in UTF-16) must be
encoded by code points.</p>

<p>This code uses <a href="http://oss.software.ibm.com/icu/">ICU</a> standard
headers and the one implementation file <code>icu/source/common/utf_impl.c</code>.
(It is not necessary to link the entire ICU common library.) This is for
convenience in the surrounding test functions and not necessary for the core
BOCU-1 functions. These headers and implementation file provide the following:</p>

<ul>
  <li>Include inttypes.h or define its types.</li>
  <li>Define UChar for UTF-16 as an unsigned 16-bit type (wchar_t or uint16_t).</li>
  <li>Define UTF* macros to handle reading and writing of in-process UTF-8/16
    strings.</li>
</ul>
<p>This code is under the <a href="http://oss.software.ibm.com/cvs/icu/~checkout~/icu/license.html">X
license (ICU version)</a>.</p>

<p>Files:</p>

<ul>
  <li><a href="bocu1.h">bocu1.h</a> (constants and macros)</li>
  <li><a href="bocu1.c">bocu1.c</a> (encoder and decoder functions)</li>
  <li><a href="bocu1tst.c">bocu1tst.c</a> (test code with <code>main()</code>
    function, see below)</li>
</ul>

<p>A complete, compiled sample <a href="http://oss.software.ibm.com/icu/dropbox/bocu1.exe">executable for Windows</a>
from this source code is available for download. Aside from basic implementation
and consistency tests, this also provides file conversion between UTF-8 and
BOCU-1. Use a command-line argument of &quot;?&quot; or &quot;-h&quot; for
usage.</p>

<h2>Changes</h2>
<p>2002-feb-21: Change adjustment of prev to account for Hiragana (not
128-aligned) and to reset at U+0085 (Newline), U+2028 (Line Separator) and
U+2029 (Paragraph Separator).</p>

</body>

</html>
