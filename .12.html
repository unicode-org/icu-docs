<html><head><TITLE></TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>    </H2><BLOCKQUOTE>

Date Format C API  consists of functions that convert dates and
times from their internal representations to textual form and back again in a
language-independent manner
</BLOCKQUOTE>
<A NAME="DOC.DOCU">
<BLOCKQUOTE>

Date Format C API  consists of functions that convert dates and
times from their internal representations to textual form and back again in a
language-independent manner. Converting from the internal representation (milliseconds
since midnight, January 1, 1970) to text is known as "formatting," and converting
from text to millis is known as "parsing."  We currently define only one concrete
structure UDateFormat, which can handle pretty much all normal
date formatting and parsing actions.
<P>
Date Format helps you to format and parse dates for any locale. Your code can
be completely independent of the locale conventions for months, days of the
week, or even the calendar format: lunar vs. solar.
<P>
To format a date for the current Locale with default time and date style, 
use one of the static factory methods:
<pre>
.    UErrorCode status;
.    UFieldPosition pos;
.    UChar *myString;
.    t_int32 myStrlen=0;
.    UDateFormat* dfmt = udat_open(UCAL_DEFAULT, UCAL_DEFAULT, NULL, "PST", &status);
.    myStrlen = udat_format(dfmt, myDate, NULL, myStrlen, &pos, &status);
.    if(status==BUFFER_OVERFLOW_ERROR){
.    status=ZERO_ERROR;
.    myString=(UChar*)malloc(sizeof(UChar) * (myStrlen+1) );
.    udat_format(dfmt, myDate, myString, myStrlen+1, &pos, &status);
.    }
</pre>
If you are formatting multiple numbers, it is more efficient to get the
format and use it multiple times so that the system doesn't have to fetch the
information about the local language and country conventions multiple times.
<pre>
.    t_int32 i, myStrlen=0;
.    UChar* myString;
.    UDate myDateArr[] = { 0.0, 100000000.0, 2000000000.0 }; // test values
.    UDateFormat* df = udat_open(UCAL_DEFAULT, UCAL_DEFAULT, NULL, "GMT", &status);
.    for (i = 0; i < 3; ++i) {
.    myStrlen = udat_format(df, myDate, NULL, myStrlen, &pos, &status);
.    if(status==BUFFER_OVERFLOW_ERROR){
.    status=ZERO_ERROR;
.    myString=(UChar*)malloc(sizeof(UChar) * (myStrlen+1) );
.    udat_format(df, myDate, myString, myStrlen+1, &pos, &status);
.    }
.    printf("%s \n", austrdup(myString) ); //austrdup( a function used to convert UChar* to char*)
.    free(myString);
.    }
</pre>
To format a date for a different Locale, specify it in the call to
udat_open()
<pre>
.       UDateFormat* df = udat_open(UDAT_SHORT, UDAT_SHORT, "fr_FR", "GMT", &status);
</pre>
You can use a DateFormat API udat_parse() to parse.
<pre>
.       UErrorCode status = ZERO_ERROR;
.       t_int32 parsepos=0;     
.       UDate myDate = udat_parse(df, myString, u_strlen(myString), &parsepos, &status);
</pre>
. You can pass in different options for the arguments for date and time style 
. to control the length of the result; from SHORT to MEDIUM to LONG to FULL. 
. The exact result depends on the locale, but generally:
. see UDateFormatStyle for more details
<ul type=round>
<li>   UDAT_SHORT is completely numeric, such as 12/13/52 or 3:30pm
<li>   UDAT_MEDIUM is longer, such as Jan 12, 1952
<li>   UDAT_LONG is longer, such as January 12, 1952 or 3:30:32pm
<li>   UDAT_FULL is pretty completely specified, such as
Tuesday, April 12, 1952 AD or 3:30:42pm PST.
</ul>
You can also set the time zone on the format if you wish. 
<P>
You can also use forms of the parse and format methods with Parse Position and
UFieldPosition to allow you to
<ul type=round>
<li>   Progressively parse through pieces of a string.
<li>   Align any particular field, or find out where it is for selection
on the screen.
</ul>
</BLOCKQUOTE>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
