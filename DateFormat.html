<html><head><TITLE>DateFormat</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  U_I18N_API DateFormat : public <!2><A HREF="Format.html#DOC.25.8">Format</A> </H2><BLOCKQUOTE>

DateFormat is an abstract class for a family of classes that convert dates and
times from their internal representations to textual form and back again in a
language-independent manner
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=95>
<param name=classes value="CFormat,MFormat.html,CDateFormat,MDateFormat.html,CSimpleDateFormat,MSimpleDateFormat.html">
<param name=before value="M,M,M^_">
<param name=after value="Md_,M,M">
<param name=indent value="0,1,1">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Classes</h3><DD><DT><A HREF="#DOC.19.1"> <IMG BORDER=0 SRC=icon1.gif></A>  enum  <B>EField</B> </B>
 <DD><I>
The following enum values are used in FieldPosition with date/time formatting</I>

<DL>
<DT><A HREF="#DOC.19.1.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>ERA_FIELD</B> </B>
 <DD><I>
These constants are provided for backwards compatibility only,
and are deprecated</I>

</DL>
<DT><A HREF="#DOC.19.2"> <IMG BORDER=0 SRC=icon1.gif></A>  enum  <B>EStyle</B> </B>
 <DD><I>
Constants for various style patterns</I>

<DL>
<DT><A HREF="#DOC.19.2.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>FULL</B> </B>
 <DD><I>
These constants are provided for backwards compatibility only,
and are deprecated</I>

</DL>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.19.29"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <B>~DateFormat</B>() </B>
 <DD><I>
Destructor</I>
<DT><A HREF="#DOC.19.3"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>operator==</B>(const <!2><A HREF="Format.html#DOC.25.8">Format</A>&) const  </B>
 <DD><I>
Equality operator</I>
<DT><A HREF="#DOC.19.4"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
Format an object to produce a string</I>
<DT><A HREF="#DOC.19.5"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>( <!1><A HREF="UDate.html">UDate</A> date, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& fieldPosition) const  </B>
 <DD><I>
Formats a UDate into a date/time string</I>
<DT><A HREF="#DOC.19.6"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>(<!1><A HREF="UDate.html">UDate</A> date, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Formats a UDate into a date/time string</I>
<DT><A HREF="#DOC.19.30"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
Redeclared Format method</I>
<DT><A HREF="#DOC.19.7"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UDate.html">UDate</A>  <B>parse</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
Parse a date/time string</I>
<DT><A HREF="#DOC.19.8"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UDate.html">UDate</A>  <B>parse</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!1><A HREF="ParsePosition.html">ParsePosition</A>& pos) const  </B>
 <DD><I>
Parse a date/time string beginning at the given parse position</I>
<DT><A HREF="#DOC.19.9"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>parseObject</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parse_pos) const  </B>
 <DD><I>
Parse a string to produce an object</I>
<DT><A HREF="#DOC.19.10"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  <B>createInstance</B>(void) </B>
 <DD><I>
Create a default date/time formatter that uses the SHORT style for both
the date and the time</I>
<DT><A HREF="#DOC.19.11"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  <B>createTimeInstance</B>(<!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> style = kDefault, const Locale& aLocale = Locale::getDefault()) </B>
 <DD><I>
Creates a time formatter with the given formatting style for the given
locale</I>
<DT><A HREF="#DOC.19.12"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  <B>createDateInstance</B>(<!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> style = kDefault, const Locale& aLocale = Locale::getDefault()) </B>
 <DD><I>
Creates a date formatter with the given formatting style for the given
const locale</I>
<DT><A HREF="#DOC.19.13"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  <B>createDateTimeInstance</B>(<!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> dateStyle = kDefault, <!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> timeStyle = kDefault, const Locale& aLocale = Locale::getDefault()) </B>
 <DD><I>
Creates a date/time formatter with the given formatting styles for the
given locale</I>
<DT><A HREF="#DOC.19.14"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  Locale*  <B>getAvailableLocales</B>(int32_t& count) </B>
 <DD><I>
Gets the set of locales for which DateFormats are installed</I>
<DT><A HREF="#DOC.19.31"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>isLenient</B>(void) const  </B>
 <DD><I>
Returns true if the formatter is set for lenient parsing</I>
<DT><A HREF="#DOC.19.15"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setLenient</B>(bool_t lenient) </B>
 <DD><I>
Specify whether or not date/time parsing is to be lenient</I>
<DT><A HREF="#DOC.19.16"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  const  <!1><A HREF="Calendar.html">Calendar</A>*  <B>getCalendar</B>(void) const  </B>
 <DD><I>
Gets the calendar associated with this date/time formatter</I>
<DT><A HREF="#DOC.19.17"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>adoptCalendar</B>(<!1><A HREF="Calendar.html">Calendar</A>* calendarToAdopt) </B>
 <DD><I>
Set the calendar to be used by this date format</I>
<DT><A HREF="#DOC.19.18"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setCalendar</B>(const <!1><A HREF="Calendar.html">Calendar</A>& newCalendar) </B>
 <DD><I>
Set the calendar to be used by this date format</I>
<DT><A HREF="#DOC.19.19"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  const  <!1><A HREF="NumberFormat.html">NumberFormat</A>*  <B>getNumberFormat</B>(void) const  </B>
 <DD><I>
Gets the number formatter which this date/time formatter uses to format
and parse the numeric portions of the pattern</I>
<DT><A HREF="#DOC.19.20"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>adoptNumberFormat</B>(<!1><A HREF="NumberFormat.html">NumberFormat</A>* formatToAdopt) </B>
 <DD><I>
Allows you to set the number formatter</I>
<DT><A HREF="#DOC.19.21"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setNumberFormat</B>(const <!1><A HREF="NumberFormat.html">NumberFormat</A>& newNumberFormat) </B>
 <DD><I>
Allows you to set the number formatter</I>
<DT><A HREF="#DOC.19.22"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  const  <!1><A HREF="TimeZone.html">TimeZone</A>&  <B>getTimeZone</B>(void) const  </B>
 <DD><I>
Returns a reference to the TimeZone used by this DateFormat's calendar</I>
<DT><A HREF="#DOC.19.23"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>adoptTimeZone</B>(<!1><A HREF="TimeZone.html">TimeZone</A>* zoneToAdopt) </B>
 <DD><I>
Sets the time zone for the calendar of this DateFormat object</I>
<DT><A HREF="#DOC.19.24"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setTimeZone</B>(const <!1><A HREF="TimeZone.html">TimeZone</A>& zone) </B>
 <DD><I>
Sets the time zone for the calendar of this DateFormat object</I>
</DL><DL>
<DT><h3>Protected Fields</h3><DD><DT><A HREF="#DOC.19.26"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="Calendar.html">Calendar</A>*  <B>fCalendar</B> </B>
 <DD><I>
The calendar that DateFormat uses to produce the time field values needed
to implement date/time formatting</I>
<DT><A HREF="#DOC.19.27"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="NumberFormat.html">NumberFormat</A>*  <B>fNumberFormat</B> </B>
 <DD><I>
The number formatter that DateFormat uses to format numbers in dates and
times</I>
</DL><DL>
<DT><h3>Protected Methods</h3><DD><DT><A HREF="#DOC.19.25"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DateFormat</B>() </B>
 <DD><I>
Default constructor</I>
<DT><A HREF="#DOC.19.32"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>DateFormat</B>(const <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>&) </B>
 <DD><I>
Copy constructor</I>
<DT><A HREF="#DOC.19.33"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>&  <B>operator=</B>(const <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>&) </B>
 <DD><I>
Default assignment operator</I>
</DL></DL>
<hr><H3>Inherited from <A HREF="Format.html">Format:</A></h3>

<DL>
<DL>
<DT><h3>Public Methods</h3><DD><DT><IMG SRC=icon2.gif> bool_t  <B>operator!=</B>(const <!2><A HREF="Format.html#DOC.25.8">Format</A>& other) const 
<DT><IMG SRC=icon2.gif> virtual  <!2><A HREF="Format.html#DOC.25.8">Format</A>*  <B>clone</B>() const 
<DT><IMG SRC=icon2.gif> virtual  <!1><A HREF="UClassID.html">UClassID</A>  <B>getDynamicClassID</B>() const 
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

DateFormat is an abstract class for a family of classes that convert dates and
times from their internal representations to textual form and back again in a
language-independent manner. Converting from the internal representation (milliseconds
since midnight, January 1, 1970) to text is known as "formatting," and converting
from text to millis is known as "parsing."  We currently define only one concrete
subclass of DateFormat: SimpleDateFormat, which can handle pretty much all normal
date formatting and parsing actions.
<P>
DateFormat helps you to format and parse dates for any locale. Your code can
be completely independent of the locale conventions for months, days of the
week, or even the calendar format: lunar vs. solar.
<P>
To format a date for the current Locale, use one of the static factory
methods:
<pre>
.    DateFormat* dfmt = DateFormat::createDateInstance();
.    UnicodeString myString;
.    myString = dfmt->format( myDate, myString );
</pre>
If you are formatting multiple numbers, it is more efficient to get the
format and use it multiple times so that the system doesn't have to fetch the
information about the local language and country conventions multiple times.
<pre>
.    DateFormat* df = DateFormat::createDateInstance();
.    UnicodeString myString;
.    UDate myDateArr[] = { 0.0, 100000000.0, 2000000000.0 }; // test values
.    for (int32_t i = 0; i < 3; ++i) {
.        myString.remove();
.        cout &lt;&lt; df->format( myDateArr[i], myString ) &lt;&lt; endl;
.    }
</pre>
To format a date for a different Locale, specify it in the call to
getDateInstance().
<pre>
.       DateFormat* df =
.          DateFormat::createDateInstance( DateFormat::SHORT, Locale::FRANCE);
</pre>
You can use a DateFormat to parse also.
<pre>
.       UErrorCode status = U_ZERO_ERROR;
.       UDate myDate = df->parse(myString, status);
</pre>
Use createDateInstance() to produce the normal date format for that country.
There are other static factory methods available. Use createTimeInstance()
to produce the normal time format for that country. Use createDateTimeInstance()
to produce a DateFormat that formats both date and time. You can pass in
different options to these factory methods to control the length of the
result; from SHORT to MEDIUM to LONG to FULL. The exact result depends on the
locale, but generally:
<ul type=round>
<li>   SHORT is completely numeric, such as 12/13/52 or 3:30pm
<li>   MEDIUM is longer, such as Jan 12, 1952
<li>   LONG is longer, such as January 12, 1952 or 3:30:32pm
<li>   FULL is pretty completely specified, such as
Tuesday, April 12, 1952 AD or 3:30:42pm PST.
</ul>
You can also set the time zone on the format if you wish. If you want even
more control over the format or parsing, (or want to give your users more
control), you can try casting the DateFormat you get from the factory methods
to a SimpleDateFormat. This will work for the majority of countries; just
remember to chck getDynamicClassID() before carrying out the cast.
<P>
You can also use forms of the parse and format methods with ParsePosition and
FieldPosition to allow you to
<ul type=round>
<li>   Progressively parse through pieces of a string.
<li>   Align any particular field, or find out where it is for selection
on the screen.
</ul>

</BLOCKQUOTE>
<DL>

<A NAME="EField">
<A NAME ="DOC.19.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  enum  EField</B></TT>
<DD>
The following enum values are used in FieldPosition with date/time formatting.
They are also used to index into DateFormatSymbols::fgPatternChars, which
is the list of standard internal-representation pattern characters, and
the resource bundle localPatternChars data. For this reason, this enum
should be treated with care; don't change the order or contents of it
unless you really know what you are doing. You'll probably have to change
the code in DateFormatSymbols, SimpleDateFormat, and all the locale
resource bundle data files.
<DL></DL><P><DL>

<A NAME="ERA_FIELD">
<A NAME ="DOC.19.1.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  ERA_FIELD</B></TT>
<DD>
These constants are provided for backwards compatibility only,
and are deprecated.  Please use the C++ style constants defined above.
<DL></DL><P></DL>

<A NAME="EStyle">
<A NAME ="DOC.19.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  enum  EStyle</B></TT>
<DD>
Constants for various style patterns. These reflect the order of items in
the DateTimePatterns resource. There are 4 time patterns, 4 date patterns,
and then the date-time pattern. Each block of 4 values in the resource occurs
in the order full, long, medium, short.
<DL></DL><P><DL>

<A NAME="FULL">
<A NAME ="DOC.19.2.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  FULL</B></TT>
<DD>
These constants are provided for backwards compatibility only,
and are deprecated.  Please use the C++ style constants defined above.
<DL></DL><P></DL>

<A NAME="~DateFormat">
<A NAME ="DOC.19.29">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  ~DateFormat()</B></TT>
<DD>
Destructor
<DL></DL><P>
<A NAME="operator==">
<A NAME ="DOC.19.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  operator==(const <!2><A HREF="Format.html#DOC.25.8">Format</A>&) const </B></TT>
<DD>
Equality operator.  Returns true if the two formats have the same behavior.
<DL></DL><P>
<A NAME="format">
<A NAME ="DOC.19.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
Format an object to produce a string. This method handles Formattable
objects with a UDate type. If a the Formattable object type is not a Date,
then it returns a failing UErrorCode.


<DL><DT><B>Returns:</B><DD>The value passed in as toAppendTo (this allows chaining,
as with UnicodeString::append())
<DT><B>Parameters:</B><DD><B>obj</B> -            The object to format. Must be a Date.
<br><B>toAppendTo</B> -     The result of the formatting operation is appended to
this string.
<br><B>pos</B> -            On input: an alignment field, if desired.
On output: the offsets of the alignment field.
<br><B>status</B> -         Output param filled with success/failure status.
<br></DL><P>
<A NAME="format">
<A NAME ="DOC.19.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format( <!1><A HREF="UDate.html">UDate</A> date, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& fieldPosition) const </B></TT>
<DD>
Formats a UDate into a date/time string. This is an abstract method which
concrete subclasses must implement.
<P>
On input, the FieldPosition parameter may have its "field" member filled with
an enum value specifying a field.  On output, the FieldPosition will be filled
in with the text offsets for that field.  
<P> For example, given a time text
"1996.07.10 AD at 15:08:56 PDT", if the given fieldPosition.field is
DateFormat::kYearField, the offsets fieldPosition.beginIndex and
statfieldPositionus.getEndIndex will be set to 0 and 4, respectively. 
<P> Notice
that if the same time field appears more than once in a pattern, the status will
be set for the first occurence of that time field. For instance,
formatting a UDate to the time string "1 PM PDT (Pacific Daylight Time)"
using the pattern "h a z (zzzz)" and the alignment field
DateFormat::TIMEZONE_FIELD, the offsets fieldPosition.beginIndex and
fieldPosition.getEndIndex will be set to 5 and 8, respectively, for the first
occurence of the timezone pattern character 'z'.


<DL><DT><B>Returns:</B><DD>A reference to 'toAppendTo'.
<DT><B>Parameters:</B><DD><B>date</B> -           a UDate to be formatted into a date/time string.
<br><B>toAppendTo</B> -     the result of the formatting operation is appended to
the end of this string.
<br><B>fieldPosition</B> -  On input: an alignment field, if desired (see examples above)
On output: the offsets of the alignment field (see examples above)
<br></DL><P>
<A NAME="format">
<A NAME ="DOC.19.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format(<!1><A HREF="UDate.html">UDate</A> date, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Formats a UDate into a date/time string. If there is a problem, you won't
know, using this method. Use the overloaded format() method which takes a
FieldPosition& to detect formatting problems.


<DL><DT><B>Returns:</B><DD>A reference to 'result'.
<DT><B>Parameters:</B><DD><B>date</B> -       The UDate value to be formatted into a string.
<br><B>result</B> -     Output param which will receive the formatted date.
<br></DL><P>
<A NAME="format">
<A NAME ="DOC.19.30">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
Redeclared Format method
<DL></DL><P>
<A NAME="parse">
<A NAME ="DOC.19.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UDate.html">UDate</A>  parse( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
Parse a date/time string.


<DL><DT><B>Parameters:</B><DD><B>text</B> -       The string to be parsed into a UDate value.
<br><B>status</B> -     Output param to be set to success/failure code. If
'text' cannot be parsed, it will be set to a failure
code.
@result          The parsed UDate value, if successful.<br></DL><P>
<A NAME="parse">
<A NAME ="DOC.19.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UDate.html">UDate</A>  parse( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& text, <!1><A HREF="ParsePosition.html">ParsePosition</A>& pos) const </B></TT>
<DD>
Parse a date/time string beginning at the given parse position. For
example, a time text "07/10/96 4:5 PM, PDT" will be parsed into a Date
that is equivalent to Date(837039928046).
<P>
By default, parsing is lenient: If the input is not in the form used by
this object's format method but can still be parsed as a date, then the
parse succeeds. Clients may insist on strict adherence to the format by
calling setLenient(false).


<DL><DT><B>Returns:</B><DD>A valid UDate if the input could be parsed.
<DT><B>Parameters:</B><DD><B>text</B> -   The date/time string to be parsed
<br><B>pos</B> -    On input, the position at which to start parsing; on
output, the position at which parsing terminated, or the
start position if the parse failed.
<br><DT><B>See Also:</B><DD><!2><A HREF="DateFormat.html#DOC.19.15">DateFormat::setLenient</A>(boolean)
<br></DL><P>
<A NAME="parseObject">
<A NAME ="DOC.19.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  parseObject(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parse_pos) const </B></TT>
<DD>
Parse a string to produce an object. This methods handles parsing of
date/time strings into Formattable objects with UDate types.
<P>
Before calling, set parse_pos.index to the offset you want to start
parsing at in the source. After calling, parse_pos.index is the end of
the text you parsed. If error occurs, index is unchanged.
<P>
When parsing, leading whitespace is discarded (with a successful parse),
while trailing whitespace is left as is.
<P>
See Format::parseObject() for more.


<DL><DT><B>Returns:</B><DD>A newly created Formattable* object, or NULL
on failure.  The caller owns this and should
delete it when done.
<DT><B>Parameters:</B><DD><B>source</B> -     The string to be parsed into an object.
<br><B>result</B> -     Formattable to be set to the parse result.
If parse fails, return contents are undefined.
<br><B>parse_pos</B> -  The position to start parsing at. Upon return
this param is set to the position after the
last character successfully parsed. If the
source is not parsed successfully, this param
will remain unchanged.
<br></DL><P>
<A NAME="createInstance">
<A NAME ="DOC.19.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  createInstance(void)</B></TT>
<DD>
Create a default date/time formatter that uses the SHORT style for both
the date and the time.


<DL><DT><B>Returns:</B><DD>A date/time formatter which the caller owns.
</DL><P>
<A NAME="createTimeInstance">
<A NAME ="DOC.19.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  createTimeInstance(<!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> style = kDefault, const Locale& aLocale = Locale::getDefault())</B></TT>
<DD>
Creates a time formatter with the given formatting style for the given
locale.


<DL><DT><B>Returns:</B><DD>A time formatter which the caller owns.
<DT><B>Parameters:</B><DD><B>style</B> -      The given formatting style. For example,
SHORT for "h:mm a" in the US locale.
<br><B>aLocale</B> -    The given locale.
<br></DL><P>
<A NAME="createDateInstance">
<A NAME ="DOC.19.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  createDateInstance(<!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> style = kDefault, const Locale& aLocale = Locale::getDefault())</B></TT>
<DD>
Creates a date formatter with the given formatting style for the given
const locale.


<DL><DT><B>Returns:</B><DD>A date formatter which the caller owns.
<DT><B>Parameters:</B><DD><B>style</B> -      The given formatting style. For example,
SHORT for "M/d/yy" in the US locale.
<br><B>aLocale</B> -    The given locale.
<br></DL><P>
<A NAME="createDateTimeInstance">
<A NAME ="DOC.19.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>*  createDateTimeInstance(<!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> dateStyle = kDefault, <!2><A HREF="DateFormat.html#DOC.19.2">EStyle</A> timeStyle = kDefault, const Locale& aLocale = Locale::getDefault())</B></TT>
<DD>
Creates a date/time formatter with the given formatting styles for the
given locale.


<DL><DT><B>Returns:</B><DD>A date/time formatter which the caller owns.
<DT><B>Parameters:</B><DD><B>dateStyle</B> -  The given formatting style for the date portion of the result.
For example, SHORT for "M/d/yy" in the US locale.
<br><B>timeStyle</B> -  The given formatting style for the time portion of the result.
For example, SHORT for "h:mm a" in the US locale.
<br><B>aLocale</B> -    The given locale.
<br></DL><P>
<A NAME="getAvailableLocales">
<A NAME ="DOC.19.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  Locale*  getAvailableLocales(int32_t& count)</B></TT>
<DD>
Gets the set of locales for which DateFormats are installed
<DL><DT><B>Returns:</B><DD>the set of locales for which DateFormats are installed.  The caller
does NOT own this list and must not delete it.
<DT><B>Parameters:</B><DD><B>count</B> -  Filled in with the number of locales in the list that is returned.
<br></DL><P>
<A NAME="isLenient">
<A NAME ="DOC.19.31">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  isLenient(void) const </B></TT>
<DD>
Returns true if the formatter is set for lenient parsing
<DL></DL><P>
<A NAME="setLenient">
<A NAME ="DOC.19.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setLenient(bool_t lenient)</B></TT>
<DD>
Specify whether or not date/time parsing is to be lenient. With lenient
parsing, the parser may use heuristics to interpret inputs that do not
precisely match this object's format. With strict parsing, inputs must
match this object's format.

<DL><DT><B>See Also:</B><DD><!2><A HREF="Calendar.html#DOC.3.29">Calendar::setLenient</A><br></DL><P>
<A NAME="getCalendar">
<A NAME ="DOC.19.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  const  <!1><A HREF="Calendar.html">Calendar</A>*  getCalendar(void) const </B></TT>
<DD>
Gets the calendar associated with this date/time formatter
<DL><DT><B>Returns:</B><DD>the calendar associated with this date/time formatter.
</DL><P>
<A NAME="adoptCalendar">
<A NAME ="DOC.19.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  adoptCalendar(<!1><A HREF="Calendar.html">Calendar</A>* calendarToAdopt)</B></TT>
<DD>
Set the calendar to be used by this date format. Initially, the default
calendar for the specified or default locale is used.  The caller should
not delete the Calendar object after it is adopted by this call.
<DL></DL><P>
<A NAME="setCalendar">
<A NAME ="DOC.19.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setCalendar(const <!1><A HREF="Calendar.html">Calendar</A>& newCalendar)</B></TT>
<DD>
Set the calendar to be used by this date format. Initially, the default
calendar for the specified or default locale is used.
<DL></DL><P>
<A NAME="getNumberFormat">
<A NAME ="DOC.19.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  const  <!1><A HREF="NumberFormat.html">NumberFormat</A>*  getNumberFormat(void) const </B></TT>
<DD>
Gets the number formatter which this date/time formatter uses to format
and parse the numeric portions of the pattern
<DL><DT><B>Returns:</B><DD>the number formatter which this date/time formatter uses.
</DL><P>
<A NAME="adoptNumberFormat">
<A NAME ="DOC.19.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  adoptNumberFormat(<!1><A HREF="NumberFormat.html">NumberFormat</A>* formatToAdopt)</B></TT>
<DD>
Allows you to set the number formatter.  The caller should
not delete the NumberFormat object after it is adopted by this call.

<DL><DT><B>Parameters:</B><DD><B>formatToAdopt</B> -      NumberFormat object to be adopted.<br></DL><P>
<A NAME="setNumberFormat">
<A NAME ="DOC.19.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setNumberFormat(const <!1><A HREF="NumberFormat.html">NumberFormat</A>& newNumberFormat)</B></TT>
<DD>
Allows you to set the number formatter
<DL><DT><B>Parameters:</B><DD><B>formatToAdopt</B> -      NumberFormat object to be adopted.<br></DL><P>
<A NAME="getTimeZone">
<A NAME ="DOC.19.22">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  const  <!1><A HREF="TimeZone.html">TimeZone</A>&  getTimeZone(void) const </B></TT>
<DD>
Returns a reference to the TimeZone used by this DateFormat's calendar
<DL><DT><B>Returns:</B><DD>the time zone associated with the calendar of DateFormat.
</DL><P>
<A NAME="adoptTimeZone">
<A NAME ="DOC.19.23">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  adoptTimeZone(<!1><A HREF="TimeZone.html">TimeZone</A>* zoneToAdopt)</B></TT>
<DD>
Sets the time zone for the calendar of this DateFormat object. The caller
no longer owns the TimeZone object and should not delete it after this call.

<DL><DT><B>Parameters:</B><DD><B>zone</B> -  the new time zone.<br></DL><P>
<A NAME="setTimeZone">
<A NAME ="DOC.19.24">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setTimeZone(const <!1><A HREF="TimeZone.html">TimeZone</A>& zone)</B></TT>
<DD>
Sets the time zone for the calendar of this DateFormat object
<DL><DT><B>Parameters:</B><DD><B>zone</B> -  the new time zone.<br></DL><P>
<A NAME="DateFormat">
<A NAME ="DOC.19.25">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DateFormat()</B></TT>
<DD>
Default constructor.  Creates a DateFormat with no Calendar or NumberFormat
associated with it.  This constructor depends on the subclasses to fill in
the calendar and numberFormat fields.
<DL></DL><P>
<A NAME="DateFormat">
<A NAME ="DOC.19.32">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  DateFormat(const <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>&)</B></TT>
<DD>
Copy constructor
<DL></DL><P>
<A NAME="operator=">
<A NAME ="DOC.19.33">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>&  operator=(const <!2><A HREF="DateFormat.html#DOC.19.25">DateFormat</A>&)</B></TT>
<DD>
Default assignment operator
<DL></DL><P>
<A NAME="fCalendar">
<A NAME ="DOC.19.26">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="Calendar.html">Calendar</A>*  fCalendar</B></TT>
<DD>
The calendar that DateFormat uses to produce the time field values needed
to implement date/time formatting. Subclasses should generally initialize
this to the default calendar for the locale associated with this DateFormat.
<DL></DL><P>
<A NAME="fNumberFormat">
<A NAME ="DOC.19.27">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="NumberFormat.html">NumberFormat</A>*  fNumberFormat</B></TT>
<DD>
The number formatter that DateFormat uses to format numbers in dates and
times. Subclasses should generally initialize this to the default number
format for the locale associated with this DateFormat.
<DL></DL><P></DL>
<hr>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="SimpleDateFormat.html"> SimpleDateFormat </A><br>
</DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
