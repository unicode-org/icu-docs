<!-- Copyright 2005 -->
<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta name="GENERATOR" content="Microsoft FrontPage 5.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>Lockable</title>
</head>

<body>

<h1>Lockable</h1>
<p>2005-08-08 MED</p>
<h2>Background</h2>
<p>The following is written in terms of Java, but can be applied to C and C++.</p>
<p>There are often times when you need objects to be objects 'safe', so that they can't be modified. 
Examples are when objects need to be thread-safe, or in writing robust code, or in caches. If you 
are only creating your own objects, you can guarantee this, of course -- but only if you don't make 
a mistake. If you have objects handed into you, or are creating objects using others handed into 
you, it is a different story.</p>
<p>It all comes down to whether you want to take the Blanche Dubois approach (&quot;depend on the 
kindness of strangers&quot;) or the Andy Grove approach (&quot;Only the Paranoid Survive&quot;).</p>
<p>For example, suppose we have a simple class</p>
<pre>public class A {
    protected Collection b;
    protected Collection c;
    public Collection get_b() {
        return b;
    }
    public Collection get_c() {
        return c;
    }
    public A(Collection new_b, Collection new_c) {
        b = new_b;
        c = new_c;
    }
}</pre>
<p>Since the class doesn't have any setters, someone might think that it is safe. This class is 
unsafe in a number of ways. For example, </p>
<pre>public test1(SupposedlySafeClass x, SafeStorage y) {
    A a = x.getA();
    Collection col = a.get_b();
    col.add(something); // a has now been changed, and x too, unless precautions were taken

    a = new A(col, col);
    y.store(a);
    col.add(something); // a has now been changed, and y too, unless precautions were taken
}</pre>
<p>There are a few different techniques for having safe classes.</p>
<ol>
  <li>Const objects. In C++, you can declare parameters const.</li>
  <li>Immutable objects. Java uses this approach, with a few variations. Examples:<ol>
    <li>Simple. Once a Color is created (eg from R, G, and B integers) it is immutable.</li>
    <li>Builder Class. There is a separate 'builder' class. For example, modifiable Strings are 
    created using StringBuffer (which doesn't have the full String API available). Once you want an 
    immutable form, you create one with toString().</li>
    <li>Primitives. These are always safe, since they are copied on input/output from methods.</li>
  </ol>
  </li>
  <li>Immutable wrappers. For example, you can put a collection in an immutable wrapper.</li>
  <li>Cloning. Where you need an object to be safe, you clone it.</li>
</ol>
<p>There are advantages and disadvantages of each of these.</p>
<ol>
  <li>Const provides a certain level of protection, but since const can be and is often cast away, 
  it only protects against most inadvertent mistakes.</li>
  <li>Immutable Objects can require excessive object creation.</li>
  <li>Immutable wrappers are not safe if someone else keeps hold of the original object, or if any 
  of the objects returned by the class are mutable.</li>
  <li>Cloning is only safe if the object truly has a 'safe' clone; Unfortunately, many objects don't 
  have a 'safe' clone, defined as one that ensures that no change to the clone affects the original.</li>
</ol>
<h2>Lockable Model</h2>
<p>An additional model is the Lockable model. With this, you can build up an object by calling 
various methods, then when it is in a final state, lock it. Once locked, an object cannot be 
modified, and is completely thread-safe: that is, multiple threads can have references to it without 
any synchronization. Here is the interface:</p>
<pre>public interface Lockable extends Cloneable {
    public boolean isLocked();
    public Object lock();
    public Object clone();
}</pre>
<p>If someone needs a modifiable version of an object, they can use <code>clone()</code>, and modify 
the copy. This provides a simple, effective mechanism for safe classes in circumstances where the 
above are insufficient or clumsy.</p>
<p>Here is what needs to be done to implement this:</p>
<p><b>Immutable Objects. </b>You just want to use the interface to reflect that, add:</p>
<pre>public class A implements Lockable {
    public final boolean isLocked() {return true;}
    public final Object lock() {}
    public final Object clone() { return this; }
...
}</pre>
<p>These can be final because subclasses of immutable objects must themselves be immutable.</p>
<p><b>Mutable Objects. </b>Start with the following. Add a private field:</p>
<pre>    private boolean locked;</pre>
<p>Add</p>
<pre>    public final boolean isLocked() {return locked;};

    public Object lock() {locked = true; return this;}</pre>
<p>Add a <code>clone()</code> method following the normal pattern, except that <code>locked=false</code> 
in the new clone.</p>
<p>Then take the setters (that is, any method that can change the internal state of the object), and 
add as the first statement:</p>
<pre>    if (isLocked()) {
        throw new UnsupportedOperationException(&quot;Attempt to modify locked object&quot;);
    }</pre>
<p>If all of the getters and setters are safe, and there are no internal caches, we're done. The 
term 'safe' means that getters only return safe objects, and all of the setters only keep references 
to safe input parameters. For example, adding to UnicodeSet is just accomplished with the above. If 
not, there is some work to do, as described below.</p>
<h2>Harder Cases</h2>
<p><b>Internal caches. </b>Suppose that UnicodeSet had an internal marker to the last code point 
accessed. In this case, the field is not externally visible, so the only requirement is to 
synchronize the field for thread safety.</p>
<p><b>Getters.</b> This includes any method that returns, directly or indirectly, a reference to an 
internal field. Any method that returns an immutable object is fine. Examples</p>
<pre>    String getX();</pre>
<pre>    int getCount();</pre>
<p>Remember that the return from a getter might be in a mutable output parameter.</p>
<pre>    int getStuff(Collection output);</pre>
<p>Otherwise, if the return value is an internal field, and Lockable, lock it and return. </p>
<pre>    private UnicodeSet foo;</pre>
<pre>    UnicodeSet getFoo() {
        return (UnicodeSet) foo.lock();
    }</pre>
<p>An alternative is to lock items in the lock() function:</p>
<pre>    public Object lock() {locked = true; foo.lock(); return this;}
    UnicodeSet getFoo() {return foo.lock();}</pre>
<p><b>Collections.</b> If the collection only contains immutable objects, then wrap it.</p>
<pre>     return zone_to_country = Collections.unmodifiableMap(zone_to_country).</pre>
<p>If the collection contains mutable objects, then one needs to recurse through the collection to 
make the entire collection immutable. This can be more work, so it is better to do this the <code>
lock()</code> function, so that it is only done once. The recursing method has to do a bit of work 
(we should supply a utility for this); for example, it should pick the most specific collection 
available, since the caller may want to downcast.</p>
<p><b>Setters. </b>This includes any method that sets an internal field of the object by direct or 
indirect reference, including the constructor. If the input object is immutable, it is not a 
problem. </p>
<pre>    void setName(String newName);</pre>
<p>Otherwise, make the object safe, typically by cloning. Collections are a problem, since they 
don't support clone. If you don't care about the type of the original collection, use your own:</p>
<pre>void setTarget(Collection foo) {
    mytarget = new HashSet(foo);
}</pre>
<p>If you want to preserve the original collection properties, then you have to do some ugly <code>
instanceof</code> work. There is more work to be done if the input collection may contain mutable 
objects, such as other collections (again, would be useful to do a utility for this): you need to 
recurse through the collection to copy the other items. For this reason, it may also be reasonable 
to postpone making the field safe until the <code>lock()</code> function is called, to avoid excess 
work.</p>
<p><b>Subclassing. </b>Any subclass of a <code>Lockable</code> will assume that its superclass 
handles all of its getters and setters, and just pay attention to its own getters, setters and 
fields. It must override <code>lock()</code> and <code>cloned()</code> to call the superclass, and 
normally does not override <code>isLocked()</code>.</p>

</body>

</html>
