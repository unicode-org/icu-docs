<html><head><TITLE></TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>    </H2><BLOCKQUOTE>

Provides means to produce concatenated messages in language-neutral way
</BLOCKQUOTE>
<A NAME="DOC.DOCU">
<BLOCKQUOTE>

Provides means to produce concatenated messages in language-neutral way.
Use this for all concatenations that show up to end users.
<P>
Takes a set of objects, formats them, then inserts the formatted
strings into the pattern at the appropriate places.
<P>
Here are some examples of usage:
Example 1:
<pre>
.    UChar *result, *tzID, *str;
.    UChar pattern[100];
.    t_int32 resultLengthOut, resultlength;
.    UCalendar *cal;
.    UDate d1;
.    UDateFormat *def1;
.    UErrorCode status = U_ZERO_ERROR;
.    str=(UChar*)malloc(sizeof(UChar) * (strlen("disturbance in force") +1));
.    u_uastrcpy(str, "disturbance in force");
.    tzID=(UChar*)malloc(sizeof(UChar) * 4);
.    u_uastrcpy(tzID, "PST");
.    cal=ucal_open(tzID, u_strlen(tzID), "en_US", UCAL_TRADITIONAL, &status);
.    ucal_setDateTime(cal, 1999, UCAL_MARCH, 18, 0, 0, 0, &status);
.    d1=ucal_getMillis(cal, &status);
.    u_uastrcpy(pattern, "On {0, date, long}, there was a {1} on planet {2,number,integer}");
.    resultlength=0;
.    resultLengthOut=u_formatMessage( "en_US", pattern, u_strlen(pattern), NULL, resultlength, &status, d1, str, 7);
.    if(status==U_BUFFER_OVERFLOW_ERROR){
.        status=U_ZERO_ERROR;
.        resultlength=resultLengthOut+1;
.        result=(UChar*)realloc(result, sizeof(UChar) * resultlength);
.        u_formatMessage( "en_US", pattern, u_strlen(pattern), result, resultlength, &status, d1, str, 7);
.    }
.    printf("%s\n", austrdup(result) );//austrdup( a function used to convert UChar* to char*)
.    //output>: "On March 18, 1999, there was a disturbance in force on planet 7
</pre>  
Typically, the message format will come from resources, and the
arguments will be dynamically set at runtime.
<P>
Example 2:
<pre>
.    UChar* str;
.    UErrorCode status = U_ZERO_ERROR;
.    UChar *result;
.    UChar pattern[100];
.    t_int32 resultlength,resultLengthOut, i;
.    double testArgs= { 100.0, 1.0, 0.0};
.    str=(UChar*)malloc(sizeof(UChar) * 10);
.    u_uastrcpy(str, "MyDisk");
.    u_uastrcpy(pattern, "The disk {1} contains {0,choice,0#no files|1#one file|1<{0,number,integer} files}");
.    for(i=0; i<3; i++){
.      resultlength=0;
.    resultLengthOut=u_formatMessage( "en_US", pattern, u_strlen(pattern), NULL, resultlength, &status, testArgs[i], str);
.    if(status==U_BUFFER_OVERFLOW_ERROR){
.        status=U_ZERO_ERROR;
.        resultlength=resultLengthOut+1;
.        result=(UChar*)malloc(sizeof(UChar) * resultlength);
.        u_formatMessage( "en_US", pattern, u_strlen(pattern), result, resultlength, &status, testArgs[i], str);
.    }
.    printf("%s\n", austrdup(result) );  //austrdup( a function used to convert UChar* to char*)
.    free(result);
.    }
.    // output, with different testArgs:
.    // output: The disk "MyDisk" contains 100 files.
.    // output: The disk "MyDisk" contains one file.
.    // output: The disk "MyDisk" contains no files.
</pre>

The pattern is of the following form.  Legend:
<pre>
.      {optional item}
.      (group that may be repeated)*
</pre>
Do not confuse optional items with items inside quotes braces, such
as this: "{".  Quoted braces are literals.
<pre>
.      messageFormatPattern := string ( "{" messageFormatElement "}" string )*
.       
.      messageFormatElement := argument { "," elementFormat }
.       
.      elementFormat := "time" { "," datetimeStyle }
.                     | "date" { "," datetimeStyle }
.                     | "number" { "," numberStyle }
.                     | "choice" "," choiceStyle
.  
.      datetimeStyle := "short"
.                     | "medium"
.                     | "long"
.                     | "full"
.                     | dateFormatPattern
.
.      numberStyle :=   "currency"
.                     | "percent"
.                     | "integer"
.                     | numberFormatPattern
. 
.      choiceStyle :=   choiceFormatPattern
</pre>
If there is no elementFormat, then the argument must be a string,
which is substituted. If there is no dateTimeStyle or numberStyle,
then the default format is used (e.g.  NumberFormat.getInstance(),
DateFormat.getDefaultTime() or DateFormat.getDefaultDate(). For
a ChoiceFormat, the pattern must always be specified, since there
is no default.
<P>
In strings, single quotes can be used to quote the "{" sign if
necessary. A real single quote is represented by ''.  Inside a
messageFormatElement, quotes are [not] removed. For example,
{1,number,$'#',##} will produce a number format with the pound-sign
quoted, with a result such as: "$#31,45".
<P>
If a pattern is used, then unquoted braces in the pattern, if any,
must match: that is, "ab {0} de" and "ab '}' de" are ok, but "ab
{0'}' de" and "ab } de" are not.
<P>
The argument is a number from 0 to 9, which corresponds to the
arguments presented in an array to be formatted.
<P>
It is ok to have unused arguments in the array.  With missing
arguments or arguments that are not of the right class for the
specified format, a failing UErrorCode result is set.
<P>

<P>
[Note:] As we see above, the string produced by a choice Format in
MessageFormat is treated specially; occurances of '{' are used to
indicated subformats.  
<P>
[Note:] Formats are numbered by order of variable in the string.
This is [not] the same as the argument numbering!
<pre>
.   For example: with "abc{2}def{3}ghi{0}...",
.   
.   format0 affects the first variable {2}
.   format1 affects the second variable {3}
.   format2 affects the second variable {0}
</pre>
and so on.
</BLOCKQUOTE>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
