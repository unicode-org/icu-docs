<html><head><TITLE>MessageFormat</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  U_I18N_API MessageFormat : public <!2><A HREF="Format.html#DOC.14.8">Format</A> </H2><BLOCKQUOTE>

Provides means to produce concatenated messages in language-neutral way
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CFormat,MFormat.html,CMessageFormat,MMessageFormat.html">
<param name=before value="M,M">
<param name=after value="Md_,M">
<param name=indent value="0,1">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Fields</h3><DD><DT><A HREF="#DOC.17.59"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>  <B>ENGLISH</B> </B>
 <DD><I>
Useful constants for language</I>
<DT><A HREF="#DOC.17.60"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>  <B>FRANCE</B> </B>
 <DD><I>
Useful constants for country</I>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.17.1"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Locale</B>() </B>
 <DD><I>
Construct an empty locale</I>
<DT><A HREF="#DOC.17.2"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Locale</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& language, const <!1><A HREF="UnicodeString.html">UnicodeString</A>& country, const <!1><A HREF="UnicodeString.html">UnicodeString</A>& variant ) </B>
 <DD><I>
Construct a locale from language, country, variant</I>
<DT><A HREF="#DOC.17.3"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>Locale</B>(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& other) </B>
 <DD><I>
Initializes a Locale object from another Locale object</I>
<DT><A HREF="#DOC.17.61"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>~Locale</B>() </B>
 <DD><I>
Destructor</I>
<DT><A HREF="#DOC.17.4"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>&  <B>operator=</B>(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& other) </B>
 <DD><I>
Replaces the entire contents of *this with the specified value</I>
<DT><A HREF="#DOC.17.5"> <IMG BORDER=0 SRC=icon1.gif></A> bool_t  <B>operator==</B>(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& other) const  </B>
 <DD><I>
Checks if two locale keys are the same</I>
<DT><A HREF="#DOC.17.6"> <IMG BORDER=0 SRC=icon1.gif></A> bool_t  <B>operator!=</B>(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& other) const  </B>
 <DD><I>
Checks if two locale keys are not the same</I>
<DT><A HREF="#DOC.17.7"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>&  <B>getDefault</B>(void) </B>
 <DD><I>
Common methods of getting the current default Locale</I>
<DT><A HREF="#DOC.17.8"> <IMG BORDER=0 SRC=icon1.gif></A> static  void  <B>setDefault</B>(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& newLocale, <!2><A HREF="#DOC.301">UErrorCode</A>& success) </B>
 <DD><I>
Sets the default</I>
<DT><A HREF="#DOC.17.9"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getLanguage</B>( <!1><A HREF="UnicodeString.html">UnicodeString</A>& lang) const  </B>
 <DD><I>
Fills in "lang" with the locale's two-letter ISO-639 language code</I>
<DT><A HREF="#DOC.17.10"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getCountry</B>( <!1><A HREF="UnicodeString.html">UnicodeString</A>& cntry) const  </B>
 <DD><I>
Fills in "cntry" with the locale's two-letter ISO-3166 country code</I>
<DT><A HREF="#DOC.17.11"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getVariant</B>( <!1><A HREF="UnicodeString.html">UnicodeString</A>& var) const  </B>
 <DD><I>
Fills in "var" with the locale's variant code</I>
<DT><A HREF="#DOC.17.12"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getName</B>( <!1><A HREF="UnicodeString.html">UnicodeString</A>& name) const  </B>
 <DD><I>
Fills in "name" the programmatic name of the entire locale, with the language,
country and variant separated by underbars</I>
<DT><A HREF="#DOC.17.13"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getISO3Language</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& name, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const  </B>
 <DD><I>
Fills in "name" with the locale's three-letter language code, as specified
in ISO draft standard ISO-639-2</I>
<DT><A HREF="#DOC.17.14"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getISO3Country</B>( <!1><A HREF="UnicodeString.html">UnicodeString</A>& name, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const  </B>
 <DD><I>
Fills in "name" with the locale's three-letter ISO-3166 country code</I>
<DT><A HREF="#DOC.17.15"> <IMG BORDER=0 SRC=icon1.gif></A> uint32_t  <B>getLCID</B>(void) const  </B>
 <DD><I>
Returns the Windows LCID value corresponding to this locale</I>
<DT><A HREF="#DOC.17.16"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayLanguage</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& dispLang) const  </B>
 <DD><I>
Fills in "dispLang" with the name of this locale's language in a format suitable for
user display in the default locale</I>
<DT><A HREF="#DOC.17.17"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayLanguage</B>( const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& inLocale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& dispLang) const  </B>
 <DD><I>
Fills in "dispLang" with the name of this locale's language in a format suitable for
user display in the locale specified by "inLocale"</I>
<DT><A HREF="#DOC.17.18"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayCountry</B>( <!1><A HREF="UnicodeString.html">UnicodeString</A>& dispCountry) const  </B>
 <DD><I>
Fills in "dispCountry" with the name of this locale's country in a format suitable
for user display in the default locale</I>
<DT><A HREF="#DOC.17.19"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayCountry</B>( const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& inLocale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& dispCountry) const  </B>
 <DD><I>
Fills in "dispCountry" with the name of this locale's country in a format suitable
for user display in the locale specified by "inLocale"</I>
<DT><A HREF="#DOC.17.20"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayVariant</B>( <!1><A HREF="UnicodeString.html">UnicodeString</A>& dispVar) const  </B>
 <DD><I>
Fills in "dispVar" with the name of this locale's variant code in a format suitable
for user display in the default locale</I>
<DT><A HREF="#DOC.17.21"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayVariant</B>( const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& inLocale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& dispVar) const  </B>
 <DD><I>
Fills in "dispVar" with the name of this locale's variant code in a format
suitable for user display in the locale specified by "inLocale"</I>
<DT><A HREF="#DOC.17.22"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayName</B>( <!1><A HREF="UnicodeString.html">UnicodeString</A>& name) const  </B>
 <DD><I>
Fills in "name" with the name of this locale in a format suitable for user display 
in the default locale</I>
<DT><A HREF="#DOC.17.23"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayName</B>( const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& inLocale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& name) const  </B>
 <DD><I>
Fills in "name" with the name of this locale in a format suitable for user display 
in the locale specfied by "inLocale"</I>
<DT><A HREF="#DOC.17.24"> <IMG BORDER=0 SRC=icon1.gif></A> int32_t  <B>hashCode</B>(void) const  </B>
 <DD><I>
Generates a hash code for the locale</I>
<DT><A HREF="#DOC.17.25"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>*  <B>getAvailableLocales</B>(int32_t& count) </B>
 <DD><I>
Returns a list of all installed locales</I>
<DT><A HREF="#DOC.17.26"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>*  <B>getISOCountries</B>(int32_t& count) </B>
 <DD><I>
Returns a list of all 2-letter country codes defined in ISO 3166</I>
<DT><A HREF="#DOC.17.27"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>*  <B>getISOLanguages</B>(int32_t& count) </B>
 <DD><I>
Returns a list of all 2-letter language codes defined in ISO 639</I>
<DT><A HREF="#DOC.17.28"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  char*  <B>getDataDirectory</B>(void) </B>
 <DD><I>
Get the path to the ResourceBundle locale files</I>
<DT><A HREF="#DOC.17.29"> <IMG BORDER=0 SRC=icon1.gif></A> static  void  <B>setDataDirectory</B>(const char* path) </B>
 <DD><I>
Set the path to the ResourceBundle locale files</I>
<DT><A HREF="#DOC.17.31"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>MessageFormat</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.301">UErrorCode</A> &status) </B>
 <DD><I>
Construct a new MessageFormat using the given pattern</I>
<DT><A HREF="#DOC.17.32"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>MessageFormat</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& newLocale, <!2><A HREF="#DOC.301">UErrorCode</A>& success) </B>
 <DD><I>
Constructor that allows locale specification</I>
<DT><A HREF="#DOC.17.63"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>MessageFormat</B>(const <!2><A HREF="MessageFormat.html#DOC.17.32">MessageFormat</A>&) </B>
 <DD><I>
Copy constructor</I>
<DT><A HREF="#DOC.17.64"> <IMG BORDER=0 SRC=icon1.gif></A> const  <!2><A HREF="MessageFormat.html#DOC.17.32">MessageFormat</A>&  <B>operator=</B>(const <!2><A HREF="MessageFormat.html#DOC.17.32">MessageFormat</A>&) </B>
 <DD><I>
Assignment operator</I>
<DT><A HREF="#DOC.17.65"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <B>~MessageFormat</B>() </B>
 <DD><I>
Destructor</I>
<DT><A HREF="#DOC.17.33"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!2><A HREF="Format.html#DOC.14.8">Format</A>*  <B>clone</B>(void) const  </B>
 <DD><I>
Clone this Format object polymorphically</I>
<DT><A HREF="#DOC.17.34"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>operator==</B>(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const  </B>
 <DD><I>
Return true if the given Format objects are semantically equal</I>
<DT><A HREF="#DOC.17.35"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setLocale</B>(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& theLocale) </B>
 <DD><I>
Sets the locale</I>
<DT><A HREF="#DOC.17.36"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  const  <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>&  <B>getLocale</B>(void) const  </B>
 <DD><I>
Gets the locale</I>
<DT><A HREF="#DOC.17.37"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>applyPattern</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.301">UErrorCode</A>& status) </B>
 <DD><I>
Apply the given pattern string to this message format</I>
<DT><A HREF="#DOC.17.38"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>toPattern</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Gets the pattern</I>
<DT><A HREF="#DOC.17.39"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>adoptFormats</B>(<!2><A HREF="Format.html#DOC.14.8">Format</A>** formatsToAdopt, int32_t count) </B>
 <DD><I>
Sets formats to use on parameters</I>
<DT><A HREF="#DOC.17.40"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setFormats</B>(const <!2><A HREF="Format.html#DOC.14.8">Format</A>** newFormats, int32_t cnt) </B>
 <DD><I>
Sets formats to use on parameters</I>
<DT><A HREF="#DOC.17.41"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>adoptFormat</B>(int32_t formatNumber, <!2><A HREF="Format.html#DOC.14.8">Format</A>* formatToAdopt) </B>
 <DD><I>
Sets formats individually to use on parameters</I>
<DT><A HREF="#DOC.17.42"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setFormat</B>(int32_t variable, const <!2><A HREF="Format.html#DOC.14.8">Format</A>& newFormat) </B>
 <DD><I>
Sets formats individually to use on parameters</I>
<DT><A HREF="#DOC.17.43"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  const  <!2><A HREF="Format.html#DOC.14.8">Format</A>**  <B>getFormats</B>(int32_t& count) const  </B>
 <DD><I>
Gets formats that were set with setFormats</I>
<DT><A HREF="#DOC.17.44"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>( const <!1><A HREF="Formattable.html">Formattable</A>* source, int32_t count, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!1><A HREF="FieldPosition.html">FieldPosition</A>& ignore, <!2><A HREF="#DOC.301">UErrorCode</A>& success) const  </B>
 <DD><I>
Returns pattern with formatted objects</I>
<DT><A HREF="#DOC.17.45"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, const <!1><A HREF="Formattable.html">Formattable</A>* arguments, int32_t count, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A>& success) </B>
 <DD><I>
Convenience routine</I>
<DT><A HREF="#DOC.17.46"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>format</B>(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const  </B>
 <DD><I>
Format an object to produce a message</I>
<DT><A HREF="#DOC.17.47"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="Formattable.html">Formattable</A>*  <B>parse</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="ParsePosition.html">ParsePosition</A>& status, int32_t& count) const  </B>
 <DD><I>
Parses the string</I>
<DT><A HREF="#DOC.17.48"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="Formattable.html">Formattable</A>*  <B>parse</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, int32_t& count, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const  </B>
 <DD><I>
Parses the string</I>
<DT><A HREF="#DOC.17.49"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>parseObject</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parse_pos) const  </B>
 <DD><I>
Parse a string to produce an object</I>
<DT><A HREF="#DOC.17.50"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="ClassID.html">ClassID</A>  <B>getDynamicClassID</B>(void) const  </B>
 <DD><I>
Returns a unique class ID POLYMORPHICALLY</I>
<DT><A HREF="#DOC.17.51"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!1><A HREF="ClassID.html">ClassID</A>  <B>getStaticClassID</B>(void) </B>
 <DD><I>
Return the class ID for this class</I>
</DL><DL>
<DT><h3>Protected Methods</h3><DD><DT><A HREF="#DOC.17.30"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>*  <B>getLanguagesForCountry</B>( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& country, int32_t& count) </B>
 <DD><I>
Given an ISO country code, returns an array of Strings containing the ISO
codes of the languages spoken in that country</I>
</DL></DL>
<hr><H3>Inherited from <A HREF="Format.html">Format:</A></h3>

<DL>
</DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

Provides means to produce concatenated messages in language-neutral way.
Use this for all concatenations that show up to end users.
<P>
Takes a set of objects, formats them, then inserts the formatted
strings into the pattern at the appropriate places.
<P>
Here are some examples of usage:
Example 1:
<pre>
.    UErrorCode success = ZERO_ERROR;
.    GregorianCalendar cal(success);
.    Formattable arguments[] = {
.        7L,
.        Formattable( (Date) cal.getTime(success), Formattable::kIsDate),
.        "a disturbance in the Force"
.    };
.    
.    UnicodeString result;
.    MessageFormat::format(
.         "At {1,time} on {1,date}, there was {2} on planet {0,number}.",
.         arguments, 3, result, success );
.    
.    cout &lt;&lt; "result: " &lt;&lt; result &lt;&lt; endl;
.    //&lt;output>: At 4:34:20 PM on 23-Mar-98, there was a disturbance
.    //             in the Force on planet 7.
</pre>  
Typically, the message format will come from resources, and the
arguments will be dynamically set at runtime.
<P>
Example 2:
<pre>
.    success = ZERO_ERROR;
.    Formattable testArgs[] = {3L, "MyDisk"};
.   
.    MessageFormat* form = new MessageFormat(
.        "The disk \"{1}\" contains {0} file(s).", success );
.        
.    UnicodeString string;
.    FieldPosition fpos = 0;
.    cout &lt;&lt; "format: " &lt;&lt; form->format(testArgs, 2, string, fpos, success ) &lt;&lt; endl;
.
.    // output, with different testArgs:
.    // output: The disk "MyDisk" contains 0 file(s).
.    // output: The disk "MyDisk" contains 1 file(s).
.    // output: The disk "MyDisk" contains 1,273 file(s).
.    de lete form;
</pre>

The pattern is of the following form.  Legend:
<pre>
.      {optional item}
.      (group that may be repeated)*
</pre>
Do not confuse optional items with items inside quotes braces, such
as this: "{".  Quoted braces are literals.
<pre>
.      messageFormatPattern := string ( "{" messageFormatElement "}" string )*
.       
.      messageFormatElement := argument { "," elementFormat }
.       
.      elementFormat := "time" { "," datetimeStyle }
.                     | "date" { "," datetimeStyle }
.                     | "number" { "," numberStyle }
.                     | "choice" "," choiceStyle
.  
.      datetimeStyle := "short"
.                     | "medium"
.                     | "long"
.                     | "full"
.                     | dateFormatPattern
.
.      numberStyle :=   "currency"
.                     | "percent"
.                     | "integer"
.                     | numberFormatPattern
. 
.      choiceStyle :=   choiceFormatPattern
</pre>
If there is no elementFormat, then the argument must be a string,
which is substituted. If there is no dateTimeStyle or numberStyle,
then the default format is used (e.g.  NumberFormat.getInstance(),
DateFormat.getDefaultTime() or DateFormat.getDefaultDate(). For
a ChoiceFormat, the pattern must always be specified, since there
is no default.
<P>
In strings, single quotes can be used to quote the "{" sign if
necessary. A real single quote is represented by ''.  Inside a
messageFormatElement, quotes are [not] removed. For example,
{1,number,$'#',##} will produce a number format with the pound-sign
quoted, with a result such as: "$#31,45".
<P>
If a pattern is used, then unquoted braces in the pattern, if any,
must match: that is, "ab {0} de" and "ab '}' de" are ok, but "ab
{0'}' de" and "ab } de" are not.
<P>
The argument is a number from 0 to 9, which corresponds to the
arguments presented in an array to be formatted.
<P>
It is ok to have unused arguments in the array.  With missing
arguments or arguments that are not of the right class for the
specified format, a failing UErrorCode result is set.
<P>
For more sophisticated patterns, you can use a ChoiceFormat to get
output such as:
<pre>
.    UErrorCode success = ZERO_ERROR;
.    MessageFormat* form = new MessageFormat("The disk \"{1}\" contains {0}.", success);
.    double filelimits[] = {0,1,2};
.    UnicodeString filepart[] = {"no files","one file","{0,number} files"};
.    ChoiceFormat* fileform = new ChoiceFormat(filelimits, filepart, 3);
.    form->setFormat(1, *fileform); // NOT zero, see below
.    
.    Formattable testArgs[] = {1273L, "MyDisk"};
.     
.    UnicodeString string;
.    FieldPosition fpos = 0;
.    cout &lt;&lt; form->format(testArgs, 2, string, fpos, success) &lt;&lt; endl;
.    
.    // output, with different testArgs
.    // output: The disk "MyDisk" contains no files.
.    // output: The disk "MyDisk" contains one file.
.    // output: The disk "MyDisk" contains 1,273 files.
</pre>
You can either do this programmatically, as in the above example,
or by using a pattern (see ChoiceFormat for more information) as in:
<pre>
.   form->applyPattern(
.     "There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.");
</pre>
<P>
[Note:] As we see above, the string produced by a ChoiceFormat in
MessageFormat is treated specially; occurances of '{' are used to
indicated subformats, and cause recursion.  If you create both a
MessageFormat and ChoiceFormat programmatically (instead of using
the string patterns), then be careful not to produce a format that
recurses on itself, which will cause an infinite loop.
<P>
[Note:] Formats are numbered by order of variable in the string.
This is [not] the same as the argument numbering!
<pre>
.   For example: with "abc{2}def{3}ghi{0}...",
.   
.   format0 affects the first variable {2}
.   format1 affects the second variable {3}
.   format2 affects the second variable {0}
</pre>
and so on.

</BLOCKQUOTE>
<DL>

<A NAME="ENGLISH">
<A NAME ="DOC.17.59">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>  ENGLISH</B></TT>
<DD>
Useful constants for language
<DL></DL><P>
<A NAME="FRANCE">
<A NAME ="DOC.17.60">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>  FRANCE</B></TT>
<DD>
Useful constants for country
<DL></DL><P>
<A NAME="Locale">
<A NAME ="DOC.17.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Locale()</B></TT>
<DD>
Construct an empty locale. It's only used when a fill-in parameter is
needed.
<DL></DL><P>
<A NAME="Locale">
<A NAME ="DOC.17.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Locale( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& language, const <!1><A HREF="UnicodeString.html">UnicodeString</A>& country, const <!1><A HREF="UnicodeString.html">UnicodeString</A>& variant )</B></TT>
<DD>
Construct a locale from language, country, variant.


<DL><DT><B>Parameters:</B><DD><B>language</B> -  Lowercase two-letter ISO-639 code.
<br><B>country</B> -   Uppercase two-letter ISO-3166 code. (optional)
<br><B>variant</B> -   Uppercase vendor and browser specific code. See class
description. (optional)<br></DL><P>
<A NAME="Locale">
<A NAME ="DOC.17.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  Locale(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& other)</B></TT>
<DD>
Initializes a Locale object from another Locale object.


<DL><DT><B>Parameters:</B><DD><B>other</B> -  The Locale object being copied in.<br></DL><P>
<A NAME="~Locale">
<A NAME ="DOC.17.61">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  ~Locale()</B></TT>
<DD>
Destructor
<DL></DL><P>
<A NAME="operator=">
<A NAME ="DOC.17.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>&  operator=(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& other)</B></TT>
<DD>
Replaces the entire contents of *this with the specified value.


<DL><DT><B>Returns:</B><DD>*this
<DT><B>Parameters:</B><DD><B>other</B> -  The Locale object being copied in.
<br></DL><P>
<A NAME="operator==">
<A NAME ="DOC.17.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool_t  operator==(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& other) const </B></TT>
<DD>
Checks if two locale keys are the same.


<DL><DT><B>Returns:</B><DD>True if the two locale keys are the same, false otherwise.
<DT><B>Parameters:</B><DD><B>other</B> -  The locale key object to be compared with this.
<br></DL><P>
<A NAME="operator!=">
<A NAME ="DOC.17.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool_t  operator!=(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& other) const </B></TT>
<DD>
Checks if two locale keys are not the same.


<DL><DT><B>Returns:</B><DD>True if the two locale keys are not the same, false
otherwise.
<DT><B>Parameters:</B><DD><B>other</B> -  The locale key object to be compared with this.
<br></DL><P>
<A NAME="getDefault">
<A NAME ="DOC.17.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>&  getDefault(void)</B></TT>
<DD>
Common methods of getting the current default Locale. Used for the
presentation: menus, dialogs, etc. Generally set once when your applet or
application is initialized, then never reset. (If you do reset the
default locale, you probably want to reload your GUI, so that the change
is reflected in your interface.)

More advanced programs will allow users to use different locales for
different fields, e.g. in a spreadsheet.

Note that the initial setting will match the host system.
<DL></DL><P>
<A NAME="setDefault">
<A NAME ="DOC.17.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  void  setDefault(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& newLocale, <!2><A HREF="#DOC.301">UErrorCode</A>& success)</B></TT>
<DD>
Sets the default. Normally set once at the beginning of applet or
application, then never reset. setDefault does NOT reset the host locale.


<DL><DT><B>Parameters:</B><DD><B>newLocale</B> -  Locale to set to.<br></DL><P>
<A NAME="getLanguage">
<A NAME ="DOC.17.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getLanguage( <!1><A HREF="UnicodeString.html">UnicodeString</A>& lang) const </B></TT>
<DD>
Fills in "lang" with the locale's two-letter ISO-639 language code
<DL><DT><B>Returns:</B><DD>A reference to "lang".
<DT><B>Parameters:</B><DD><B>lang</B> -   Receives the language code.
<br></DL><P>
<A NAME="getCountry">
<A NAME ="DOC.17.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getCountry( <!1><A HREF="UnicodeString.html">UnicodeString</A>& cntry) const </B></TT>
<DD>
Fills in "cntry" with the locale's two-letter ISO-3166 country code
<DL><DT><B>Returns:</B><DD>A reference to "cntry".
<DT><B>Parameters:</B><DD><B>cntry</B> -  Receives the country code.
<br></DL><P>
<A NAME="getVariant">
<A NAME ="DOC.17.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getVariant( <!1><A HREF="UnicodeString.html">UnicodeString</A>& var) const </B></TT>
<DD>
Fills in "var" with the locale's variant code
<DL><DT><B>Returns:</B><DD>A reference to "var".
<DT><B>Parameters:</B><DD><B>var</B> -    Receives the variant code.
<br></DL><P>
<A NAME="getName">
<A NAME ="DOC.17.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getName( <!1><A HREF="UnicodeString.html">UnicodeString</A>& name) const </B></TT>
<DD>
Fills in "name" the programmatic name of the entire locale, with the language,
country and variant separated by underbars. If a field is missing, at
most one underbar will occur. Example: "en", "de_DE", "en_US_WIN",
"de_POSIX", "fr_MAC"

<DL><DT><B>Returns:</B><DD>A reference to "name".
<DT><B>Parameters:</B><DD><B>var</B> -    Receives the programmatic locale name.
<br></DL><P>
<A NAME="getISO3Language">
<A NAME ="DOC.17.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getISO3Language(<!1><A HREF="UnicodeString.html">UnicodeString</A>& name, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const </B></TT>
<DD>
Fills in "name" with the locale's three-letter language code, as specified
in ISO draft standard ISO-639-2..

<DL><DT><B>Returns:</B><DD>A reference to "name".
<DT><B>Parameters:</B><DD><B>name</B> -   Receives the three-letter language code.
<br><B>status</B> -  An UErrorCode to receive any MISSING_RESOURCE_ERRORs
<br></DL><P>
<A NAME="getISO3Country">
<A NAME ="DOC.17.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getISO3Country( <!1><A HREF="UnicodeString.html">UnicodeString</A>& name, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const </B></TT>
<DD>
Fills in "name" with the locale's three-letter ISO-3166 country code
<DL><DT><B>Returns:</B><DD>A reference to "name".
<DT><B>Parameters:</B><DD><B>name</B> -   Receives the three-letter country code.
<br><B>status</B> -  An UErrorCode to receive any MISSING_RESOURCE_ERRORs
<br></DL><P>
<A NAME="getLCID">
<A NAME ="DOC.17.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> uint32_t  getLCID(void) const </B></TT>
<DD>
Returns the Windows LCID value corresponding to this locale.
This value is stored in the resource data for the locale as a one-to-four-digit
hexadecimal number.  If the resource is missing, in the wrong format, or
there is no Windows LCID value that corresponds to this locale, returns 0.
<DL></DL><P>
<A NAME="getDisplayLanguage">
<A NAME ="DOC.17.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayLanguage(<!1><A HREF="UnicodeString.html">UnicodeString</A>& dispLang) const </B></TT>
<DD>
Fills in "dispLang" with the name of this locale's language in a format suitable for
user display in the default locale.  For example, if the locale's language code is
"fr" and the default locale's language code is "en", this function would set
dispLang to "French".

<DL><DT><B>Returns:</B><DD>A reference to "dispLang".
<DT><B>Parameters:</B><DD><B>dispLang</B> -   Receives the language's display name.
<br></DL><P>
<A NAME="getDisplayLanguage">
<A NAME ="DOC.17.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayLanguage( const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& inLocale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& dispLang) const </B></TT>
<DD>
Fills in "dispLang" with the name of this locale's language in a format suitable for
user display in the locale specified by "inLocale".  For example, if the locale's
language code is "en" and inLocale's language code is "fr", this function would set
dispLang to "Anglais".

<DL><DT><B>Returns:</B><DD>A reference to "dispLang".
<DT><B>Parameters:</B><DD><B>inLocale</B> -   Specifies the locale to be used to display the name.  In other words,
if the locale's language code is "en", passing Locale::FRENCH for
inLocale would result in "Anglais", while passing Locale::GERMAN
for inLocale would result in "Englisch".
<br><B>dispLang</B> -   Receives the language's display name.
<br></DL><P>
<A NAME="getDisplayCountry">
<A NAME ="DOC.17.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayCountry( <!1><A HREF="UnicodeString.html">UnicodeString</A>& dispCountry) const </B></TT>
<DD>
Fills in "dispCountry" with the name of this locale's country in a format suitable
for user display in the default locale.  For example, if the locale's country code
is "FR" and the default locale's language code is "en", this function would set
dispCountry to "France".

<DL><DT><B>Returns:</B><DD>A reference to "dispCountry".
<DT><B>Parameters:</B><DD><B>dispCountry</B> -    Receives the country's display name.
<br></DL><P>
<A NAME="getDisplayCountry">
<A NAME ="DOC.17.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayCountry( const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& inLocale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& dispCountry) const </B></TT>
<DD>
Fills in "dispCountry" with the name of this locale's country in a format suitable
for user display in the locale specified by "inLocale".  For example, if the locale's
country code is "US" and inLocale's language code is "fr", this function would set
dispCountry to "Etats-Unis".

<DL><DT><B>Returns:</B><DD>A reference to "dispCountry".
<DT><B>Parameters:</B><DD><B>inLocale</B> -       Specifies the locale to be used to display the name.  In other
words, if the locale's country code is "US", passing
Locale::FRENCH for inLocale would result in "États-Unis", while
passing Locale::GERMAN for inLocale would result in
"Vereinigte Staaten".
<br><B>dispCountry</B> -    Receives the country's display name.
<br></DL><P>
<A NAME="getDisplayVariant">
<A NAME ="DOC.17.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayVariant( <!1><A HREF="UnicodeString.html">UnicodeString</A>& dispVar) const </B></TT>
<DD>
Fills in "dispVar" with the name of this locale's variant code in a format suitable
for user display in the default locale
<DL><DT><B>Returns:</B><DD>A reference to "dispVar".
<DT><B>Parameters:</B><DD><B>dispVar</B> -    Receives the variant's name.
<br></DL><P>
<A NAME="getDisplayVariant">
<A NAME ="DOC.17.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayVariant( const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& inLocale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& dispVar) const </B></TT>
<DD>
Fills in "dispVar" with the name of this locale's variant code in a format
suitable for user display in the locale specified by "inLocale"
<DL><DT><B>Returns:</B><DD>A reference to "dispVar".
<DT><B>Parameters:</B><DD><B>inLocale</B> -   Specifies the locale to be used to display the name.
<br><B>dispVar</B> -    Receives the variant's display name.
<br></DL><P>
<A NAME="getDisplayName">
<A NAME ="DOC.17.22">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayName( <!1><A HREF="UnicodeString.html">UnicodeString</A>& name) const </B></TT>
<DD>
Fills in "name" with the name of this locale in a format suitable for user display 
in the default locale.  This function uses getDisplayLanguage(), getDisplayCountry(),
and getDisplayVariant() to do its work, and outputs the display name in the format
"language (country[,variant])".  For example, if the default locale is en_US, then
fr_FR's display name would be "French (France)", and es_MX_Traditional's display name
would be "Spanish (Mexico,Traditional)".

<DL><DT><B>Returns:</B><DD>A reference to "name".
<DT><B>Parameters:</B><DD><B>name</B> -   Receives the locale's display name.
<br></DL><P>
<A NAME="getDisplayName">
<A NAME ="DOC.17.23">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayName( const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& inLocale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& name) const </B></TT>
<DD>
Fills in "name" with the name of this locale in a format suitable for user display 
in the locale specfied by "inLocale".  This function uses getDisplayLanguage(),
getDisplayCountry(), and getDisplayVariant() to do its work, and outputs the display
name in the format "language (country[,variant])".  For example, if inLocale is
fr_FR, then en_US's display name would be "Anglais (États-Unis)", and no_NO_NY's
display name would be "norvégien (Norvège,NY)".

<DL><DT><B>Returns:</B><DD>A reference to "name".
<DT><B>Parameters:</B><DD><B>inLocale</B> -   Specifies the locale to be used to display the name.
<br><B>name</B> -       Receives the locale's display name.
<br></DL><P>
<A NAME="hashCode">
<A NAME ="DOC.17.24">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> int32_t  hashCode(void) const </B></TT>
<DD>
Generates a hash code for the locale. Since Locales are often used in hashtables, 
caches the value for speed.
<DL></DL><P>
<A NAME="getAvailableLocales">
<A NAME ="DOC.17.25">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>*  getAvailableLocales(int32_t& count)</B></TT>
<DD>
Returns a list of all installed locales
<DL><DT><B>Returns:</B><DD>A pointer to an array of Locale objects.  This array is the list
of all locales with installed resource files.  The called does NOT
get ownership of this list, and must NOT delete it.
<DT><B>Parameters:</B><DD><B>count</B> -  Receives the number of locales in the list.
<br></DL><P>
<A NAME="getISOCountries">
<A NAME ="DOC.17.26">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>*  getISOCountries(int32_t& count)</B></TT>
<DD>
Returns a list of all 2-letter country codes defined in ISO 3166.
Can be used to create Locales.

<DL><DT><B>Returns:</B><DD>A pointer to an array of UnicodeString objects. The caller does NOT
get ownership of this list, and must NOT delete it.
<DT><B>Parameters:</B><DD><B>count</B> -  Receives the number of countries in the list.
<br></DL><P>
<A NAME="getISOLanguages">
<A NAME ="DOC.17.27">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>*  getISOLanguages(int32_t& count)</B></TT>
<DD>
Returns a list of all 2-letter language codes defined in ISO 639.
Can be used to create Locales.
[NOTE:  ISO 639 is not a stable standard-- some languages' codes have changed.
The list this function returns includes both the new and the old codes for the
languages whose codes have changed.]

<DL><DT><B>Returns:</B><DD>A pointer to an array of UnicodeString objects. The caller does NOT
get ownership of this list, and must NOT delete it.
<DT><B>Parameters:</B><DD><B>count</B> -  Receives the number of languages in the list.
<br></DL><P>
<A NAME="getDataDirectory">
<A NAME ="DOC.17.28">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  char*  getDataDirectory(void)</B></TT>
<DD>
Get the path to the ResourceBundle locale files. This path will be a
platform-specific path name ending in a directory separator, so that file
names may be concatenated to it. This path may be changed by calling
setDataDirectory(). If setDataDirectory() has not been called yet,
getDataDirectory() will return a platform-dependent default path as
specified by TPlatformUtilities::getDefaultDataDirectory().


<DL><DT><B>Returns:</B><DD>Current data path.
</DL><P>
<A NAME="setDataDirectory">
<A NAME ="DOC.17.29">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  void  setDataDirectory(const char* path)</B></TT>
<DD>
Set the path to the ResourceBundle locale files. After making this call,
all objects in the Unicode Analytics package will read ResourceBundle
data files in the specified directory in order to obtain locale data.


<DL><DT><B>Parameters:</B><DD><B>path</B> -  The new data path to be set to.<br></DL><P>
<A NAME="getLanguagesForCountry">
<A NAME ="DOC.17.30">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>*  getLanguagesForCountry( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& country, int32_t& count)</B></TT>
<DD>
Given an ISO country code, returns an array of Strings containing the ISO
codes of the languages spoken in that country.  Official languages are listed
in the returned table before unofficial languages, but other than that, the
order of the returned list is indeterminate.  If the value the user passes in
for "country" is not a valid ISO 316 country code, or if we don't have language
information for the specified country, this function returns an empty array.

[This function is not currently part of Locale's API, but is needed in the
implementation.  We hope to add it to the API in a future release.]

<DL><DT><B>Returns:</B><DD>A pointer to an array of UnicodeString objects. The caller does NOT
get ownership of this list, and must NOT delete it.
<DT><B>Parameters:</B><DD><B>country</B> -  The ISO 2-letter country code of the desired country
<br><B>count</B> -  Receives the number of languages in the list.
<br></DL><P>
<A NAME="MessageFormat">
<A NAME ="DOC.17.31">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  MessageFormat(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.301">UErrorCode</A> &status)</B></TT>
<DD>
Construct a new MessageFormat using the given pattern.


<DL><DT><B>Parameters:</B><DD><B>pattern</B> -    Pattern used to construct object.
<br><B>status</B> -     Output param to receive success code.  If the
pattern cannot be parsed, set to failure code.<br></DL><P>
<A NAME="MessageFormat">
<A NAME ="DOC.17.32">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  MessageFormat(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& newLocale, <!2><A HREF="#DOC.301">UErrorCode</A>& success)</B></TT>
<DD>
Constructor that allows locale specification
<DL><DT><B>Parameters:</B><DD><B>pattern</B> -    Pattern used to construct object.
<br><B>newLocale</B> -  The locale to use for formatting dates and numbers.
<br><B>status</B> -     Output param to receive success code.  If the
pattern cannot be parsed, set to failure code.<br></DL><P>
<A NAME="MessageFormat">
<A NAME ="DOC.17.63">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  MessageFormat(const <!2><A HREF="MessageFormat.html#DOC.17.32">MessageFormat</A>&)</B></TT>
<DD>
Copy constructor
<DL></DL><P>
<A NAME="operator=">
<A NAME ="DOC.17.64">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> const  <!2><A HREF="MessageFormat.html#DOC.17.32">MessageFormat</A>&  operator=(const <!2><A HREF="MessageFormat.html#DOC.17.32">MessageFormat</A>&)</B></TT>
<DD>
Assignment operator
<DL></DL><P>
<A NAME="~MessageFormat">
<A NAME ="DOC.17.65">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  ~MessageFormat()</B></TT>
<DD>
Destructor
<DL></DL><P>
<A NAME="clone">
<A NAME ="DOC.17.33">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!2><A HREF="Format.html#DOC.14.8">Format</A>*  clone(void) const </B></TT>
<DD>
Clone this Format object polymorphically. The caller owns the
result and should delete it when done.
<DL></DL><P>
<A NAME="operator==">
<A NAME ="DOC.17.34">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  operator==(const <!2><A HREF="Format.html#DOC.14.8">Format</A>& other) const </B></TT>
<DD>
Return true if the given Format objects are semantically equal.
Objects of different subclasses are considered unequal.
<DL></DL><P>
<A NAME="setLocale">
<A NAME ="DOC.17.35">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setLocale(const <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>& theLocale)</B></TT>
<DD>
Sets the locale. This locale is used for fetching default number or date
format information.
<DL></DL><P>
<A NAME="getLocale">
<A NAME ="DOC.17.36">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  const  <!2><A HREF="MessageFormat.html#DOC.17.3">Locale</A>&  getLocale(void) const </B></TT>
<DD>
Gets the locale. This locale is used for fetching default number or date
format information.
<DL></DL><P>
<A NAME="applyPattern">
<A NAME ="DOC.17.37">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  applyPattern(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, <!2><A HREF="#DOC.301">UErrorCode</A>& status)</B></TT>
<DD>
Apply the given pattern string to this message format.


<DL><DT><B>Parameters:</B><DD><B>pattern</B> -    The pattern to be applied.
<br><B>status</B> -     Output param set to success/failure code on
exit. If the pattern is invalid, this will be
set to a failure result.<br></DL><P>
<A NAME="toPattern">
<A NAME ="DOC.17.38">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  toPattern(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Gets the pattern. See the class description.
<DL></DL><P>
<A NAME="adoptFormats">
<A NAME ="DOC.17.39">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  adoptFormats(<!2><A HREF="Format.html#DOC.14.8">Format</A>** formatsToAdopt, int32_t count)</B></TT>
<DD>
Sets formats to use on parameters.
See the class description about format numbering.
The caller should not delete the Format objects after this call.
<DL></DL><P>
<A NAME="setFormats">
<A NAME ="DOC.17.40">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setFormats(const <!2><A HREF="Format.html#DOC.14.8">Format</A>** newFormats, int32_t cnt)</B></TT>
<DD>
Sets formats to use on parameters.
See the class description about format numbering.
<DL></DL><P>
<A NAME="adoptFormat">
<A NAME ="DOC.17.41">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  adoptFormat(int32_t formatNumber, <!2><A HREF="Format.html#DOC.14.8">Format</A>* formatToAdopt)</B></TT>
<DD>
Sets formats individually to use on parameters.
See the class description about format numbering.
The caller should not delete the Format object after this call.
<DL></DL><P>
<A NAME="setFormat">
<A NAME ="DOC.17.42">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setFormat(int32_t variable, const <!2><A HREF="Format.html#DOC.14.8">Format</A>& newFormat)</B></TT>
<DD>
Sets formats individually to use on parameters.
See the class description about format numbering.
<DL></DL><P>
<A NAME="getFormats">
<A NAME ="DOC.17.43">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  const  <!2><A HREF="Format.html#DOC.14.8">Format</A>**  getFormats(int32_t& count) const </B></TT>
<DD>
Gets formats that were set with setFormats.
See the class description about format numbering.
<DL></DL><P>
<A NAME="format">
<A NAME ="DOC.17.44">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format( const <!1><A HREF="Formattable.html">Formattable</A>* source, int32_t count, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!1><A HREF="FieldPosition.html">FieldPosition</A>& ignore, <!2><A HREF="#DOC.301">UErrorCode</A>& success) const </B></TT>
<DD>
Returns pattern with formatted objects.  Does not take ownership
of the Formattable* array; just reads it and uses it to generate
the format string.


<DL><DT><B>Parameters:</B><DD><B>source</B> -     An array of objects to be formatted & substituted.
<br><B>result</B> -     Where text is appended.
<br><B>ignore</B> -     No useful status is returned.<br></DL><P>
<A NAME="format">
<A NAME ="DOC.17.45">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& pattern, const <!1><A HREF="Formattable.html">Formattable</A>* arguments, int32_t count, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result, <!2><A HREF="#DOC.301">UErrorCode</A>& success)</B></TT>
<DD>
Convenience routine.  Avoids explicit creation of
MessageFormat, but doesn't allow future optimizations.
<DL></DL><P>
<A NAME="format">
<A NAME ="DOC.17.46">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UnicodeString.html">UnicodeString</A>&  format(const <!1><A HREF="Formattable.html">Formattable</A>& obj, <!1><A HREF="UnicodeString.html">UnicodeString</A>& toAppendTo, <!1><A HREF="FieldPosition.html">FieldPosition</A>& pos, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const </B></TT>
<DD>
Format an object to produce a message.  This method handles
Formattable objects of type kArray. If the Formattable
object type is not of type kArray, then it returns a failing
UErrorCode.


<DL><DT><B>Returns:</B><DD>The value passed in as toAppendTo (this allows chaining,
as with UnicodeString::append())
<DT><B>Parameters:</B><DD><B>obj</B> -            The object to format
<br><B>toAppendTo</B> -     Where the text is to be appended
<br><B>pos</B> -            On input: an alignment field, if desired.
On output: the offsets of the alignment field.
<br><B>status</B> -         Output param filled with success/failure status.
<br></DL><P>
<A NAME="parse">
<A NAME ="DOC.17.47">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="Formattable.html">Formattable</A>*  parse( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="ParsePosition.html">ParsePosition</A>& status, int32_t& count) const </B></TT>
<DD>
Parses the string.
<P>
Caveats: The parse may fail in a number of circumstances.  For
example:
<P>
If one of the arguments does not occur in the pattern.
<P>
If the format of an argument is loses information, such as with
a choice format where a large number formats to "many".
<P>
Does not yet handle recursion (where the substituted strings
contain {n} references.)
<P>
Will not always find a match (or the correct match) if some
part of the parse is ambiguous.  For example, if the pattern
"{1},{2}" is used with the string arguments {"a,b", "c"}, it
will format as "a,b,c".  When the result is parsed, it will
return {"a", "b,c"}.
<P>
If a single argument is formatted twice in the string, then the
later parse wins.


<DL><DT><B>Parameters:</B><DD><B>source</B> -     String to be parsed.
<br><B>status</B> -     On input, starting position for parse. On output,
final position after parse.
<br><B>count</B> -      Output param to receive size of returned array.
@result          Array of Formattable objects, with length
'count', owned by the caller.<br></DL><P>
<A NAME="parse">
<A NAME ="DOC.17.48">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="Formattable.html">Formattable</A>*  parse( const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, int32_t& count, <!2><A HREF="#DOC.301">UErrorCode</A>& status) const </B></TT>
<DD>
Parses the string. Does not yet handle recursion (where
the substituted strings contain {n} references.)


<DL><DT><B>Parameters:</B><DD><B>source</B> -     String to be parsed.
<br><B>count</B> -      Output param to receive size of returned array.
<br><B>status</B> -     Output param to receive success/error code.
@result          Array of Formattable objects, with length
'count', owned by the caller.<br></DL><P>
<A NAME="parseObject">
<A NAME ="DOC.17.49">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  parseObject(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& source, <!1><A HREF="Formattable.html">Formattable</A>& result, <!1><A HREF="ParsePosition.html">ParsePosition</A>& parse_pos) const </B></TT>
<DD>
Parse a string to produce an object.  This methods handles
parsing of message strings into arrays of Formattable objects.
Does not yet handle recursion (where the substituted strings
contain %n references.)
<P>
Before calling, set parse_pos.index to the offset you want to
start parsing at in the source. After calling, parse_pos.index
is the end of the text you parsed.  If error occurs, index is
unchanged.
<P>
When parsing, leading whitespace is discarded (with successful
parse), while trailing whitespace is left as is.
<P>
See Format::parseObject() for more.


<DL><DT><B>Returns:</B><DD>A newly created Formattable* object, or NULL
on failure.  The caller owns this and should
delete it when done.
<DT><B>Parameters:</B><DD><B>source</B> -     The string to be parsed into an object.
<br><B>result</B> -     Formattable to be set to the parse result.
If parse fails, return contents are undefined.
<br><B>parse_pos</B> -  The position to start parsing at. Upon return
this param is set to the position after the
last character successfully parsed. If the
source is not parsed successfully, this param
will remain unchanged.
<br></DL><P>
<A NAME="getDynamicClassID">
<A NAME ="DOC.17.50">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="ClassID.html">ClassID</A>  getDynamicClassID(void) const </B></TT>
<DD>
Returns a unique class ID POLYMORPHICALLY.  Pure virtual override.
This method is to implement a simple version of RTTI, since not all
C++ compilers support genuine RTTI.  Polymorphic operator==() and
clone() methods call this method.


<DL><DT><B>Returns:</B><DD>The class ID for this object. All objects of a
given class have the same class ID.  Objects of
other classes have different class IDs.
</DL><P>
<A NAME="getStaticClassID">
<A NAME ="DOC.17.51">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!1><A HREF="ClassID.html">ClassID</A>  getStaticClassID(void)</B></TT>
<DD>
Return the class ID for this class.  This is useful only for
comparing to a return value from getDynamicClassID().  For example:
<pre>
.   Base* polymorphic_pointer = createPolymorphicObject();
.   if (polymorphic_pointer->getDynamicClassID() ==
.      Derived::getStaticClassID()) ...
</pre>

<DL><DT><B>Returns:</B><DD>The class ID for all objects of this class.
</DL><P></DL>
<hr>
 <DL><DT><B>This class has no child classes.</B></DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
