<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>New description for</title>
</head>

<body style="font-family: Arial Unicode MS">

<p><i><b>[ed note: New description for &quot;Transformations&quot; page]</b></i></p>
<p>Transliteration provides a general-purpose package for processing Unicode
text. Originally it was designed to deal with the conversion of characters from
one script to another, such as converting from Greek to Latin, or Japanese
katakana to Latin. However, it is now a more flexible mechanism applicable to a
much broader range of tasks. In particular, you can use pre-built
transformations for case conversions, normalization convertions, removal of
given characters, plus a variety of language/script transliterations.
Transliterations can be chained together to perform a series of operations, and
each step of the way can use a UnicodeSet to restrict the characters that are
affected. For example, to remove accents from characters, you can use the
following transliteration: &quot;NFD; [:Nonspacing Mark:] Remove; NFC&quot;</p>
<p><i><b>[ed note: New Transliteration Section]</b></i></p>
<h1>Transliteration</h1>
<p>Transliteration provides a general-purpose package for processing Unicode
text. Originally it was designed to deal with the conversion of characters from
one script to another, such as converting from Greek to Latin, or Japanese
katakana to Latin. However, it is now a more flexible mechanism applicable to a
much broader range of tasks. In particular, you can use pre-built
transformations for case conversions, normalization convertions, removal of
given characters, plus a variety of language/script transliterations.
Transliterations can be chained together to perform a series of operations, and
each step of the way can use a UnicodeSet to restrict the characters that are
affected.</p>
<p>For example, to remove accents from characters, you can use the following
transliteration: &quot;NFD; [:Nonspacing Mark:] Remove; NFC&quot;.</p>
<p>ICU provides a general mechanism for performing transliterations. It includes
a number of standard transliterators; additional transliterators can be built
from a series of textual rules, or built with specialized code.</p>
<p>Transliterations can be chained together so that a single operations can
perform multiple transformations at once. A transliteration can either be
applied to a string of text in one fell swoop, or can be used incrementally for
typing or buffered input. In the latter case, it provides for correct delay in
processing characters until there is an unambiguous mapping. Transliterators can
also be used with more complex text, such as styled text, maintaining the style
information where possible. For example, &quot;<font color="#0000ff">&#913;&#955;&#966;&#945;</font><font
color="#ff0000">&#946;&#951;&#964;&#953;&#954;&#972;&#962;</font>&quot; will
maintain the two colors in transliterating to &quot;<font color="#0000ff">Alpha</font><font
color="#ff0000">b<font size="3">&#275;</font>tikós</font>&quot;.</p>
<p>For an online demonstration of ICU transliteration, see <a
href="http://oss.software.ibm.com/icu/demo" target="_parent"
onclick="window.event.cancelBubble=true;" style="position:relative">http://oss.software.ibm.com/icu/demo</a>.
</p>
<h2>Script Transliteration</h2>
<p>Script Transliteration is the general process of converting characters from
one script to another, such as converting from Greek to Latin, or Japanese <i>katakana</i>
to Latin. It is very important to note that script transliteration is <b><i>not</i></b>
translation; it is simply converting the letters from one script to another, <i>not</i>
translating the underlying words. Here is a sample of script transliteration:</p>
<center>
<table cellpadding="4" border="1">
  <tbody>
    <tr>
      <th width="50%">Source</th>
      <th width="50%">Transliteration</th>
    </tr>
    <tr>
      <td align="middle" width="50%">&#12461;&#12515;&#12531;&#12497;&#12473;</td>
      <td align="middle" width="50%">kyanpasu</td>
    </tr>
    <tr>
      <td align="middle" width="50%">&#913;&#955;&#966;&#945;&#946;&#951;&#964;&#953;&#954;&#972;&#962;
        &#922;&#945;&#964;&#940;&#955;&#959;&#947;&#959;&#962;</td>
      <td align="middle" width="50%">Alphab&#275;tikós Katálogos</td>
    </tr>
    <tr>
      <td align="middle" width="50%">&#1073;&#1080;&#1086;&#1083;&#1086;&#1075;&#1080;&#1095;&#1077;&#1089;&#1082;&#1086;&#1084;</td>
      <td align="middle" width="50%">biologichyeskom</td>
    </tr>
  </tbody>
</table>
</center>
<p>While it may be a stretch to realize that <i>kyanpasu</i> is equivalent to
the English word <i>campus</i>, someone without any knowledge of Japanese will
have a far easier time recognizing and interpreting the text than if the letters
were left in the original script. This is especially useful in particular
instances. For example, when viewing names that are entered in a world-wide
database, it is extremely helpful to be able to view and refer to them in one's
native script. It is also useful for product support; if a service engineer is
sent a program dump filled with characters from foreign scripts, it can be much
easier to diagnose the problem when the text is transliterated and the
characters are recognizable. When doing searching and indexing, it also allows
for retrieval of information in a different script. Thus a more useful example
in practice is:</p>
<table border="1" width="100%">
  <tr>
    <td width="50%">&#44608;, &#44397;&#49340;<br>
      &#44608;, &#47749;&#55148;<br>
      &#51221;, &#48337;&#54840;<br>
      ...<br>
      &#12383;&#12369;&#12384;, &#12414;&#12373;&#12422;&#12365;<br>
      &#12414;&#12377;&#12384;, &#12424;&#12375;&#12402;&#12371;<br>
      &#12420;&#12414;&#12418;&#12392;, &#12398;&#12412;&#12427;<br>
      ...<br>
      &#929;&#959;&#973;&#964;&#963;&#951;, &#902;&#957;&#957;&#945;<br>
      &#922;&#945;&#955;&#959;&#973;&#948;&#951;&#962;,
      &#935;&#961;&#942;&#963;&#964;&#959;&#962;<br>
      &#920;&#949;&#959;&#948;&#969;&#961;&#940;&#964;&#959;&#965;,
      &#917;&#955;&#941;&#957;&#951;</td>
    <td width="50%">Gim, Gugsam<br>
      Gim, Myeonghyi<br>
      Jeong, Byeongho<br>
      ...<br>
      Takeda, Masayuki<br>
      Masuda, Yoshihiko<br>
      Yamamoto, Noboru<br>
      ...<br>
      Roúts&#275;, Ánna<br>
      Kaloúd&#275;s, Chr&#7703;stos<br>
      Theod&#333;rátou, Elén&#275;</td>
  </tr>
</table>
<p>Transliteration can also be used to convert unfamiliar letters within the
same script, such as converting Icelandic THORN (þ) to <i>th</i>.</p>
<h3>Naming Conventions</h3>
<p>Transliterators use the following conventions for names:</p>
<p align="center"><b><i>transliterator := (source &quot;-&quot;)? target?
(&quot;/&quot; variant)?</i></b></p>
<ul>
  <li>If <b><i>source &quot;-&quot;</i></b> is missing, then it is assumed to be
    &quot;any-&quot;.</li>
  <li>If <b><i>target</i></b> is missing, it is assumed to be &quot;any&quot;.</li>
  <li>If <b><i>&quot;/&quot; </i></b><i><b>variant</b></i> is missing, it is
    assumed to be the default.</li>
</ul>
<p>For example, &quot;hex/xml&quot; means &quot;any-hex/xml&quot;; &quot;hex-/xml&quot;
means &quot;hex-any/xml&quot;. Another example of a variant is &quot;<span
style="mso-fareast-font-family:&quot;Times New Roman&quot;;mso-hansi-font-family:&quot;Times New Roman&quot;">Greek-Latin/ISO-843</span>&quot;.</p>
<p>When constructing Transliterators from strings, the general format is</p>
<p align="center"><i><b>filter? transliterator (&quot;;&quot; filter?
transliterator)*</b></i></p>
<p>That is, any number of transliterators can be supplied, each with an optional
filter. The filter is a UnicodeSet [ed note: add link]. If it is not supplied,
all characters may be subject to change.</p>
<p>For example, to remove accents from characters, you can use the following
transliteration:</p>
<p align="center">NFD; [:nonspacing mark:] remove; NFC</p>
<p>this is short for</p>
<p align="center">any-NFD; [:nonspacing mark:] any-remove; any-NFC</p>
<p>Another example of a filter is one used to convert uppercase Latin to
Katakana and lowercase to Hiragana:</p>
<p align="center">[:uppercaseLetter:] Latin - Katakana; Latin - Hiragana;</p>
<h2><a name="ICU Transliterators">ICU Transliterators</a></h2>
<p>There are a number of basic transliterations currently supplied with ICU.
Additional ones will be added over time.</p>
<h3>General</h3>
<p>Most general-purpose transliterations follow the convention of
&quot;Any-X&quot;.</p>
<ul>
  <li>Any
    <ul>
      <li><font size="3">&#8594; </font>Case conversions: Lower, Title, Upper
        <ul>
          <li>Converts to the specified case. See Case Mappings [add link] for
            more information</li>
        </ul>
      </li>
      <li><font size="3">&#8594; </font>Normalization conversions: NFC, NFD,
        NFKD, NFKC
        <ul>
          <li>Converts to the specified normalized form. See Normalizer [add
            link] for more information</li>
        </ul>
      </li>
      <li>&#8644;<font size="3"> </font>Character Info: Name, Hex,
        KeyboardEscape
        <ul>
          <li>converts between characters and their Unicode names in curly
            braces.<br>
            ., &#8644; {FULL STOP}{COMMA}</li>
          <li>converts between characters and a hex representation.<br>
            .,&nbsp; &#8644;&nbsp; \u002E\u002C</li>
          <li>hex/xml uses the &amp;#xXXXX; format.<br>
            .,&nbsp; &#8644;&nbsp; &amp;#x2E;&amp;#x2C;</li>
          <li>KeyboardEscape lets you type e- for e-macron, etc.<br>
            e.g. o'&nbsp; &#8644;&nbsp; ó</li>
        </ul>
      </li>
      <li><font size="3">&#8594; </font>Misc: Null, Remove
        <ul>
          <li>Null has no effect</li>
          <li>Remove removes all characters (that are not filtered)</li>
        </ul>
      </li>
      <li>&#8644; Typewriter
        <ul>
          <li>converts between real punctuation and typewriter punctuation<br>
            e.g.&nbsp; “a” — ‘b’ &#8644; &quot;a&quot; -- 'b'</li>
        </ul>
      </li>
      <li>&#8644; Fullwidth
        <ul>
          <li>converts between narrow or half-width characters and fullwidth<br>
            book &#8644; &#65346;&#65359;&#65359;&#65355;</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
<h3>Script/Language</h3>
<p>The ICU script/language transliterators are based on common standards for the
particular scripts, where possible. In some cases, they are augmented to support
reversibility. One caution: standard transliteration methods often do not follow
the pronunciation rules of any particular language in the target script. For
more information on the design of transliterations, see <a href="#Guidelines">Guidelines</a>.</p>
<p>The built-in script transliterators are:</p>
<ul>
  <li>Latin
    <ul>
      <li>&#8644;<font size="3"> </font>Greek, Cyrillic, Hangul, Hiragana,
        Katakana, <i>Indic</i></li>
    </ul>
  <li><i>Indic </i>&#8644;
    <ul>
      <li>Latin, Devanagari, Gujarati, Gurmukhi, Kannada, Malayalam, Oriya,
        Tamil, Telegu
        <ul>
          <li>All transliterate from one to the other. Thus you can
            transliterate from Kannada to Gujarati, or from Latin to Oriya.</li>
        </ul>
      </li>
    </ul>
</ul>
<p>In addition, ICU may supply transliterations that are specific to language
pairs, or between a language and a script. For example, it could have ru-en
(Russian-English).</p>
<p>As with locales, there is a fallback mechanism. If Russian-English is
requested, but is not available, then the system will see if Russian-Latin is
available. If not, it will see if Cyrillic-Latin is available.</p>
<h2><a name="Guidelines">Goals for Script/Language Transliterations</a></h2>
<p>There are a number of generally desirable goals for script transliterations.
Rarely can all of these goals be satisfied simultaneously, so constructing a
reasonable transliteration is always a process of balancing different
requirements. These requirements are most important for people actually building
transliterations, but are also useful background information for those simply
using them. The general goals are for transliterations to be:</p>
<ul>
  <li><b>complete: </b>every well-formed sequence of characters in the source
    script should transliterate to a sequence of characters from the target
    script.
  <li><b>predictable: </b>the letters themselves — without any knowledge of
    the languages written in that script — should be sufficient for the
    transliteration, based on a relatively small number of rules. This allows
    the transliteration to be performed mechanically.
  <li><b>pronounceable: </b>it is of little use if a transliteration simply maps
    the characters without any regard to their pronunciation. Simply mapping
    &quot;&#945;&#946;&#947;&#948;&#949;&#950;&#951;&#952;...&quot; to &quot;abcdefgh...&quot;
    would yield strings that might be complete and unambiguous, but that would
    be unpronounceable.</li>
  <li><b>unambiguous: </b>from the transliteration in the target script, it is
    always possible to recover the text in the source script. That means that
    someone knows the transliteration rules will be able to recover the precise
    spelling of the original source text: for example, to go from <i>Elláda</i>
    back to the original &#917;&#955;&#955;&#940;&#948;&#945;. That means it is
    possible to define an reverse (or <i>inverse</i>) mapping, so sometimes this
    property is called <i>reversibility (or</i> <i>invertibility).</i>
</ul>
<h3>Ambiguity</h3>
In transliteration, multiple characters may produce ambiguities, unless the
rules are carefully designed. For example, the Greek character PSI (&#968;) maps
to <i>ps, </i>but <i>ps </i>could also (theoretically) result from the sequence
PI, SIGMA (&#960;&#963;), since PI (&#960;) maps to <i>p</i> and SIGMA (&#963;)
maps to <i>s.</i>
<p>The standard Japanese transliteration standards provide a good mechanism for
handling this: whenever an ambiguous sequence in the target script does not
result from a single letter, they use an apostrophe to disambiguate it. For
example, that mechanism is used to distinguish between <i>man'ichi</i> and <i>ma<u>ni</u>chi.</i>
Applying this mechanism to the case of Greek, we have PI SIGMA (&#960;&#963;)
mapping to <i>p's.</i> The Korean transliteration standard uses a hyphen instead
of a single quote mark: the principle is the same. This method is recommended
for all script transliteration methods.</p>
<p><b>Note: </b>Some characters in a target script are not normally found in
isolation. For example, in Japanese &quot;kya&quot; (&#12461;&#12515;) the small
&quot;ya&quot; character is not normally found in isolation. The convention to
handle such characters is to use a tilde. For example, to type an isolated small
&quot;ya&quot;, you would use &quot;~ya&quot;; to represent a non-final Greek <i>sigma</i>
(&#945;&#963;) at the end of a word you would use &quot;a~s&quot;; to represent
a final sigma in a non-final position (&#962;&#945;) you would type &quot;~sa&quot;.</p>
<p>For the general script transliterators, a common technique for reversibility
is to use extra accents to distinguish letters that may not be otherwise
distinguished. For example,</p>
<table border="1" width="100%">
  <tr>
    <td width="66%" colspan="2">
      <p align="center">Greek-Latin</td>
  </tr>
  <tr>
    <td width="33%">&#964;&#943; &#966;&#8132;&#962;;
      &#947;&#961;&#945;&#966;&#8052;&#957; &#963;&#941; &#964;&#953;&#962;,
      &#8033;&#962; &#7956;&#959;&#953;&#954;&#949;,
      &#947;&#941;&#947;&#961;&#945;&#960;&#964;&#945;&#953;: &#959;&#8016;
      &#947;&#8048;&#961; &#7952;&#954;&#949;&#8150;&#957;&#972; &#947;&#949;
      &#954;&#945;&#964;&#945;&#947;&#957;&#974;&#963;&#959;&#956;&#945;&#953;,
      &#8033;&#962; &#963;&#8058; &#7957;&#964;&#949;&#961;&#959;&#957;.</td>
    <td width="33%">tí ph&#7703;is; graph&#7701;n sé tis, h&#333;s éoike,
      gégraptai: ou gàr ekeînó ge katagn&#7763;somai, h&#333;s s&#7923; héteron.</td>
  </tr>
</table>
<p>If the user desires a version without certain accents, then a simple
transliterator can be used to remove the accents. For example, the following
removes the macron accents on the long vowels.</p>
<table border="1" width="100%">
  <tr>
    <td width="66%" colspan="2">
      <p align="center">Greek-Latin; nfd; [\u0304] remove; nfc</td>
  </tr>
  <tr>
    <td width="33%">&#964;&#943; &#966;&#8132;&#962;;
      &#947;&#961;&#945;&#966;&#8052;&#957; &#963;&#941; &#964;&#953;&#962;,
      &#8033;&#962; &#7956;&#959;&#953;&#954;&#949;,
      &#947;&#941;&#947;&#961;&#945;&#960;&#964;&#945;&#953;: &#959;&#8016;
      &#947;&#8048;&#961; &#7952;&#954;&#949;&#8150;&#957;&#972; &#947;&#949;
      &#954;&#945;&#964;&#945;&#947;&#957;&#974;&#963;&#959;&#956;&#945;&#953;,
      &#8033;&#962; &#963;&#8058; &#7957;&#964;&#949;&#961;&#959;&#957;.</td>
    <td width="33%">tí phéis; graphèn sé tis, hos éoike, gégraptai: ou
      gàr ekeînó ge katagnósomai, hos s&#7923; héteron.</td>
  </tr>
</table>
<p>And the following removes all accents:</p>
<table border="1" width="100%">
  <tr>
    <td width="66%" colspan="2">
      <p align="center">Greek-Latin; nfd; [\u0304] remove; nfc</td>
  </tr>
  <tr>
    <td width="33%">&#964;&#943; &#966;&#8132;&#962;;
      &#947;&#961;&#945;&#966;&#8052;&#957; &#963;&#941; &#964;&#953;&#962;,
      &#8033;&#962; &#7956;&#959;&#953;&#954;&#949;,
      &#947;&#941;&#947;&#961;&#945;&#960;&#964;&#945;&#953;: &#959;&#8016;
      &#947;&#8048;&#961; &#7952;&#954;&#949;&#8150;&#957;&#972; &#947;&#949;
      &#954;&#945;&#964;&#945;&#947;&#957;&#974;&#963;&#959;&#956;&#945;&#953;,
      &#8033;&#962; &#963;&#8058; &#7957;&#964;&#949;&#961;&#959;&#957;.</td>
    <td width="33%">ti pheis; graphen se tis, hos eoike, gegraptai: ou gar
      ekeino ge katagnosomai, hos sy heteron.</td>
  </tr>
</table>
<h3><a name="Pronunciation">Pronunciation</a></h3>
<p>Standard transliteration methods often do not follow the pronunciation rules
of any particular language in the target script. For example, the Japanese
Hepburn system uses a <i>j</i> that has the English phonetic value (as opposed
to French, German or Spanish), but uses vowels that do not have the standard
English sounds. A transliteration method might also require some special
knowledge for correct pronunciation. For example, with the Japanese <i>kunrei-siki</i>
system, <i>tu</i> is pronounced as <i>tsu.</i> This is similar to the case of
different languages within the same script. For example, knowing that the word <i>Gewalt</i>
comes from German allows a knowledgeable reader to pronounce the <i>w</i> as a <i>v.</i></p>
<p align="left">In some cases, transliteration may be heavily influenced by
tradition. For example, the modern Greek letter beta<i> (&#946;)</i> sounds like
a <i>v,</i> but a transliteration may continue to use a <i>b</i> (as in <i>biology</i>).
In that case, one would need to know that a <i>b</i> in the transliterated word
corresponded to beta<i> (&#946;)</i> and is to be pronounced as a <i>v</i> in
modern Greek. Letters may also be transliterated differently according to their
context to make the pronunciation more predictable. For example, since the Greek
sequence GAMMA GAMMA (&#947;&#947;) is pronounced as <i>ng,</i> the first GAMMA
can be transcribed as an <i>n.</i></p>
<blockquote>
  <b>Note: </b>In general, predictability means that when transliterating Latin
  script to other scripts, English text will not produce phonetic results. This
  is because the pronunciation of English cannot be easily predicted from the
  letters in a word: e.g. <i>grove, move, </i>and<i> love</i> all end with <i>ove,</i>
  but are pronounced very differently.
</blockquote>
<h3><a name="Cautions">Cautions</a></h3>
<p>Reversibility may require modifications of traditional transcription methods.
For example, there are two standard methods for transliterating Japanese <i>katakana</i>
and <i>hiragana</i> into Latin letters. The <i>kunrei-siki</i> method is
unambiguous. The Hepburn method is more easily pronounceable by foreigners but
is ambiguous: both ZI (&#12472;) and DI (&#12482;) are represented by<i> ji</i>
and both ZU (&#12474;) and DU (&#12485;) are represented by <i>zu.</i> A
slightly amended version of Hepburn, that uses <i>dji</i> for DI and <i>dzu</i>
for DU, <i>is</i> unambiguous.</p>
<p>When a sequence of two letters map to one, case mappings (uppercasing and
lowercasing) must be handled specially to ensure reversibility. For cased
scripts, the two letters may need to have different cases, depending on the next
letter. For example, the Greek letter PHI (&#934;) maps to <i>PH</i> in Latin,
but &#934;&#959;.. maps to <i>Pho..,</i> <i>not</i> to <i>PHo..</i></p>
<p>Some scripts have characters that take on different shapes depending on their
context. Usually, this is done at the display level (such as with Arabic), and
does not require special transliteration support. However, in a few cases this
is represented with different character codes, such as in Greek and Hebrew. For
example, a Greek SIGMA is written in a final form (&#962;) at the end of words,
and a non-final form (&#963;) otherwise. This requires the transliteration to
pick different characters based on the context.</p>
<p align="left"><b>Note:</b> we have found it useful for the reverse mapping to
be complete, so that arbitrary strings in the target script can be reasonably
mapped back to the source script. This makes it much easier to do mechanical
quality checks, for one thing. For example, even though the letter <i>q</i>
might not be necessary in a transliteration of Greek, it can be mapped to a
KAPPA (&#954;). Such reverse mappings will not, in general, be unambiguous.</p>
<h2><a name="Using Transliterators">Using Transliterators</a></h2>
<p>Transliterators have APIs in C, C++ and Java. For simplicity, only the C++
APIs are listed here. For more information on them and the other APIs, see the
relevant API docs.</p>
<p>To list the available Transliterators, use code like the following:</p>
<pre>count = Transliterator:: countAvailableIDs();
myID = Transliterator::getAvailableID(n);</pre>
<p>The ID should not be displayed to users; it is for internal use only. A
separate string, one that can be localized to different languages, is obtained
with a static method. (This method is static to allow the translated names to be
augmented without changing the code.) To get a localized name for use in a GUI,
use the following:</p>
<blockquote>
  <pre>Transliterator::getDisplayName(myID, france, nameForUser);</pre>
</blockquote>
<p>To create a Transliterator, use the following:</p>
<blockquote>
  <pre>myTrans = Transliterator::createInstance(&quot;Latin-Greek&quot;);</pre>
</blockquote>
<p>If you want to get a pre-made compound transliterator, use a series of IDs
separated by &quot;;&quot;. For example:</p>
<blockquote>
  <pre>myTrans = Transliterator::createInstance(&quot;any-NFD; [:nonspacing mark:] any-remove; any-NFC&quot;);</pre>
</blockquote>
<p>To convert an entire string, use: </p>
<blockquote>
  <pre>myTrans.transliterate(myString);</pre>
</blockquote>
<p>For simple cases, that suffices. For more complex cases, such a keyboard
input, the full method provides more control. Here is an example of that method:</p>
<blockquote>
  <pre>myTrans.transliterate(replaceable, positions, complete);</pre>
</blockquote>
<p>The Replaceable interface (or abstract class in C++) allows more complex text
to be used with Transliterators, such as styled text. (In ICU4J a wrapper is
supplied for StringBuffer.) This is an interface to text that handles a very few
operations: essentially access to characters, plus replacement of a substring by
another. By using this interface, replacement text can take on the same style as
the text it is replacing, so that style information is not lost. With a
replaceable interface to HTML or XML, even higher level structure can be
preserved.</p>
<p>The positions parameter contains information about the range of text that
should be transliterated, plus the possibly larger range of text that can serve
as context.</p>
<p align="center"><img border="0" src="user_g1.gif" width="540" height="237"></p>
<p>The <code>complete</code> parameter indicates whether or not you are to
consider the text up to limit to be complete or not. For example, for keyboard
input this should normally be false. Only when the conversion is complete is
that parameter set to true. For example, suppose that a transliterator converts
&quot;sh&quot; to X, and &quot;s&quot; in other cases to Y. If the complete
parameter is true, then a dangling &quot;s&quot; converts to Y; when the
complete parameter is false, then the dangling &quot;s&quot; should not be
converted, since there is more text to come.</p>
<p>For example, in keyboard input, normally start/cursor and limit/end are set
to the selection at the time the transliterator is chosen.</p>
<blockquote>
  <pre>positions.start = positions.cursor = selection.getStart();
positions.limit = positions.end = selection.getEnd();</pre>
</blockquote>
<p>As the user types or inserts inputChars, you would call:</p>
<blockquote>
  <pre>replacable.replace(positions.limit, positions.limit, inputChars); // update the text
positions.limit += inputChars.length(); // update the positions
myTrans.transliterate(replaceable, positions, false);</pre>
</blockquote>
<p>If the user performs an action that indicates s/he is done with the text,
then transliterate is called one last time:</p>
<blockquote>
  <pre>myTrans.transliterate(replaceable, positions, false);</pre>
</blockquote>
<h2><a name="Designing Transliterators">Designing Transliterators</a></h2>
<p>Many people will just use the supplied transliterators. In case you are
interested in designing transliterators yourself, there are two avenues. Many
transliterators can be produced without subclassing, simply by designing rules
for a RuleBasedTransliterator. If conversions can be done algorithmically much
more compactly than with a long list of rules, then you may consider subclassing
Transliterator directly. For example, ICU itself supplies specialized subclasses
for:</p>
<ul>
  <li>Hangul &#8644; Jamo
  <li>Any &#8644; Hex
  <li>Wrapping the string functions for normalization, case mapping, etc.</li>
</ul>
<h3><a name="Subclassing Transliterators">Subclassing Transliterators</a></h3>
<p>Subclassers must override <code>handleTransliterate(Replaceable text,
Positions positions, boolean complete)</code>. They can override some of the
other methods for efficiency, but must take care that the results are identical!
In <code>handleTransliterate</code> you will convert the text from <code>positions.cursor</code>
up to <code>positions.limit</code>. The context from <code>positions.start</code>
to <code>positions.end</code> may be taken into account as context when doing
this conversion, but should not be converted themselves. You should never look
at any characters before <code>positions.start</code> or after <code>positions.end</code>.</p>
<p>The <code>complete</code> parameter indicates whether or not you are to
consider the text up to limit to be complete or not. For example, suppose that
you would convert &quot;sh&quot; to X, and &quot;s&quot; in other cases to Y. If
the complete parameter is true, then a dangling &quot;s&quot; converts to Y;
when the complete parameter is false, then the dangling &quot;s&quot; should not
be converted. When you return from the method, positions.cursor should be set to
the furthest position you processed. Typically this will be up to <code>limit</code>;
in case there was an incomplete sequence at the end, <code>cursor</code> should
be set to the position just before that sequence.</p>
<h3><a name="ICU Rule-Based Transliterators">Rule-Based Transliterators</a></h3>
<p>ICU supplies the foundation for producing well-behaved transliterations, and
supplies a number of typing transliterations for different scripts. The simplest
mechanism for producing transliterations is called a RuleBasedTransliterator. It
is a data-based class that allows transliterations to be built up with a series
of rules. These rules allow for a specialized set of context-sensitive matching
operations. The operations are similar to regular-expression rules, but adapted
to the specific domain of transliterations.</p>
<p>The simplest rule is of the following form, which simply replaces x with y:</p>
<blockquote>
  <p>x &gt; y ;</p>
</blockquote>
<p>Context can be used to have the results of a transformation be different
depending on the characters before or after. The following means: Convert gamma
into n <b><i>if </i></b>followed by any of gamma, kappa, chi or ksi; otherwise
convert gamma into g.</p>
<blockquote>
  <p>{ &#947; } [ &#915; &#922; &#935; &#926; &#947; &#954; &#967; &#958; ] &gt;
  n;<br>
  &#947; &gt; g;</p>
</blockquote>
<p>Note: The context itself (e.g. &#915;, …, &#958;) is unaffected by the
replacement; only the text between the curly braces is changed.</p>
<h3>Regular Expressions</h3>
<p>The rules are similar to Regular Expressions in offering: Variables, Property
matches, Contextual matches, Rearrangement ($1, $2…), and Quantifiers (*, +,
?). They are more powerful in offering: Ordered Rules, Cursor Backup,
Buffered/Keyboard support. They are less powerful in that they have only greedy
quantifiers, no backup (so no X | Y), and no input-side back references.</p>
<p>Here is an example that shows the difference between a set of Transliterator
rules, and successively applying regular expression replacements.</p>
<p align="center"><img border="0" src="user_g2.gif" width="463" height="388"></p>
<p>Since the transliterator processes each of its rules at each point, it
catches the yx before the xy in the second case. Since each of the regular
expressions is evaluated over the whole string, that isn’t possible. Simply
using multiple regular expressions can’t account for the interaction and
ordering of characters and rules.</p>
<p>For more details on constructing rules, see the Transliterator Rule Tutorial
[add link].</p>

</body>

</html>
