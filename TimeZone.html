<html><head><TITLE>TimeZone</TITLE></head>
<body>
<H2><A HREF ="#DOC.DOCU" > <IMG BORDER=0 SRC=down.gif></A>  class  U_I18N_API TimeZone  </H2><BLOCKQUOTE>

<code>TimeZone</code> represents a time zone offset, and also figures out daylight
savings
</BLOCKQUOTE>
<hr>
 <h2> Inheritance:</h2>
<APPLET CODE="ClassGraph.class" WIDTH=600 HEIGHT=65>
<param name=classes value="CTimeZone,MTimeZone.html,CSimpleTimeZone,MSimpleTimeZone.html">
<param name=before value="M,M^_">
<param name=after value="M,M">
<param name=indent value="0,0">
<param name=arrowdir value="down">
</APPLET>
<hr>

<DL>
<DL>
<DT><h3>Public Classes</h3><DD><DT><A HREF="#DOC.48.29"> <IMG BORDER=0 SRC=icon1.gif></A>  enum  <B>EDisplayType</B> </B>
 <DD><I>
Enum for use with getDisplayName</I>
</DL><DL>
<DT><h3>Public Methods</h3><DD><DT><A HREF="#DOC.48.1"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>*  <B>createTimeZone</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& ID) </B>
 <DD><I>
Creates a <code>TimeZone</code> for the given ID</I>
<DT><A HREF="#DOC.48.2"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>**  const  <B>createAvailableIDs</B>(int32_t rawOffset, int32_t& numIDs) </B>
 <DD><I>
Returns a list of time zone IDs, one for each time zone with a given GMT offset</I>
<DT><A HREF="#DOC.48.3"> <IMG BORDER=0 SRC=icon1.gif></A> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>**  const  <B>createAvailableIDs</B>(int32_t& numIDs) </B>
 <DD><I>
Returns a list of all time zone IDs supported by the TimeZone class (i</I>
<DT><A HREF="#DOC.48.4"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>*  <B>createDefault</B>(void) </B>
 <DD><I>
Creates a new copy of the default TimeZone for this host</I>
<DT><A HREF="#DOC.48.5"> <IMG BORDER=0 SRC=icon1.gif></A> static  void  <B>adoptDefault</B>(<!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>* zone) </B>
 <DD><I>
Sets the default time zone (i</I>
<DT><A HREF="#DOC.48.6"> <IMG BORDER=0 SRC=icon1.gif></A> static  void  <B>setDefault</B>(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& zone) </B>
 <DD><I>
Same as adoptDefault(), except that the TimeZone object passed in is NOT adopted;
the caller remains responsible for deleting it</I>
<DT><A HREF="#DOC.48.7"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>operator==</B>(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& that) const  </B>
 <DD><I>
Returns true if the two TimeZones are equal</I>
<DT><A HREF="#DOC.48.8"> <IMG BORDER=0 SRC=icon1.gif></A> bool_t  <B>operator!=</B>(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& that) const  </B>
 <DD><I>
Returns true if the two TimeZones are NOT equal; that is, if operator==() returns
false</I>
<DT><A HREF="#DOC.48.9"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  int32_t  <B>getOffset</B>(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
Returns the TimeZone's adjusted GMT offset (i</I>
<DT><A HREF="#DOC.48.10"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  int32_t  <B>getOffset</B>(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t milliseconds, int32_t monthLength, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
Gets the time zone offset, for current date, modified in case of
daylight savings</I>
<DT><A HREF="#DOC.48.11"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  void  <B>setRawOffset</B>(int32_t offsetMillis) </B>
 <DD><I>
Sets the TimeZone's raw GMT offset (i</I>
<DT><A HREF="#DOC.48.12"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  int32_t  <B>getRawOffset</B>(void) const  </B>
 <DD><I>
Returns the TimeZone's raw GMT offset (i</I>
<DT><A HREF="#DOC.48.13"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getID</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& ID) const  </B>
 <DD><I>
Fills in "ID" with the TimeZone's ID</I>
<DT><A HREF="#DOC.48.14"> <IMG BORDER=0 SRC=icon1.gif></A> void  <B>setID</B>(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& ID) </B>
 <DD><I>
Sets the TimeZone's ID to the specified value</I>
<DT><A HREF="#DOC.48.15"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayName</B>(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Returns a name of this time zone suitable for presentation to the user
in the default locale</I>
<DT><A HREF="#DOC.48.16"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayName</B>(const Locale& locale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Returns a name of this time zone suitable for presentation to the user
in the specified locale</I>
<DT><A HREF="#DOC.48.17"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayName</B>(bool_t daylight, <!2><A HREF="TimeZone.html#DOC.48.29">EDisplayType</A> style, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Returns a name of this time zone suitable for presentation to the user
in the default locale</I>
<DT><A HREF="#DOC.48.18"> <IMG BORDER=0 SRC=icon1.gif></A> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  <B>getDisplayName</B>(bool_t daylight, <!2><A HREF="TimeZone.html#DOC.48.29">EDisplayType</A> style, const Locale& locale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const  </B>
 <DD><I>
Returns a name of this time zone suitable for presentation to the user
in the specified locale</I>
<DT><A HREF="#DOC.48.19"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>useDaylightTime</B>(void) const  </B>
 <DD><I>
Queries if this time zone uses daylight savings time</I>
<DT><A HREF="#DOC.48.20"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>inDaylightTime</B>(<!1><A HREF="UDate.html">UDate</A> date, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const  </B>
 <DD><I>
Queries if the given date is in daylight savings time in
this time zone</I>
<DT><A HREF="#DOC.48.21"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  bool_t  <B>hasSameRules</B>(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& other) const  </B>
 <DD><I>
Returns true if this zone has the same rule and offset as another zone</I>
<DT><A HREF="#DOC.48.22"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>*  <B>clone</B>(void) const  </B>
 <DD><I>
Clones TimeZone objects polymorphically</I>
<DT><A HREF="#DOC.48.23"> <IMG BORDER=0 SRC=icon1.gif></A> static  <!1><A HREF="UClassID.html">UClassID</A>  <B>getStaticClassID</B>(void) </B>
 <DD><I>
Return the class ID for this class</I>
<DT><A HREF="#DOC.48.24"> <IMG BORDER=0 SRC=icon1.gif></A> virtual  <!1><A HREF="UClassID.html">UClassID</A>  <B>getDynamicClassID</B>(void) const  </B>
 <DD><I>
Returns a unique class ID POLYMORPHICALLY</I>
<DT><A HREF="#DOC.48.32"> <IMG BORDER=0 SRC=icon1.gif></A> static  void  <B>deleteTimeZone</B>(void*) </B>
 <DD><I>
Delete function for fgHashtable</I>
</DL><DL>
<DT><h3>Protected Methods</h3><DD><DT><A HREF="#DOC.48.25"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>TimeZone</B>() </B>
 <DD><I>
Default constructor</I>
<DT><A HREF="#DOC.48.30"> <IMG BORDER=0 SRC=icon1.gif></A>  <B>TimeZone</B>(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& source) </B>
 <DD><I>
Copy constructor</I>
<DT><A HREF="#DOC.48.31"> <IMG BORDER=0 SRC=icon1.gif></A> <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>&  <B>operator=</B>(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& right) </B>
 <DD><I>
Default assignment operator</I>
</DL></DL>
<A NAME="DOC.DOCU">
<hr>
 <h2> Documentation </h2>
<BLOCKQUOTE>

<code>TimeZone</code> represents a time zone offset, and also figures out daylight
savings.

<p>
Typically, you get a <code>TimeZone</code> using <code>createDefault</code>
which creates a <code>TimeZone</code> based on the time zone where the program
is running. For example, for a program running in Japan, <code>createDefault</code>
creates a <code>TimeZone</code> object based on Japanese Standard Time.

<p>
You can also get a <code>TimeZone</code> using <code>createTimeZone</code> along
with a time zone ID. For instance, the time zone ID for the Pacific
Standard Time zone is "PST". So, you can get a PST <code>TimeZone</code> object
with:
<blockquote>
<pre>
TimeZone *tz = TimeZone::createTimeZone("PST");
</pre>
</blockquote>
You can use <code>getAvailableIDs</code> method to iterate through
all the supported time zone IDs. You can then choose a
supported ID to get a <code>TimeZone</code>.
If the time zone you want is not represented by one of the
supported IDs, then you can create a custom time zone ID with
the following syntax:

<blockquote>
<pre>
GMT[+|-]hh[[:]mm]
</pre>
</blockquote>

For example, you might specify GMT+14:00 as a custom
time zone ID.  The <code>TimeZone</code> that is returned
when you specify a custom time zone ID does not include
daylight savings time.



TimeZone is an abstract class representing a time zone.  A TimeZone is needed for
Calendar to produce local time for a particular time zone.  A TimeZone comprises
three basic pieces of information:<ul>
<li>A time zone offset; that, is the number of milliseconds to add or subtract
from a time expressed in terms of GMT to convert it to the same time in that
time zone (without taking daylight savings time into account).
<li>Logic necessary to take daylight savings time into account if daylight savings
time is observed in that time zone (e.g., the days and hours on which daylight
savings time begins and ends).
<li>An ID.  This is a text string that uniquely identifies the time zone.</ul>

(Only the ID is actually implemented in TimeZone; subclasses of TimeZone may handle
daylight savings time and GMT offset in different ways.  Currently we only have one
TimeZone subclass: SimpleTimeZone.)
<P>
The TimeZone class contains a static list containing a TimeZone object for every
combination of GMT offset and daylight-savings time rules currently in use in the
world, each with a unique ID.  Each ID consists of a region (usually a continent or
ocean) and a city in that region, separated by a slash, (for example, Pacific
Standard Time is "America/Los_Angeles.")  Because older versions of this class used
three- or four-letter abbreviations instead, there is also a table that maps the older
abbreviations to the newer ones (for example, "PST" maps to "America/LosAngeles").
Anywhere the API requires an ID, you can use either form.
<P>
To create a new TimeZone, you call the factory function TimeZone::createTimeZone()
and pass it a time zone ID.  You can use the createAvailableIDs() function to
obtain a list of all the time zone IDs recognized by createTimeZone().
<P>
You can also use TimeZone::createDefault() to create a TimeZone.  This function uses
platform-specific APIs to produce a TimeZone for the time zone corresponding to 
the client's computer's physical location.  For example, if you're in Japan (assuming
your machine is set up correctly), TimeZone::createDefault() will return a TimeZone
for Japanese Standard Time ("Asia/Tokyo").

</BLOCKQUOTE>
<DL>

<A NAME="createTimeZone">
<A NAME ="DOC.48.1">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>*  createTimeZone(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& ID)</B></TT>
<DD>
Creates a <code>TimeZone</code> for the given ID
<DL><DT><B>Returns:</B><DD>the specified <code>TimeZone</code>, or the GMT zone if the given ID
cannot be understood.
<DT><B>Parameters:</B><DD><B>ID</B> -  the ID for a <code>TimeZone</code>, either an abbreviation such as
"PST", a full name such as "America/Los_Angeles", or a custom ID
such as "GMT-8:00".
<br></DL><P>
<A NAME="createAvailableIDs">
<A NAME ="DOC.48.2">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>**  const  createAvailableIDs(int32_t rawOffset, int32_t& numIDs)</B></TT>
<DD>
Returns a list of time zone IDs, one for each time zone with a given GMT offset.
The return value is a list because there may be several times zones with the same
GMT offset that differ in the way they handle daylight savings time.  For example,
the state of Arizona doesn't observe Daylight Savings time.  So if you ask for
the time zone IDs corresponding to GMT-7:00, you'll get back two time zone IDs:
"America/Denver," which corresponds to Mountain Standard Time in the winter and
Mountain Daylight Time in the summer, and "America/Phoenix", which corresponds to
Mountain Standard Time year-round, even in the summer.
<P>
The caller owns the list that is returned, but does not own the strings contained
in that list.  Delete the array, but DON'T delete the elements in the array.


<DL><DT><B>Returns:</B><DD>An array of UnicodeString pointers, where each UnicodeString is
a time zone ID for a time zone with the given GMT offset.  If
there is no timezone that matches the GMT offset
specified, NULL is returned.
<DT><B>Parameters:</B><DD><B>rawOffset</B> -   An offset from GMT in milliseconds.
<br><B>numIDs</B> -      Receives the number of items in the array that is returned.
<br></DL><P>
<A NAME="createAvailableIDs">
<A NAME ="DOC.48.3">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  const  <!1><A HREF="UnicodeString.html">UnicodeString</A>**  const  createAvailableIDs(int32_t& numIDs)</B></TT>
<DD>
Returns a list of all time zone IDs supported by the TimeZone class (i.e., all
IDs that it's legal to pass to createTimeZone()).  The caller owns the list that
is returned, but does not own the strings contained in that list.  Delete the array,
but DON'T delete the elements in the array.


<DL><DT><B>Returns:</B><DD>An array of UnicodeString pointers, where each is a time zone ID
supported by the TimeZone class.
<DT><B>Parameters:</B><DD><B>numIDs</B> -   Receives the number of zone IDs returned.
<br></DL><P>
<A NAME="createDefault">
<A NAME ="DOC.48.4">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>*  createDefault(void)</B></TT>
<DD>
Creates a new copy of the default TimeZone for this host. Unless the default time
zone has already been set using adoptDefault() or setDefault(), the default is
determined by querying the system using methods in TPlatformUtilities. If the
system routines fail, or if they specify a TimeZone or TimeZone offset which is not
recognized, the TimeZone indicated by the ID kLastResortID is instantiated
and made the default.


<DL><DT><B>Returns:</B><DD>A default TimeZone. Clients are responsible for deleting the time zone
object returned.
</DL><P>
<A NAME="adoptDefault">
<A NAME ="DOC.48.5">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  void  adoptDefault(<!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>* zone)</B></TT>
<DD>
Sets the default time zone (i.e., what's returned by getDefault()) to be the
specified time zone.  If NULL is specified for the time zone, the default time
zone is set to the default host time zone.  This call adopts the TimeZone object
passed in; the clent is no longer responsible for deleting it.


<DL><DT><B>Parameters:</B><DD><B>zone</B> -   A pointer to the new TimeZone object to use as the default.<br></DL><P>
<A NAME="setDefault">
<A NAME ="DOC.48.6">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  void  setDefault(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& zone)</B></TT>
<DD>
Same as adoptDefault(), except that the TimeZone object passed in is NOT adopted;
the caller remains responsible for deleting it.


<DL><DT><B>Parameters:</B><DD><B>zone</B> -   The given timezone.<br></DL><P>
<A NAME="operator==">
<A NAME ="DOC.48.7">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  operator==(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& that) const </B></TT>
<DD>
Returns true if the two TimeZones are equal.  (The TimeZone version only compares
IDs, but subclasses are expected to also compare the fields they add.)


<DL><DT><B>Returns:</B><DD>True if the given TimeZone is equal to this TimeZone; false
otherwise.
<DT><B>Parameters:</B><DD><B>that</B> -   The TimeZone object to be compared with.
<br></DL><P>
<A NAME="operator!=">
<A NAME ="DOC.48.8">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> bool_t  operator!=(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& that) const </B></TT>
<DD>
Returns true if the two TimeZones are NOT equal; that is, if operator==() returns
false.


<DL><DT><B>Returns:</B><DD>True if the given TimeZone is not equal to this TimeZone; false
otherwise.
<DT><B>Parameters:</B><DD><B>that</B> -   The TimeZone object to be compared with.
<br></DL><P>
<A NAME="getOffset">
<A NAME ="DOC.48.9">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  int32_t  getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t millis, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
Returns the TimeZone's adjusted GMT offset (i.e., the number of milliseconds to add
to GMT to get local time in this time zone, taking daylight savings time into
account) as of a particular reference date.  The reference date is used to determine
whether daylight savings time is in effect and needs to be figured into the offset
that is returned (in other words, what is the adjusted GMT offset in this time zone
at this particular date and time?).  For the time zones produced by createTimeZone(),
the reference data is specified according to the Gregorian calendar, and the date
and time fields are in GMT, NOT local time.


<DL><DT><B>Returns:</B><DD>The offset in milliseconds to add to GMT to get local time.
<DT><B>Parameters:</B><DD><B>era</B> -         The reference date's era
<br><B>year</B> -        The reference date's year
<br><B>month</B> -       The reference date's month (0-based; 0 is January)
<br><B>day</B> -         The reference date's day-in-month (1-based)
<br><B>dayOfWeek</B> -   The reference date's day-of-week (1-based; 1 is Sunday)
<br><B>millis</B> -      The reference date's milliseconds in day, UTT (NOT local time).
<br></DL><P>
<A NAME="getOffset">
<A NAME ="DOC.48.10">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  int32_t  getOffset(uint8_t era, int32_t year, int32_t month, int32_t day, uint8_t dayOfWeek, int32_t milliseconds, int32_t monthLength, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
Gets the time zone offset, for current date, modified in case of
daylight savings. This is the offset to add *to* UTC to get local time.

<DL><DT><B>Returns:</B><DD>the offset to add *to* GMT to get local time.
<DT><B>Parameters:</B><DD><B>era</B> -  the era of the given date.
<br><B>year</B> -  the year in the given date.
<br><B>month</B> -  the month in the given date.
Month is 0-based. e.g., 0 for January.
<br><B>day</B> -  the day-in-month of the given date.
<br><B>dayOfWeek</B> -  the day-of-week of the given date.
<br><B>milliseconds</B> -  the millis in day in <em>standard</em> local time.
<br><B>monthLength</B> -  the length of the given month in days.
<br></DL><P>
<A NAME="setRawOffset">
<A NAME ="DOC.48.11">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  void  setRawOffset(int32_t offsetMillis)</B></TT>
<DD>
Sets the TimeZone's raw GMT offset (i.e., the number of milliseconds to add
to GMT to get local time, before taking daylight savings time into account).


<DL><DT><B>Parameters:</B><DD><B>offsetMillis</B> -   The new raw GMT offset for this time zone.<br></DL><P>
<A NAME="getRawOffset">
<A NAME ="DOC.48.12">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  int32_t  getRawOffset(void) const </B></TT>
<DD>
Returns the TimeZone's raw GMT offset (i.e., the number of milliseconds to add
to GMT to get local time, before taking daylight savings time into account).


<DL><DT><B>Returns:</B><DD>The TimeZone's raw GMT offset.
</DL><P>
<A NAME="getID">
<A NAME ="DOC.48.13">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getID(<!1><A HREF="UnicodeString.html">UnicodeString</A>& ID) const </B></TT>
<DD>
Fills in "ID" with the TimeZone's ID.


<DL><DT><B>Returns:</B><DD>"ID"
<DT><B>Parameters:</B><DD><B>ID</B> -   Receives this TimeZone's ID.
<br></DL><P>
<A NAME="setID">
<A NAME ="DOC.48.14">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> void  setID(const <!1><A HREF="UnicodeString.html">UnicodeString</A>& ID)</B></TT>
<DD>
Sets the TimeZone's ID to the specified value.  This doesn't affect any other
fields (for example, if you say<
blockquote><pre>
.     TimeZone* foo = TimeZone::createTimeZone("America/New_York");
.     foo.setID("America/Los_Angeles");
</pre></blockquote>
the time zone's GMT offset and daylight-savings rules don't change to those for
Los Angeles.  They're still those for New York.  Only the ID has changed.)


<DL><DT><B>Parameters:</B><DD><B>ID</B> -   The new timezone ID.<br></DL><P>
<A NAME="EDisplayType">
<A NAME ="DOC.48.29">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  enum  EDisplayType</B></TT>
<DD>
Enum for use with getDisplayName
<DL></DL><P>
<A NAME="getDisplayName">
<A NAME ="DOC.48.15">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayName(<!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Returns a name of this time zone suitable for presentation to the user
in the default locale.
This method returns the long name, not including daylight savings.
If the display name is not available for the locale,
then this method returns a string in the format
<code>GMT[+-]hh:mm</code>.

<DL><DT><B>Returns:</B><DD>the human-readable name of this time zone in the default locale.
</DL><P>
<A NAME="getDisplayName">
<A NAME ="DOC.48.16">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayName(const Locale& locale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Returns a name of this time zone suitable for presentation to the user
in the specified locale.
This method returns the long name, not including daylight savings.
If the display name is not available for the locale,
then this method returns a string in the format
<code>GMT[+-]hh:mm</code>.

<DL><DT><B>Returns:</B><DD>the human-readable name of this time zone in the given locale
or in the default locale if the given locale is not recognized.
<DT><B>Parameters:</B><DD><B>locale</B> -  the locale in which to supply the display name.
<br></DL><P>
<A NAME="getDisplayName">
<A NAME ="DOC.48.17">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayName(bool_t daylight, <!2><A HREF="TimeZone.html#DOC.48.29">EDisplayType</A> style, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Returns a name of this time zone suitable for presentation to the user
in the default locale.
If the display name is not available for the locale,
then this method returns a string in the format
<code>GMT[+-]hh:mm</code>.

<DL><DT><B>Returns:</B><DD>the human-readable name of this time zone in the default locale.
<DT><B>Parameters:</B><DD><B>daylight</B> -  if true, return the daylight savings name.
<br><B>style</B> -  either <code>LONG</code> or <code>SHORT</code>
<br></DL><P>
<A NAME="getDisplayName">
<A NAME ="DOC.48.18">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!1><A HREF="UnicodeString.html">UnicodeString</A>&  getDisplayName(bool_t daylight, <!2><A HREF="TimeZone.html#DOC.48.29">EDisplayType</A> style, const Locale& locale, <!1><A HREF="UnicodeString.html">UnicodeString</A>& result) const </B></TT>
<DD>
Returns a name of this time zone suitable for presentation to the user
in the specified locale.
If the display name is not available for the locale,
then this method returns a string in the format
<code>GMT[+-]hh:mm</code>.

<DL><DT><B>Returns:</B><DD>the human-readable name of this time zone in the given locale
or in the default locale if the given locale is not recognized.
<DT><B>Parameters:</B><DD><B>daylight</B> -  if true, return the daylight savings name.
<br><B>style</B> -  either <code>LONG</code> or <code>SHORT</code>
<br><B>locale</B> -  the locale in which to supply the display name.
<br></DL><P>
<A NAME="useDaylightTime">
<A NAME ="DOC.48.19">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  useDaylightTime(void) const </B></TT>
<DD>
Queries if this time zone uses daylight savings time
<DL><DT><B>Returns:</B><DD>true if this time zone uses daylight savings time,
false, otherwise.
</DL><P>
<A NAME="inDaylightTime">
<A NAME ="DOC.48.20">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  inDaylightTime(<!1><A HREF="UDate.html">UDate</A> date, <!2><A HREF="#DOC.320">UErrorCode</A>& status) const </B></TT>
<DD>
Queries if the given date is in daylight savings time in
this time zone
<DL><DT><B>Returns:</B><DD>true if the given date is in daylight savings time,
false, otherwise.
<DT><B>Parameters:</B><DD><B>date</B> -  the given UDate.
<br></DL><P>
<A NAME="hasSameRules">
<A NAME ="DOC.48.21">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  bool_t  hasSameRules(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& other) const </B></TT>
<DD>
Returns true if this zone has the same rule and offset as another zone.
That is, if this zone differs only in ID, if at all.

<DL><DT><B>Returns:</B><DD>true if the given zone is the same as this one,
with the possible exception of the ID
<DT><B>Parameters:</B><DD><B>other</B> -  the <code>TimeZone</code> object to be compared with
<br></DL><P>
<A NAME="clone">
<A NAME ="DOC.48.22">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>*  clone(void) const </B></TT>
<DD>
Clones TimeZone objects polymorphically. Clients are responsible for deleting
the TimeZone object cloned.


<DL><DT><B>Returns:</B><DD>A new copy of this TimeZone object.
</DL><P>
<A NAME="getStaticClassID">
<A NAME ="DOC.48.23">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  <!1><A HREF="UClassID.html">UClassID</A>  getStaticClassID(void)</B></TT>
<DD>
Return the class ID for this class.  This is useful only for
comparing to a return value from getDynamicClassID().  For example:
<pre>
.   Base* polymorphic_pointer = createPolymorphicObject();
.   if (polymorphic_pointer->getDynamicClassID() ==
.       Derived::getStaticClassID()) ...
</pre>

<DL><DT><B>Returns:</B><DD>The class ID for all objects of this class.
</DL><P>
<A NAME="getDynamicClassID">
<A NAME ="DOC.48.24">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> virtual  <!1><A HREF="UClassID.html">UClassID</A>  getDynamicClassID(void) const </B></TT>
<DD>
Returns a unique class ID POLYMORPHICALLY. Pure virtual method. This method is to
implement a simple version of RTTI, since not all C++ compilers support genuine
RTTI. Polymorphic operator==() and clone() methods call this method.
<P>
Concrete subclasses of TimeZone must implement getDynamicClassID() and also a
static method and data member:
<pre>
.     static UClassID getStaticClassID() { return (UClassID)&fgClassID; }
.     static char fgClassID;
</pre>

<DL><DT><B>Returns:</B><DD>The class ID for this object. All objects of a given class have the
same class ID. Objects of other classes have different class IDs.
</DL><P>
<A NAME="TimeZone">
<A NAME ="DOC.48.25">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  TimeZone()</B></TT>
<DD>
Default constructor.  ID is initialized to the empty string.
<DL></DL><P>
<A NAME="TimeZone">
<A NAME ="DOC.48.30">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B>  TimeZone(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& source)</B></TT>
<DD>
Copy constructor
<DL></DL><P>
<A NAME="operator=">
<A NAME ="DOC.48.31">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>&  operator=(const <!2><A HREF="TimeZone.html#DOC.48.30">TimeZone</A>& right)</B></TT>
<DD>
Default assignment operator
<DL></DL><P>
<A NAME="deleteTimeZone">
<A NAME ="DOC.48.32">
<DT><IMG BORDER=0 SRC=icon2.gif><TT><B> static  void  deleteTimeZone(void*)</B></TT>
<DD>
Delete function for fgHashtable
<DL></DL><P></DL>
<hr>
<DL><DT><B>Direct child classes:
</B><DD><A HREF="SimpleTimeZone.html"> SimpleTimeZone </A><br>
</DL>
<DL></DL><P><I><A HREF="aindex.html"> alphabetic index</A></I>  <I><A HREF="HIER.html"> hierarchy of classes</A></I><P><hr>
<A HREF="http://www.zib.de/Visual/software/doc++/index.html"><IMG BORDER=0 ALIGN=RIGHT SRC=logo.gif></A>
<P Align=Center><I>this page has been generated automatically by doc++</I>
<P Align=Center><I>(c)opyright by <A HREF="http://www.zib.de/zoeckler/"> Malte  Z&ouml;ckler</A>, <A HREF="mailto:wunderling@zib.de"> Roland Wunderling </A><br>contact: <A HREF="mailto:doc++@zib.de"> doc++@zib.de</a></I>
</BODY>
