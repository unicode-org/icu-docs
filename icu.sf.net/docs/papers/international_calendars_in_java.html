<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<title>International Calendars in Java</title>
</head>

<body LINK="#0000ff" VLINK="#800080">
<font FACE="Arial" SIZE="5"><b>

<p ALIGN="CENTER">International Calendars in Java</p>
</b></font> 
<p ALIGN="CENTER"> by <a HREF="#about_author">Laura Werner</a></p>
<p ALIGN="CENTER">IBM Center for Java Technology<br>
Cupertino, California</p>

<p ALIGN="CENTER">&nbsp;</p>

<p>Over the last few years, many programmers have had a growing awareness of international 
issues, both in Java and in other languages. The software industry and the economy as a 
whole are becoming much more global, and there is an increasing need for applications that 
can function properly in more than one language and country. In addition, many programming 
toolkits such as the Java Class Libraries, the Win32 and Macintosh API’s, POSIX, etc., 
have fairly extensive international support built in, which makes writing an 
internationalized application much easier than it used to be.</p>

<p>While these API’s are all designed differently, at their core they provide a similar 
set of functionality. There are character converters that transform Unicode to legacy code 
pages, and vice-versa. There are sorting routines or collator objects that can be used for 
language-sensitive string comparison. There are facilities for word- and line-break 
detection in different languages. Finally, there are ways of formatting numbers, dates, 
times, and currencies for different languages and countries.</p>

<p>The date, time, and number formatters are necessary because most countries 
  have different conventions for displaying this data. For example, an American 
  English speaker would write the date 1/1/2000 AD (or 1/1/2000 CE) as &quot;Saturday, 
  January 1, 2000.&quot; A British English speaker might write &quot;Saturday, 
  1 January 2000&quot; instead. And a French speaker would write &quot;samedi 
  1 janvier 2000&quot;. Any self-respecting international library can handle this 
  for you. In Java, you’d use the class <code>java.text.DateFormat</code> to 
  do the work.</p>

<p>Still, I suspect that even today a lot of programmers would look at the title of this 
article: &quot;International Calendars&quot;, and wonder just what those two words have to 
do with each other. Dates, sure. But calendars? Though the topics might not seem linked at 
first, the connection is fairly obvious once you think about it. </p>

<p>Consider what should happen when a Hebrew speaker in Israel is using your program. 
  The same date we discussed above, 1/1/2000 AD, would be displayed as &quot;<font
FACE="Bitstream Cyberbit" SIZE="2">תבש 23 תבט 5760</font><font FACE="Arial" SIZE="2">&quot; 
  or &quot;</font><font FACE="Bitstream Cyberbit" SIZE="2">Saturday 23 Tevet 5760</font>&quot;. 
  Not only are the strings different, the <i>numbers</i> are as well. </p>

<p>Though it comes as a surprise to many Americans, the official calendar in Israel 
  is the Hebrew calendar, not the Gregorian one that we use in most of the Western 
  world. The Hebrew calendar, as well as many others such as Hijri (Islamic), 
  Hindu, Buddhist, and Japanese, all number the years differently. Many of them, 
  including the Hebrew, also have a different system for calculating months, which 
  leads to 1/1/2000 AD being &quot;<font
FACE="Bitstream Cyberbit" SIZE="2">תבש 23&quot;</font>, or &quot;Tevet 23&quot;, 
  rather than January 1. </p>

<p>All of this means that internationalization of dates and times requires more than just 
a different table of strings for each language. A program that naïvely assumes that the 
Gregorian calendar applies everywhere will be hopelessly wrong in countries that use a 
different calendar rather than just a different language.</p>

<p>In this article, I’ll discuss the Java Class Library facilities that allow you to 
manipulate and display dates and times. Next, I’ll show how you can extend the Java 
calendar classes to support calendars that are not built in to the JDK. Finally, I’ll 
discuss some free classes from IBM that support the Buddhist, Hebrew, Hijri, and Japanese 
Imperial calendars. </p>
<font FACE="Arial" SIZE="4"><b> 
<p><a NAME="Date">A brief history</a></p>
</b></font> 
<p>First, let me jump back to JDK 1.0 for a moment. The first release of Java 
  had relatively poor support for international dates and times, with <code>java.util.Date</code><font
FACE="Arial" SIZE="2"> and its </font><code>toString</code><font FACE="Arial" SIZE="2"> 
  method the only real tools at your disposal. The situation in the rest of Java 
  was similar. It had the beginnings of international support, because a Java 
  </font><code>char</code> is stored as a Unicode character. But that's all. You 
  couldn't enter or display non-Latin characters, and there were no facilities 
  for language-sensitive formatting, sorting, and so on.</p>

<p>The management of Sun and IBM found a way to fix this problem for JDK 1.1. Java was 
missing international support. But IBM’s Taligent subsidiary had great international 
technology, talented engineers -- including Dr. Mark Davis, president of the Unicode 
Consortium -- and a location about 100 yards away from Sun’s JavaSoft division in 
Cupertino, California. Thus a partnership was born. IBM arranged for Taligent’s Text and 
International group to contribute international classes into Sun’s JDK in order to make 
Java powerful enough for real-world business applications.</p>

<p>Taligent, in collaboration with Sun's internationalization engineers, provided 
  the new <code>java.text</code><font
FACE="Arial" SIZE="2"> package, plus a number of new classes in </font><code>java.util</code><font
FACE="Arial" SIZE="2">. This included the date- and time-related classes </font><code>DateFormat</code><font
FACE="Arial" SIZE="2">, </font><code>SimpleDateFormat</code><font FACE="Arial" SIZE="2">, 
  </font><code>Calendar</code><font
FACE="Arial" SIZE="2">, </font><code>GregorianCalendar</code><font FACE="Arial" SIZE="2">, 
  </font><code>TimeZone</code><font FACE="Arial" SIZE="2">, and </font><code>SimpleTimeZone</code><font
FACE="Arial" SIZE="2">. I’ll discuss these classes in turn, starting with the 
  old </font><code>Date</code> class.</p>
<font FACE="Arial" SIZE="4"><b> 
<p>Date</a></p>
</b></font> 
<p>The <code>java.util.Date</code><font FACE="Arial" SIZE="2"> class has been 
  part of Java since JDK 1.0. Each instance of </font><code>Date</code><font FACE="Arial"
SIZE="2"> represents a particular instant in time, stored as a </font><code>long</code>
number of milliseconds since January 1, 1970 AD, 00:00 GMT. To construct a Date, 
you would typically use the constructor: 
<dir>
  <dir> 
    <pre>Date(int year, int month, int date)</pre>
  </dir>
</dir>
<p>or one of its variants that takes additional arguments such as hours, minutes, 
  seconds, etc. In addition, there is a constructor whose argument is a <code>String</code> 
  such as &quot;Sat Aug 12 1995 13:30:00 GMT&quot;. </p>

<p>In JDK 1.0, and even today, these methods all work as advertised. If you execute the 
following code:

<dir>
  <dir> 
    <pre>Date d = new Date(99, 1, 1);

String s = d.toString();</pre>
  </dir>
</dir>
<p>the value of <code>s</code> will be &quot;Mon Feb 1 00:00:00 PDT 1999&quot;.</p>

<p>There are a few obvious problems here. The most blatant is that the year argument to 
the constructor is only two digits, with 1900 assumed to be the origin. This is a huge Y2K 
problem, because there’s no way to specify a date before 1900 or after 1999. There’s 
also no obvious way to fix this. Sun can’t change the meaning of the first parameter, 
because that would break existing code. Adding a Y2K-safe override would be difficult too, 
since that would require the overload to have different argument types.</p>

<p>The next problem is the <code>toString</code> method. The JDK 1.0 documentation 
  stated that the string it returns was always of the form &quot;Sat Aug 12 1995 
  13:30:00 GMT&quot;, with US English day and names and time zone abbreviations. 
  Again, there was no way to change this in a later release. Once the documentation, 
  which is effectively the specification for the Java Class Libraries, guarantees 
  a certain behavior, it can't be changed without the danger of breaking existing 
  applications.</p>

<p>Finally, take another look at the Date constructor in the code snippet above:

<dir>
  <dir> 
    <pre>Date d = new Date(99, 1, 1);</pre>
  </dir>
</dir>
<p>Notice that we passed in &quot;1&quot; for the month and day, but the resulting date 
was February 1<sup>st</sup>. Since arrays in Java and C are 0-based, and since month 
numbers are often used as an index into an array of strings, the original designers of 
Java decided to make the month numbers 0-based. So January is month 0, February is month 
1, and so on. Unfortunately most people, even programmers, think of January as the 1<sup>st</sup> 
month of the year, not the 0<sup>th</sup>, so this choice has led to a great deal of 
confusion.</p>

<p>When it was time to work on JDK 1.1, we were faced with a decision: What should 
  we do about <code>Date</code>? Because of the problems I discussed above, IBM 
  and Sun decided that Date was so broken that it couldn't be fixed and decided 
  to replace it instead. But since Date was trying to do so many different things 
  -- date formatting, calendar calculations, and time zones, we decided to replace 
  it with several different classes.</p>
<font FACE="Arial" SIZE="4"><b> 
<p><a NAME="DateFormat">Date Format</a>ting</p>
</b></font> 
<p>The first of these new classes is <code>DateFormat</code><font FACE="Arial"
SIZE="2">. As I mentioned above, </font><code>Date's</code><font FACE="Arial" SIZE="2"> 
  String constructor and its </font><code>toString</code><font FACE="Arial" SIZE="2"> 
  method had two problems: the strings were in a fixed format and they were always 
  in English. </font><code>DateFormat</code> solves both of these problems.</p>

<p>The job DateFormat and its concrete subclass SimpleDateFormat is to convert from a Date 
object to a String and vice-versa, and to do it properly for all of the locales that Java 
supports. To format a date and time for the current locale, the code is fairly simple:

<dir>
  <dir> 
    <pre>Date d = new Date(1999, 0, 1);

DateFormat f = DateFormat.getDateTimeInstance(

                               DateFormat.FULL,  // Date style

                               DateFormat.FULL); // Time style

String s = s.format(d);</pre>
  </dir>
</dir>
<font FACE="Arial" SIZE="2">

<p>If you run this on a US English system, the result will be &quot;Friday, January 1, 
1999 00:00:00 AM PST&quot;.</p>

<p>So far, this just seems like an expensive way of spelling <code>Date.toString.</code>
But you get something for the extra effort: internationalization. If you change 
the second line of code to this: 
<dir>
  <dir> 
    <pre>DateFormat f = DateFormat.getDateTimeInstance(DateFormat.FULL,

                                              DateFormat.FULL,

                                              Locale.FRANCE);</pre>
  </dir>
</dir>
<font FACE="Arial" SIZE="2">

<p>the result will appear in French: &quot;venredi 1 janvier 1999 00:00:00 
GMT-08:00&quot;. </p>
</font> 
<p>DateFormat<font FACE="Arial" SIZE="2"> also solves the fixed-format problem. 
  The examples above uses a &quot;</font><code>FULL</code><font FACE="Arial" SIZE="2">&quot; 
  date/time formatter. If you want to be a bit more concise, you can use </font><code>DateFormat.MEDIUM</code><font
FACE="Arial" SIZE="2">, which gives the result &quot;Jan 1, 1999 00:00:00 AM&quot; 
  for English. Similarly, </font><code>DateFormat.SHORT</code> gives &quot;1/1/99 
  00:00 AM.&quot;</p>

<p>If you want to see just the date in your output, not the time, the solution 
  is also simple -- call <code>getDateInstance</code><font FACE="Arial" SIZE="2"> 
  instead of </font><code>getDateTimeInstance</code>
: 
<dir>
  <dir> 
    <pre>Date d = new Date(99, 0, 1);

DateFormat f = DateFormat.getDateInstance(DateFormat.FULL);

String s = s.format(d);</pre>
  </dir>
</dir>
<p>and the result will be &quot;January 1, 1999.&quot;</p>

<p>Now, remember the <code>Date</code><font FACE="Arial" SIZE="2"> constructor 
  that takes a </font><code>String</code><font FACE="Arial" SIZE="2">. That constructor 
  had the same problems as </font><code>toString</code>
, but in reverse: it required a fixed format and it assumed the string would be 
in English. DateFormat solves these problems too, because it doesn’t just format 
dates; it parses them. For example, consider the following code: 
<dir>
  <dir> 
    <pre>DateFormat f = DateFormat.getDateInstance(DateFormat.FULL,

                                          Locale.FRANCE);

Date d = f.parse(&quot;venredi 1 janvier 1999&quot;);</pre>
  </dir>
</dir>
<p>The <code>Date</code><font FACE="Arial" SIZE="2"> object, </font><code>d</code>, 
  will end up referring to 1/1/1999. All of the other points I discussed above 
  apply to parsing as well as to formatting: you can request a particular locale, 
  choose shorter or longer formats, etc.</p>
<font FACE="Arial" SIZE="4"><b> 
<p><a NAME="TimeZone">TimeZone</a></p>
</b></font> 
<p>Many of the <code>DateFormat</code><font FACE="Arial" SIZE="2"> examples I 
  showed above included time zones in their output. In JDK 1.0, all of Java's 
  time zone logic was baked into </font><code>Date.toString</code><font FACE="Arial" SIZE="2">. 
  It assumed that you always wanted dates displayed using the current default 
  time zone, and that you wanted the US English abbreviations for the time zone 
  names. This was fixed in JDK 1.1 as well, with the addition of the new class 
  </font><code>java.util.TimeZone</code>.</p>
<p>TimeZone<font FACE="Arial" SIZE="2"> and its concrete subclass </font><code>SimpleTimeZone</code> 
  are relatively low-level classes that encapsulate the relationship between local 
  clock time and Greenwich Mean Time. You can use them to convert from GMT to 
  local time and back as well as to determine whether daylight savings time is 
  in effect. The other classes use TimeZone in their time-related calculations, 
  and many of them expose the time zone as a property that you can get and set.</p>

<p>Here's a simple example. Say that you want to display the same date we've been using in 
all of our examples, but that you want to force it to be displayed in GMT, regardless of 
the time zone you're running in. The code would look like this:

<dir>
  <dir> 
    <pre>Date d = new Date(99, 0, 1);

DateFormat f = DateFormat.getDateTimeInstance(DateFormat.FULL);

f.setTimeZone(TimeZone.getTimeZone(&quot;GMT&quot;));

String s = s.format(d);</pre>
  </dir>
</dir>
<p>The formatter will now use GMT, so the result will be something like &quot; Friday, 
January 1, 1999 08:00:00 AM GMT &quot;. Note that the time zone is different, and that the 
time of day is 08:00, since GMT is 8 hours ahead of PST.</p>

<p>In JDK 1.1, there was one problem with the way that DateFormat used TimeZone. Let's 
jump back to this example for a moment:

<dir>
  <dir> 
    <pre>Date d = new Date(99, 0, 1);

DateFormat f = DateFormat.getDateTimeInstance(DateFormat.FULL,

                                              DateFormat.FULL,

                                              Locale.FRANCE);

String s = s.format(d);</pre>
  </dir>
</dir>
<p>As I mentioned above, you'd expect the result to be &quot;venredi 1 janvier 
  1999 00:00:00 GMT-08:00&quot; if you were running your computer in the Pacific 
  time zone. However, in JDK 1.1.5 and earlier, the result would actually be &quot;venredi 
  1 janvier 1999 09:00:00 CEST&quot;. CEST is &quot;Central European Standard 
  Time&quot;, the time zone used in Paris, which is one hour ahead of GMT. Rather 
  than using the system's default time zone, <code>DateFormat</code><font FACE="Arial" SIZE="2"> 
  was using the first time zone it could find for the locale you requested, in 
  this case </font><code>Locale.FRANCE</code>. This caused no end of confusion, 
  since it was almost never what programmers expected.</p>

<p>Fortunately, there was a simple workaround for this problem. To force a DateFormat to 
use the default time zone, you just do this:

<dir>
  <dir> 
    <pre>DateFormat f = . . . .;

f.setTimeZone(TimeZone.getDefault());</pre>
  </dir>
</dir>
<p>In JDK 1.1.6 we fixed this problem, and a newly-created DateFormat object always 
  uses the default time zone. If you need a different time zone, you can always 
  call <code>DateFormat.setTimeZone</code> to request the one you want.</p>
<font FACE="Arial" SIZE="4"><b> 
<p><a NAME="Calendar">Calendar</a></p>
</b></font> 
<p>Now that I've given a quick tour of the other date-related classes that were 
  new to JDK 1.1, I can go on to the meat of this article: <code>java.util.Calendar</code><font
FACE="Arial" SIZE="2">. As an introduction, let's revisit a code snippet from 
  our discussion of </font><code>Date</code>
: 
<dir>
  <dir> 
    <pre>Date d = new Date(99, 1, 1);</pre>
  </dir>
</dir>
<p>In this example, the constructor arguments are interpreted in only one way: 
  February 1, 1999 AD, in the Gregorian calendar. There's a similar problem with 
  Date methods such as <code>getDay</code><font
FACE="Arial" SIZE="2">, </font><code>getMonth</code><font FACE="Arial" SIZE="2">, 
  </font><code>getYear</code>, etc. But as I described in the introduction, some 
  countries use different calendars: Hebrew, Hijri, or whatever. A fully-internationalized 
  Java application needs to be able to support multiple calendar systems, not 
  just the Gregorian one.</p>

<p>Since the Java Class Libraries are object-oriented, the obvious solution to 
  this problem is to create an abstract class that represents a generic calendar, 
  with concrete subclasses for specific calendar systems. And that's just what 
  we did. JDK 1.1. included a new abstract class, <code>java.util.Calendar</code><font FACE="Arial" SIZE="2">, 
  which provides a generic API for calendar operations. It also included one concrete 
  subclass, which as you might guess is </font><code>GregorianCalendar</code>.</p>

<p>Calendar has a number of abstract methods that parallel the old, deprecated get methods 
of Date. For example, imagine that you want to find out what year it is. With the old Date 
API, the code would look like this:

<dir>
  <dir> 
    <pre>int year = new Date().getYear();</pre>
  </dir>
</dir>
<p>With Calendar, you do this instead:

<dir>
  <dir> 
    <pre>int year = Calendar.getInstance().get(Calendar.MONTH);</pre>
  </dir>
</dir>
<p>The call to <code>getInstance</code><font FACE="Arial" SIZE="2"> creates a 
  </font><code>Calendar</code><font
FACE="Arial" SIZE="2"> that is appropriate for the current locale, and the call 
  to </font><code>get</code><font
FACE="Arial" SIZE="2"> returns the current value of the calendar's </font><code>MONTH</code><font
FACE="Arial" SIZE="2"> field. Calendar provides constants for about fifteen fields, 
  including </font><code>YEAR</code><font FACE="Arial" SIZE="2">, </font><code>DAY_OF_MONTH</code><font
FACE="Arial" SIZE="2">, </font><code>DAY_OF_WEEK</code><font FACE="Arial" SIZE="2">, 
  </font><code>WEEK_OF_YEAR</code>, and many others. These constants are all interpreted 
  in terms of the calendar system that your Calendar object represents, so if 
  you have a Hebrew calendar object, you'll get the Hebrew month, not the Gregorian 
  one.</p>

<p>If you're wondering how this works, remember that Calendar is an abstract class. 
  Each time that get is called, the calendar checks to see if the fields are up 
  to date. If they are not, it calls the abstract, protected method <code>computeFields</code><font
FACE="Arial" SIZE="2">. Each subclass overrides this method to perform the calculations 
  appropriate for that calendar system. For example, </font><code>GregorianCalendar</code><font
FACE="Arial" SIZE="2"> has a </font><code>computeFields</code> method that performs 
  the standard Gregorian calculations.</p>
<p>Calendar.get
replaces the deprecated get methods on Date, but what about the constructor? That 
functionality is provided by constructors on the concrete Calendar subclasses. 
If you want to construct a Calendar set to January 1, 2000, you write: 
<dir>
  <dir> 
    <pre>Calendar c = new GregorianCalendar(2000, Calendar.JANUARY, 1);</pre>
  </dir>
</dir>
<p>This solves the problem neatly. You know exactly which calendar system will be used to 
interpret the year, month, and day that you've specified: the calendar that you're 
instantiating. If someone has input a Hebrew date, and you have a HebrewCalendar class, 
the code is fairly obvious:

<dir>
  <dir> 
    <pre>Calendar c = new HebrewCalendar(5760, HebrewCalendar.TEVET, 23);</pre>
  </dir>
</dir>
<font FACE="Arial" SIZE="4"><b>

<p>January is still Zero</p>
</b></font> 
<p>You would think that when we deprecated most of Date and added the new Calendar class, 
we would have fixed Date's biggest annoyance: the fact that January is month 0. We 
certainly should have, but unfortunately we didn't. We were afraid that programmers would 
be confused if Date used zero-based months and Calendar used one-based months. And a few 
programmers probably would have been. But in hindsight, the fact that Calendar is still 
zero-based has caused an enormous amount of confusion, and it was probably the biggest 
single mistake in the Java international API's.</p>

<p>When you're using Calendar or any of its subclasses, it's usually best not to use raw 
numbers in Calendar calls unless you just can't avoid it. Instead of writing code like 
this:

<dir>
  <dir> 
    <pre>Calendar c = new GregorianCalendar(2000, 0, 1);</pre>
  </dir>
</dir>
<p>write this instead:

<dir>
  <dir> 
    <pre>Calendar c = new GregorianCalendar(2000, Calendar.JANUARY, 1);</pre>
  </dir>
</dir>
<font FACE="Arial" SIZE="2">

<p>This takes a bit longer to type, but it's a lot less error-prone.</p>
</font><font FACE="Arial" SIZE="4"><b>

<p>Add and Roll</p>
</b></font> 
<p>One aspect of Calendars that wasn't addressed at all in <code>Date</code><font
FACE="Arial" SIZE="2"> was calendar <i>manipulation</i>. For example, imagine 
  that you want to determine what the date will be one month in the future. With 
  the old API, you had to do an awful lot of work on your own: call </font><code>getMonth</code><font
FACE="Arial" SIZE="2">, </font><code>getYear</code><font FACE="Arial" SIZE="2">, 
  and </font><code>getDate</code>, add one to the month, see if it wrapped to 
  a new year, make sure the day of the month is still in bounds (remembering those 
  leap years!) and so on. Not only is this a hassle, it's not internationalized. 
  Other calendar systems have a different number of days per month, different 
  (and possibly variable) months per year, different leap year calculations, and 
  so on.</p>

<p>Calendar and its subclasses solve this problem for you, with their <code>add</code><font
FACE="Arial" SIZE="2"> and </font><code>roll</code>
methods. If you want to add one month to the current date, you only need two lines 
of code: 
<dir>
  <dir> 
    <pre>Calendar c = Calendar.getInstance();

c.add(Calendar.MONTH, 1);</pre>
  </dir>
</dir>
<p>As you'd expect, the add method adds the given number to the field that you specify. It 
knows about all of the rules for the calendar system, so code like this will work 
properly.

<dir>
  <dir> 
    <pre>GregorianCalendar c = new GregorianCalendar(1999, Calendar.JULY, 29);

c.add(Calendar.MONTH, 7);

String s = DateFormat.getInstance().format(c.getTime());</pre>
  </dir>
</dir>
<p>The result of this calculation will be February 29, 2000. <code>GregorianCalendar.add</code> 
  knows that when the month passes 11 (December) it should roll back to 0. It 
  also knows that February 29, 2000 is a valid date, using the complicated rules 
  that it <i>is</i> a leap year because it's divisible by four, except it <i>isn't</i> 
  because it's divisible by 100, except it <i>is</i> because it's divisible by 
  400.</p>

<p>Closely related to <code>add</code><font FACE="Arial" SIZE="2"> is the </font><code>roll</code>
method. This method is handy when you want to implement a user interface that 
&quot;rolls&quot; from the end of a month back to the beginning of the same month, 
or to do the same thing for weeks or years. The usage is almost identical to add: 
<dir>
  <dir> 
    <pre>GregorianCalendar c = new GregorianCalendar(1999, Calendar.JULY, 29);

c.roll(Calendar.DAY_OF_MONTH, 6);</pre>
  </dir>
</dir>
<font FACE="Arial" SIZE="2">

<p>The result will be July 4, 1999. If roll just added 7 to 29 it would get 33, which is 
past the end of July. Add would handle this by continuing on into August, ending up on 
August 4<sup>th</sup>. But roll is different. It wraps back to the beginning of July and 
end up on July 4<sup>th</sup>.</p>
</font><font FACE="Arial" SIZE="4"><b>

<p>Locale-Specific Calendar Properties</p>
</b></font><font FACE="Arial" SIZE="2">

<p>If you thought we'd now solved all possible calendar internationalization problems, 
you'd be incorrect. Even within a single calendar system, such as Gregorian, there are a 
few properties that can differ from one country to the next. As an example, here are the 
US and French versions of the calendar for July, 1999:</p>
</font>

<table BORDER="1" CELLSPACING="1" CELLPADDING="2" WIDTH="235">
  <tr>
    <td VALIGN="TOP" COLSPAN="7"><p ALIGN="CENTER"><font FACE="Arial" SIZE="2"><b>United 
    States</b></font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">Sun</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">Mon</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">Tue</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">Wed</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">Thu</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">Fri</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">Sat</font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">1</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">2</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">3</font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">4</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">5</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">6</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">7</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">8</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">9</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">10</font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">11</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">12</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">13</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">14</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">15</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">16</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">17</font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">18</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">19</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">20</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">21</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">22</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">23</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">24</font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">25</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">26</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">27</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">28</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">29</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">30</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">31</font></td>
  </tr>
</table>
<font FACE="Arial" SIZE="2">

<p>&nbsp;</p>

<p>&nbsp;</p>
</font>

<table BORDER="1" CELLSPACING="1" CELLPADDING="2" WIDTH="235">
  <tr>
    <td VALIGN="TOP" COLSPAN="7"><p ALIGN="CENTER"><font FACE="Arial" SIZE="2"><b>France</b></font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">lun</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">mar</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">mer</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">jeu</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">ven</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">sam</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">dim</font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">1</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">2</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">3</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">4</font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">5</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">6</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">7</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">8</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">9</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">10</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">11</font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">12</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">13</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">14</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">15</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">16</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">17</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">18</font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">19</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">20</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">21</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">22</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">23</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">24</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">25</font></td>
  </tr>
  <tr>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">26</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">27</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">28</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">29</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">30</font></td>
    <td WIDTH="14%" VALIGN="TOP"><font FACE="Arial" SIZE="2"><p ALIGN="CENTER">31</font></td>
    <td WIDTH="14%" VALIGN="TOP">&nbsp;</td>
  </tr>
</table>
<p>&nbsp;</p>

<p>Notice that in France, the first day of the week is Monday (or lundi), while 
  in the United States it is Sunday. If you're writing an application that displays 
  calendars graphically, you need to take this into account. Java provides the 
  method <code>Calendar.getFirstDayOfWeek</code>
to handle this. When you create a calendar, you can specify the locale you're 
interested in: 
<dir>
  <dir> 
    <pre>Calendar c = Calendar.getInstance(Locale.FRANCE);</pre>
  </dir>
</dir>
<p>and then call <code>getFirstDayOfWeek</code>
to find out how to draw it: 
<dir>
  <dir> 
    <pre>int d = c.getFirstDayOfWeek();</pre>
  </dir>
</dir>
<p>A related method is <code>getMinimalDaysInFirstWeek</code><font FACE="Arial"
SIZE="2">, which tells you how long a week has to be to qualify as the &quot;first&quot; 
  week of the month. In the US calendar shown above, is the first week of July 
  the week that starts on July 5, or the previous one that starts on June 27? 
  According to Java's locale data it's the latter, because </font><code>getMinimalDaysInFirstWeek</code> 
  returns 1.</p>
<font FACE="Arial" SIZE="4"><b> 
<p>Creating your own Calendars</p>
</b></font> 
<p>All of the international calendar features I've talked about so far are great. 
  However, there's a catch that limits the amount of calendar internationalization 
  that you can actually do. Both JDK 1.1 and Java 2 only provide one concrete 
  subclass of <code>Calendar</code><font
FACE="Arial" SIZE="2">: </font><code>GregorianCalendar</code>. The traditional 
  calendars used in other countries are not yet supported.</p>

<p>However, all is not lost. It entirely possible to create your own subclasses 
  of <code>Calendar</code> that support different calendar systems. I've written 
  classes that support the Buddhist, Hebrew, Hijri, and Japanese Imperial calendars, 
  and I want to share some of that knowledge here.</p>

<p>When you look at the Calendar class, you'll notice that it has 11 abstract 
  methods: add, after, before, equals, <code>getMinimum</code><font FACE="Arial" SIZE="2">, 
  </font><code>getMaximum</code><font
FACE="Arial" SIZE="2">, </font><code>getGreatestMinimum</code><font FACE="Arial" SIZE="2">, 
  </font><code>getLeastMaximum</code><font FACE="Arial" SIZE="2">, </font><code>roll</code><font
FACE="Arial" SIZE="2">, </font><code>computeTime</code><font FACE="Arial" SIZE="2">, 
  and </font><code>computeFields</code>. Implementing your own calendar subclass 
  requires that you override all of these methods to provide an implementation 
  that's specific to your calendar system. These methods can be divided into three 
  basic groups.</p>

<p>The first group, the minimum and maximum functions, are the easiest so these 
  are usually the ones that I implement first. The first two, <code>getMinimum</code><font
FACE="Arial" SIZE="2"> and </font><code>getMaximum</code><font FACE="Arial" SIZE="2">, 
  tell you the largest allowable range for each field, while </font><code>getLeastMaximum</code><font
FACE="Arial" SIZE="2"> and </font><code>getGreatestMinimum</code>
, tell you the smallest range for the field. For example, the DAY_OF_MONTH field 
of GregorianCalendar has a minimum and maximum of 1 and 31, but a greatest minimum 
and least maximum of 1 and 29. Implementing this is easy. Since the result is 
a constant, you can just store it in a table. The methods almost always ends up 
looking like this: 
<dir>
  <dir> 
    <pre>public int getMinimum(int field) {

    return minMax[field][0];

}</pre>
  </dir>
</dir>
<p>The real heart of a calendar class consists of its <code>computeFields</code><font
FACE="Arial" SIZE="2"> and </font><code>computeTime</code><font FACE="Arial" SIZE="2"> 
  methods. The first, </font><code>computeFields</code><font FACE="Arial" SIZE="2">, 
  calculates the values of all of the fields (year, month, day, etc.) from the 
  absolute time, which is represented as the number of milliseconds since January 
  1, 1970. Conversely, </font><code>computeTime</code> uses the field values to 
  calculate the absolute time.</p>

<p>These two methods are usually quite complicated, because they must implement the 
calendar system's rules very precisely. The details for a real calendar are way beyond the 
scope of this article, so I've invented a very simple calendar that we can experiment 
with. It has 360 days per year, divided into 12 months of 30 days each, with no leap 
years. There are seven days per week, just like our calendar, and the day 1/1/1 in this 
calendar was a Saturday. Based on this simplification, I can offer a few generalizations.</p>

<p>First, your calculations will usually be based on an &quot;epoch&quot; date on which 
the calendar started. Usually you'll want this to be the 0<sup>th</sup> day of your 
calendar, that is the day before the first day of year 1. You should define a constant 
that specifies the epoch in milliseconds since 1/1/1970 AD. I'll start our example 
calendar on the same day the Hebrew calendar started, just because I have the constant 
handy:

<dir>
  <dir> 
    <pre>private static final long EPOCH_MILLIS = -180799862400000L;</pre>
  </dir>
</dir>
<p>You'll also need a few constants for the number of milliseconds in a second, minute, 
hour, etc:

<dir>
  <dir> 
    <pre>private static final long SECOND_MS = 1000;

private static final long MINUTE_MS = 60 * SECOND_MS;

private static final long HOUR_MS   = 60 * MINUTE_MS;

private static final long DAY_MS    = 24 * HOUR_MS;</pre>
  </dir>
</dir>
<p>Next, you'll want to get used to modular arithmetic, because you'll be doing a lot of 
it. Many of the calculations will be based on the number of days since the epoch, so you 
should calculate that first:

<dir>
  <dir> 
    <pre>long absDay = (time - EPOCH_MILLIS) / DAY_MS;</pre>
  </dir>
</dir>
<p>Once you have that number, it's easy to calculate the year, month, and day:

<dir>
  <dir> 
    <pre>int year  = (int)(absDay / 360) + 1;

int month = (int)((absDay / 30) % 12) + 1;

int day   = (int)(absDay % 30) + 1;</pre>
  </dir>
</dir>
<font FACE="Arial" SIZE="2">

<p>Of course, the calculations are a lot more complicated for real calendar systems, what 
with the variable month and year lengths, leap years, and the other complex 
interdependencies such as the &quot;postponement rules&quot; in the Hebrew calendar. There 
are a number of good references on this subject, including some web sites you can find 
with most search engines. But my favorite resource is the book <i>Calendrical Calculations</i>, 
which is listed in the references at the end of this article.</p>
</font><font FACE="Arial" SIZE="4"><b>

<p>Real Code</p>
</b></font> 
<p>If you'd like to see some real Java classes that implement non-Gregorian calendars, 
  pay a visit to <a HREF="http://www.alphaWorks.ibm.com/tech/calendars">http://www.alphaWorks.ibm.com/tech/calendars</a>. 
  The &quot;International Calendars&quot; package you'll find on that page supports 
  the Buddhist, Hebrew, Hijri, and Japanese Imperial calendars. It includes Java 
  <code>ResourceBundle</code> files containing translated strings for these calendars 
  in a number of different languages, as well as some utility methods for formatting 
  dates as strings using non-Gregorian calendars.</p>

<p>I hope this article has given you a good feel for the things that you can do with 
calendars in Java. Though it has its warts, Java's calendar framework is the most powerful 
one I've seen in any major operating system or application framework. </p>
<font FACE="Arial" SIZE="4"><b> 
<p>Acknowledgements</p>
</b></font><font FACE="Arial" SIZE="2">

<p>Alan Liu, the IBM engineer responsible for the time and date classes in the JDK, was 
very helpful while I was writing this paper.</p>
</font><font FACE="Arial" SIZE="4"><b>

<p>References</p>
</b></font><font FACE="Arial" SIZE="2"> 
<p>Calendrical Calculations, by Nachum Dershowitz and Edward M. Reingold (Cambridge 
  University Press, 1997) has excellent descriptions of calendar algorithms in 
  general as well as detailed algorithms for all of the calendar systems in common 
  use today.</p>
<p>The Java Class Libraries, 2nd Edition, vol. 1, by Chan, Lee, and Kramer (Addison-Wesley, 
  1998) has a nice description of Calendar and GregorianCalendar.</p>
<p>Making your Java/C++/C Applications Global, at <a
HREF="http://www-105.ibm.com/developerworks/education.nsf/dw/java-onlinecourse-bytitle">www.ibm.com/java/education/international-unicode/unicode1.html</a> 
  is a good overview of some of the issues involved in writing global applications.</p>
</font><font FACE="Arial" SIZE="4"><b> </b></font>
<hr>
<font FACE="Arial" SIZE="4"><b>
<p><a NAME="about_author">About the Author</a></p>
</b></font> 
<p>Laura Werner is the is the manager of the Unicode Technology Group at IBM Cupertino. 
  She joined Taligent in 1994 and moved to the Unicode group in 1997, just before 
  Taligent was absorbed into IBM. Laura became the group's manager in 1999 and 
  is now responsible for coordinating the Java and C++ Unicode efforts at IBM 
  Cupertino, helping to architect the Unicode class libraries, and working on 
  occasional side projects such as this paper. Laura holds Bachelor’s degrees 
  in Geological Sciences and Integrated Science from Northwestern University. 
</p>
</body>
</html>
