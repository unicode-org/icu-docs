<HTML>
<HEAD>
  <META NAME="GENERATOR" CONTENT="Adobe PageMill 2.0 Win">
  <TITLE>Optimized Unicode Compression and Decompression</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">

<H2><CENTER>Optimized Unicode Composition and Decomposition</CENTER></H2>

<P><CENTER>by Mark Davis</CENTER></P>

<P><CENTER>
</CENTER>
<H3>Background</H3>

<P>The Unicode Standard, Version 2.0 (TUS2.0) provides different ways to
encode accented characters, either decomposed (a combining character sequence
[CCS]) or composed (as a single precomposed character). For example, the
following are equivalent:</P>

<P><CENTER><TABLE WIDTH="450" BORDER="1" CELLSPACING="2" CELLPADDING="0">
<TR>
<TH VALIGN="TOP">Precomposed</TH>
<TH VALIGN="TOP">Decomposed</TH></TR>
<TR>
<TD WIDTH="50%" VALIGN="TOP" ALIGN="CENTER">&nbsp;&Atilde;</TD>
<TD WIDTH="50%" VALIGN="TOP" ALIGN="CENTER">&nbsp;A + ~</TD></TR>
</TABLE>
</CENTER>
<P>The TUS2.0 specifies an algorithm for determining whether any two sequences
of Unicode characters are canonical equivalent (see TUS2.0, pages 3-9 through
3-10). This algorithm basically decomposes any precomposed characters, then
sorts them according to special rules, based on each character's <I>combining
class</I>. This produces a normalized form.</P>

<P>Two common functions on Unicode text are to fully decompose the text
(as far as possible), and to fully compose the text (as far as possible).
In both cases, the correct result can only be achieved if the text is first
converted to a normalized form.</P>

<H3>Method</H3>

<P>The following describes mechanisms for composing and decomposing Unicode
text that do not require fully normalizing the text, and yet produce the
correct results. By avoiding the normalization phase, they represent significant
performance advantages.</P>

<P><TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0">
<TR>
<TD WIDTH="62" VALIGN="TOP"><B>Note:</B></TD>
<TD VALIGN="TOP" WIDTH="92%">In the following discussion, we will abbreviate the Unicode names for brevity.
Thus <TT>LATIN CAPITAL LETTER G WITH BREVE</TT> will be represented as <TT>G-breve</TT>.
A plus sign will be used to indicate a sequence of characters.</TD></TR>
</TABLE>
<P>The following discussion requires that the reader have first read Chapter
3 of TUS2.0.</P>

<H3>Decomposition</H3>

<P>The simple method for producing a normalized decomposed form is to replace
each character by its decomposition, then normalize the entire string. However,
this does more work than is necessary, especially in the common cases. The
optimized method works as follows:</P>

<H4>Preprocessing the composition data</H4>

<OL>
  <LI>Get the decomposition data from http://unicode.org
  <LI>Process the data to put all the decompositions in normalized order.
  <LI>The result is a mapping from characters to their normalized decompositions.
</OL>

<H4>Processing a particular source string</H4>

<OL>
  <LI>Iterate through each character C in the source string. Process C according
  to its type:
  <OL>
    <LI>C has a decomposition, where the first character of the decomposition
    is a base character:
    <UL>
      <LI>Append the decomposition to the result string.
    </UL>
    <LI>C is a combining mark:
    <UL>
      <LI>Append the combining mark to the result string, then bubble-sort the
      combining mark through the result string, from the end forward, according
      to the description on TUS2.0, p 3-10.
    </UL>
    <LI>C has a decomposition, where the first character of the decomposition
    is not a base character:
    <UL>
      <LI>For each character in the decompostion, treat as in the last step.
    </UL>
    <LI>C is none of the above:
    <UL>
      <LI>Add to the result string.
    </UL>
  </OL>
</OL>

<P>This method avoids bubble-sorting all of the combining marks in a string,
and optimizes for the common cases:</P>

<UL>
  <LI>there are no, or few additional combining characters in the string.
  <LI>the string is already in normalized form.
</UL>

<P>Since you are guaranteed that the decomposition is already in normalized
order, as each successive combining character is appended, it is bubble-sorted
up in the decomposition. Since the sequence starts in normalized order,
and after each successive character the result is in normalized order, then
the final result is in normalized order.</P>

<H4>Example</H4>

<P><CENTER><TABLE WIDTH="450" BORDER="1" CELLSPACING="2" CELLPADDING="0">
<TR>
<TH VALIGN="TOP" WIDTH="34%">Source</TH>
<TH VALIGN="TOP" WIDTH="33%">1</TH>
<TH VALIGN="TOP" WIDTH="33%">2</TH></TR>
<TR>
<TD WIDTH="50%" VALIGN="TOP" ALIGN="CENTER">&nbsp;&Atilde;`</TD>
<TD WIDTH="50%" VALIGN="TOP" ALIGN="CENTER">&nbsp;A + ~</TD>
<TD WIDTH="50%" VALIGN="TOP" ALIGN="CENTER">&nbsp;A + ~ + `</TD></TR>
<TR>
<TD WIDTH="50%" VALIGN="TOP" ALIGN="CENTER">&nbsp;&Atilde;.</TD>
<TD WIDTH="50%" VALIGN="TOP" ALIGN="CENTER">&nbsp;A + ~</TD>
<TD WIDTH="50%" VALIGN="TOP" ALIGN="CENTER">&nbsp;A + . + ~</TD></TR>
</TABLE>
</CENTER>
<H3>Composition</H3>

<P>The simple method for producing a normalized composed form is to match
each possible CCS against a database to see what matches, then replace the
CCS with the result. However, this does more work than is necessary, especially
in the common cases. The optimized method works as follows:</P>

<H4>Preprocessing the composition data</H4>

<P>The following algorithm depends on the fact that except for one anomolous
case, every CCS of length greater than two (which is canonical equivalent
to a precomposed character) is also equivalent to a CCS of length exactly
two. For example, <TT>C + cedilla + acute</TT> is equivalent to <TT>C-cedilla
+ acute</TT>, and <TT>C + acut</TT>e<TT> + cedilla</TT> is equivalent to
<TT>C-acute + cedilla</TT>.</P>

<OL>
  <LI>Get the decomposition data from http://unicode.org
  <LI>Process the data to generate the set of all possible orders of combining
  marks.<BR>
  For example, from the CCS <TT>A + tilde + acute + dot_below</TT>, generate
  the following: <BR>
  (This CCS does not actually have a precomposed character in Unicode--it
  is only used for illustration.)
  <UL>
    <LI><TT>A + tilde + acute + dot_below</TT>
    <LI><TT>A + tilde + dot_below + acute</TT>
    <LI><TT>A + acute + tilde + dot_below</TT>
    <LI><TT>A + acute + dot_below + tilde</TT>
    <LI><TT>A + dot_below + tilde + acute</TT>
    <LI><TT>A + dot_below + acute + tilde</TT>
  </UL>
  <LI>Filter out any combinations that are not canonically equivalent to
  the original.<BR>
  For example, for <TT>A + tilde + acute + dot_below</TT>, tilde and acute
  cannot be reversed and remain canonical equivalent, so you end up with
  just:
  <UL>
    <LI><TT>A + tilde + acute + dot_below</TT>
    <LI><TT>A + tilde + dot_below + acute</TT>
    <LI><TT>A + dot_below + tilde + acute</TT>
  </UL>
  <LI>For every combination left, if the combination has length greater than
  two, replace all but the last character with the corresponding precomposed
  character, thus ending with combinations of exactly length 2.<BR>
  For example: <TT>A + tilde + acute + dot_below</TT> becomes <TT>A-tilde-acute
  + dot_below</TT>
  <LI>To the mapping table, add the mappings from all these pairs to the
  fully precomposed character:<BR>
  <TT>A-tilde-acute + dot_below =&gt; A-tilde-acute-dot_below<BR>
  A-tilde-dot_below + acute =&gt; A-tilde-acute-dot_below<BR>
  A-dot_below-tilde + acute =&gt; A-tilde-acute-dot_below</TT>
</OL>

<H4>Processing a particular source string</H4>

<OL>
  <LI>Iterate through each character C in the source string.
  <OL>
    <LI>If C is a base character, add it to the result string, remember its
    position, and continue iterating
    <LI>If C is a combining mark, see if the last base character + C have a
    mapping M in the mapping table.
  </OL>
  <UL>
    <LI>If not, append C to the result string, and continue iterating
    <LI>If so, scan the combining characters after the last base character
    (if any)
    <UL>
      <LI>If any such characters have the same combining class as C, then append
      C to the result string, and continue iterating
      <LI>Otherwise, replace the base character by M, and continue iterating
    </UL>
  </UL>
</OL>

<P>Since all combinations of characters that could combine are in the mapping
table, in every order that they could occur in, all the precomposed forms
will be generated. Since we scan for illegal reversals, we eliminate non-canonical
equivalents. At each point in this process, the result string contains a
valid composition of the initial portion of the source string.</P>

<P><TABLE WIDTH="100%" BORDER="0" CELLSPACING="0" CELLPADDING="0">
<TR>
<TD WIDTH="62" VALIGN="TOP"><B>Notes:</B></TD>
<TD VALIGN="TOP" WIDTH="92%">If we didn't scan the intervening combining characters, then we could end
up with a non-canonical equivalent sequence. For example, consider the following
sequence: <TT>G + acute + breve</TT>. If we didn't scan, then this would
produce <TT>G-breve + acute</TT>, since <TT>G-breve</TT> is a precomposed
Unicode character, but <TT>G-acute</TT> is not. When decomposed, this represents
<TT>G + brev + acute</TT>, which is not a cononical equivalent to the orginal
string, since breve and acute have the same canonical class.</TD></TR>
<TR>
<TD>&nbsp;</TD>
<TD>The one anomolous precomposed character does require a special case in this
algorithm--for simplicity of presentation, this complication is omitted.</TD></TR>
</TABLE>
<P>&nbsp;</P>

<P>&nbsp;
</BODY>
</HTML>
