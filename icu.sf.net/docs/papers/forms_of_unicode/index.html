<html>

<head>

<title>Forms of Unicode</title>
<meta name="DESCRIPTION" content="In the beginning, Unicode was a simple, fixed-width 16-bit encoding. Under its initial design principles, there was enough room in 16 bits for all modern writing systems. But over the course of Unicode's growth and development, those principles had to give way. When characters were added to ensure compatibility with legacy character sets, available space dwindled rapidly. Many of these compatibility characters are superfluous, and were required only because different platform technologies at the time couldn't handle the representation of those characters as originally designed." />

<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /></meta> 
<meta content="The Unicode zone on developerWorks is your developer resource for building Web and e-business applications that are designed for worldwide audiences, regardless of culture or language." name="ABSTRACT"></meta> </meta> </meta> </meta> 
</head>

<body bgcolor="#ffffff" marginheight="2" marginwidth="2" topmargin="2" leftmargin="2">
<h1><span class="atitle">Forms of Unicode</span> </h1>
<span class="atitle2"></span> 
<p> <a href="#author1">Mark 
  Davis</a><br />
  IBM developer and President of the Unicode Consortium, IBM<br />
  September 1999</p>
<p>Originally published on <a href="http://www-106.ibm.com/developerworks/unicode/library/sun-ibm-java.html?dwzone=unicode">http://www-106.ibm.com/developerworks/unicode/library/sun-ibm-java.html?dwzone=unicode</a></p>
<blockquote><i>In the beginning, Unicode was a simple, fixed-width 16-bit encoding. 
  Under its initial design principles, there was enough room in 16 bits for all 
  modern writing systems. But over the course of Unicode's growth and development, 
  those principles had to give way. When characters were added to ensure compatibility 
  with legacy character sets, available space dwindled rapidly. Many of these 
  compatibility characters are superfluous, and were required only because different 
  platform technologies at the time couldn't handle the representation of those 
  characters as originally designed.</i></blockquote>
<table width="160" border="0" align="right" bgcolor="#999999">
  <tr bgcolor="#0000CC"> 
    <td height="20"> 
      <div align="center"><b><font color="#FFFFFF">Contents</font></b></div>
    </td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td height="20"><a href="#h7">Characters 
      vs. glyphs</a></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td height="20"><a href="#h0">Characters 
      vs. code points vs. code units</a></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td height="20"><a href="#h1">Avoiding 
      ambiguity</a></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td height="20"><a href="#h2">Memory 
      formats</a></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td height="20"><a href="#h3">Storage 
      vs. performance</a></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td height="20"><a href="#h4">Serialized 
      formats</a></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td height="20"><a href="#h6">Decisions, 
      decisions...</a></td>
  </tr>
  <tr bgcolor="#E3E3E3"> 
    <td height="20"><a href="#h8">Acronyms 
      defined</a></td>
  </tr>
  <!--Standard links for every article--> 
  <tr bgcolor="#E3E3E3"> 
    <td height="20"><a href="#author1">About 
      the author</a></td>
  </tr>
</table>
<p>So 16 bits were not enough anymore. Unicode needed an extension mechanism to 
  get up to a larger number of characters. The standard mechanism uses pairs of 
  Unicode values called </p>
<p><i>surrogates</i> to address over 1,000,000 possible values. There are no characters 
  in surrogate space yet, although there should be by the end of the year 2000. 
</p>
<p> Additionally, some systems couldn't easily handle extending their interfaces 
  to use 16-bit units in processing. These systems needed a form of Unicode that 
  could be handled in 8-bit bytes. Other systems found it easier to use larger 
  units of 32 bits for representing Unicode. </p>
<p> As a result of these different requirements, there are now three different 
  forms of Unicode: UTF-8, UTF-16, and UTF-32. (See <a href="#h8">Acronyms 
  defined</a> later in this article.) A great deal of thought was put into the 
  development of these three forms, so that each form is most useful for its particular 
  environment, and each can be quickly converted to and from the other forms as 
  needed. It is important to understand both the capabilities -- and the limitations 
  -- of each of these forms. </p>
<p> UTF-32 is a working name from <a href="http://www.unicode.org/unicode/reports/tr19/"> 
  <i>UTR #19: Interoperable 32-bit Serialization</i> </a>. It is very similar 
  to the ISO 10646 format <i>UCS-4, </i>except that it is constrained to valid 
  Unicode values for interoperability. The Unicode Standard similarly constrains 
  the Unicode definition of UTF-8. </p>
<p> <a name="h7"><span class="atitle2"><b>Characters vs. glyphs</b></span></a><br />
  Before getting into these forms of Unicode, we need to make a few things clear. 
  First is the distinction between <i>characters</i> and <i>glyphs.</i> A glyph 
  is a particular image that represents a character or part of a character. It 
  may have very different shapes: below are just some of the possibilities for 
  the letter <b><i>a</i> </b>. In the examples below, a selection of alternatives 
  is presented in different cells in the table. </p>
<p> 
<table border="1" cellpadding="2">
  <tr> 
    <th>Character</th>
    <th colspan="6">Sample glyphs</th>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/A1.gif" width="49" height="50"></i></td>
    <td><i><img border="0" src="images/A2.gif" width="50" height="50"></i></td>
    <td><i><img border="0" src="images/A3.gif" width="49" height="50"></i></td>
    <td><i><img border="0" src="images/A5.gif" width="48" height="50"></i></td>
    <td><i><img border="0" src="images/A6.gif" width="49" height="50"></i></td>
    <td><i><img border="0" src="images/A10.gif" width="49" height="50"></i></td>
    <td><i><img border="0" src="images/A8.gif" width="49" height="50"></i></td>
  </tr>
</table>
<p></p>
<p> Glyphs do not correspond one-for-one with characters. For example, a sequence 
  of <i>f </i>followed by <i>i</i> can be represented with a single glyph, called 
  an <i>fi ligature.</i> Notice that the shapes are merged together, and the dot 
  is missing from the <i>i.</i> </p>
<p> 
<table border="1" cellpadding="2">
  <tr> 
    <th>Character sequence</th>
    <th>Sample glyph</th>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/f.gif" width="49" height="50"><img border="0" src="images/i.gif" width="49" height="50"></i></td>
    <td> 
      <p align="center"><i><img border="0" src="images/fi.gif" width="49" height="50"></i></p>
    </td>
  </tr>
</table>
<p></p>
<p> On the other hand, the same image as the <i>fi ligature</i> could be achieved 
  by a sequence of two glyphs with the right shapes. The choice of whether to 
  use a single glyph or a sequence of two is up to the font containing the glyphs 
  and the rendering software. </p>
<p>
<table border="1" cellpadding="2">
  <tr> 
    <th>Character sequence</th>
    <th>Possible glyph sequence</th>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/f.gif" width="49" height="50"><img border="0" src="images/i.gif" width="49" height="50"></i></td>
    <td> 
      <p align="center"><i><img border="0" src="images/fi1.gif" width="49" height="50"><img border="0" src="images/fi2.gif" width="49" height="50"></i></p>
    </td>
  </tr>
</table>
<p></p>
<p> Similarly, an accented character could be represented by a single glyph, or 
  by different component glyphs positioned appropriately. In addition, the separate 
  accents can also be considered characters in their own right, in which case 
  a sequence of characters can also correspond to different possible glyph representations: 
</p>
<p>
<table border="1" cellpadding="2">
  <tr> 
    <th>Character Sequence</th>
    <th colspan="3">Possible glyph sequences</th>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/o-circum.gif" width="49" height="49"></i></td>
    <td><i><img border="0" src="images/o-circum.gif" width="49" height="49"></i></td>
    <td><i><img border="0" src="images/o.gif" width="49" height="49"><img border="0" src="images/circumfl.gif" width="48" height="49"><img border="0" src="images/acute.gif" width="49" height="49"></i></td>
    <td> 
      <p align="center"><i><img border="0" src="images/o.gif" width="49" height="49"><img border="0" src="images/circumfm.gif" width="48" height="49"></i></p>
    </td>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/o.gif" width="49" height="49"><img border="0" src="images/circumfl.gif" width="48" height="49"><img border="0" src="images/acute.gif" width="49" height="49"></i></td>
    <td><i><img border="0" src="images/o-circum.gif" width="49" height="49"></i></td>
    <td><i><img border="0" src="images/o.gif" width="49" height="49"><img border="0" src="images/circumfl.gif" width="48" height="49"><img border="0" src="images/acute.gif" width="49" height="49"></i></td>
    <td> 
      <p align="center"><i><img border="0" src="images/o.gif" width="49" height="49"><img border="0" src="images/circumfm.gif" width="48" height="49"></i></p>
    </td>
  </tr>
</table>
<p></p>
<p> In non-Latin languages, the connection between glyphs and characters may be 
  even less direct. Glyphs may be required to change their shape and widths depending 
  on the surrounding glyphs. These glyphs are called contextual forms. For example, 
  see the Arabic glyphs below. </p>
<p>
<table border="1" cellpadding="2">
  <tr> 
    <th>Character</th>
    <th colspan="4">Possible Glyphs, depending on context</th>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/ArabicHe.gif" width="49" height="50"></i></td>
    <td><i><img border="0" src="images/ArabicHe.gif" width="49" height="50"></i></td>
    <td><i><img border="0" src="images/ArabicHf.gif" width="49" height="50"></i></td>
    <td><i><img border="0" src="images/ArabicHg.gif" width="49" height="50"></i></td>
    <td> 
      <p align="center"><i><img border="0" src="images/ArabicHh.gif" width="49" height="50"></i></p>
    </td>
  </tr>
</table>
<p></p>
<p> Glyphs may also need to be widened for justification instead of simply adding 
  width to the spaces. Ideally this would involve changing the shape of the glyph 
  depending on the desired width. On some systems, this widening can be achieved 
  by inserting extra connecting glyphs called <i>kashidas</i>. In such a case, 
  a single character can conceivably correspond to a whole sequence of <i>kashidas 
  + glyphs + kashidas</i>. </p>
<p>
<table border="1" cellpadding="2">
  <tr> 
    <th>Character</th>
    <th>Sequence of glyphs</th>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/ArabicHe.gif" width="49" height="50"></i></td>
    <td><img border="0" src="images/ArabicKa.gif" width="49" height="50"><i><img border="0" src="images/ArabicHf.gif" width="49" height="50"></i><img border="0" src="images/ArabicKa.gif" width="49" height="50"></td>
  </tr>
</table>
<p></p>
<p> In other cases a single character must correspond to two glyphs, because those 
  two glyphs are positioned <i>around</i> other letters. See the Tamil characters 
  below. If one of those glyphs forms a ligature with other characters, then we 
  have a situation where <i>part</i> of a character corresponds to <i>part</i> 
  of a glyph. If a character (or any part of it) corresponds to a glyph (or any 
  part of it), then we say that the character <i>contributes</i> to the glyph. 
</p>
<p>
<table border="1" cellpadding="2">
  <tr> 
    <th>Character</th>
    <th>Split glyphs</th>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/TamilAU.gif" width="49" height="50"></i></td>
    <td><i><img border="0" src="images/TamilAUL.gif" width="49" height="50"><img border="0" src="images/TamilE.gif" width="49" height="50"></i></td>
  </tr>
</table>
<p></p>
<p> The upshot is that the correspondence between glyphs and characters is not 
  one-to-one, and cannot in general be predicted from the text. The ordering of 
  glyphs will also not in general correspond to the ordering of the characters, 
  because of right-to-left scripts like Arabic and Hebrew. Whether a particular 
  string of characters is rendered by a particular sequence of glyphs will depend 
  on the sophistication of the host operating system and the font. </p>
<p> <a name="h0"><span class="atitle2"><b>Characters vs. code points vs. code 
  units</b></span></a><br />
  In principle, the goal of Unicode is pretty simple: to assign each character 
  in the world a number, called a <i>code point</i> (or <i>scalar value).</i> 
  These numbers can range from 0 to 1,114,111 = 10FFFF<sub>16</sub>, although 
  every value of the form xxFFFE<sub>16</sub> or xxFFFF<sub>16</sub> is illegal.</p>
<p> Given this goal, we can just say that Unicode encodes characters, right? </p>
<p> <i>Wrong. </i>One of the main design requirements on Unicode was to interwork 
  with pre-existing character encoding standards. This requires lossless round-tripping, 
  where you can take text from an encoding into Unicode, and back again, without 
  losing information. Unfortunately, those legacy character encoding standards 
  contained a lot of things that aren't characters, and Unicode had to pull them 
  in. </p>
<p> These non-characters included ligature glyphs, contextual form glyphs, glyphs 
  that varied in width, sequences of characters, and adorned glyphs (such as circled 
  numbers). The following examples show where glyphs are encoded as single characters 
  in Unicode. As with glyphs, there is no one-to-one relationship between characters 
  and code points. What an end-user thinks of as a single character (<i>grapheme</i>) 
  may in fact be represented by multiple code points; conversely, a single code 
  point may correspond to multiple characters. Here are some examples. </p>
<p>
<table border="1" cellpadding="2">
  <tr> 
    <th>Characters</th>
    <th colspan="4">Unicode Code Points</th>
    <th>Notes</th>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/ArabicHe.gif" width="49" height="50"></i></td>
    <td><i><img border="0" src="images/ArabicHe.gif" width="49" height="50"></i></td>
    <td><i><img border="0" src="images/ArabicHf.gif" width="49" height="50"></i></td>
    <td><i><img border="0" src="images/ArabicHg.gif" width="49" height="50"></i></td>
    <td> 
      <p align="center"><i><img border="0" src="images/ArabicHh.gif" width="49" height="50"></i></p>
    </td>
    <td><i>Each of these Arabic contextual form glyphs has a code point.</i></td>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/f.gif" width="49" height="50"><img border="0" src="images/i.gif" width="49" height="50"></i></td>
    <td colspan="4" align="center"><i><img border="0" src="images/fi.gif" width="49" height="50"></i></td>
    <td align="left"><i>This ligature glyph has a code point.</i></td>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/P.gif" width="49" height="50"><img border="0" src="images/t.gif" width="49" height="50"><img border="0" src="images/s.gif" width="48" height="50"></i></td>
    <td colspan="4" align="center"><i><img border="0" src="images/Pts.gif" width="49" height="50"></i></td>
    <td align="left"><i>A single code point represents a sequence of three characters.</i></td>
  </tr>
  <tr> 
    <td align="center"><i><img border="0" src="images/Devanaga.gif" width="49" height="50"></i></td>
    <td colspan="4" align="center"><i><img border="0" src="images/Devanaga.gif" width="49" height="50"><img border="0" src="images/Devanagc.gif" width="49" height="50"><img border="0" src="images/Devanagd.gif" width="49" height="50"></i></td>
    <td align="left"><i>The Devanagari syllable ksha is represented by three code 
      points.</i></td>
  </tr>
  <!-- Leah, do you have g-ring.gif, g.gif, and ring.gif? They are new since the 9/20 delivery of the zip file for the article.  For Mark's post-launch updates, I got an HTML file but no new gifs. Thanks, --GEM      <tr>

    <td align="center"><img border="0" src="g-ring.gif" width="46" height="46"></td>

    <td colspan="4" align="center"><img border="0" src="g.gif" width="46" height="46"><img border="0" src="ring.gif" width="47" height="46"></td>

    <td align="left"><i>G-ring is represented by two code points.</i></td>

  </tr> --> 
</table>
<p></p>
<p> Even once we have code points, we're not done. A particular encoding will 
  represent code points as a sequence of one or more <i>code units,</i> where 
  a code unit is a unit of memory: 8, 16, or 32 bits. We will talk more about 
  this when we get to "<a href="#h2">Memory 
  formats</a>." </p>
<p> <a name="h1"><span class="atitle2"><b>Avoiding ambiguity</b></span></a><br />
  We have seen that <i>characters, glyphs, code points, </i>and <i>code units</i> 
  are all different. Unfortunately the term <i>character</i> is vastly overloaded. 
  At various times people can use it to mean any of these things: </p>
<ul>
  <li> An image on paper (glyph) </li>
  <li> What an end-user thinks of as a character (grapheme) </li>
  <li> What a character encoding standard encodes (code point) </li>
  <li> A memory storage unit in a character encoding (code unit) </li>
</ul>
<p> Because of this, ironically, it is best to avoid the use of the term <i>character</i> 
  entirely when discussing character encodings, and stick to the term <i>code 
  point.</i> </p>
<p> <a name="h2"><span class="atitle2"><b>Memory formats</b></span></a><br />
  Now that we have gotten all that out of the way, let's turn back to the Unicode 
  formats. For now, we will discuss only the use of UTFs in memory (there is an 
  additional complication when it comes to serialization, but we will get to that 
  later). Each UTF-<i>n</i> represents a code point as a sequence of one or more 
  <i>code units</i>, where each code unit occupies <i>n</i> bits. </p>
<p> <a href="#t1">Table 
  1</a> shows the code unit formats that the UTFs use, and provides an indication 
  of the storage requirements averaged over all computer text. The average storage 
  requirements for UTF-16 and UTF-32 should remain constant over time (I would 
  be surprised if the average number of UTF-16 surrogate-space characters ever 
  hit 0.1%). </p>
<p> However, the average storage requirements for UTF-8 will change, because it 
  is heavily dependent on the proportion of text in different languages. The growth 
  between the years 1999 and 2004 is due to the expected increase in the use of 
  computers in East and South Asia. (The estimates in the table use the proportion 
  of Web page languages in the world as a proxy for all computer text. Those proportions 
  are based on estimates from IDC.) </p>
<p> <a name="t1"><span class="atitle3"><b>Table 1: UTF types</b></span></a><br />

<table border="1" cellpadding="2">
  <tr> 
    <th align="left">UTF</th>
    <th align="left">Formats</th>
    <th colspan="2" align="left">Estimated average storage required per page (3000 
      characters)</th>
  </tr>
  <tr> 
    <th align="center">UTF-8</th>
    <td> 
      <p align="left"><img border="0" src="images/8S.gif" width="26" height="26"><br>
        <img border="0" src="images/8L.gif" width="26" height="26"><img border="0" src="images/8T.gif" width="26" height="26"><br>
        <img border="0" src="images/8L3.gif" width="26" height="26"><img border="0" src="images/8T.gif" width="26" height="26"><img border="0" src="images/8T.gif" width="26" height="26"><br>
        <img border="0" src="images/8L4.gif" width="26" height="26"><img border="0" src="images/8T.gif" width="26" height="26"><img border="0" src="images/8T.gif" width="26" height="26"><img border="0" src="images/8T.gif" width="26" height="26"></p>
    </td>
    <td align="center">3 KB<br>
      (1999) 
      <hr>
      5 KB<br>
      (2003)</td>
    <td>On average, English takes slightly over one unit per code point. Most 
      Latin-script languages take about 1.1 bytes. Greek, Russian, Arabic and 
      Hebrew take about 1.7 bytes, and most others (including Japanese, Chinese, 
      Korean and Hindi) take about 3 bytes. Characters in surrogate space take 
      4 bytes, but as a proportion of all world text they will always be very 
      rare.</td>
  </tr>
  <tr> 
    <th align="center">UTF-16</th>
    <td> 
      <p align="left"><img border="0" src="images/16S.gif" width="52" height="26"><br>
        <img border="0" src="images/16L.gif" width="52" height="26"><img border="0" src="images/16T.gif" width="59" height="26"></p>
    </td>
    <td align="center">6 KB</td>
    <td>All of the most common characters in use for all modern writing systems 
      are already represented with 2 bytes. Characters in surrogate space take 
      4 bytes, but as a proportion of all world text they will always be very 
      rare.</td>
  </tr>
  <tr> 
    <th align="center">UTF-32</th>
    <td> 
      <p align="left"><img border="0" src="images/32S.gif" width="111" height="26"></p>
    </td>
    <td align="center">12 KB</td>
    <td>All take 4 bytes</td>
  </tr>
</table>
<p></p>
<p> Programming using UTF-8 and UTF-16 is much more straightforward than with 
  other mixed-width character encodings. For each code point, they have either 
  a singleton form or a multi-unit form. With UTF-16, there is only one multi-unit 
  form, having exactly two code units. With UTF-8, the number of trailing units 
  is determined by the value of the lead unit: thus you can't have the same lead 
  unit with a different number of trailing units. Within each encoding form, the 
  values for singletons, for lead units, and for trailing units are all <i>completely 
  disjoint.</i> This has crucial implications for implementations: </p>
<ul>
  <li> <b>No overlap. </b>If you search for string A in a string B, you will <i>never</i> 
    get a false match on code points. You <i>never</i> need to convert to code 
    points for string searching. False matches never occur because the end of 
    one sequence can never be the same as the start of another sequence. <i>Overlap 
    is one of the biggest problems with common multi-byte encodings like Shift-JIS. 
    All of the UTFs avoid this problem.</i> </li>
  <li> <b>Determinate boundaries. </b>If you randomly access into text, you can 
    <i>always</i> determine the nearest code-point boundaries with a small number 
    of machine instructions. </li>
  <li> <b>Pass-through. </b>Processes that don't look at particular character 
    values don't need to know about the internal structure of the text. </li>
  <li> <b>Simple iteration. </b>Getting the next or previous code point is straightforward, 
    and only takes a small number of machine instructions. </li>
  <li> <b>Slow indexing.</b> Except in UTF-32, it is inefficient to find code 
    unit boundaries corresponding to the <i>n</i> th code point, or to find the 
    code point offset containing the <i>n</i> th code unit. Both involve scanning 
    from the start of the text. </li>
  <li> <b>Frequency.</b> Because the proportion of world text that needs surrogate 
    space is extremely small, UTF-16 code should always be optimized for the single 
    code unit. With UTF-8, it is probably worth optimizing for the single-unit 
    case also, but not if it slows down the multi-unit case appreciably. </li>
</ul>
<p> UTF-8 has one additional complication, called the <i>shortest form requirement.</i> 
  Of the possible sequences in <a href="#t1">Table 
  1</a> that could represent a code point, the Unicode Standard requires that 
  the shortest possible sequence be generated. When mapping back from code units 
  to code points, however, implementations are not required to check for the shortest 
  form. This problem does not occur in UTF-16. </p>
<p> Most systems will be upgrading their UTF-16 support for surrogates in the 
  next year or two. This upgrade can use a phased approach. From a market standpoint, 
  the only interesting surrogate-space characters expected in the near term are 
  an additional set of CJK ideographs used for Japan, China, and Korea. If a system 
  is already internationalized, most of the operations on the system will work 
  sufficiently well that minor changes will suffice for these in the near term. 
</p>
<p> <a name="h3"><span class="atitle2"><b>Storage vs. performance</b></span></a><br />
  Both UTF-8 and UTF-16 are substantially more compact than UTF-32, when averaging 
  over the world's text in computers. UTF-8 is currently more compact than UTF-16 
  on average, although it is not particularly suited for East-Asian text because 
  it occupies about 3 bytes of storage per code point. UTF-8 will probably end 
  up as about the same as UTF-16 over time, and may end up being less compact 
  on average as computers continue to make inroads into East and South Asia. Both 
  UTF-8 and UTF-16 offer substantial advantages over UTF-32 in terms of storage 
  requirements. </p>
<p> Code-point boundaries, iteration, and indexing are very fast with UTF-32. 
  Code-point boundaries, accessing code points at a given offset, and iteration 
  involve a few extra machine instructions for UTF-16; UTF-8 is a bit more cumbersome. 
  Indexing is slow for both of them, but in practice indexing by different code 
  units is done very rarely, except when communicating with specifications that 
  use UTF-32 code units, such as XSL. </p>
<p> This point about indexing is true unless an API for strings allows access 
  only by <i>code point</i> offsets. This is a very inefficient design: strings 
  should always allow indexing with <i>code unit</i> offsets. Moreover, because 
  code points do not, in general, correspond to end-user expectations for characters, 
  it is often better to use <i>grapheme</i> (user character) boundaries instead, 
  and to store text in strings rather than as single code points. See <i> <a href="http://www.unicode.org/">The 
  Unicode Standard, Version 3.0</a> </i> for more information. </p>
<p> Conversion between different UTFs is very fast. Unlike converting to and from 
  legacy encodings like Latin-2, conversion between UTFs doesn't require table 
  lookups. </p>
<p> Overall performance may also be affected by other factors. For example, if 
  the code units match the machine word size, access can be faster; but if they 
  use up more memory, more page faults and cache faults may occur, slowing down 
  performance. </p>
<p> <a name="h4"><span class="atitle2"><b>Serialized format</b>s</span></a><br />
  Serialization is the process of converting a sequence of code units into a sequence 
  of bytes for storage or transmission. There are two complications with serialization, 
  <i>endianness</i> and <i>encoding signatures</i>: </p>
<ul>
  <li> <b>Endianness.</b> If a code unit is not a single byte, it can be written 
    in two ways because of differences in machine architectures: big endian (most 
    significant byte first) or little endian (least significant byte first). With 
    today's microprocessor speed this is not a big deal, but at the time Unicode 
    was being adopted it was felt that both BE and LE formats were required. </li>
  <li> <b>Encoding.</b> If a system does not tag files with the character encoding, 
    then it might know that the file contains text, but not know which encoding 
    is used. </li>
</ul>
<p> To meet these two requirements (from an unnamed, but rather influential company), 
  the character <code>ZERO WIDTH NOBREAK SPACE </code>(<code>FEFF 16</code>) can 
  be used as a <i>signature</i> in the initial few bytes of a file. When the character 
  has that usage, it is called a <i>byte order mark (BOM).</i> The BOM has the 
  special feature that its byte-swapped counterpart BSBOM (<code>FFFE</code>) 
  is defined to never be a valid Unicode character, so it also serves to indicate 
  the endianness. This signature is not part of the content -- think of it as 
  a mini-header -- and must be stripped when processing. For example, blindly 
  concatenating two files will give an incorrect result. </p>
<p> Because of this, there are multiple forms of the UTFs, based on their endianness 
  and whether they use a signature (see <a href="#t2">Table 
  2</a> for details). It is important not to confuse the memory formats and serialized 
  formats, especially because some of them have the same names. For example, <i>UTF-16</i> 
  when referring to a memory format has no endianness issues and does not use 
  a signature (one may be present when generating or reading files, but this should 
  be only ephemeral). On the other hand, <i>UTF-16</i> when referring to a serialization 
  format may have a signature and may be in either endianness. </p>
<p> Now, most people will never need to know all the grimy details of these encodings, 
  but <a href="#t2">Table 
  2</a> shows the differences for those who are interested. In practice, most 
  of these are handled transparently by the character-code conversion utilities. 
</p>
<p> <a name="t2"><span class="atitle3">Table 2: UTF serializations</span></a><br />
<table border="2" width="100%" cellpadding="2">
  <th valign="top" align="left">UTF-8</th>
  <td valign="top"> 
    <ul>
      <li>Inital <code>EF BB BF</code> is a signature, indicating that the rest 
        of the file is UTF-8.</li>
      <li>Any <code>EF BF BE</code> is an error.</li>
      <li>A real ZWNBSP at the start of a file requires a signature first.</li>
    </ul>
  </td>
  </tr>
  <tr> 
    <th valign="top" align="left"><i>UTF-8N</i></th>
    <td valign="top"> 
      <ul>
        <li>All of the text is normal UTF-8; there is no signature.</li>
        <li>Inital <code>EF BB BF</code> is a ZWNBSP.</li>
        <li>Any <code>EF BF BE</code> is an error.</li>
      </ul>
    </td>
  </tr>
  <tr> 
    <th valign="top" align="left">UTF-16</th>
    <td valign="top"> 
      <ul>
        <li>Initial <code>FE FF</code> is a signature indicating the rest of the 
          text is big endian UTF-16.</li>
        <li>Initial <code>FF FE</code> is a signature indicating the rest of the 
          text is little endian UTF-16.</li>
        <li>If neither of these are present, all of the text is big endian.</li>
        <li>A real ZWNBSP at the start of a file requires a signature first.</li>
      </ul>
    </td>
  </tr>
  <tr> 
    <th valign="top" align="left">UTF-16BE</th>
    <td valign="top"> 
      <ul>
        <li>All of the text is big endian: there is no signature.</li>
        <li>Initial <code>FE FF</code> is a ZWNBSP.</li>
        <li>Any <code>FF FE</code> is an error.</li>
      </ul>
    </td>
  </tr>
  <tr> 
    <th valign="top" align="left">UTF-16LE</th>
    <td valign="top"> 
      <ul>
        <li>All of the text is little endian: there is no signature.</li>
        <li>Initial <code>FF FE</code> is a ZWNBSP.</li>
        <li>Any <code>FE FF</code> is an error.</li>
      </ul>
    </td>
  </tr>
  <tr> 
    <th valign="top" align="left"><i>UTF-32</i></th>
    <td valign="top"> 
      <ul>
        <li>Initial <code>00 00 FE FF</code> is a signature indicating the rest 
          of the text is big endian UTF-32.</li>
        <li>Initial <code>FF FE 00 00</code> is a signature indicating the rest 
          of the text is little endian UTF-32.</li>
        <li>If neither of these are present, all of the text is big endian.</li>
        <li>A real ZWNBSP at the start of a file requires a signature first.</li>
      </ul>
    </td>
  </tr>
  <tr> 
    <th valign="top" align="left"><i>UTF-32BE</i></th>
    <td valign="top"> 
      <ul>
        <li>All of the text is big endian: there is no signature.</li>
        <li>Initial <code>00 00 FE FF</code> is a ZWNBSP.</li>
        <li>Any <code>FF FE 00 00</code> is an error.</li>
      </ul>
    </td>
  </tr>
  <tr> 
    <th valign="top" align="left"><i>UTF-32LE</i></th>
    <td valign="top"> 
      <ul>
        <li>All of the text is little endian: there is no signature.</li>
        <li>Initial <code>FF FE 00 00</code> is a ZWNBSP.</li>
        <li>Initial <code>00 00 FE FF</code> is an error.</li>
      </ul>
    </td>
  </tr>
</table>
<p></p>
<blockquote> <i> <b>Note: </b>The italicized names are not yet registered, but 
  are useful for reference.</i> </blockquote>
<p> <a name="h6"><span class="atitle2"><b>Decisions, decisions...</b></span></a><br />
  Ultimately, the choice of which encoding format to use will depend heavily on 
  the programming environment. For systems that only offer 8-bit strings currently, 
  but are multi-byte enabled, UTF-8 may be the best choice. For systems that do 
  not care about storage requirements, UTF-32 may be best. For systems such as 
  Windows, Java, or ICU that use UTF-16 strings already, UTF-16 is the obvious 
  choice. Even if they have not yet upgraded to fully support surrogates, they 
  will be before long. </p>
<p> If the programming environment is not an issue, UTF-16 is recommended as a 
  good compromise between elegance, performance, and storage. </p>
<p> <a name="h8"><span class="atitle2"><b>Acronyms defined</b></span></a><br />
  For those unfamiliar with some of the acronyms used in this article, here is 
  a short list. </p>
<p>
<table border="1" width="100%">
  <tr> 
    <td width="100%"> 
      <table border="0" width="100%" cellpadding="2">
        <tr> 
          <td valign="top"><a name="ICU"><font size="-1">ICU</font></a></td>
          <td valign="top"><font size="-1"><a href="http://icu.sourceforge.net/">IBM 
            Components for Unicode</a>: IBM open-source software for Unicode enablement</font></td>
        </tr>
        <tr> 
          <td valign="top"><font size="-1"><a name="IDC">IDC</a></font></td>
          <td valign="top"><font size="-1"><a href="http://www.idc.com/">International 
            Data Corporation</a>: a provider of information technology data</font></td>
        </tr>
        <tr> 
          <td valign="top"><font size="-1"><a name="UTF">UTF</a></font></td>
          <td valign="top"><font size="-1"><a href="http://www.unicode.org/">Unicode 
            Transformation Format</a>: a transformation that maps each Unicode 
            code point onto a unique sequence of code units. </font>
            <blockquote> 
              <p><font size="-1"><b>Note: </b>UTF-32 is a working name from <a href="http://www.unicode.org/unicode/reports/tr19/"><i>UTR 
                #19: Interoperable 32-bit Serialization</i></a>. It is very similar 
                to the ISO 10646 format <i>UCS-4, </i>except that it is constrained 
                to valid Unicode values for interoperability. The Unicode Standard 
                similarly constrains the Unicode definition of UTF-8.</font></p>
            </blockquote>
          </td>
        </tr>
        <tr> 
          <td valign="top"><font size="-1"><a name="W3C">W3C</a></font></td>
          <td valign="top"><font size="-1"><a href="http://www.w3.org/">World 
            Wide Web Consortium</a>: organization responsible for HTML, XML and 
            other Web standards.</font></td>
        </tr>
        <tr> 
          <td valign="top"><font size="-1"><a name="XML">XML</a></font></td>
          <td valign="top"><font size="-1"><a href="http://www.w3.org/XML/">Extensible 
            Markup Language</a>: the &quot;universal format for structured documents 
            and data on the Web&quot;</font></td>
        </tr>
        <tr> 
          <td valign="top"><font size="-1"><a name="XSL">XSL</a></font></td>
          <td valign="top"><font size="-1"><a href="http://www.w3.org/TR/WD-xsl/">Extensible 
            Stylesheet Language</a>: one of the <a href="http://www.w3.org/TR/">many</a> 
            specifications in the <a href="http://www.w3.org/XML/">XML</a> family 
            being developed by the <a href="http://www.w3.org/">W3C</a></font></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<p></p>
<hr>
<a name="author1" /></a> <span class="atitle2"><b>About the author</b></span><br />
Dr. Mark Davis is a Senior Technical Staff Member responsible for international 
software architecture. Mark co-founded the Unicode effort, and is the president 
of the Unicode Consortium. He is a principal co-author and editor of the Unicode 
Standard, Versions 1.0 and 2.0. At various times, his department has included 
software groups covering text, international, operating system services, Windows 
porting, and technical communications. Technically, he specializes in object-oriented 
programming and in the architecture and implementation of international and text 
software. 
<p>&nbsp;</p>
</body>

</html>
