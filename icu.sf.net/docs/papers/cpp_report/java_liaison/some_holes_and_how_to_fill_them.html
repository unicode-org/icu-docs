<html>

<head>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 3.0">
<title>&quot;Java Liaison&quot; column, March 1999</title>
</head>

<body>
<font SIZE="2">

<p>&quot;Java Liaison&quot; column<br>
Richard Gillam<br>
March 1999<br>
</font><font SIZE="5">Some Holes, and How To Fill Them</p>
</font>

<p>In the previous installments of this column, I&#146;ve tried to dispel (or minimize)
the big complaints about Java and have focused on its standard libraries and runtime
environment. This time, I&#146;d like to look more closely at the core language itself and
some of its warts.</p>

<p>The designers of Java decided to make Java look and feel more or less like C++ because
so many programmers are familiar with C++. Since the underlying philosophy of Java was
very different, they had to depart from the C++ model, often radically, in many places.
They also made some smaller syntactic changes to improve readability and usability.<code>
Furthermore, t</code>hey made a conscious decision to simplify the language, jettisoning
whole features of C++ that they deemed to be unnecessary. This may or may not have been a
good idea, but C++ programmers used to these features will be justifiably annoyed at their
absence in Java. I&#146;d like to look at four such features of C++ and show how (when
possible) their absence in Java can be worked around.</p>

<h3>Operator overloading</h3>

<p>The most conspicuous omission, and one of the ones that spark really heated religious
wars, is operator overloading. Java preserves function-name overloading, but not operator
overloading.</p>

<p>This was a very intentional omission. The designers of the language felt that operator
overloading wasn&#146;t really necessary. It added complexity without enabling you to do
anything you couldn&#146;t do by other means.</p>

<p>Many people have cried foul. They use operator overloading all the time, it&#146;s
convenient, and it simplifies their code. One example is scientific applications that
define their own numeric types, such as <code>Complex</code>, <code>Matrix</code>, <code>Ratio</code>,
or <code>Bignum</code>. If you&#146;re doing a lot of math on different data types, you
don&#146;t want to mess with manually converting types everywhere, and more importantly,
you don&#146;t want to have to do <code>a + b</code> with some types of <code>a</code> and
<code>b</code> and <code>add(a, b)</code> with other types. This is confusing and
inconsistent.</p>

<p>You could, of course, standardize on the <code>add(a, b)</code> format for all
mathematical operations, but you lose automatic operator precedence and everything becomes
<i>much</i> longer and uglier. Instead of &quot;<code>(2 * a + 4 * b) / 3</code>&quot;,
you&#146;d have to write something like &quot;<code>div(add(mult(2, a), mult(4, b)),
3)&quot;. </code>Which one of these expressions is easier to read? (Of course, <img
SRC="image1.gif" WIDTH="56" HEIGHT="41"> would be easier yet, but it&#146;s kind of hard
to type.)</p>

<p>Another thing operator overloading is frequently used for in C++ is accessing
individual elements in a collection. Everybody knows what &quot;<code>x = y[3]</code>&quot;
or &quot;<code>a[b] = 3</code>&quot; mean, no matter what type of collection <code>y</code>
or <code>a</code> might be in these examples. In Java, on the other hand, if the
collection is an array, you say &quot;<code>x = y[3]</code>&quot;, but if the collection
is a string, you say &quot;<code>x = y.charAt(3)</code>&quot;, and if the collection is a <code>Vector</code>,
you say &quot;<code>x = (foo)y.elementAt(3)</code>&quot; [where &quot;<code>foo</code>&quot;
is the type of <code>x</code>]. At best, this is confusing.</p>

<p>There are few other things operator overloading is used for in C++. A biggie is for
implementing smart pointers and proxy classes so that their operation is completely (or
almost completely) transparent to the code using them. There are situations where
it&#146;d be nice to be able to do this in Java too, but most of the things that C++ smart
pointers do automatically (e.g., adjusting reference counts, deleting objects, etc.)
aren&#146;t necessary in Java.</p>

<p>Despite the usefulness of operator overloading, I suspect that it&#146;ll never get
added to the language. Operator overloading (at least C++-style operator overloading) <i>does</i>
significantly complicate things, although Java&#146;s overall design would eliminate some
of the biggest hassles and there are simpler, more constrained alternatives to C++-style
operator overloading that could be used instead. There&#146;s no practical workaround
either, other than the obvious one: use regular function calls and put up with the
disadvantages described above. Personally, I find this not to be a really big deal, but
there are a lot of people that do.</p>

<h3>Enumerated types</h3>

<p>Java doesn&#146;t have enumerated types. This is one thing I definitely have missed. In
Java, the standard approach taken by the Java Class Libraries is to define named constants
of some integral type. For example, where in C++, you&#146;d write something like</p>

<pre>enum EScrollbarStatus {
	kScrollbarsNone,
	kScrollbarsVertical,
	kScrollbarsHorizontal,
	kScrollbarsBoth
};</pre>

<p>instead you&#146;d do the following in Java:</p>

<pre>public final int
	SCROLLBARS_NONE = 0;
	SCROLLBARS_VERTICAL = 1;
	SCROLLBARS_HORIZONTAL = 2;
	SCROLLBARS_BOTH = 3;</pre>

<p>This is syntactically uglier, which is a pain, but a bigger problem is that it&#146;s
not type-safe. In C++, you can define parameters and variables of type <code>EScrollbarStatus</code>.
The compiler will then guarantee that the parameter will have one of the four legal
values; everything else will cause a compile error. In Java, you have to check for illegal
values manually. In other words, where in C++ you can just say </p>

<pre>void doSomething(EScrollbarStatus status) {
	// do something with &quot;status&quot;
}</pre>

<p>in Java you have to do something more like</p>

<pre>public void doSomething(int status) {
	if (status &lt; SCROLLBARS_NONE || status &gt; SCROLLBARS_BOTH)
		return; // or throw an exception, or something

	// do something with &quot;status&quot;
}</pre>

<p>This both forces more work on the programmer and is brittle. If you add another
constant to the enumerated type, you have to remember to check and fix all these validity
checks to account for it (you could separate the check into a function of its own, but
this gets kind of silly after a while, and it only minimizes the labor).</p>

<p>In C++, enums are often used just to define a bunch of symbolic constants <i>en masse.</i>
In Java, you have to put up with a little more syntactic ugliness, but that isn&#146;t
such a big deal. On the other hand, when you really need a whole new type with a
restricted range of values, as in the example above, Java forces you to do more work and
introduces the potential for bugs.</p>

<p>There <i>is</i> a workaround for this in Java. Instead of making the individual
enumeration values integers, you make them references to individual instances of a private
class. It looks something like this:</p>

<pre>private static class ScrollbarStatus {
}

public static final ScrollbarStatus SCROLLBARS_NONE = new ScrollbarStatus();

public static final ScrollbarStatus SCROLLBARS_VERTICAL =
	    new ScrollbarStatus();

public static final ScrollbarStatus SCROLLBARS_HORIZONTAL =
		new ScrollbarStatus();

public static final ScrollbarStatus SCROLLBARS_BOTH = new ScrollbarStatus();</pre>

<p>You usually scope the &quot;enumeration&quot; class inside some other class, and scope
the constant definitions in the same class. (The &quot;enumeration&quot; class is a
private member of its enclosing class so you can&#146;t create more instances of it;
interestingly, you can still declare variables or parameters of the enumerated type even
though it&#146;s private.) The class doesn&#146;t have to carry any state or define any
methods&#151;we&#146;re only interested in object identity (i.e., address in memory) here.
Then the function using the type can look like this</p>

<pre>void doSomething(ScrollbarStatus status) {
	// do something with &quot;status&quot;
}</pre>

<p>and you still get the type safety check for free. One problem with this arrangement is
that you can&#146;t use <code>switch</code> with the constants of the enumerated type
because <code>switch</code> only works with primitive types. Instead of</p>

<pre>void doSomething(ScrollbarStatus status) {
	switch (status) {
		case SCROLLBARS_NONE:
			// blah blah blah
	
		case SCROLLBARS_VERTICAL:
			// blah blah blah
	
		case SCROLLBARS_HORIZONTAL:
			// blah blah blah
	
		case SCROLLBARS_BOTH:
			// blah blah blah
	}
}</pre>

<p>you have to do</p>

<pre>void doSomething(ScrollbarStatus status) {
	if (status == SCROLLBARS_NONE)
		// blah blah blah
	else if (status == SCROLLBARS_VERTICAL)
		// blah blah blah
	else if (status == SCROLLBARS_HORIZONTAL)
		// blah blah blah
	else
		// blah blah blah
}</pre>

<p>To get around this, or deal with situations where you need real values for the
enumeration constants, you have to modify things like this:</p>

<pre>public static class ScrollbarStatus {
	public ScrollbarStatus(int value) {
		this.value = value;
	}

	private int value;
}

public static final ScrollbarStatus SCROLLBARS_NONE = new ScrollbarStatus(0);
public static final ScrollbarStatus SCROLLBARS_VERTICAL = new 
		ScrollbarStatus(1);
// and so on...</pre>

<p>Making an enumerated type into a class can be kind of complicated, and probably
isn&#146;t always worth the trouble, but it very neatly handles the type safety problem.
One big problem here is that most of the Java Class Library APIs don&#146;t use this
approach, so if you want to use this approach with enumeration parameters defined by the
JCL, it either doesn&#146;t help you or introduces more work.</p>

<h3>Macro system</h3>

<p>When faced with a choice between no macro system at all and a bad macro system,
it&#146;s kind of hard to know which way to vote. But there are definitely times when a
macro system is a nice thing to have, and I occasionally miss its presence in Java.</p>

<p>In fact, there are some things that you don&#146;t need a macro system to do in C++,
where you really do in Java, so you could argue that a macro system would be even more
useful in Java. In C++, stack-based classes are frequently used to automatically release a
resource when a particular block of code is exited. You don&#146;t need to do this with
memory in Java, but you do have to do it with most other resources. Consider files, for
example. In C++, you could define a class that represents a file and takes care of closing
the file in its destructor. Then all you&#146;d have to do in a function that used it is
declare an object of the proper type and do your thing. Whether the function terminates
normally or abnormally, you&#146;re guaranteed that the file will be closed.</p>

<p>In Java, on the other hand, you have to close the file manually. So code using the
built-in Java File class would have to look something like this:</p>

<pre>void doSomething() {
	File f = new File(&quot;foo.txt&quot;);

	try {
		// do stuff with f
	}
	finally {
		f.close();
	}
}</pre>

<p>It&#146;d be wonderful if you could take all of this boilerplate code out, so the
function basically only consists of the code doing the actual work. Something like</p>

<pre>void doSomething() {
	WITH_OPEN_FILE(f, &quot;foo.txt&quot;) {
		// do stuff with f
	}
}</pre>

<p><code>WITH_OPEN_FILE</code> would do the <code>new</code> and <code>close</code> calls
for you, and would also do the <code>try</code>/<code>finally</code> block. It would also
automatically define a variable of type <code>File</code> named <code>f</code>. To make
things look and work this way, however, requires that you be able to extend the program
syntax, which you can&#146;t do. This requires a macro system.</p>

<p>Of course, the C/C++ macro system (<code>#define</code>) doesn&#146;t allow you to do
that either. Since all it does is simple textual substitution, it doesn&#146;t really know
about the language syntax or let you extend it. You can&#146;t use a single macro call to
bracket a body of code with extra boilerplate on either side. But in C++, you have the
destructor trick, so this doesn&#146;t matter.</p>

<p>The designers of Java did take care of one of the other major uses for the destructor
trick by extending the language. Instead of having to manually acquire and release monitor
locks, you use the <code>synchronized</code> keyword to bracket critical sections of code,
and the release of the lock happens automatically. But other uses of the destructor trick,
such as opening and closing files or acquiring and releasing GUI system resources (such as
windows) still have to be done manually in Java.</p>

<p>The C++ macro system is good for things like inserting canned boilerplate code in a lot
of places (say, you&#146;ve got a bunch of classes that are all supposed to define the
same four functions with the same implementation) or isolating platform-specific code from
client code (e.g., defining <code>t_int32</code> to be a 32-bit integer, making it an <code>int</code>
on some systems and a <code>long</code> on others). These uses are less important in Java,
but do still come up.</p>

<p>A good language-sensitive macro system is hard to do and greatly complicates the
language, but it might be possible to add a very limited one, or merely extend the
language syntax to cover more of the common cases (e.g., add a keyword that would force an
object&#146;s finalizer to be called at a predictable time).</p>

<h3><code>const</code></h3>

<p>The most unpleasant and error-prone omission from Java, the one that&#146;s given our
whole team the most grief, is the absence of <code>const</code>. I have to be careful here
to explain what I mean. The <code>const</code> keyword in C++, combined with the C
declarator syntax, is a syntactic monstrosity, and I&#146;m not for a minute advocating
bringing all that complexity over to Java. I also am not confusing the meanings of <code>const</code>
in C++ and <code>final</code> (<code>const</code>&#146;s closest analogue) in Java.</p>

<p>Let me explain what I <i>do</i> mean. Say you&#146;re writing a function in Java and
it&#146;s supposed to call another function and pass it a reference to one of your
objects. You&#146;re guaranteed that the variable that points to that object will still
point to it when the function you call returns, but you&#146;re <i>not</i> guaranteed that
that object&#146;s state hasn&#146;t been changed by the function you called. If
you&#146;re <i>receiving</i> a reference to an object from your function&#146;s caller,
you don&#146;t know whether the caller is expecting you to leave the object alone or if
you can change it.</p>

<p>This is important. Sometimes you want multiple functions or objects pointing to another
object to see changes to it, and sometimes you don&#146;t. You have to be careful to make
sure just which objects hold references and which objects hold copies, and to uphold these
invariants everywhere. Breaking those invariants (or setting them up wrong in the first
place) can produce wrong results, and they can be hard to track down.</p>

<p>Java dramatically simplified the various access-control and storage-class options
available in C++. Variables (class, instance, and local), function parameters, and
function return values all come in only two flavors: immediate values and references. If a
variable is of a primitive type, it&#146;s an immediate value; if it&#146;s of an object
or array type, it&#146;s a reference. If a variable is declared <code>final</code>, that
means you&#146;re not allowed to change the value <i>of the variable.</i> That means that
if the variable is a reference, you can&#146;t change it to refer to another object, but
you <i>can</i> freely make changes to the object it refers to. There&#146;s no way to
prevent this.</p>

<p>In other words,</p>

<pre>int x;
Foo y;
final Foo z;</pre>

<p>in Java are equivalent to</p>

<pre>int x;
Foo&amp; y;
Foo &amp; const y;</pre>

<p>In C++.</p>

<pre>const Foo&amp; x;
Foo x;
Foo* x;</pre>

<p>have no equivalents in Java.</p>

<p>Because there&#146;s no built-in way to prevent the innards of an object from being
messed with without permission, you&#146;re left having to rely on documentation to tell
people the expected semantics of function parameters and return values. And we all know
how effective relying exclusively on documentation tends to be. The ultimate result is a
lot of bugs, a lot of rummaging in other people&#146;s source code looking for the answer,
and a lot of defensive copying. You can run into situations in a team environment where
the functions on both sides of a call copy defensively:</p>

<pre>Bar func1() {
	Foo f = new Foo();
	// do stuff... 
	Bar result = func2((Foo)f.clone());
	return (Bar)(result.clone());
}

Bar func2(Foo f) {
	Foo internalF = (Foo)(f.clone());
	// do stuff with internalF, create &quot;result&quot;...
	return (Bar)(result.clone());
}</pre>

<p>Notice how many unnecessary copies are being made here. Depending on the situation,
they may actually <i>all</i> be unnecessary. This is terribly inefficient.</p>

<p>The only way to prevent excess defensive copying is to have some kind of protocol <i>that
is enforced by the compiler</i> whereby a caller can communicate to a callee whether or
not the callee can change the state of an object passed to it, and whereby a callee can
communicate to a caller whether or not it can change the state of its return value. This
involves a way of identifying which methods on a class change its internal state and which
don&#146;t. C++ uses the <code>const</code> keyword (in different ways) for all of these
things.</p>

<p>The Java language doesn&#146;t provide this kind of special support, but you can get
pretty close on your own by using interfaces. For each class you think is important enough
to protect in this way (the ones that are most expensive to clone, for example), define an
interface that contains just the functions in your class that don&#146;t change its
internal state (i.e., its getter functions). Functions that promise not to change the
state of an object referred to by a parameter define that parameter&#146;s type as the
interface type. Functions that return something you don&#146;t want changed return the
interface type. In the opposite situations, you use the regular class type instead.</p>

<p>Here&#146;s an example:</p>

<pre>public interface ImmutableFoo extends Cloneable {
	public int getX();
	public Bar getY();
	public int getZElement(int index);
}

public class Foo implements ImmutableFoo {
	// function bodies omitted for clarity 

	public Foo( /* params */ );

	public int getX();
	public void setX(int newX);
	public Bar getY();
	public void setY(Bar newY);
	public int getZElement(int index);
	public void setZElement(int index, int value);
}</pre>

<p>Now if you have a function defined like this:</p>

<pre>copyState(ImmutableFoo source, Foo destination);</pre>

<p>it&#146;s promising that it won&#146;t mess with the internals of <code>source</code>
(which makes sense), but that it reserves for itself the right to mess with <code>destination</code>
(and, in fact, it <i>will</i> do so&#151;that&#146;s this function&#146;s whole point). If
a function calling <code>copyState()</code> wants to copy into an object that it only
knows as an <code>ImmutableFoo</code>, it has to create a new object to copy into first.</p>

<p>(Of course, there&#146;s nothing to prevent somebody from casting an <code>ImmutableFoo</code>
to a <code>Foo</code>, but this is the same as casting away <code>const</code> in C++, and
just as dangerous.)</p>

<p>This is a lot of work. That&#146;s one of the drawbacks, but frequently it&#146;s worth
the trouble. A bigger drawback, like the workaround for enumerated types above, is that
the standard Java libraries generally don&#146;t work this way (there are some
exceptions).</p>

<p>An even bigger drawback is that Java <i>arrays</i> don&#146;t either. There&#146;s no
way to create an immutable Java array. Another problem is that Java arrays aren&#146;t
completely type safe at compile time; you can define a variable of type <code>Object[]</code>
and store any array in it. Then you can put an instance of any class into an <code>Object[]</code>.
There&#146;s a <i>run-time</i> type check that throws an exception if the type
doesn&#146;t match the type of the actual array. The reason this is a run-time check is
that if you get a <code>Foo[]</code> where you&#146;re looking for an <code>Object[]</code>,
you can still <i>read</i> from it, but not write to it. A <code>const</code> array type
would allow the check to happen at compile time (using a non-<code>const</code> array type
would be an indication that you plan to write to it).</p>

<p>You can&#146;t change the Java APIs or the Java array implementation, but you can
protect your use of them by creating wrapper classes and using them instead.</p>

<h3>Until next time&#133;</h3>

<p>Our team has run into many glitches, both big and small, in porting our code from C++
to Java and vice versa. I&#146;ve tried to hit the highlights here. For a more
comprehensive treatment of this issue, take a look at <code>http://www.ibm.com/java/education/portingc</code>.
In addition, for a <i>lot</i> more information on mutable and immutable objects in Java,
check out Mark Davis&#146;s column in the March issue of <i>Java Report.</p>
</i>

<p>I&#146;ve left out probably the biggest issue for many hardcore C++ programmers trying
to write Java code. That&#146;s the fact that Java doesn&#146;t have templates. This is a <i>really</i>
big topic, and I&#146;m going to save it for the next installment. Hope to see you here
again next time.</p>
</body>
</html>
